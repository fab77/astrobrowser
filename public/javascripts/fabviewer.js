(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("fabviewer", [], factory);
	else if(typeof exports === 'object')
		exports["fabviewer"] = factory();
	else
		root["fabviewer"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/canvas/browser.js":
/*!****************************************!*\
  !*** ./node_modules/canvas/browser.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

/* globals document, ImageData */

exports.createCanvas = function (width, height) {
  return Object.assign(document.createElement('canvas'), { width: width, height: height })
}

exports.createImageData = function (array, width, height) {
  // Browser implementation of ImageData looks at the number of arguments passed
  switch (arguments.length) {
    case 0: return new ImageData()
    case 1: return new ImageData(array)
    case 2: return new ImageData(array, width)
    default: return new ImageData(array, width, height)
  }
}

exports.loadImage = function (src, options) {
  return new Promise(function (resolve, reject) {
    const image = Object.assign(document.createElement('img'), options)

    function cleanup () {
      image.onload = null
      image.onerror = null
    }

    image.onload = function () { cleanup(); resolve(image) }
    image.onerror = function () { cleanup(); reject(new Error('Failed to load the image "' + src + '"')) }

    image.src = src
  })
}


/***/ }),

/***/ "./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

// Save global object in a variable
var __global__ =
(typeof globalThis !== 'undefined' && globalThis) ||
(typeof self !== 'undefined' && self) ||
(typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g);
// Create an object that extends from __global__ without the fetch function
var __globalThis__ = (function () {
function F() {
this.fetch = false;
this.DOMException = __global__.DOMException
}
F.prototype = __global__; // Needed for feature detection on whatwg-fetch's code
return new F();
})();
// Wraps whatwg-fetch with a function scope to hijack the global object
// "globalThis" that's going to be patched
(function(globalThis) {

var irrelevant = (function (exports) {

  /* eslint-disable no-prototype-builtins */
  var g =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof self !== 'undefined' && self) ||
    // eslint-disable-next-line no-undef
    (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g) ||
    {};

  var support = {
    searchParams: 'URLSearchParams' in g,
    iterable: 'Symbol' in g && 'iterator' in Symbol,
    blob:
      'FileReader' in g &&
      'Blob' in g &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in g,
    arrayBuffer: 'ArrayBuffer' in g
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
      throw new TypeError('Invalid character in header field name: "' + name + '"')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        if (header.length != 2) {
          throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)
        }
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body._noBody) return
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
    var encoding = match ? match[1] : 'utf-8';
    reader.readAsText(blob, encoding);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */
      // eslint-disable-next-line no-self-assign
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._noBody = true;
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);
        if (isConsumed) {
          return isConsumed
        } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          )
        } else {
          return Promise.resolve(this._bodyArrayBuffer)
        }
      } else if (support.blob) {
        return this.blob().then(readBlobAsArrayBuffer)
      } else {
        throw new Error('could not read as ArrayBuffer')
      }
    };

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    if (!(this instanceof Request)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }

    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal || (function () {
      if ('AbortController' in g) {
        var ctrl = new AbortController();
        return ctrl.signal;
      }
    }());
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);

    if (this.method === 'GET' || this.method === 'HEAD') {
      if (options.cache === 'no-store' || options.cache === 'no-cache') {
        // Search for a '_' parameter in the query string
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          // If it already exists then set the value with the current time
          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
        } else {
          // Otherwise add a new '_' parameter to the end with the current time
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
        }
      }
    }
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
    // https://github.com/github/fetch/issues/748
    // https://github.com/zloirock/core-js/issues/751
    preProcessedHeaders
      .split('\r')
      .map(function(header) {
        return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
      })
      .forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          try {
            headers.append(key, value);
          } catch (error) {
            console.warn('Response ' + error.message);
          }
        }
      });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!(this instanceof Response)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    if (this.status < 200 || this.status > 599) {
      throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].")
    }
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 200, statusText: ''});
    response.ok = false;
    response.status = 0;
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = g.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        // This check if specifically for when a user fetches a file locally from the file system
        // Only if the status is out of a normal range
        if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
          options.status = 200;
        } else {
          options.status = xhr.status;
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response(body, options));
        }, 0);
      };

      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError('Network request timed out'));
        }, 0);
      };

      xhr.onabort = function() {
        setTimeout(function() {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        }, 0);
      };

      function fixUrl(url) {
        try {
          return url === '' && g.location.href ? g.location.href : url
        } catch (e) {
          return url
        }
      }

      xhr.open(request.method, fixUrl(request.url), true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr) {
        if (support.blob) {
          xhr.responseType = 'blob';
        } else if (
          support.arrayBuffer
        ) {
          xhr.responseType = 'arraybuffer';
        }
      }

      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {
        var names = [];
        Object.getOwnPropertyNames(init.headers).forEach(function(name) {
          names.push(normalizeName(name));
          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
        });
        request.headers.forEach(function(value, name) {
          if (names.indexOf(name) === -1) {
            xhr.setRequestHeader(name, value);
          }
        });
      } else {
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!g.fetch) {
    g.fetch = fetch;
    g.Headers = Headers;
    g.Request = Request;
    g.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(__globalThis__);
// This is a ponyfill, so...
__globalThis__.fetch.ponyfill = true;
delete __globalThis__.fetch.polyfill;
// Choose between native implementation (__global__) or custom implementation (__globalThis__)
var ctx = __global__.fetch ? __global__ : __globalThis__;
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports["default"] = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/controlpanelcontainer.css":
/*!*********************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/controlpanelcontainer.css ***!
  \*********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `@charset "UTF-8";



#controlpanel2container{
    top: 5px;
    left: 5px;
    position: absolute;
    z-index: 100;
    padding: 2px;
    color: var(--commonTextColor);

}

.controlPanel{
    position: absolute;
    max-height: 600px;
    background-color: var(--commonBg);
    left: 45px;
    top: 15px;
    border-radius: 3px;
    overflow-x: hidden;
    overflow-y: auto;
}

.controlPanel label {
    margin-left: 4px;
}
.controlPanel .dataRow {
    display: flex;
    padding-right: 20px;
    padding-left: 3px;
}
.controlPanel label {
    white-space: nowrap;
}

.controlPanel .dataRow label:hover, .controlPanel .dataRow input:hover{
    cursor: pointer;
}

.controlPanel .dataRow:hover{
    background-color: var(--commonHover);
    cursor: pointer;
    color: white;
}
.controlPanel .dataRow:active{
    background-color: var(--commonActive);
}

#hipsPanel{
    max-height: 450px;
    background-color: var(--commonBg);
    overflow: scroll;
}

#hipsPanel input[type=range]{
    width: calc(100% - 5px);
}
#hipsPanel input[type=checkbox]{
    margin-left: 15px;
}

#hipsListCtrl{
    top: 500px;
    left: 50px;
}

.hipsRowContainer{
    display: flex;
    flex-direction: column;
    width: 100%;
}

.hipsNameSelection, .hipsFormatOpacity{
    display: flex;
    flex-direction: row;
    align-items: center;
}
.hipsRowContainer{
    padding-bottom: 5px;
    text-align: center;
}

#controlButtonContainer{
    display: flex;
    flex-direction: column;
}

.controlButton{
    max-width: 0px;
    border-radius: 8px;
    transition: 0.5s ease-in-out;
    margin-top: -5px;
    margin-left: 19px;
}

.controlButton:hover{
    cursor: pointer;
    background: rgba(255, 255, 255, 0.3);
    transition: .2s ease-in-out;

}

.controlButton:active{
    cursor: pointer;
    background: rgba(255, 255, 255, 0.6);
    transition: .1s ease-in-out;
}

.controlButtonVisible {
    display: block;
}

.controlButton.controlButtonVisible {
    transition: 0.25s ease-in-out;
    max-width: 38px;
    margin-left: 0px;
    margin-top: 3px;
}

.controlButtonDisabled {
    cursor: pointer;
    opacity: 0.5;
}

#cutoutButton:disabled{
    cursor: pointer;
    opacity: 0.5;
}

#cat-gearButton {
    max-width: 17px;
    border-radius: 8px;
    cursor: pointer;
}

#foot-gearButton {
    max-width: 17px;
    border-radius: 8px;
    cursor: pointer;
}

#hips-gearButton {
    max-width: 17px;
    border-radius: 8px;
    cursor: pointer;
}

#settings-popup {
    position: fixed;
    left: 40%;
    border: 1px solid;
    padding: 5px;
    top: 16%;
    min-width: 200px;
    min-height: 150px;
    display: none;
    background: black;
    border-radius: 3px;
}



#hamburgerButton {
    width: 30px;
    height: 22px;
    position: relative;
    transform: rotate(0deg);
    transition: .5s ease-in-out;
    cursor: pointer;
    margin-bottom: 6px;
    padding: 4px;
    border-radius: 4px;
}

#hamburgerButton:hover {
    background: rgba(255, 255, 255, 0.2);
    transition: .2s ease-in-out;
}

#hamburgerButton:active {
    background: rgba(255, 255, 255, 0.3);
    transition: .1s ease-in-out;
}

#hamburgerButton span {
    display: block;
    position: absolute;
    height: 4px;
    margin-left: 4px;
    margin-top: 4px;
    width: calc(100% - 8px);
    background: white;
    border-radius: 5px;
    left: 0;
    transform: rotate(0deg);
    transition: .25s ease-in-out;
}

#hamburgerButton span:nth-child(1) {
    top: 0px;
}

#hamburgerButton span:nth-child(2),#hamburgerButton span:nth-child(3) {
    top: 9px;
}

#hamburgerButton span:nth-child(4) {
    top: 18px;
}

#hamburgerButton.open span:nth-child(1) {
    top: 9px;
    width: 0%;
    left: 50%;
}

#hamburgerButton.open span:nth-child(2) {
    transform: rotate(45deg);
}

#hamburgerButton.open span:nth-child(3) {
    transform: rotate(-45deg);
}

#hamburgerButton.open span:nth-child(4) {
    top: 9px;
    width: 0%;
    left: 50%;
}

.hipsRowContainer select:hover{
	background-color: rgba(255, 255, 255, 0.15);
}

.hipsRowContainer select:active{
	background-color: rgba(255, 255, 255, 0.30);
}

#coordinateContainer, .hipsRowContainer label {
	line-height: 30px;
}

.hipsRowContainer select {
	color: var(--commonTextColor);
	font-weight: bold;
	background-color: transparent;
	border: 0px;
    padding: 2px;
    margin-right:3px;
}

.hipsRowContainer select:hover {
	cursor: pointer;
}

.hipsRowContainer option{
	background-color: #000000;
}

.settingsRow{
    display: flex;
    margin-top: 10px;
    align-items: center;
    justify-content: space-evenly;
}

#sphericalCoordName {
    text-align: center;
    font-weight: bold;
}

#coords {
    display: grid;
    justify-items: center;
    margin-bottom: 15px;
}

#phiName {
    grid-row: 1;
    grid-column: 1;
}

#thetaName {
    grid-row: 1;
    grid-column: 2;
}

#phi {
    grid-row: 2;
    grid-column: 1;
}

#theta {
    grid-row: 2;
    grid-column: 2;
}

#getFovPoly {
    margin-top: 15px;
    width: 150px;
}

#ctoPanel {
    width: 200px;
    border: 1px solid;
    padding: 3px;
}

#gotoButtonText, #catalogueButtonText, #footprintButtonText,
#mapsButtonText, #settingsButtonText, #cutoutButtonText {
    display: none;
    border: 1px solid #000;
    height: 30px;
    width: 280px;
    margin-left: 53px;
    position: absolute;
}

#gotoButton:hover + #gotoButtonText, 
#cataloguesButton:hover + #catalogueButtonText,
#footprintsButton:hover + #footprintButtonText,
#mapsButton:hover + #mapsButtonText,
#settingsButton:hover + #settingsButtonText,
#cutoutButton:hover + #cutoutButtonText {
    display: block;
}`, "",{"version":3,"sources":["webpack://./src/css/controlpanelcontainer.css"],"names":[],"mappings":"AAAA,gBAAgB;;;;AAIhB;IACI,QAAQ;IACR,SAAS;IACT,kBAAkB;IAClB,YAAY;IACZ,YAAY;IACZ,6BAA6B;;AAEjC;;AAEA;IACI,kBAAkB;IAClB,iBAAiB;IACjB,iCAAiC;IACjC,UAAU;IACV,SAAS;IACT,kBAAkB;IAClB,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,gBAAgB;AACpB;AACA;IACI,aAAa;IACb,mBAAmB;IACnB,iBAAiB;AACrB;AACA;IACI,mBAAmB;AACvB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,oCAAoC;IACpC,eAAe;IACf,YAAY;AAChB;AACA;IACI,qCAAqC;AACzC;;AAEA;IACI,iBAAiB;IACjB,iCAAiC;IACjC,gBAAgB;AACpB;;AAEA;IACI,uBAAuB;AAC3B;AACA;IACI,iBAAiB;AACrB;;AAEA;IACI,UAAU;IACV,UAAU;AACd;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,WAAW;AACf;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,mBAAmB;AACvB;AACA;IACI,mBAAmB;IACnB,kBAAkB;AACtB;;AAEA;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,cAAc;IACd,kBAAkB;IAClB,4BAA4B;IAC5B,gBAAgB;IAChB,iBAAiB;AACrB;;AAEA;IACI,eAAe;IACf,oCAAoC;IACpC,2BAA2B;;AAE/B;;AAEA;IACI,eAAe;IACf,oCAAoC;IACpC,2BAA2B;AAC/B;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,6BAA6B;IAC7B,eAAe;IACf,gBAAgB;IAChB,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,kBAAkB;IAClB,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,kBAAkB;IAClB,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,kBAAkB;IAClB,eAAe;AACnB;;AAEA;IACI,eAAe;IACf,SAAS;IACT,iBAAiB;IACjB,YAAY;IACZ,QAAQ;IACR,gBAAgB;IAChB,iBAAiB;IACjB,aAAa;IACb,iBAAiB;IACjB,kBAAkB;AACtB;;;;AAIA;IACI,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,uBAAuB;IACvB,2BAA2B;IAC3B,eAAe;IACf,kBAAkB;IAClB,YAAY;IACZ,kBAAkB;AACtB;;AAEA;IACI,oCAAoC;IACpC,2BAA2B;AAC/B;;AAEA;IACI,oCAAoC;IACpC,2BAA2B;AAC/B;;AAEA;IACI,cAAc;IACd,kBAAkB;IAClB,WAAW;IACX,gBAAgB;IAChB,eAAe;IACf,uBAAuB;IACvB,iBAAiB;IACjB,kBAAkB;IAClB,OAAO;IACP,uBAAuB;IACvB,4BAA4B;AAChC;;AAEA;IACI,QAAQ;AACZ;;AAEA;IACI,QAAQ;AACZ;;AAEA;IACI,SAAS;AACb;;AAEA;IACI,QAAQ;IACR,SAAS;IACT,SAAS;AACb;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,yBAAyB;AAC7B;;AAEA;IACI,QAAQ;IACR,SAAS;IACT,SAAS;AACb;;AAEA;CACC,2CAA2C;AAC5C;;AAEA;CACC,2CAA2C;AAC5C;;AAEA;CACC,iBAAiB;AAClB;;AAEA;CACC,6BAA6B;CAC7B,iBAAiB;CACjB,6BAA6B;CAC7B,WAAW;IACR,YAAY;IACZ,gBAAgB;AACpB;;AAEA;CACC,eAAe;AAChB;;AAEA;CACC,yBAAyB;AAC1B;;AAEA;IACI,aAAa;IACb,gBAAgB;IAChB,mBAAmB;IACnB,6BAA6B;AACjC;;AAEA;IACI,kBAAkB;IAClB,iBAAiB;AACrB;;AAEA;IACI,aAAa;IACb,qBAAqB;IACrB,mBAAmB;AACvB;;AAEA;IACI,WAAW;IACX,cAAc;AAClB;;AAEA;IACI,WAAW;IACX,cAAc;AAClB;;AAEA;IACI,WAAW;IACX,cAAc;AAClB;;AAEA;IACI,WAAW;IACX,cAAc;AAClB;;AAEA;IACI,gBAAgB;IAChB,YAAY;AAChB;;AAEA;IACI,YAAY;IACZ,iBAAiB;IACjB,YAAY;AAChB;;AAEA;;IAEI,aAAa;IACb,sBAAsB;IACtB,YAAY;IACZ,YAAY;IACZ,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;;;;;;IAMI,cAAc;AAClB","sourcesContent":["@charset \"UTF-8\";\n\n\n\n#controlpanel2container{\n    top: 5px;\n    left: 5px;\n    position: absolute;\n    z-index: 100;\n    padding: 2px;\n    color: var(--commonTextColor);\n\n}\n\n.controlPanel{\n    position: absolute;\n    max-height: 600px;\n    background-color: var(--commonBg);\n    left: 45px;\n    top: 15px;\n    border-radius: 3px;\n    overflow-x: hidden;\n    overflow-y: auto;\n}\n\n.controlPanel label {\n    margin-left: 4px;\n}\n.controlPanel .dataRow {\n    display: flex;\n    padding-right: 20px;\n    padding-left: 3px;\n}\n.controlPanel label {\n    white-space: nowrap;\n}\n\n.controlPanel .dataRow label:hover, .controlPanel .dataRow input:hover{\n    cursor: pointer;\n}\n\n.controlPanel .dataRow:hover{\n    background-color: var(--commonHover);\n    cursor: pointer;\n    color: white;\n}\n.controlPanel .dataRow:active{\n    background-color: var(--commonActive);\n}\n\n#hipsPanel{\n    max-height: 450px;\n    background-color: var(--commonBg);\n    overflow: scroll;\n}\n\n#hipsPanel input[type=range]{\n    width: calc(100% - 5px);\n}\n#hipsPanel input[type=checkbox]{\n    margin-left: 15px;\n}\n\n#hipsListCtrl{\n    top: 500px;\n    left: 50px;\n}\n\n.hipsRowContainer{\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n}\n\n.hipsNameSelection, .hipsFormatOpacity{\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n.hipsRowContainer{\n    padding-bottom: 5px;\n    text-align: center;\n}\n\n#controlButtonContainer{\n    display: flex;\n    flex-direction: column;\n}\n\n.controlButton{\n    max-width: 0px;\n    border-radius: 8px;\n    transition: 0.5s ease-in-out;\n    margin-top: -5px;\n    margin-left: 19px;\n}\n\n.controlButton:hover{\n    cursor: pointer;\n    background: rgba(255, 255, 255, 0.3);\n    transition: .2s ease-in-out;\n\n}\n\n.controlButton:active{\n    cursor: pointer;\n    background: rgba(255, 255, 255, 0.6);\n    transition: .1s ease-in-out;\n}\n\n.controlButtonVisible {\n    display: block;\n}\n\n.controlButton.controlButtonVisible {\n    transition: 0.25s ease-in-out;\n    max-width: 38px;\n    margin-left: 0px;\n    margin-top: 3px;\n}\n\n.controlButtonDisabled {\n    cursor: pointer;\n    opacity: 0.5;\n}\n\n#cutoutButton:disabled{\n    cursor: pointer;\n    opacity: 0.5;\n}\n\n#cat-gearButton {\n    max-width: 17px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n#foot-gearButton {\n    max-width: 17px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n#hips-gearButton {\n    max-width: 17px;\n    border-radius: 8px;\n    cursor: pointer;\n}\n\n#settings-popup {\n    position: fixed;\n    left: 40%;\n    border: 1px solid;\n    padding: 5px;\n    top: 16%;\n    min-width: 200px;\n    min-height: 150px;\n    display: none;\n    background: black;\n    border-radius: 3px;\n}\n\n\n\n#hamburgerButton {\n    width: 30px;\n    height: 22px;\n    position: relative;\n    transform: rotate(0deg);\n    transition: .5s ease-in-out;\n    cursor: pointer;\n    margin-bottom: 6px;\n    padding: 4px;\n    border-radius: 4px;\n}\n\n#hamburgerButton:hover {\n    background: rgba(255, 255, 255, 0.2);\n    transition: .2s ease-in-out;\n}\n\n#hamburgerButton:active {\n    background: rgba(255, 255, 255, 0.3);\n    transition: .1s ease-in-out;\n}\n\n#hamburgerButton span {\n    display: block;\n    position: absolute;\n    height: 4px;\n    margin-left: 4px;\n    margin-top: 4px;\n    width: calc(100% - 8px);\n    background: white;\n    border-radius: 5px;\n    left: 0;\n    transform: rotate(0deg);\n    transition: .25s ease-in-out;\n}\n\n#hamburgerButton span:nth-child(1) {\n    top: 0px;\n}\n\n#hamburgerButton span:nth-child(2),#hamburgerButton span:nth-child(3) {\n    top: 9px;\n}\n\n#hamburgerButton span:nth-child(4) {\n    top: 18px;\n}\n\n#hamburgerButton.open span:nth-child(1) {\n    top: 9px;\n    width: 0%;\n    left: 50%;\n}\n\n#hamburgerButton.open span:nth-child(2) {\n    transform: rotate(45deg);\n}\n\n#hamburgerButton.open span:nth-child(3) {\n    transform: rotate(-45deg);\n}\n\n#hamburgerButton.open span:nth-child(4) {\n    top: 9px;\n    width: 0%;\n    left: 50%;\n}\n\n.hipsRowContainer select:hover{\n\tbackground-color: rgba(255, 255, 255, 0.15);\n}\n\n.hipsRowContainer select:active{\n\tbackground-color: rgba(255, 255, 255, 0.30);\n}\n\n#coordinateContainer, .hipsRowContainer label {\n\tline-height: 30px;\n}\n\n.hipsRowContainer select {\n\tcolor: var(--commonTextColor);\n\tfont-weight: bold;\n\tbackground-color: transparent;\n\tborder: 0px;\n    padding: 2px;\n    margin-right:3px;\n}\n\n.hipsRowContainer select:hover {\n\tcursor: pointer;\n}\n\n.hipsRowContainer option{\n\tbackground-color: #000000;\n}\n\n.settingsRow{\n    display: flex;\n    margin-top: 10px;\n    align-items: center;\n    justify-content: space-evenly;\n}\n\n#sphericalCoordName {\n    text-align: center;\n    font-weight: bold;\n}\n\n#coords {\n    display: grid;\n    justify-items: center;\n    margin-bottom: 15px;\n}\n\n#phiName {\n    grid-row: 1;\n    grid-column: 1;\n}\n\n#thetaName {\n    grid-row: 1;\n    grid-column: 2;\n}\n\n#phi {\n    grid-row: 2;\n    grid-column: 1;\n}\n\n#theta {\n    grid-row: 2;\n    grid-column: 2;\n}\n\n#getFovPoly {\n    margin-top: 15px;\n    width: 150px;\n}\n\n#ctoPanel {\n    width: 200px;\n    border: 1px solid;\n    padding: 3px;\n}\n\n#gotoButtonText, #catalogueButtonText, #footprintButtonText,\n#mapsButtonText, #settingsButtonText, #cutoutButtonText {\n    display: none;\n    border: 1px solid #000;\n    height: 30px;\n    width: 280px;\n    margin-left: 53px;\n    position: absolute;\n}\n\n#gotoButton:hover + #gotoButtonText, \n#cataloguesButton:hover + #catalogueButtonText,\n#footprintsButton:hover + #footprintButtonText,\n#mapsButton:hover + #mapsButtonText,\n#settingsButton:hover + #settingsButtonText,\n#cutoutButton:hover + #cutoutButtonText {\n    display: block;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/style.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/style.css ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `:root {
	--commonBg: rgba(0, 0, 0, .85);
	--commonHover: rgba(42, 54, 239, 0.17);
	--commonActive: rgba(42, 54, 239, 0.3);
	--commonfontfamily: monospace;
	--commonTextColor: #57d1c9;
}

body {
	margin: 0px;
	border: 0px;
	padding: 0px;
	font-family: var(--commonfontfamily);
	background-color: black;
	overflow: hidden;
}

#fabviewer_canvas {
	/* 	position: absolute; */
	left: 0px;
	top: 0px;
}

#fabvcontainer {
	/* 	border: 1px solid green; */
	min-width: 150px;
	min-height: 150px;
	float: left;
	position: relative;
}

#version {
	position: absolute;
	bottom: 3px;
	left: 50%;
	height: 18px;
	color: #57d1c9;
}

#message {
	position: absolute;
	top: 64px;
	color: #57d1c9;
	left: 41%;
	width: 267px;
	overflow: scroll;
	max-height: 50px;
}

#controlpanel {
	border: 1px solid black;
	padding: 5px;
	min-width: 180px;
	min-height: 50px;
	position: absolute;
	width: 20%;
	background-color: rgba(255, 255, 255, .15);
	backdrop-filter: blur(5px);
	color: #85d6d1;
	cursor: move;
	text-shadow: 0px 0px 5px #85d6d1;
	font-family: monospace;
	border-radius: 5px;
	left: 1%;
	top: 1%;
}

#metadata_button {
	bottom: 2px;
	position: absolute;
	right: 10px;
	padding: 1px;
}

#metadata_button>img{
	height: 40px;
}
/* #metadata_button {
	bottom: 0px;
	width: 73px;
	height: 16px;
	position: absolute;
	right: 10px;
	padding: 1px;
	font-size: 12px;
} */

#datapanel {
	min-height: 150px;
	border: 1px solid blue;
	position: absolute;
	width: 99%;
	height: 20%;
	bottom: 25px;
	left: auto;
	right: auto;
	margin-left: 4px;
	background: cornflowerblue;
	overflow: scroll;
}

.button {
	border: none;
	color: white;
	padding: 5px 12px;
	text-align: center;
	text-decoration: none;
	display: block;
	font-size: 16px;
	margin: 4px 2px;
	border-radius: 5px;
	cursor: pointer;
	background-color: #008CBA;
}


::-webkit-scrollbar {
	width: 12px;
}

::-webkit-scrollbar-corner {
	background-color: transparent;
}

::-webkit-scrollbar-thumb {
	-webkit-border-radius: 10px;
	border-radius: 10px;
	background: rgba(255, 255, 255, 0.8);
	box-shadow: inset 0 0 6px rgb(0 0 0 / 50%);
	-webkit-box-shadow: inset 0 0 6px rgb(0 0 0 / 50%);
}

::-webkit-scrollbar-track {
	box-shadow: inset 0 0 6px rgb(0 0 0 / 30%);
	-webkit-box-shadow: inset 0 0 6px rgb(0 0 0 / 30%);
	-webkit-border-radius: 10px;
	border-radius: 10px;
}

.floating-div-ra {
	position: absolute;
	color: blue;
}

.floating-div-dec {
	position: absolute;
	color: green;
}`, "",{"version":3,"sources":["webpack://./src/css/style.css"],"names":[],"mappings":"AAAA;CACC,8BAA8B;CAC9B,sCAAsC;CACtC,sCAAsC;CACtC,6BAA6B;CAC7B,0BAA0B;AAC3B;;AAEA;CACC,WAAW;CACX,WAAW;CACX,YAAY;CACZ,oCAAoC;CACpC,uBAAuB;CACvB,gBAAgB;AACjB;;AAEA;CACC,yBAAyB;CACzB,SAAS;CACT,QAAQ;AACT;;AAEA;CACC,8BAA8B;CAC9B,gBAAgB;CAChB,iBAAiB;CACjB,WAAW;CACX,kBAAkB;AACnB;;AAEA;CACC,kBAAkB;CAClB,WAAW;CACX,SAAS;CACT,YAAY;CACZ,cAAc;AACf;;AAEA;CACC,kBAAkB;CAClB,SAAS;CACT,cAAc;CACd,SAAS;CACT,YAAY;CACZ,gBAAgB;CAChB,gBAAgB;AACjB;;AAEA;CACC,uBAAuB;CACvB,YAAY;CACZ,gBAAgB;CAChB,gBAAgB;CAChB,kBAAkB;CAClB,UAAU;CACV,0CAA0C;CAC1C,0BAA0B;CAC1B,cAAc;CACd,YAAY;CACZ,gCAAgC;CAChC,sBAAsB;CACtB,kBAAkB;CAClB,QAAQ;CACR,OAAO;AACR;;AAEA;CACC,WAAW;CACX,kBAAkB;CAClB,WAAW;CACX,YAAY;AACb;;AAEA;CACC,YAAY;AACb;AACA;;;;;;;;GAQG;;AAEH;CACC,iBAAiB;CACjB,sBAAsB;CACtB,kBAAkB;CAClB,UAAU;CACV,WAAW;CACX,YAAY;CACZ,UAAU;CACV,WAAW;CACX,gBAAgB;CAChB,0BAA0B;CAC1B,gBAAgB;AACjB;;AAEA;CACC,YAAY;CACZ,YAAY;CACZ,iBAAiB;CACjB,kBAAkB;CAClB,qBAAqB;CACrB,cAAc;CACd,eAAe;CACf,eAAe;CACf,kBAAkB;CAClB,eAAe;CACf,yBAAyB;AAC1B;;;AAGA;CACC,WAAW;AACZ;;AAEA;CACC,6BAA6B;AAC9B;;AAEA;CACC,2BAA2B;CAC3B,mBAAmB;CACnB,oCAAoC;CACpC,0CAA0C;CAC1C,kDAAkD;AACnD;;AAEA;CACC,0CAA0C;CAC1C,kDAAkD;CAClD,2BAA2B;CAC3B,mBAAmB;AACpB;;AAEA;CACC,kBAAkB;CAClB,WAAW;AACZ;;AAEA;CACC,kBAAkB;CAClB,YAAY;AACb","sourcesContent":[":root {\n\t--commonBg: rgba(0, 0, 0, .85);\n\t--commonHover: rgba(42, 54, 239, 0.17);\n\t--commonActive: rgba(42, 54, 239, 0.3);\n\t--commonfontfamily: monospace;\n\t--commonTextColor: #57d1c9;\n}\n\nbody {\n\tmargin: 0px;\n\tborder: 0px;\n\tpadding: 0px;\n\tfont-family: var(--commonfontfamily);\n\tbackground-color: black;\n\toverflow: hidden;\n}\n\n#fabviewer_canvas {\n\t/* \tposition: absolute; */\n\tleft: 0px;\n\ttop: 0px;\n}\n\n#fabvcontainer {\n\t/* \tborder: 1px solid green; */\n\tmin-width: 150px;\n\tmin-height: 150px;\n\tfloat: left;\n\tposition: relative;\n}\n\n#version {\n\tposition: absolute;\n\tbottom: 3px;\n\tleft: 50%;\n\theight: 18px;\n\tcolor: #57d1c9;\n}\n\n#message {\n\tposition: absolute;\n\ttop: 64px;\n\tcolor: #57d1c9;\n\tleft: 41%;\n\twidth: 267px;\n\toverflow: scroll;\n\tmax-height: 50px;\n}\n\n#controlpanel {\n\tborder: 1px solid black;\n\tpadding: 5px;\n\tmin-width: 180px;\n\tmin-height: 50px;\n\tposition: absolute;\n\twidth: 20%;\n\tbackground-color: rgba(255, 255, 255, .15);\n\tbackdrop-filter: blur(5px);\n\tcolor: #85d6d1;\n\tcursor: move;\n\ttext-shadow: 0px 0px 5px #85d6d1;\n\tfont-family: monospace;\n\tborder-radius: 5px;\n\tleft: 1%;\n\ttop: 1%;\n}\n\n#metadata_button {\n\tbottom: 2px;\n\tposition: absolute;\n\tright: 10px;\n\tpadding: 1px;\n}\n\n#metadata_button>img{\n\theight: 40px;\n}\n/* #metadata_button {\n\tbottom: 0px;\n\twidth: 73px;\n\theight: 16px;\n\tposition: absolute;\n\tright: 10px;\n\tpadding: 1px;\n\tfont-size: 12px;\n} */\n\n#datapanel {\n\tmin-height: 150px;\n\tborder: 1px solid blue;\n\tposition: absolute;\n\twidth: 99%;\n\theight: 20%;\n\tbottom: 25px;\n\tleft: auto;\n\tright: auto;\n\tmargin-left: 4px;\n\tbackground: cornflowerblue;\n\toverflow: scroll;\n}\n\n.button {\n\tborder: none;\n\tcolor: white;\n\tpadding: 5px 12px;\n\ttext-align: center;\n\ttext-decoration: none;\n\tdisplay: block;\n\tfont-size: 16px;\n\tmargin: 4px 2px;\n\tborder-radius: 5px;\n\tcursor: pointer;\n\tbackground-color: #008CBA;\n}\n\n\n::-webkit-scrollbar {\n\twidth: 12px;\n}\n\n::-webkit-scrollbar-corner {\n\tbackground-color: transparent;\n}\n\n::-webkit-scrollbar-thumb {\n\t-webkit-border-radius: 10px;\n\tborder-radius: 10px;\n\tbackground: rgba(255, 255, 255, 0.8);\n\tbox-shadow: inset 0 0 6px rgb(0 0 0 / 50%);\n\t-webkit-box-shadow: inset 0 0 6px rgb(0 0 0 / 50%);\n}\n\n::-webkit-scrollbar-track {\n\tbox-shadow: inset 0 0 6px rgb(0 0 0 / 30%);\n\t-webkit-box-shadow: inset 0 0 6px rgb(0 0 0 / 30%);\n\t-webkit-border-radius: 10px;\n\tborder-radius: 10px;\n}\n\n.floating-div-ra {\n\tposition: absolute;\n\tcolor: blue;\n}\n\n.floating-div-dec {\n\tposition: absolute;\n\tcolor: green;\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_TYPE: () => (/* binding */ ARRAY_TYPE),
/* harmony export */   EPSILON: () => (/* binding */ EPSILON),
/* harmony export */   RANDOM: () => (/* binding */ RANDOM),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   setMatrixArrayType: () => (/* binding */ setMatrixArrayType),
/* harmony export */   toRadian: () => (/* binding */ toRadian)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromMat2d: () => (/* binding */ fromMat2d),
/* harmony export */   fromMat4: () => (/* binding */ fromMat4),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   normalFromMat4: () => (/* binding */ normalFromMat4),
/* harmony export */   projection: () => (/* binding */ projection),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromQuat2: () => (/* binding */ fromQuat2),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromRotationTranslation: () => (/* binding */ fromRotationTranslation),
/* harmony export */   fromRotationTranslationScale: () => (/* binding */ fromRotationTranslationScale),
/* harmony export */   fromRotationTranslationScaleOrigin: () => (/* binding */ fromRotationTranslationScaleOrigin),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   fromXRotation: () => (/* binding */ fromXRotation),
/* harmony export */   fromYRotation: () => (/* binding */ fromYRotation),
/* harmony export */   fromZRotation: () => (/* binding */ fromZRotation),
/* harmony export */   frustum: () => (/* binding */ frustum),
/* harmony export */   getRotation: () => (/* binding */ getRotation),
/* harmony export */   getScaling: () => (/* binding */ getScaling),
/* harmony export */   getTranslation: () => (/* binding */ getTranslation),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   lookAt: () => (/* binding */ lookAt),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   ortho: () => (/* binding */ ortho),
/* harmony export */   orthoNO: () => (/* binding */ orthoNO),
/* harmony export */   orthoZO: () => (/* binding */ orthoZO),
/* harmony export */   perspective: () => (/* binding */ perspective),
/* harmony export */   perspectiveFromFieldOfView: () => (/* binding */ perspectiveFromFieldOfView),
/* harmony export */   perspectiveNO: () => (/* binding */ perspectiveNO),
/* harmony export */   perspectiveZO: () => (/* binding */ perspectiveZO),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   targetTo: () => (/* binding */ targetTo),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   angle: () => (/* binding */ angle),
/* harmony export */   bezier: () => (/* binding */ bezier),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   hermite: () => (/* binding */ hermite),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat3: () => (/* binding */ transformMat3),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/CircleFinder.js":
/*!********************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/CircleFinder.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircleFinder: () => (/* binding */ CircleFinder)
/* harmony export */ });
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3.js */ "./node_modules/healpixjs/lib-esm/Vec3.js");

class CircleFinder {
    /**
     * @param point: Vec3
     */
    constructor(point) {
        let np = point.length;
        //HealpixUtils.check(np>=2,"too few points");
        if (!(np >= 2)) {
            console.log("too few points");
            return;
        }
        this.center = point[0].add(point[1]);
        this.center.normalize();
        this.cosrad = point[0].dot(this.center);
        for (let i = 2; i < np; ++i) {
            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle
                this.getCircle(point, i);
            }
        }
    }
    ;
    /**
     * @parm point: Vec3
     * @param q: int
     */
    getCircle(point, q) {
        this.center = point[0].add(point[q]);
        this.center.normalize();
        this.cosrad = point[0].dot(this.center);
        for (let i = 1; i < q; ++i) {
            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle
                this.getCircle2(point, i, q);
            }
        }
    }
    ;
    /**
     * @parm point: Vec3
     * @param q1: int
     * @param q2: int
     */
    getCircle2(point, q1, q2) {
        this.center = point[q1].add(point[q2]);
        this.center.normalize();
        this.cosrad = point[q1].dot(this.center);
        for (let i = 0; i < q1; ++i) {
            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle
                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));
                this.center.normalize();
                this.cosrad = point[i].dot(this.center);
                if (this.cosrad < 0) {
                    this.center.flip();
                    this.cosrad = -this.cosrad;
                }
            }
        }
    }
    ;
    getCenter() {
        return new _Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(this.center.x, this.center.y, this.center.z);
    }
    getCosrad() {
        return this.cosrad;
    }
    ;
}
//# sourceMappingURL=CircleFinder.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Constants: () => (/* binding */ Constants)
/* harmony export */ });
class Constants {
}
//	static halfpi = Math.PI/2.;
Constants.halfpi = 1.5707963267948966;
Constants.inv_halfpi = 2. / Math.PI;
/** The Constant twopi. */
Constants.twopi = 2 * Math.PI;
Constants.inv_twopi = 1. / (2 * Math.PI);
//# sourceMappingURL=Constants.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Fxyf.js":
/*!************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Fxyf.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fxyf: () => (/* binding */ Fxyf)
/* harmony export */ });
/* harmony import */ var _Hploc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hploc.js */ "./node_modules/healpixjs/lib-esm/Hploc.js");
/**
 * Partial porting to Javascript of Fxyf.java from Healpix3.30
 */

class Fxyf {
    constructor(x, y, f) {
        this.fx = x;
        this.fy = y;
        this.face = f;
        // coordinate of the lowest corner of each face
        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);
        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);
        this.halfpi = Math.PI / 2.;
    }
    toHploc() {
        let loc = new _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc();
        let jr = this.jrll[this.face] - this.fx - this.fy;
        let nr;
        if (jr < 1) {
            nr = jr;
            let tmp = nr * nr / 3.;
            loc.z = 1 - tmp;
            if (loc.z > 0.99) {
                loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                loc.have_sth = true;
            }
        }
        else if (jr > 3) {
            nr = 4 - jr;
            let tmp = nr * nr / 3.;
            loc.z = tmp - 1;
            if (loc.z < -0.99) {
                loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                loc.have_sth = true;
            }
        }
        else {
            nr = 1;
            loc.z = (2 - jr) * 2.0 / 3.;
        }
        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;
        if (tmp < 0) {
            tmp += 8;
        }
        if (tmp >= 8) {
            tmp -= 8;
        }
        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;
        return loc;
    }
    ;
    toVec3() {
        return this.toHploc().toVec3();
    }
    ;
}
//# sourceMappingURL=Fxyf.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Healpix.js":
/*!***************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Healpix.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Healpix: () => (/* binding */ Healpix)
/* harmony export */ });
/* harmony import */ var _CircleFinder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CircleFinder.js */ "./node_modules/healpixjs/lib-esm/CircleFinder.js");
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Constants.js */ "./node_modules/healpixjs/lib-esm/Constants.js");
/* harmony import */ var _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Fxyf.js */ "./node_modules/healpixjs/lib-esm/Fxyf.js");
/* harmony import */ var _Hploc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hploc.js */ "./node_modules/healpixjs/lib-esm/Hploc.js");
/* harmony import */ var _Pointing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pointing.js */ "./node_modules/healpixjs/lib-esm/Pointing.js");
/* harmony import */ var _pstack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pstack.js */ "./node_modules/healpixjs/lib-esm/pstack.js");
/* harmony import */ var _RangeSet_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RangeSet.js */ "./node_modules/healpixjs/lib-esm/RangeSet.js");
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Vec3.js */ "./node_modules/healpixjs/lib-esm/Vec3.js");
/* harmony import */ var _Xyf_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Xyf.js */ "./node_modules/healpixjs/lib-esm/Xyf.js");
/* harmony import */ var _Zphi_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Zphi.js */ "./node_modules/healpixjs/lib-esm/Zphi.js");











/**
 * Partial porting to Javascript of HealpixBase.java from Healpix3.30
 */
// import Fxyf from './Fxyf.js';
// import Hploc from './Hploc.js';
// import Xyf from './Xyf.js';
// import Vec3 from './Vec3.js';
// import Pointing from './Pointing.js';
// import CircleFinder from './CircleFinder.js';
// import Zphi from './Zphi.js';
// import pstack from './pstack.js';
// import Constants from './Constants.js';
// import RangeSet from './RangeSet.js';
class Healpix {
    constructor(nside_in) {
        this.order_max = 29;
        this.inv_halfpi = 2.0 / Math.PI;
        this.twothird = 2.0 / 3.;
        // console.log("twothird "+this.twothird);
        // this.ns_max=1L<<order_max;
        this.ns_max = Math.pow(2, this.order_max);
        this.ctab = new Uint16Array([
            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,
            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,
            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,
            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,
            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,
            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,
            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,
            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,
            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,
            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,
            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,
            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,
            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,
            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,
            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,
            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855
        ]);
        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,
            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,
            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,
            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,
            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,
            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,
            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,
            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,
            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,
            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,
            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,
            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,
            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,
            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,
            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,
            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,
            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,
            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);
        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);
        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);
        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);
        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);
        this.facearray = [
            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),
            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),
            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),
            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),
            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),
            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),
            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),
            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),
            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N
        ];
        // questo forse deve essere un UInt8Array. Viene usato da neighbours
        this.swaparray = [
            new Int16Array([0, 0, 3]),
            new Int16Array([0, 0, 6]),
            new Int16Array([0, 0, 0]),
            new Int16Array([0, 0, 5]),
            new Int16Array([0, 0, 0]),
            new Int16Array([5, 0, 0]),
            new Int16Array([0, 0, 0]),
            new Int16Array([6, 0, 0]),
            new Int16Array([3, 0, 0]) // N
        ];
        if (nside_in <= this.ns_max && nside_in > 0) {
            this.nside = nside_in;
            this.npface = this.nside * this.nside;
            this.npix = 12 * this.npface;
            this.order = this.nside2order(this.nside);
            this.nl2 = 2 * this.nside;
            this.nl3 = 3 * this.nside;
            this.nl4 = 4 * this.nside;
            this.fact2 = 4.0 / this.npix;
            this.fact1 = (this.nside << 1) * this.fact2;
            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap
            // console.log("order: "+this.order);
            // console.log("nside: "+this.nside);
        }
        this.bn = [];
        this.mpr = [];
        this.cmpr = [];
        this.smpr = [];
        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT
        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT
        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT
        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT
        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT
        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT
        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT
        // Uncaught RangeError: Maximum call stack size exceeded
        // MOVED TO computeBn()
        //        for (let i=0; i <= this.order_max; ++i) {
        //        	this.bn[i]=new Healpix(1<<i);
        //        	this.mpr[i]=bn[i].maxPixrad();
        //        	this.cmpr[i]=Math.cos(mpr[i]);
        //        	this.smpr[i]=Math.sin(mpr[i]);
        //        }
    }
    computeBn() {
        for (let i = 0; i <= this.order_max; ++i) {
            this.bn[i] = new Healpix(1 << i);
            this.mpr[i] = this.bn[i].maxPixrad();
            this.cmpr[i] = _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.cos(this.mpr[i]);
            this.smpr[i] = _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.sin(this.mpr[i]);
        }
    }
    getNPix() {
        return this.npix;
    }
    ;
    getBoundaries(pix) {
        let points = new Array();
        let xyf = this.nest2xyf(pix);
        // console.log("PIXEL: "+pix);
        // console.log("XYF "+xyf.ix+" "+xyf.iy+" "+xyf.face);
        let dc = 0.5 / this.nside;
        let xc = (xyf.ix + 0.5) / this.nside;
        let yc = (xyf.iy + 0.5) / this.nside;
        // let d = 1.0/(this.nside);
        // console.log("------------------------");
        // console.log("xc, yc, dc "+xc+","+ yc+","+ dc);
        // console.log("xc+dc-d, yc+dc, xyf.face, d "+(xc+dc) +","+ (yc+dc)+","+
        // xyf.face+","+ d);
        points[0] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc, yc + dc, xyf.face).toVec3();
        points[1] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc, yc + dc, xyf.face).toVec3();
        points[2] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc, yc - dc, xyf.face).toVec3();
        points[3] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc, yc - dc, xyf.face).toVec3();
        // console.log("Points for npix: "+pix);
        // console.log(points);
        // if (pix > 750){
        // console.log("pix: "+pix);
        // console.log("dc: "+dc);
        // console.log("xyf.ix: "+xyf.ix);
        // console.log("xyf.iy: "+xyf.iy);
        // console.log("xc: "+xc);
        // console.log("yc: "+yc);
        // console.log("d: "+d);
        // }
        return points;
    }
    ;
    /** Returns a set of points along the boundary of the given pixel.
     * Step 1 gives 4 points on the corners. The first point corresponds
     * to the northernmost corner, the subsequent points follow the pixel
     * boundary through west, south and east corners.
     *
     * @param pix pixel index number
     * @param step the number of returned points is 4*step
     * @return {@link Vec3} for each point
     */
    getBoundariesWithStep(pix, step) {
        // var points = new Array(); 
        let points = new Array();
        let xyf = this.nest2xyf(pix);
        let dc = 0.5 / this.nside;
        let xc = (xyf.ix + 0.5) / this.nside;
        let yc = (xyf.iy + 0.5) / this.nside;
        let d = 1.0 / (this.nside * step);
        for (let i = 0; i < step; i++) {
            points[i] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();
            points[i + step] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();
            points[i + 2 * step] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();
            points[i + 3 * step] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();
        }
        return points;
    }
    ;
    getPointsForXyfNoStep(x, y, face) {
        let nside = Math.pow(2, this.order);
        let points = new Array();
        let xyf = new _Xyf_js__WEBPACK_IMPORTED_MODULE_8__.Xyf(x, y, face);
        let dc = 0.5 / nside;
        let xc = (xyf.ix + 0.5) / nside;
        let yc = (xyf.iy + 0.5) / nside;
        points[0] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc, yc + dc, xyf.face).toVec3();
        points[1] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc, yc + dc, xyf.face).toVec3();
        points[2] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc, yc - dc, xyf.face).toVec3();
        points[3] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc, yc - dc, xyf.face).toVec3();
        return points;
    }
    getPointsForXyf(x, y, step, face) {
        let nside = step * Math.pow(2, this.order);
        let points = new Array();
        let xyf = new _Xyf_js__WEBPACK_IMPORTED_MODULE_8__.Xyf(x, y, face);
        let dc = 0.5 / nside;
        let xc = (xyf.ix + 0.5) / nside;
        let yc = (xyf.iy + 0.5) / nside;
        points[0] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc, yc + dc, xyf.face).toVec3();
        points[1] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc, yc + dc, xyf.face).toVec3();
        points[2] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc - dc, yc - dc, xyf.face).toVec3();
        points[3] = new _Fxyf_js__WEBPACK_IMPORTED_MODULE_2__.Fxyf(xc + dc, yc - dc, xyf.face).toVec3();
        return points;
    }
    /** Returns the neighboring pixels of ipix.
    This method works in both RING and NEST schemes, but is
    considerably faster in the NEST scheme.
    @param ipix the requested pixel number.
    @return array with indices of the neighboring pixels.
      The returned array contains (in this order)
      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor
      of ipix. If a neighbor does not exist (this can only happen
      for the W, N, E and S neighbors), its entry is set to -1. */
    neighbours(ipix) {
        let result = new Int32Array(8);
        let xyf = this.nest2xyf(ipix);
        let ix = xyf.ix;
        let iy = xyf.iy;
        let face_num = xyf.face;
        var nsm1 = this.nside - 1;
        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {
            let fpix = Math.floor(face_num << (2 * this.order));
            let px0 = this.spread_bits(ix);
            let py0 = this.spread_bits(iy) << 1;
            let pxp = this.spread_bits(ix + 1);
            let pyp = this.spread_bits(iy + 1) << 1;
            let pxm = this.spread_bits(ix - 1);
            let pym = this.spread_bits(iy - 1) << 1;
            result[0] = fpix + pxm + py0;
            result[1] = fpix + pxm + pyp;
            result[2] = fpix + px0 + pyp;
            result[3] = fpix + pxp + pyp;
            result[4] = fpix + pxp + py0;
            result[5] = fpix + pxp + pym;
            result[6] = fpix + px0 + pym;
            result[7] = fpix + pxm + pym;
        }
        else {
            for (let i = 0; i < 8; ++i) {
                let x = ix + this.xoffset[i];
                let y = iy + this.yoffset[i];
                let nbnum = 4;
                if (x < 0) {
                    x += this.nside;
                    nbnum -= 1;
                }
                else if (x >= this.nside) {
                    x -= this.nside;
                    nbnum += 1;
                }
                if (y < 0) {
                    y += this.nside;
                    nbnum -= 3;
                }
                else if (y >= this.nside) {
                    y -= this.nside;
                    nbnum += 3;
                }
                let f = this.facearray[nbnum][face_num];
                if (f >= 0) {
                    let bits = this.swaparray[nbnum][face_num >>> 2];
                    if ((bits & 1) > 0) {
                        x = Math.floor(this.nside - x - 1);
                    }
                    if ((bits & 2) > 0) {
                        y = Math.floor(this.nside - y - 1);
                    }
                    if ((bits & 4) > 0) {
                        let tint = x;
                        x = y;
                        y = tint;
                    }
                    result[i] = this.xyf2nest(x, y, f);
                }
                else {
                    result[i] = -1;
                }
            }
        }
        return result;
    }
    ;
    nside2order(nside) {
        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);
    }
    ;
    nest2xyf(ipix) {
        let pix = Math.floor(ipix & (this.npface - 1));
        let xyf = new _Xyf_js__WEBPACK_IMPORTED_MODULE_8__.Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));
        return xyf;
    }
    ;
    xyf2nest(ix, iy, face_num) {
        return Math.floor(face_num << (2 * this.order))
            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);
    }
    ;
    loc2pix(hploc) {
        let z = hploc.z;
        let phi = hploc.phi;
        let za = Math.abs(z);
        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)
        let pixNo;
        if (za <= this.twothird) { // Equatorial region
            let temp1 = this.nside * (0.5 + tt);
            let temp2 = this.nside * (z * 0.75);
            let jp = Math.floor(temp1 - temp2); // index of ascending edge line
            let jm = Math.floor(temp1 + temp2); // index of descending edge line
            let ifp = Math.floor(jp >>> this.order); // in {0,4}
            let ifm = Math.floor(jm >>> this.order);
            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));
            let ix = Math.floor(jm & (this.nside - 1));
            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);
            pixNo = this.xyf2nest(ix, iy, face_num);
        }
        else { // polar region, za > 2/3
            let ntt = Math.min(3, Math.floor(tt));
            let tp = tt - ntt;
            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?
                this.nside * Math.sqrt(3 * (1 - za)) :
                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);
            let jp = Math.floor(tp * tmp); // increasing edge line index
            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index
            if (jp >= this.nside) {
                jp = this.nside - 1; // for points too close to the boundary
            }
            if (jm >= this.nside) {
                jm = this.nside - 1;
            }
            if (z >= 0) {
                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);
            }
            else {
                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);
            }
        }
        return pixNo;
    }
    ;
    /** Returns the normalized 3-vector corresponding to the center of the
    supplied pixel.
    @param pix long the requested pixel number.
    @return the pixel's center coordinates. */
    pix2vec(pix) {
        return this.pix2loc(pix).toVec3();
    }
    ;
    /** Returns the Zphi corresponding to the center of the supplied pixel.
     @param pix the requested pixel number.
     @return the pixel's center coordinates. */
    pix2zphi(pix) {
        return this.pix2loc(pix).toZphi();
    }
    /**
     * @param pix long
     * @return Hploc
     */
    pix2loc(pix) {
        let loc = new _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc(undefined);
        let xyf = this.nest2xyf(pix);
        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;
        let nr;
        if (jr < this.nside) {
            nr = jr;
            let tmp = (nr * nr) * this.fact2;
            loc.z = 1 - tmp;
            if (loc.z > 0.99) {
                loc.sth = Math.sqrt(tmp * (2. - tmp));
                loc.have_sth = true;
            }
        }
        else if (jr > this.nl3) {
            nr = this.nl4 - jr;
            let tmp = (nr * nr) * this.fact2;
            loc.z = tmp - 1;
            if (loc.z < -0.99) {
                loc.sth = Math.sqrt(tmp * (2. - tmp));
                loc.have_sth = true;
            }
        }
        else {
            nr = this.nside;
            loc.z = (this.nl2 - jr) * this.fact1;
        }
        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;
        //      	assert(tmp<8*nr); // must not happen
        if (tmp < 0) {
            tmp += 8 * nr;
        }
        loc.phi = (nr == this.nside) ? 0.75 * _Constants_js__WEBPACK_IMPORTED_MODULE_1__.Constants.halfpi * tmp * this.fact1 : (0.5 * _Constants_js__WEBPACK_IMPORTED_MODULE_1__.Constants.halfpi * tmp) / nr;
        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);
        return loc;
    }
    ;
    ang2pix(ptg, mirror) {
        return this.loc2pix(new _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc(ptg));
    }
    ;
    fmodulo(v1, v2) {
        if (v1 >= 0) {
            return (v1 < v2) ? v1 : v1 % v2;
        }
        var tmp = v1 % v2 + v2;
        return (tmp === v2) ? 0.0 : tmp;
    }
    ;
    compress_bits(v) {
        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));
        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);
        return compressed;
    }
    ;
    spread_bits(v) {
        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))
            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));
    }
    ;
    /**
     * Returns a range set of pixels that overlap with the convex polygon
     * defined by the {@code vertex} array.
     * <p>
     * This method is more efficient in the RING scheme.
     * <p>
     * This method may return some pixels which don't overlap with the polygon
     * at all. The higher {@code fact} is chosen, the fewer false positives are
     * returned, at the cost of increased run time.
     *
     * @param vertex
     *            an array containing the vertices of the requested convex
     *            polygon.
     * @param fact
     *            The overlapping test will be done at the resolution
     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be
     *            a power of 2, else it can be any positive integer. A typical
     *            choice would be 4.
     * @return the requested set of pixel number ranges
     */
    queryPolygonInclusive(vertex, fact) {
        let inclusive = (fact != 0);
        let nv = vertex.length;
        //        let ncirc = inclusive ? nv+1 : nv;
        if (!(nv >= 3)) {
            console.log("not enough vertices in polygon");
            return;
        }
        let vv = new Array();
        for (let i = 0; i < nv; ++i) {
            vv[i] = _Vec3_js__WEBPACK_IMPORTED_MODULE_7__.Vec3.pointing2Vec3(vertex[i]);
        }
        let normal = new Array();
        let flip = 0;
        let index = 0;
        let back = false;
        while (index < vv.length) {
            let first = vv[index];
            let medium = null;
            let last = null;
            if (index == vv.length - 1) {
                last = vv[1];
                medium = vv[0];
            }
            else if (index == vv.length - 2) {
                last = vv[0];
                medium = vv[index + 1];
            }
            else {
                medium = vv[index + 1];
                last = vv[index + 2];
            }
            normal[index] = first.cross(medium).norm();
            let hnd = normal[index].dot(last);
            if (index == 0) {
                flip = (hnd < 0.) ? -1 : 1;
                let tmp = new _Pointing_js__WEBPACK_IMPORTED_MODULE_4__.Pointing(first); // TODO not used
                back = false;
            }
            else {
                let flipThnd = flip * hnd;
                if (flipThnd < 0) {
                    let tmp = new _Pointing_js__WEBPACK_IMPORTED_MODULE_4__.Pointing(medium);
                    vv.splice(index + 1, 1);
                    normal.splice(index, 1);
                    back = true;
                    index -= 1;
                    continue;
                }
                else {
                    let tmp = new _Pointing_js__WEBPACK_IMPORTED_MODULE_4__.Pointing(first);
                    back = false;
                }
            }
            normal[index].scale(flip);
            index += 1;
        }
        nv = vv.length;
        let ncirc = inclusive ? nv + 1 : nv;
        let rad = new Array(ncirc);
        rad = rad.fill(_Constants_js__WEBPACK_IMPORTED_MODULE_1__.Constants.halfpi);
        //        rad = rad.fill(1.5707963267948966);
        //        let p = "1.5707963267948966";
        //        rad = rad.fill(parseFloat(p));
        if (inclusive) {
            let cf = new _CircleFinder_js__WEBPACK_IMPORTED_MODULE_0__.CircleFinder(vv);
            normal[nv] = cf.getCenter();
            rad[nv] = _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.acos(cf.getCosrad());
        }
        return this.queryMultiDisc(normal, rad, fact);
    }
    ;
    /**
     * For NEST schema only
     *
     * @param normal:
     *            Vec3[]
     * @param rad:
     *            Float32Array
     * @param fact:
     *            The overlapping test will be done at the resolution
     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be
     *            a power of 2, else it can be any positive integer. A typical
     *            choice would be 4.
     * @return RangeSet the requested set of pixel number ranges
     */
    queryMultiDisc(norm, rad, fact) {
        this.computeBn();
        let inclusive = (fact != 0);
        let nv = norm.length;
        // HealpixUtils.check(nv==rad.lengt0,"inconsistent input arrays");
        if (!(nv == rad.length)) {
            console.error("inconsistent input arrays");
            return;
        }
        let res = new _RangeSet_js__WEBPACK_IMPORTED_MODULE_6__.RangeSet(4 << 1);
        // Removed code for Scheme.RING
        let oplus = 0;
        if (inclusive) {
            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {
                console.error("invalid oversampling factor");
            }
            if (!((fact & (fact - 1)) == 0)) {
                console.error("oversampling factor must be a power of 2");
            }
            oplus = this.ilog2(fact);
        }
        let omax = this.order + oplus; // the order up to which we test
        // TODO: ignore all disks with radius>=pi
        //        let crlimit = new Float32Array[omax+1][nv][3];
        let crlimit = new Array(omax + 1);
        let o;
        let i;
        for (o = 0; o <= omax; ++o) { // prepare data at the required orders
            crlimit[o] = new Array(nv);
            let dr = this.bn[o].maxPixrad(); // safety distance
            for (i = 0; i < nv; ++i) {
                crlimit[o][i] = new Float64Array(3);
                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.cos(rad[i] + dr);
                crlimit[o][i][1] = (o == 0) ? _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.cos(rad[i]) : crlimit[0][i][1];
                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.cos(rad[i] - dr);
            }
        }
        let stk = new _pstack_js__WEBPACK_IMPORTED_MODULE_5__.pstack(12 + 3 * omax);
        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse
            // order
            stk.push(11 - i, 0);
        }
        while (stk.size() > 0) { // as long as there are pixels on the stack
            // pop current pixel number and order from the stack
            let pix = stk.ptop();
            let o = stk.otop();
            stk.pop();
            let pv = this.bn[o].pix2vec(pix);
            let zone = 3;
            for (let i = 0; (i < nv) && (zone > 0); ++i) {
                let crad = pv.dot(norm[i]);
                for (let iz = 0; iz < zone; ++iz) {
                    if (crad < crlimit[o][i][iz]) {
                        zone = iz;
                    }
                }
            }
            if (zone > 0) {
                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);
            }
        }
        return res;
    }
    ;
    /** Integer base 2 logarithm.
    @param arg
    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.
    For negative arguments and zero, 0 is returned. */
    ilog2(arg) {
        let max = Math.max(arg, 1);
        return 31 - Math.clz32(max);
    }
    ;
    /** Computes the cosine of the angular distance between two z, phi positions
      on the unit sphere. */
    cosdist_zphi(z1, phi1, z2, phi2) {
        return z1 * z2 + _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));
    }
    /**
     * @param int o
     * @param int omax
     * @param int zone
     * @param RangeSet pixset
     * @param long pix
     * @param pstack stk
     * @param boolean inclusive
     */
    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {
        if (zone == 0)
            return;
        if (o < this.order) {
            if (zone >= 3) { // output all subpixels
                let sdist = 2 * (this.order - o); // the "bit-shift distance" between map orders
                pixset.append1(pix << sdist, ((pix + 1) << sdist));
            }
            else { // (zone>=1)
                for (let i = 0; i < 4; ++i) {
                    stk.push(4 * pix + 3 - i, o + 1); // add children
                }
            }
        }
        else if (o > this.order) { // this implies that inclusive==true
            if (zone >= 2) { // pixel center in shape
                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order
                stk.popToMark(); // unwind the stack
            }
            else { // (zone>=1): pixel center in safety range
                if (o < omax) { // check sublevels
                    for (let i = 0; i < 4; ++i) { // add children in reverse order
                        stk.push(4 * pix + 3 - i, o + 1); // add children
                    }
                }
                else { // at resolution limit
                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order
                    stk.popToMark(); // unwind the stack
                }
            }
        }
        else { // o==order
            if (zone >= 2) {
                pixset.append(pix);
            }
            else if (inclusive) { // and (zone>=1)
                if (this.order < omax) { // check sublevels
                    stk.mark(); // remember current stack position
                    for (let i = 0; i < 4; ++i) { // add children in reverse order
                        stk.push(4 * pix + 3 - i, o + 1); // add children
                    }
                }
                else { // at resolution limit
                    pixset.append(pix); // output the pixel
                }
            }
        }
    }
    /** Returns the maximum angular distance between a pixel center and its
    corners.
    @return maximum angular distance between a pixel center and its
      corners. */
    maxPixrad() {
        let zphia = new _Zphi_js__WEBPACK_IMPORTED_MODULE_9__.Zphi(2. / 3., Math.PI / this.nl4);
        let xyz1 = this.convertZphi2xyz(zphia);
        let va = new _Vec3_js__WEBPACK_IMPORTED_MODULE_7__.Vec3(xyz1[0], xyz1[1], xyz1[2]);
        let t1 = 1. - 1. / this.nside;
        t1 *= t1;
        let zphib = new _Zphi_js__WEBPACK_IMPORTED_MODULE_9__.Zphi(1 - t1 / 3, 0);
        let xyz2 = this.convertZphi2xyz(zphib);
        let vb = new _Vec3_js__WEBPACK_IMPORTED_MODULE_7__.Vec3(xyz2[0], xyz2[1], xyz2[2]);
        return va.angle(vb);
    }
    ;
    /**
     * this is a workaround replacing the Vec3(Zphi) constructor.
     */
    convertZphi2xyz(zphi) {
        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));
        let x = sth * _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.cos(zphi.phi);
        let y = sth * _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.sin(zphi.phi);
        let z = zphi.z;
        return [x, y, z];
    }
    ;
    /** Returns a range set of pixels which overlap with a given disk. <p>
      This method is more efficient in the RING scheme. <p>
      This method may return some pixels which don't overlap with
      the polygon at all. The higher {@code fact} is chosen, the fewer false
      positives are returned, at the cost of increased run time.
      @param ptg the angular coordinates of the disk center
      @param radius the radius (in radians) of the disk
      @param fact The overlapping test will be done at the resolution
        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power
        of 2, else it can be any positive integer. A typical choice would be 4.
      @return the requested set of pixel number ranges  */
    queryDiscInclusive(ptg, radius, fact) {
        this.computeBn();
        let inclusive = (fact != 0);
        let pixset = new _RangeSet_js__WEBPACK_IMPORTED_MODULE_6__.RangeSet();
        if (radius >= Math.PI) { // disk covers the whole sphere
            pixset.append1(0, this.npix);
            return pixset;
        }
        let oplus = 0;
        if (inclusive) {
            // HealpixUtils.check ((1L<<order_max)>=fact,"invalid oversampling factor");
            if (!((fact & (fact - 1)) == 0)) {
                console.error("oversampling factor must be a power of 2");
            }
            oplus = this.ilog2(fact);
        }
        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test
        let vptg = _Vec3_js__WEBPACK_IMPORTED_MODULE_7__.Vec3.pointing2Vec3(ptg);
        let crpdr = new Array(omax + 1);
        let crmdr = new Array(omax + 1);
        let cosrad = _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.cos(radius);
        let sinrad = _Hploc_js__WEBPACK_IMPORTED_MODULE_3__.Hploc.sin(radius);
        for (let o = 0; o <= omax; o++) { // prepare data at the required orders
            let dr = this.mpr[o]; // safety distance
            let cdr = this.cmpr[o];
            let sdr = this.smpr[o];
            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;
            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;
        }
        let stk = new _pstack_js__WEBPACK_IMPORTED_MODULE_5__.pstack(12 + 3 * omax);
        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order
            stk.push(11 - i, 0);
        }
        while (stk.size() > 0) { // as long as there are pixels on the stack
            // pop current pixel number and order from the stack
            let pix = stk.ptop();
            let curro = stk.otop();
            stk.pop();
            let pos = this.bn[curro].pix2zphi(pix);
            // cosine of angular distance between pixel center and disk center
            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);
            if (cangdist > crpdr[curro]) {
                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);
                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);
            }
        }
        return pixset;
    }
}
//# sourceMappingURL=Healpix.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Hploc.js":
/*!*************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Hploc.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hploc: () => (/* binding */ Hploc)
/* harmony export */ });
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3.js */ "./node_modules/healpixjs/lib-esm/Vec3.js");
/* harmony import */ var _Zphi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Zphi.js */ "./node_modules/healpixjs/lib-esm/Zphi.js");


class Hploc {
    constructor(ptg) {
        Hploc.PI4_A = 0.7853981554508209228515625;
        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;
        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;
        Hploc.M_1_PI = 0.3183098861837906715377675267450287;
        if (ptg) {
            this.sth = 0.0;
            this.have_sth = false;
            this.z = Hploc.cos(ptg.theta);
            this._phi = ptg.phi;
            if (Math.abs(this.z) > 0.99) {
                this.sth = Hploc.sin(ptg.theta);
                this.have_sth = true;
            }
        }
    }
    setZ(z) {
        this.z = z;
    }
    ;
    get phi() {
        return this._phi;
    }
    ;
    set phi(phi) {
        this._phi = phi;
    }
    ;
    setSth(sth) {
        this.sth = sth;
    }
    ;
    toVec3() {
        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));
        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);
        var vector = new _Vec3_js__WEBPACK_IMPORTED_MODULE_0__.Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);
        return vector;
    }
    ;
    toZphi() {
        return new _Zphi_js__WEBPACK_IMPORTED_MODULE_1__.Zphi(this.z, this.phi);
    }
    static sin(d) {
        let u = d * Hploc.M_1_PI;
        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);
        let x = 4.0 * q;
        d -= x * Hploc.PI4_A;
        d -= x * Hploc.PI4_B;
        d -= x * Hploc.PI4_C;
        if ((q & 1) != 0) {
            d = -d;
        }
        return this.sincoshelper(d);
    }
    ;
    static cos(d) {
        //		let u = d * Hploc.M_1_PI - 0.5;
        let u = d * Hploc.M_1_PI - 0.5;
        //		u -= 0.5;
        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);
        let x = 2.0 * q;
        let t = x * Hploc.PI4_A;
        d = d - t;
        d -= x * Hploc.PI4_B;
        d -= x * Hploc.PI4_C;
        if ((q & 2) == 0) {
            d = -d;
        }
        return Hploc.sincoshelper(d);
    }
    ;
    static sincoshelper(d) {
        let s = d * d;
        let u = -7.97255955009037868891952e-18;
        u = u * s + 2.81009972710863200091251e-15;
        u = u * s - 7.64712219118158833288484e-13;
        u = u * s + 1.60590430605664501629054e-10;
        u = u * s - 2.50521083763502045810755e-08;
        u = u * s + 2.75573192239198747630416e-06;
        u = u * s - 0.000198412698412696162806809;
        u = u * s + 0.00833333333333332974823815;
        u = u * s - 0.166666666666666657414808;
        return s * u * d + d;
    }
    ;
    /** This method calculates the arc sine of x in radians. The return
    value is in the range [-pi/2, pi/2]. The results may have
    maximum error of 3 ulps. */
    static asin(d) {
        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);
    }
    ;
    /** This method calculates the arc cosine of x in radians. The
        return value is in the range [0, pi]. The results may have
        maximum error of 3 ulps. */
    static acos(d) {
        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);
    }
    ;
    static mulsign(x, y) {
        let sign = Hploc.copySign(1, y);
        return sign * x;
    }
    ;
    static copySign(magnitude, sign) {
        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);
        // let finalsign = 1;
        // if (Object.is(finalsign , -0)){
        // 	sign = -1;
        // }else if (Object.is(finalsign , 0)){
        // 	sign = 1;
        // }else {
        // 	sign = Math.sign(finalsign);
        // }
        // return finalsign * magnitude;
    }
    static atanhelper(s) {
        let t = s * s;
        let u = -1.88796008463073496563746e-05;
        u = u * t + (0.000209850076645816976906797);
        u = u * t + (-0.00110611831486672482563471);
        u = u * t + (0.00370026744188713119232403);
        u = u * t + (-0.00889896195887655491740809);
        u = u * t + (0.016599329773529201970117);
        u = u * t + (-0.0254517624932312641616861);
        u = u * t + (0.0337852580001353069993897);
        u = u * t + (-0.0407629191276836500001934);
        u = u * t + (0.0466667150077840625632675);
        u = u * t + (-0.0523674852303482457616113);
        u = u * t + (0.0587666392926673580854313);
        u = u * t + (-0.0666573579361080525984562);
        u = u * t + (0.0769219538311769618355029);
        u = u * t + (-0.090908995008245008229153);
        u = u * t + (0.111111105648261418443745);
        u = u * t + (-0.14285714266771329383765);
        u = u * t + (0.199999999996591265594148);
        u = u * t + (-0.333333333333311110369124);
        return u * t * s + s;
    }
    ;
    static atan2k(y, x) {
        let q = 0.;
        if (x < 0) {
            x = -x;
            q = -2.;
        }
        if (y > x) {
            let t = x;
            x = y;
            y = -t;
            q += 1.;
        }
        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);
    }
    ;
    /** This method calculates the arc tangent of y/x in radians, using
    the signs of the two arguments to determine the quadrant of the
    result. The results may have maximum error of 2 ulps. */
    static atan2(y, x) {
        let r = Hploc.atan2k(Math.abs(y), x);
        r = Hploc.mulsign(r, x);
        if (Hploc.isinf(x) || x == 0) {
            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);
        }
        if (Hploc.isinf(y)) {
            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);
        }
        if (y == 0) {
            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);
        }
        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);
    }
    ;
    /** Checks if the argument is a NaN or not. */
    static isnan(d) {
        return d != d;
    }
    ;
    /** Checks if the argument is either positive or negative infinity. */
    static isinf(d) {
        return Math.abs(d) === +Infinity;
    }
    ;
}
Hploc.PI4_A = 0.7853981554508209228515625;
Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;
Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;
Hploc.M_1_PI = 0.3183098861837906715377675267450287;
//# sourceMappingURL=Hploc.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Pointing.js":
/*!****************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Pointing.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pointing: () => (/* binding */ Pointing)
/* harmony export */ });
/* harmony import */ var _Hploc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hploc.js */ "./node_modules/healpixjs/lib-esm/Hploc.js");

class Pointing {
    /**
     *
     * @param {*} vec3 Vec3.js
     * @param {*} mirror
     * @param {*} in_theta radians
     * @param {*} in_phi radians
     */
    constructor(vec3, mirror, in_theta, in_phi) {
        if (vec3 != null) {
            this.theta = _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);
            if (mirror) {
                this.phi = -_Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.atan2(vec3.y, vec3.x);
            }
            else {
                this.phi = _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.atan2(vec3.y, vec3.x);
            }
            if (this.phi < 0.0) {
                this.phi = this.phi + 2 * Math.PI;
            }
            if (this.phi >= 2 * Math.PI) {
                this.phi = this.phi - 2 * Math.PI;
            }
        }
        else {
            this.theta = in_theta;
            this.phi = in_phi;
        }
    }
}
//# sourceMappingURL=Pointing.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/RangeSet.js":
/*!****************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/RangeSet.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RangeSet: () => (/* binding */ RangeSet)
/* harmony export */ });
class RangeSet {
    /**
     * @param int cap: initial capacity
     */
    constructor(cap) {
        if (cap < 0)
            console.error("capacity must be positive");
        this.r = new Int32Array(cap << 1);
        this.sz = 0;
    }
    ;
    /** Append a single-value range to the object.
    @param val value to append */
    append(val) {
        this.append1(val, val + 1);
    }
    ;
    /** Append a range to the object.
   @param a first long in range
   @param b one-after-last long in range */
    append1(a, b) {
        if (a >= b)
            return;
        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {
            if (a < this.r[this.sz - 2])
                console.error("bad append operation");
            if (b > this.r[this.sz - 1])
                this.r[this.sz - 1] = b;
            return;
        }
        // this.ensureCapacity(this.sz+2);
        let cap = this.sz + 2;
        if (this.r.length < cap) {
            let newsize = Math.max(2 * this.r.length, cap);
            let rnew = new Int32Array(newsize);
            rnew.set(this.r);
            this.r = rnew;
        }
        this.r[this.sz] = a;
        this.r[this.sz + 1] = b;
        this.sz += 2;
    }
    ;
    /** Make sure the object can hold at least the given number of entries.
     * @param cap int
     * */
    ensureCapacity(cap) {
        if (this.r.length < cap)
            this.resize(Math.max(2 * this.r.length, cap));
    }
    ;
    /**
     * @param newsize int
     */
    resize(newsize) {
        if (newsize < this.sz)
            console.error("requested array size too small");
        if (newsize == this.r.length)
            return;
        let rnew = new Int32Array(newsize);
        let sliced = this.r.slice(0, this.sz + 1);
        //		this.arrayCopy(this.r, 0, rnew, 0, this.sz);
        this.r = sliced;
    }
    ;
}
//# sourceMappingURL=RangeSet.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Vec3.js":
/*!************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Vec3.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vec3: () => (/* binding */ Vec3)
/* harmony export */ });
/* harmony import */ var _Hploc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hploc.js */ "./node_modules/healpixjs/lib-esm/Hploc.js");
/* harmony import */ var _Pointing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pointing.js */ "./node_modules/healpixjs/lib-esm/Pointing.js");
/**
 * Partial porting to Javascript of Vec3.java from Healpix3.30
 */


class Vec3 {
    constructor(in_x, in_y, in_z) {
        if (in_x instanceof _Pointing_js__WEBPACK_IMPORTED_MODULE_1__.Pointing) {
            let ptg = in_x;
            let sth = _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.sin(ptg.theta);
            this.x = sth * _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.cos(ptg.phi);
            this.y = sth * _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.sin(ptg.phi);
            this.z = _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.cos(ptg.theta);
        }
        else {
            this.x = in_x;
            this.y = in_y;
            this.z = in_z;
        }
    }
    getX() {
        return this.x;
    }
    ;
    getY() {
        return this.y;
    }
    ;
    getZ() {
        return this.z;
    }
    ;
    /** Scale the vector by a given factor
    @param n the scale factor */
    scale(n) {
        this.x *= n;
        this.y *= n;
        this.z *= n;
    }
    ;
    /** Vector cross product.
    @param v another vector
    @return the vector cross product between this vector and {@code v} */
    cross(v) {
        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);
    }
    ;
    /** Vector addition
        * @param v the vector to be added
        * @return addition result */
    add(v) {
        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
    }
    ;
    /** Normalize the vector */
    normalize() {
        let d = 1. / this.length();
        this.x *= d;
        this.y *= d;
        this.z *= d;
    }
    ;
    /** Return normalized vector */
    norm() {
        let d = 1. / this.length();
        return new Vec3(this.x * d, this.y * d, this.z * d);
    }
    ;
    /** Vector length
    @return the length of the vector. */
    length() {
        return Math.sqrt(this.lengthSquared());
    }
    ;
    /** Squared vector length
        @return the squared length of the vector. */
    lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    ;
    /** Computes the dot product of the this vector and {@code v1}.
     * @param v1 another vector
     * @return dot product */
    dot(v1) {
        return this.x * v1.x + this.y * v1.y + this.z * v1.z;
    }
    ;
    /** Vector subtraction
     * @param v the vector to be subtracted
     * @return subtraction result */
    sub(v) {
        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
    }
    ;
    /** Angle between two vectors.
    @param v1 another vector
    @return the angle in radians between this vector and {@code v1};
      constrained to the range [0,PI]. */
    angle(v1) {
        return _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.atan2(this.cross(v1).length(), this.dot(v1));
    }
    /** Invert the signs of all components */
    flip() {
        this.x *= -1.0;
        this.y *= -1.0;
        this.z *= -1.0;
    }
    static pointing2Vec3(pointing) {
        let sth = _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.sin(pointing.theta);
        let x = sth * _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.cos(pointing.phi);
        let y = sth * _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.sin(pointing.phi);
        let z = _Hploc_js__WEBPACK_IMPORTED_MODULE_0__.Hploc.cos(pointing.theta);
        return new Vec3(x, y, z);
    }
    ;
}
//# sourceMappingURL=Vec3.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Xyf.js":
/*!***********************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Xyf.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Xyf: () => (/* binding */ Xyf)
/* harmony export */ });
/**
 * Partial porting to Javascript of Xyf.java from Healpix3.30
 */
class Xyf {
    constructor(x, y, f) {
        this.ix = x;
        this.iy = y;
        this.face = f;
    }
}
//# sourceMappingURL=Xyf.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/Zphi.js":
/*!************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/Zphi.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Zphi: () => (/* binding */ Zphi)
/* harmony export */ });
class Zphi {
    /** Creation from individual components */
    constructor(z_, phi_) {
        this.z = z_;
        this.phi = phi_;
    }
    ;
}
//# sourceMappingURL=Zphi.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircleFinder: () => (/* reexport safe */ _CircleFinder_js__WEBPACK_IMPORTED_MODULE_2__.CircleFinder),
/* harmony export */   Constants: () => (/* reexport safe */ _Constants_js__WEBPACK_IMPORTED_MODULE_0__.Constants),
/* harmony export */   Fxyf: () => (/* reexport safe */ _Fxyf_js__WEBPACK_IMPORTED_MODULE_3__.Fxyf),
/* harmony export */   Healpix: () => (/* reexport safe */ _Healpix_js__WEBPACK_IMPORTED_MODULE_4__.Healpix),
/* harmony export */   Hploc: () => (/* reexport safe */ _Hploc_js__WEBPACK_IMPORTED_MODULE_10__.Hploc),
/* harmony export */   Pointing: () => (/* reexport safe */ _Pointing_js__WEBPACK_IMPORTED_MODULE_5__.Pointing),
/* harmony export */   RangeSet: () => (/* reexport safe */ _RangeSet_js__WEBPACK_IMPORTED_MODULE_6__.RangeSet),
/* harmony export */   Vec3: () => (/* reexport safe */ _Vec3_js__WEBPACK_IMPORTED_MODULE_7__.Vec3),
/* harmony export */   Xyf: () => (/* reexport safe */ _Xyf_js__WEBPACK_IMPORTED_MODULE_8__.Xyf),
/* harmony export */   Zphi: () => (/* reexport safe */ _Zphi_js__WEBPACK_IMPORTED_MODULE_9__.Zphi),
/* harmony export */   pstack: () => (/* reexport safe */ _pstack_js__WEBPACK_IMPORTED_MODULE_1__.pstack)
/* harmony export */ });
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constants.js */ "./node_modules/healpixjs/lib-esm/Constants.js");
/* harmony import */ var _pstack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pstack.js */ "./node_modules/healpixjs/lib-esm/pstack.js");
/* harmony import */ var _CircleFinder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CircleFinder.js */ "./node_modules/healpixjs/lib-esm/CircleFinder.js");
/* harmony import */ var _Fxyf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Fxyf.js */ "./node_modules/healpixjs/lib-esm/Fxyf.js");
/* harmony import */ var _Healpix_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Healpix.js */ "./node_modules/healpixjs/lib-esm/Healpix.js");
/* harmony import */ var _Pointing_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pointing.js */ "./node_modules/healpixjs/lib-esm/Pointing.js");
/* harmony import */ var _RangeSet_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RangeSet.js */ "./node_modules/healpixjs/lib-esm/RangeSet.js");
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Vec3.js */ "./node_modules/healpixjs/lib-esm/Vec3.js");
/* harmony import */ var _Xyf_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Xyf.js */ "./node_modules/healpixjs/lib-esm/Xyf.js");
/* harmony import */ var _Zphi_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Zphi.js */ "./node_modules/healpixjs/lib-esm/Zphi.js");
/* harmony import */ var _Hploc_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Hploc.js */ "./node_modules/healpixjs/lib-esm/Hploc.js");











//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/healpixjs/lib-esm/pstack.js":
/*!**************************************************!*\
  !*** ./node_modules/healpixjs/lib-esm/pstack.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pstack: () => (/* binding */ pstack)
/* harmony export */ });
class pstack {
    /** Creation from individual components */
    constructor(sz) {
        this.p = new Array(sz);
        this.o = new Int32Array(sz);
        this.s = 0;
        this.m = 0;
    }
    ;
    /**
     * @param p long
     * @param o int
     */
    push(p_, o_) {
        this.p[this.s] = p_;
        this.o[this.s] = o_;
        ++this.s;
    }
    ;
    pop() {
        --this.s;
    }
    ;
    popToMark() {
        this.s = this.m;
    }
    ;
    size() {
        return this.s;
    }
    ;
    mark() {
        this.m = this.s;
    }
    ;
    otop() {
        return this.o[this.s - 1];
    }
    ;
    ptop() {
        return this.p[this.s - 1];
    }
    ;
}
//# sourceMappingURL=pstack.js.map

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/FITSParser.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/FITSParser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FITSParser: () => (/* binding */ FITSParser)
/* harmony export */ });
/* harmony import */ var _FITSWriter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FITSWriter.js */ "./node_modules/jsfitsio/lib-esm/FITSWriter.js");
/* harmony import */ var _ParsePayload_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ParsePayload.js */ "./node_modules/jsfitsio/lib-esm/ParsePayload.js");
/* harmony import */ var _ParseHeader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ParseHeader.js */ "./node_modules/jsfitsio/lib-esm/ParseHeader.js");
/**

 * @link   github https://github.com/fab77/FITSParser
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



// import fetch from 'cross-fetch';
// import { readFile } from "node:fs/promises";
class FITSParser {
    constructor(url) {
        this._url = url;
    }
    loadFITS() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getFile(this._url)
                .then((rawdata) => {
                if (rawdata !== null && rawdata.byteLength > 0) {
                    const uint8 = new Uint8Array(rawdata);
                    const fits = this.processFits(uint8);
                    return fits;
                }
                return null;
            })
                .catch((error) => {
                var _a, _b;
                if ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) {
                    throw new Error("[FITSParser->loadFITS] " + error.response.data.message);
                }
                throw error;
            });
        });
    }
    processFits(rawdata) {
        const header = _ParseHeader_js__WEBPACK_IMPORTED_MODULE_2__.ParseHeader.parse(rawdata);
        const payloadParser = new _ParsePayload_js__WEBPACK_IMPORTED_MODULE_1__.ParsePayload(header, rawdata);
        const pixelvalues = payloadParser.parse();
        // if (rawdata.length > (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length))) {
        // let leftover = rawdata.length - (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length));
        // 	throw new Error("[FITSParser->processFits] It seems that there's at least one more HDU since there are " + leftover + " bytes not processed.");
        // 	console.warn("It seems that there's at least one more HDU since there are " + leftover + " bytes not processed.")
        // }
        return {
            header: header,
            data: pixelvalues,
        };
    }
    static generateFITS(header, rawdata) {
        const writer = new _FITSWriter_js__WEBPACK_IMPORTED_MODULE_0__.FITSWriter();
        writer.run(header, rawdata);
        return writer.typedArrayToURL();
    }
    getFile(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            let data;
            if (!uri.substring(0, 5).toLowerCase().includes("http")) {
                let p = yield __webpack_require__.e(/*! import() */ "node_modules_jsfitsio_lib-esm_getLocalFile_js").then(__webpack_require__.bind(__webpack_require__, /*! ./getLocalFile.js */ "./node_modules/jsfitsio/lib-esm/getLocalFile.js"));
                // data = await p.getLocalFile(uri);
                return yield p.getLocalFile(uri);
            }
            else {
                let p = yield __webpack_require__.e(/*! import() */ "node_modules_jsfitsio_lib-esm_getFile_js").then(__webpack_require__.bind(__webpack_require__, /*! ./getFile.js */ "./node_modules/jsfitsio/lib-esm/getFile.js"));
                return p.getFile(uri).then((data) => {
                    return data;
                }).catch((err) => {
                    // console.error("Error in FITSParser getFile ", uri, err);
                    return null;
                });
                // data = await p.getFile(uri);
                // return await p.getFile(uri).catch((err) => {
                //   console.error(err);
                // });
            }
            // return data;
        });
    }
}
//# sourceMappingURL=FITSParser.js.map

/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/FITSWriter.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/FITSWriter.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FITSWriter: () => (/* binding */ FITSWriter)
/* harmony export */ });
/* harmony import */ var _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/FITSHeaderItem.js */ "./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js");
/* harmony import */ var _ParseUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ParseUtils.js */ "./node_modules/jsfitsio/lib-esm/ParseUtils.js");
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/fitsontheweb
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 * import GnomonicProjection from './GnomonicProjection';
 * BITPIX definition from https://archive.stsci.edu/fits/fits_standard/node39.html
 * and "Definition of the Flexible Image Transport System (FITS)" standard document
 * defined by FITS Working Group from the International Astronomical Union
 * http://fits.gsfc.nasa.gov/iaufwg/
 * 8	8-bit Character or unsigned binary integer
 * 16	16-bit twos-complement binary integer
 * 32	32-bit twos-complement binary integer
 * -32	32-bit IEEE single precision floating point
 * -64	64-bit IEEE double precision floating point
 *
 */
// import { Blob } from 'blob-polyfill';


// import fs from 'node:fs/promises';
class FITSWriter {
    constructor() {
        this._headerArray = new Uint8Array();
        this._payloadArray = new Array();
        this._fitsData = new Uint8Array();
    }
    run(header, rawdata) {
        this.prepareHeader(header);
        this._payloadArray = rawdata;
        this.prepareFITS();
    }
    prepareHeader(headerDetails) {
        const item = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("END");
        headerDetails.addItem(item);
        let str = "";
        for (let i = 0; i < headerDetails.getItemList().length; i++) {
            const item = headerDetails.getItemList()[i];
            let s = this.formatHeaderLine(item);
            if (s !== undefined) {
                str += s;
            }
        }
        const strBytelen = new TextEncoder().encode(str).length;
        const nhdu = Math.ceil(strBytelen / 2880);
        const offset = nhdu * 2880;
        for (let j = 0; j < offset - strBytelen; j++) {
            str += " ";
        }
        const ab = new ArrayBuffer(str.length);
        // Javascript character occupies 2 16-bit -> reducing it to 1 byte
        this._headerArray = new Uint8Array(ab);
        for (let i = 0; i < str.length; i++) {
            this._headerArray[i] = _ParseUtils_js__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.getByteAt(str, i);
        }
    }
    // formatHeaderLine(item: string | undefined, value: string | number, comment: string) {
    formatHeaderLine(item) {
        let str;
        let keyword = item.key;
        let value = item.value;
        let comment = item.comment;
        if (keyword !== null && keyword !== undefined) {
            str = keyword;
            if (keyword == "END") {
                for (let j = 80; j > keyword.length; j--) {
                    str += " ";
                }
                return str;
            }
            if (keyword == "COMMENT" || keyword == "HISTORY") {
                for (let i = 0; i < 10 - keyword.length; i++) {
                    str += " ";
                }
                str += value;
                const len = str.length;
                for (let j = 80; j > len; j--) {
                    str += " ";
                }
                return str;
            }
            for (let i = 0; i < 8 - keyword.length; i++) {
                str += " ";
            }
            str += "= ";
            if (value !== null && value !== undefined) {
                // value
                str += value;
                if (comment !== null && comment !== undefined) {
                    str += comment;
                }
                const len = str.length;
                for (let j = 80; j > len; j--) {
                    str += " ";
                }
            }
            else {
                if (comment !== null && comment !== undefined) {
                    str += comment;
                }
                const len = str.length;
                for (let j = 80; j > len; j--) {
                    str += " ";
                }
            }
        }
        else {
            // keyword null
            str = "";
            for (let j = 0; j < 18; j++) {
                str += " ";
            }
            if (comment !== null && comment !== undefined) {
                str += comment;
                const len = str.length;
                for (let j = 80; j > len; j--) {
                    str += " ";
                }
            }
            else {
                str = "";
                for (let j = 80; j > 0; j--) {
                    str += " ";
                }
            }
        }
        return str;
    }
    prepareFITS() {
        const bytes = new Uint8Array(this._headerArray.length +
            this._payloadArray[0].length * this._payloadArray.length);
        bytes.set(this._headerArray, 0);
        for (let i = 0; i < this._payloadArray.length; i++) {
            const uint8 = this._payloadArray[i];
            bytes.set(uint8, this._headerArray.length + i * uint8.length);
        }
        this._fitsData = bytes;
    }
    // writeFITS(fileuri: string) {
    //   // const dirname = path.dirname(fileuri);
    //   // fs.mkdir(dirname, { recursive: true });
    //   fs.writeFile(fileuri, this._fitsData);
    //   // if (fs.existsSync(dirname)) {
    //   //   fs.writeFileSync(fileuri, this._fitsData);
    //   // } else {
    //   //   console.error(dirname + " doesn't exist");
    //   // }
    // }
    typedArrayToURL() {
        const b = new Blob([this._fitsData], { type: "application/fits" });
        // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);
        return URL.createObjectURL(b);
    }
}
//# sourceMappingURL=FITSWriter.js.map

/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/ParseHeader.js":
/*!******************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/ParseHeader.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParseHeader: () => (/* binding */ ParseHeader)
/* harmony export */ });
/* harmony import */ var _model_FITSHeader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/FITSHeader.js */ "./node_modules/jsfitsio/lib-esm/model/FITSHeader.js");
/* harmony import */ var _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/FITSHeaderItem.js */ "./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js");


/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/FITSParser
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
class ParseHeader {
    static parse(rawdata) {
        // only one header block (2880) allowed atm.
        // TODO handle multiple header blocks
        // let headerByteData = new Uint8Array(rawdata, 0, 2880);
        const textDecoder = new TextDecoder("iso-8859-1");
        const header = new _model_FITSHeader_js__WEBPACK_IMPORTED_MODULE_0__.FITSHeader();
        let nline = 0;
        let key = "";
        let val;
        let u8line;
        let u8key;
        let u8val;
        let u8ind;
        // let ind: string;
        let item;
        let fitsLine;
        item = null;
        while (key !== "END" && rawdata.length > 0) {
            // line 80 characters
            u8line = new Uint8Array(rawdata.slice(nline * 80, nline * 80 + 80));
            nline++;
            // key
            u8key = new Uint8Array(u8line.slice(0, 8));
            key = textDecoder.decode(u8key).trim();
            // value indicator
            u8ind = new Uint8Array(u8line.slice(8, 10));
            // ind = textDecoder.decode(u8ind);
            // reading value
            u8val = new Uint8Array(u8line.slice(10, 80));
            val = textDecoder.decode(u8val).trim();
            // ascii 61 -> =
            // ascii 32 -> [space]
            if (u8ind[0] == 61 && u8ind[1] == 32) {
                let firstchar = 32;
                for (let i = 0; i < u8val.length; i++) {
                    if (u8val[i] != 32) {
                        firstchar = u8val[i];
                        break;
                    }
                }
                // ascii 39 -> '
                if (firstchar == 39 || !Number(val)) {
                    // [ival, icomment]
                    // fitsLine = ParseHeader.parseStringValue(u8val);
                    fitsLine = ParseHeader.parseLogicalValue(u8val);
                }
                else {
                    // ascii 84 -> T
                    // ascii 70 -> F
                    if (firstchar == 84 || firstchar == 70) {
                        // T or F
                        fitsLine = ParseHeader.parseLogicalValue(u8val);
                    }
                    else {
                        val = textDecoder.decode(u8val).trim();
                        if (val.includes(".")) {
                            fitsLine = ParseHeader.parseFloatValue(u8val);
                        }
                        else {
                            fitsLine = ParseHeader.parseIntValue(u8val);
                        }
                    }
                }
                item = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem(key, fitsLine.val, fitsLine.comment);
            }
            else {
                if (key == "COMMENT" || key == "HISTORY") {
                    item = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem(key, undefined, val);
                }
                else {
                    let firstchar = 32;
                    for (let i = 0; i < u8val.length; i++) {
                        if (u8val[i] != 32) {
                            firstchar = u8val[i];
                            break;
                        }
                    }
                    if (firstchar == 47) {
                        // single / this is the case when no key nor value indicator is defined
                        item = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem(undefined, undefined, val);
                    }
                    else if (firstchar == 32) {
                        // case when there's a line with only spaces
                        item = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem(undefined, undefined, undefined);
                    }
                }
            }
            if (item != null) {
                header.addItem(item);
            }
        }
        item = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("COMMENT", "FITS generated with FITSParser on ", undefined);
        header.addItem(item);
        const now = new Date();
        item = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("COMMENT", now.toString());
        header.addItem(item);
        const nblock = Math.ceil(nline / 36);
        const offset = nblock * 2880;
        header.offset = offset;
        return header;
    }
    static parseStringValue(u8buffer) {
        const textDecoder = new TextDecoder("iso-8859-1");
        const decoded = textDecoder.decode(u8buffer).trim();
        const idx = decoded.lastIndexOf("/");
        const val = decoded.substring(0, idx);
        let comment = decoded.substring(idx);
        // if (comment === undefined) {
        //   comment = null;
        // }
        return {
            val: val,
            comment: comment,
        };
    }
    static parseLogicalValue(u8buffer) {
        const textDecoder = new TextDecoder("iso-8859-1");
        const val = textDecoder.decode(u8buffer).trim();
        const tokens = val.split("/");
        if (tokens[1] === undefined) {
            return {
                val: tokens[0].trim(),
                comment: undefined,
            };
        }
        return {
            val: tokens[0].trim(),
            comment: " /" + tokens[1],
        };
    }
    static parseIntValue(u8buffer) {
        const textDecoder = new TextDecoder("iso-8859-1");
        const val = textDecoder.decode(u8buffer).trim();
        const tokens = val.split("/");
        if (tokens[1] === undefined) {
            return {
                val: parseInt(tokens[0].trim()),
                comment: undefined,
            };
        }
        return {
            val: parseInt(tokens[0].trim()),
            comment: " /" + tokens[1],
        };
    }
    static parseFloatValue(u8buffer) {
        const textDecoder = new TextDecoder("iso-8859-1");
        const val = textDecoder.decode(u8buffer).trim();
        const tokens = val.split("/");
        if (tokens[1] === undefined) {
            return {
                val: parseFloat(tokens[0].trim()),
                comment: undefined,
            };
        }
        return {
            val: parseFloat(tokens[0].trim()),
            comment: " /" + tokens[1],
        };
    }
}
//# sourceMappingURL=ParseHeader.js.map

/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/ParsePayload.js":
/*!*******************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/ParsePayload.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParsePayload: () => (/* binding */ ParsePayload)
/* harmony export */ });
/* harmony import */ var _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/FITSHeaderItem.js */ "./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js");
/* harmony import */ var _ParseUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ParseUtils.js */ "./node_modules/jsfitsio/lib-esm/ParseUtils.js");
// "use strict";


// let colorsMap = new Map();
// colorsMap.set("grayscale","grayscale");
// colorsMap.set("planck","planck");
// colorsMap.set("eosb","eosb");
// colorsMap.set("rainbow","rainbow");
// colorsMap.set("cmb","cmb");
// colorsMap.set("cubehelix","cubehelix");
class ParsePayload {
    constructor(fitsheader, rawdata) {
        this._u8data = new Uint8Array();
        this._BZERO = undefined;
        this._BSCALE = undefined;
        this._BLANK = undefined;
        this._BITPIX = undefined;
        this._NAXIS1 = undefined;
        this._NAXIS2 = undefined;
        this._DATAMIN = undefined;
        this._DATAMAX = undefined;
        this._physicalblank = undefined;
        const buffer = rawdata.slice(fitsheader.offset);
        this._u8data = new Uint8Array(buffer);
        this.init(fitsheader);
    }
    init(fitsheader) {
        this._BZERO = fitsheader.get("BZERO");
        if (this._BZERO === undefined) {
            this._BZERO = 0;
        }
        this._BSCALE = fitsheader.get("BSCALE");
        if (this._BSCALE === undefined) {
            this._BSCALE = 1;
        }
        this._BLANK = fitsheader.get("BLANK"); // undefined in case it's not present in the header
        // this._BLANK_pv = this._BZERO + this._BSCALE * this._BLANK || undefined;
        this._BITPIX = fitsheader.get("BITPIX");
        this._NAXIS1 = fitsheader.get("NAXIS1");
        this._NAXIS2 = fitsheader.get("NAXIS2");
        this._DATAMIN = fitsheader.get("DATAMIN");
        this._DATAMAX = fitsheader.get("DATAMAX");
        this._physicalblank = undefined;
        if (this._DATAMAX === undefined || this._DATAMIN === undefined) {
            const [min, max] = this.computePhysicalMinAndMax();
            this._DATAMAX = max;
            this._DATAMIN = min;
            const maxitem = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("DATAMAX", max, " / computed with FITSParser");
            const minitem = new _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("DATAMIN", min, " / computed with FITSParser");
            fitsheader.addItem(maxitem);
            fitsheader.addItem(minitem);
            // fitsheader.set("DATAMAX", max);
            // fitsheader.set("DATAMIN", min);
        }
        // let item = new FITSHeaderItem("END", null, null);
        // fitsheader.addItem(item);
    }
    computePhysicalMinAndMax() {
        let i = 0;
        if (this._BITPIX === undefined) {
            throw new Error("BITPIX is not defined");
        }
        const bytesXelem = Math.abs(this._BITPIX / 8);
        const pxLength = this._u8data.byteLength / bytesXelem;
        let px_val, ph_val;
        let min = undefined;
        let max = undefined;
        if (this._BLANK !== undefined) {
            this._physicalblank = this.pixel2physicalValue(this._BLANK);
        }
        while (i < pxLength) {
            // px_val = this.extractPixelValue(bytesXelem*i);
            px_val = this.extractPixelValue(bytesXelem * i);
            if (px_val === undefined) {
                i++;
                continue;
            }
            ph_val = this.pixel2physicalValue(px_val);
            if (min === undefined) {
                min = ph_val;
            }
            if (max === undefined) {
                max = ph_val;
            }
            //TODO check below if
            if (this._physicalblank === undefined || this._physicalblank !== ph_val) {
                if (ph_val !== undefined && (ph_val < min || min === undefined)) {
                    min = ph_val;
                }
                if (ph_val !== undefined && (ph_val > max || max === undefined)) {
                    max = ph_val;
                }
            }
            i++;
        }
        return [min, max];
    }
    parse() {
        // let px_val; // pixel array value
        // let ph_val = undefined; // pixel physical value
        if (this._BITPIX === undefined) {
            throw new Error("BITPIX is undefined");
        }
        if (this._NAXIS1 === undefined) {
            throw new Error("NAXIS1 is undefined");
        }
        if (this._NAXIS2 === undefined) {
            throw new Error("NAXIS2 is undefined");
        }
        const bytesXelem = Math.abs(this._BITPIX / 8);
        let pxLength = this._u8data.byteLength / bytesXelem;
        pxLength = this._NAXIS1 * this._NAXIS2;
        let k = 0;
        let c, r;
        const pixelvalues = [];
        //  let pixv, pv;
        while (k < pxLength) {
            r = Math.floor(k / this._NAXIS1); // row
            c = (k - r * this._NAXIS1) * bytesXelem; // col
            if (c === 0) {
                pixelvalues[r] = new Uint8Array(this._NAXIS1 * bytesXelem);
            }
            // px_val = this.extractPixelValue(bytesXelem * k);
            // ph_val = this.pixel2physicalValue(px_val);
            // TODO check if ph_val == blank
            // if not then use ph_val to compute datamin and datamax
            for (let i = 0; i < bytesXelem; i++) {
                pixelvalues[r][c + i] = this._u8data[k * bytesXelem + i];
            }
            // if (k == 232) {
            // 	pixv = this.extractPixelValue(k * bytesXelem);
            // 	pv = this._BZERO + this._BSCALE * pixv;
            // }
            k++;
        }
        return pixelvalues;
    }
    /** this can be deleted */
    extractPixelValue(offset) {
        let px_val = undefined; // pixel value
        if (this._BITPIX == 16) {
            // 16-bit 2's complement binary integer
            px_val = _ParseUtils_js__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.parse16bit2sComplement(this._u8data[offset], this._u8data[offset + 1]);
        }
        else if (this._BITPIX == 32) {
            // IEEE 754 half precision (float16) ??
            px_val = _ParseUtils_js__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.parse32bit2sComplement(this._u8data[offset], this._u8data[offset + 1], this._u8data[offset + 2], this._u8data[offset + 3]);
        }
        else if (this._BITPIX == -32) {
            // 32-bit IEEE single-precision floating point
            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);
            px_val = _ParseUtils_js__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 4), 8, 23);
        }
        else if (this._BITPIX == 64) {
            // 64-bit 2's complement binary integer
            throw new Error("BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.");
        }
        else if (this._BITPIX == -64) {
            // 64-bit IEEE double-precision floating point
            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html
            px_val = _ParseUtils_js__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 8), 11, 52);
        }
        return px_val;
    }
    pixel2physicalValue(pxval) {
        if (this._BZERO === undefined || this._BSCALE === undefined) {
            throw new Error("Either BZERO or BSCALE is undefined");
        }
        return this._BZERO + this._BSCALE * pxval;
    }
}
//# sourceMappingURL=ParsePayload.js.map

/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/ParseUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/ParseUtils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParseUtils: () => (/* binding */ ParseUtils)
/* harmony export */ });
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/FITSParser
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
class ParseUtils {
    static getStringAt(data, offset, length) {
        const chars = [];
        for (let i = offset, j = 0; i < offset + length; i++, j++) {
            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);
        }
        return chars.join("");
    }
    static byteString(n) {
        if (n < 0 || n > 255 || n % 1 !== 0) {
            throw new Error(n + " does not fit in a byte");
        }
        return ("000000000" + n.toString(2)).substr(-8);
    }
    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {
        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;
        if (long < 0)
            long += 4294967296;
        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *
            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);
        return float;
    }
    static convertBlankToBytes(blank, nbytes) {
        let str = Math.abs(blank).toString(2);
        while (str.length / 8 < nbytes) {
            str += "0";
        }
        const buffer = new ArrayBuffer(nbytes);
        const uint8 = new Uint8Array(buffer);
        for (let i = 0; i < nbytes; i++) {
            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);
        }
        return uint8;
    }
    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */
    static parseFloatingPointFormat(bytes, ebits, fbits) {
        // Bytes to bits
        const bits = [];
        for (let i = bytes.length; i; i -= 1) {
            let byte = bytes[i - 1];
            for (let j = 8; j; j -= 1) {
                bits.push(byte % 2 ? 1 : 0);
                byte = byte >> 1;
            }
        }
        bits.reverse();
        const str = bits.join("");
        // Unpack sign, exponent, fraction
        const bias = (1 << (ebits - 1)) - 1;
        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
        const e = parseInt(str.substring(1, 1 + ebits), 2);
        const f = parseInt(str.substring(1 + ebits), 2);
        // Produce number
        if (e === (1 << ebits) - 1) {
            return f !== 0 ? undefined : s * Infinity;
        }
        else if (e > 0) {
            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
        }
        else if (f !== 0) {
            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));
        }
        else {
            return s * 0;
        }
    }
    static generate16bit2sComplement(val) {
        throw new TypeError("not implemented yet" + val);
    }
    static parse16bit2sComplement(byte1, byte2) {
        const unsigned = (byte1 << 8) | byte2;
        if (unsigned & 0x8000) {
            return unsigned | 0xffff0000;
        }
        else {
            return unsigned;
        }
    }
    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {
        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;
        const s = (unsigned & 0x80000000) >> 31;
        let res = unsigned & 0xffffffff;
        if (s) {
            res = (~unsigned & 0xffffffff) + 1;
            return -1 * res;
        }
        return res;
    }
    /**
     *
     * @param {*} data string?
     * @param {*} offset offset in the data
     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.
     */
    static getByteAt(data, offset) {
        const dataOffset = 0;
        return data.charCodeAt(offset + dataOffset) & 0xff;
    }
    static extractPixelValue(offset, bytes, bitpix) {
        let px_val = undefined; // pixel value
        // let px_val1, px_val2, px_val3, px_val4;
        if (bitpix == 8) {
            px_val = bytes[0];
        }
        else if (bitpix == 16) {
            // 16-bit 2's complement binary integer
            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);
        }
        else if (bitpix == 32) {
            // IEEE 754 half precision (float16) ??
            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);
        }
        else if (bitpix == -32) {
            // 32-bit IEEE single-precision floating point
            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);
            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);
        }
        else if (bitpix == 64) {
            // 64-bit 2's complement binary integer
            throw new Error("BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.");
        }
        else if (bitpix == -64) {
            // 64-bit IEEE double-precision floating point
            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html
            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);
        }
        return px_val;
    }
}
// export default ParseUtils;
//# sourceMappingURL=ParseUtils.js.map

/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FITSHeader: () => (/* reexport safe */ _model_FITSHeader_js__WEBPACK_IMPORTED_MODULE_1__.FITSHeader),
/* harmony export */   FITSHeaderItem: () => (/* reexport safe */ _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem),
/* harmony export */   FITSParser: () => (/* reexport safe */ _FITSParser_js__WEBPACK_IMPORTED_MODULE_2__.FITSParser),
/* harmony export */   FITSWriter: () => (/* reexport safe */ _FITSWriter_js__WEBPACK_IMPORTED_MODULE_3__.FITSWriter),
/* harmony export */   ParseHeader: () => (/* reexport safe */ _ParseHeader_js__WEBPACK_IMPORTED_MODULE_4__.ParseHeader),
/* harmony export */   ParsePayload: () => (/* reexport safe */ _ParsePayload_js__WEBPACK_IMPORTED_MODULE_5__.ParsePayload),
/* harmony export */   ParseUtils: () => (/* reexport safe */ _ParseUtils_js__WEBPACK_IMPORTED_MODULE_6__.ParseUtils)
/* harmony export */ });
/* harmony import */ var _model_FITSHeaderItem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/FITSHeaderItem.js */ "./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js");
/* harmony import */ var _model_FITSHeader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/FITSHeader.js */ "./node_modules/jsfitsio/lib-esm/model/FITSHeader.js");
/* harmony import */ var _FITSParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FITSParser.js */ "./node_modules/jsfitsio/lib-esm/FITSParser.js");
/* harmony import */ var _FITSWriter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FITSWriter.js */ "./node_modules/jsfitsio/lib-esm/FITSWriter.js");
/* harmony import */ var _ParseHeader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ParseHeader.js */ "./node_modules/jsfitsio/lib-esm/ParseHeader.js");
/* harmony import */ var _ParsePayload_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ParsePayload.js */ "./node_modules/jsfitsio/lib-esm/ParsePayload.js");
/* harmony import */ var _ParseUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ParseUtils.js */ "./node_modules/jsfitsio/lib-esm/ParseUtils.js");







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/model/FITSHeader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/model/FITSHeader.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FITSHeader: () => (/* binding */ FITSHeader)
/* harmony export */ });
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/FITSParser
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
// reference FTIS standard doc https://heasarc.gsfc.nasa.gov/docs/fcg/standard_dict.html
class FITSHeader extends Map {
    constructor() {
        super();
        this._offset = undefined;
        this._items = [];
    }
    set offset(offset) {
        this._offset = offset;
    }
    get offset() {
        return this._offset;
    }
    getItemList() {
        return this._items;
    }
    getItemListOf(key) {
        const res = [];
        for (let i = 0; i < this._items.length; i++) {
            const item = this._items[i];
            if (item.key == key) {
                res.push(item);
            }
        }
        return res;
    }
    addItemAtTheBeginning(item) {
        if (item.key !== undefined) {
            if ([
                "SIMPLE",
                "BITPIX",
                "NAXIS",
                "NAXIS1",
                "NAXIS2",
                "BLANK",
                "BZERO",
                "BSCALE",
                "DATAMIN",
                "DATAMAX",
                "NPIX",
                "ORDER",
                "CRPIX1",
                "CRPIX2",
                "CDELT1",
                "CDELT2",
                "CRVAL1",
                "CRVAL2",
            ].includes(item.key)) {
                this.set(item.key, item.value);
            }
        }
        const newitemlist = [item].concat(this._items);
        this._items = newitemlist;
    }
    addItem(item) {
        if (item.key !== undefined) {
            if ([
                "SIMPLE",
                "BITPIX",
                "NAXIS",
                "NAXIS1",
                "NAXIS2",
                "BLANK",
                "BZERO",
                "BSCALE",
                "DATAMIN",
                "DATAMAX",
                "NPIX",
                "ORDER",
                "CRPIX1",
                "CRPIX2",
                "CDELT1",
                "CDELT2",
                "CRVAL1",
                "CRVAL2",
            ].includes(item.key)) {
                this.set(item.key, item.value);
            }
        }
        this._items.push(item);
    }
    getNumRows() {
        return this._items.length;
    }
}
//# sourceMappingURL=FITSHeader.js.map

/***/ }),

/***/ "./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js":
/*!***************************************************************!*\
  !*** ./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FITSHeaderItem: () => (/* binding */ FITSHeaderItem)
/* harmony export */ });
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/FITSParser
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
class FITSHeaderItem {
    constructor(key, value, comment) {
        this._key = key !== undefined ? key : undefined;
        this._value = value !== undefined ? value : undefined;
        this._comment = comment !== undefined ? comment : undefined;
    }
    get key() {
        return this._key;
    }
    get comment() {
        return this._comment;
    }
    get value() {
        return this._value;
    }
}
//# sourceMappingURL=FITSHeaderItem.js.map

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/tabulator-tables/dist/js/tabulator_esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/tabulator-tables/dist/js/tabulator_esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessorModule: () => (/* binding */ Accessor),
/* harmony export */   AjaxModule: () => (/* binding */ Ajax),
/* harmony export */   CalcComponent: () => (/* binding */ CalcComponent),
/* harmony export */   CellComponent: () => (/* binding */ CellComponent),
/* harmony export */   ClipboardModule: () => (/* binding */ Clipboard),
/* harmony export */   ColumnCalcsModule: () => (/* binding */ ColumnCalcs),
/* harmony export */   ColumnComponent: () => (/* binding */ ColumnComponent),
/* harmony export */   DataTreeModule: () => (/* binding */ DataTree),
/* harmony export */   DownloadModule: () => (/* binding */ Download),
/* harmony export */   EditModule: () => (/* binding */ Edit$1),
/* harmony export */   ExportModule: () => (/* binding */ Export),
/* harmony export */   FilterModule: () => (/* binding */ Filter),
/* harmony export */   FormatModule: () => (/* binding */ Format),
/* harmony export */   FrozenColumnsModule: () => (/* binding */ FrozenColumns),
/* harmony export */   FrozenRowsModule: () => (/* binding */ FrozenRows),
/* harmony export */   GroupComponent: () => (/* binding */ GroupComponent),
/* harmony export */   GroupRowsModule: () => (/* binding */ GroupRows),
/* harmony export */   HistoryModule: () => (/* binding */ History),
/* harmony export */   HtmlTableImportModule: () => (/* binding */ HtmlTableImport),
/* harmony export */   ImportModule: () => (/* binding */ Import),
/* harmony export */   InteractionModule: () => (/* binding */ Interaction),
/* harmony export */   KeybindingsModule: () => (/* binding */ Keybindings),
/* harmony export */   MenuModule: () => (/* binding */ Menu),
/* harmony export */   Module: () => (/* binding */ Module),
/* harmony export */   MoveColumnsModule: () => (/* binding */ MoveColumns),
/* harmony export */   MoveRowsModule: () => (/* binding */ MoveRows),
/* harmony export */   MutatorModule: () => (/* binding */ Mutator),
/* harmony export */   PageModule: () => (/* binding */ Page),
/* harmony export */   PersistenceModule: () => (/* binding */ Persistence),
/* harmony export */   PopupModule: () => (/* binding */ Popup$1),
/* harmony export */   PrintModule: () => (/* binding */ Print),
/* harmony export */   PseudoRow: () => (/* binding */ PseudoRow),
/* harmony export */   ReactiveDataModule: () => (/* binding */ ReactiveData),
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   ResizeColumnsModule: () => (/* binding */ ResizeColumns),
/* harmony export */   ResizeRowsModule: () => (/* binding */ ResizeRows),
/* harmony export */   ResizeTableModule: () => (/* binding */ ResizeTable),
/* harmony export */   ResponsiveLayoutModule: () => (/* binding */ ResponsiveLayout),
/* harmony export */   RowComponent: () => (/* binding */ RowComponent),
/* harmony export */   SelectRangeModule: () => (/* binding */ SelectRange),
/* harmony export */   SelectRowModule: () => (/* binding */ SelectRow),
/* harmony export */   SortModule: () => (/* binding */ Sort),
/* harmony export */   Tabulator: () => (/* binding */ Tabulator),
/* harmony export */   TabulatorFull: () => (/* binding */ TabulatorFull),
/* harmony export */   TooltipModule: () => (/* binding */ Tooltip),
/* harmony export */   ValidateModule: () => (/* binding */ Validate)
/* harmony export */ });
/* Tabulator v5.6.1 (c) Oliver Folkerd 2024 */
class CoreFeature{

	constructor(table){
		this.table = table;
	}

	//////////////////////////////////////////
	/////////////// DataLoad /////////////////
	//////////////////////////////////////////

	reloadData(data, silent, columnsChanged){
		return this.table.dataLoader.load(data, undefined, undefined, undefined, silent, columnsChanged);
	}

	//////////////////////////////////////////
	///////////// Localization ///////////////
	//////////////////////////////////////////

	langText(){
		return this.table.modules.localize.getText(...arguments);
	}

	langBind(){
		return this.table.modules.localize.bind(...arguments);
	}

	langLocale(){
		return this.table.modules.localize.getLocale(...arguments);
	}


	//////////////////////////////////////////
	////////// Inter Table Comms /////////////
	//////////////////////////////////////////

	commsConnections(){
		return this.table.modules.comms.getConnections(...arguments);
	}

	commsSend(){
		return this.table.modules.comms.send(...arguments);
	}

	//////////////////////////////////////////
	//////////////// Layout  /////////////////
	//////////////////////////////////////////

	layoutMode(){
		return this.table.modules.layout.getMode();
	}

	layoutRefresh(force){
		return this.table.modules.layout.layout(force);
	}


	//////////////////////////////////////////
	/////////////// Event Bus ////////////////
	//////////////////////////////////////////

	subscribe(){
		return this.table.eventBus.subscribe(...arguments);
	}

	unsubscribe(){
		return this.table.eventBus.unsubscribe(...arguments);
	}

	subscribed(key){
		return this.table.eventBus.subscribed(key);
	}

	subscriptionChange(){
		return this.table.eventBus.subscriptionChange(...arguments);
	}

	dispatch(){
		return this.table.eventBus.dispatch(...arguments);
	}

	chain(){
		return this.table.eventBus.chain(...arguments);
	}

	confirm(){
		return this.table.eventBus.confirm(...arguments);
	}

	dispatchExternal(){
		return this.table.externalEvents.dispatch(...arguments);
	}

	subscribedExternal(key){
		return this.table.externalEvents.subscribed(key);
	}

	subscriptionChangeExternal(){
		return this.table.externalEvents.subscriptionChange(...arguments);
	}

	//////////////////////////////////////////
	//////////////// Options /////////////////
	//////////////////////////////////////////

	options(key){
		return this.table.options[key];
	}

	setOption(key, value){
		if(typeof value !== "undefined"){
			this.table.options[key] = value;
		}

		return this.table.options[key];
	}

	//////////////////////////////////////////
	/////////// Deprecation Checks ///////////
	//////////////////////////////////////////

	deprecationCheck(oldOption, newOption,  convert){
		return this.table.deprecationAdvisor.check(oldOption, newOption,  convert);
	}

	deprecationCheckMsg(oldOption, msg){
		return this.table.deprecationAdvisor.checkMsg(oldOption, msg);
	}

	deprecationMsg(msg){
		return this.table.deprecationAdvisor.msg(msg);
	}
	//////////////////////////////////////////
	//////////////// Modules /////////////////
	//////////////////////////////////////////

	module(key){
		return this.table.module(key);
	}
}

class Helpers{

	static elVisible(el){
		return !(el.offsetWidth <= 0 && el.offsetHeight <= 0);
	}

	static elOffset(el){
		var box = el.getBoundingClientRect();

		return {
			top: box.top + window.pageYOffset - document.documentElement.clientTop,
			left: box.left + window.pageXOffset - document.documentElement.clientLeft
		};
	}

	static retrieveNestedData(separator, field, data){
		var structure = separator ? field.split(separator) : [field],
		length = structure.length,
		output;

		for(let i = 0; i < length; i++){

			data = data[structure[i]];

			output = data;

			if(!data){
				break;
			}
		}

		return output;
	}

	static deepClone(obj, clone, list = []){
		var objectProto = {}.__proto__,
		arrayProto = [].__proto__;

		if (!clone){
			clone = Object.assign(Array.isArray(obj) ? [] : {}, obj);
		}

		for(var i in obj) {
			let subject = obj[i],
			match, copy;

			if(subject != null && typeof subject === "object" && (subject.__proto__ === objectProto || subject.__proto__ === arrayProto)){
				match = list.findIndex((item) => {
					return item.subject === subject;
				});

				if(match > -1){
					clone[i] = list[match].copy;
				}else {
					copy = Object.assign(Array.isArray(subject) ? [] : {}, subject);

					list.unshift({subject, copy});

					clone[i] = this.deepClone(subject, copy, list);
				}
			}
		}

		return clone;
	}
}

class Popup extends CoreFeature{
	constructor(table, element, parent){
		super(table);
		
		this.element = element;
		this.container = this._lookupContainer();
		
		this.parent = parent;
		
		this.reversedX = false;
		this.childPopup = null;
		this.blurable = false;
		this.blurCallback = null;
		this.blurEventsBound = false;
		this.renderedCallback = null;
		
		this.visible = false;
		this.hideable = true;
		
		this.element.classList.add("tabulator-popup-container");
		
		this.blurEvent = this.hide.bind(this, false);
		this.escEvent = this._escapeCheck.bind(this);
		
		this.destroyBinding = this.tableDestroyed.bind(this);
		this.destroyed = false;
	}
	
	tableDestroyed(){
		this.destroyed = true;
		this.hide(true);
	}
	
	_lookupContainer(){
		var container = this.table.options.popupContainer;
		
		if(typeof container === "string"){
			container = document.querySelector(container);
			
			if(!container){
				console.warn("Menu Error - no container element found matching selector:",  this.table.options.popupContainer , "(defaulting to document body)");
			}
		}else if (container === true){
			container = this.table.element;
		}
		
		if(container && !this._checkContainerIsParent(container)){
			container = false;
			console.warn("Menu Error - container element does not contain this table:",  this.table.options.popupContainer , "(defaulting to document body)");
		}
		
		if(!container){
			container = document.body;
		}
		
		return container;
	}
	
	_checkContainerIsParent(container, element = this.table.element){
		if(container === element){
			return true;
		}else {
			return element.parentNode ? this._checkContainerIsParent(container, element.parentNode) : false;
		}
	}
	
	renderCallback(callback){
		this.renderedCallback = callback;
	}
	
	containerEventCoords(e){
		var touch = !(e instanceof MouseEvent);
		
		var x = touch ? e.touches[0].pageX : e.pageX;
		var y = touch ? e.touches[0].pageY : e.pageY;
		
		if(this.container !== document.body){
			let parentOffset = Helpers.elOffset(this.container);
			
			x -= parentOffset.left;
			y -= parentOffset.top;
		}
		
		return {x, y};
	}
	
	elementPositionCoords(element, position = "right"){
		var offset = Helpers.elOffset(element),
		containerOffset, x, y;
		
		if(this.container !== document.body){
			containerOffset = Helpers.elOffset(this.container);
			
			offset.left -= containerOffset.left;
			offset.top -= containerOffset.top;
		}
		
		switch(position){
			case "right":
				x = offset.left + element.offsetWidth;
				y = offset.top - 1;
				break;
			
			case "bottom":
				x = offset.left;
				y = offset.top + element.offsetHeight;
				break;
			
			case "left":
				x = offset.left;
				y = offset.top - 1;
				break;
			
			case "top":
				x = offset.left;
				y = offset.top;
				break;
			
			case "center":
				x = offset.left + (element.offsetWidth / 2);
				y = offset.top + (element.offsetHeight / 2);
				break;
			
		}
		
		return {x, y, offset};
	}
	
	show(origin, position){
		var x, y, parentEl, parentOffset, coords;
		
		if(this.destroyed || this.table.destroyed){
			return this;
		}
		
		if(origin instanceof HTMLElement){
			parentEl = origin;
			coords = this.elementPositionCoords(origin, position);
			
			parentOffset = coords.offset;
			x = coords.x;
			y = coords.y;
			
		}else if(typeof origin === "number"){
			parentOffset = {top:0, left:0};
			x = origin;
			y = position;
		}else {
			coords = this.containerEventCoords(origin);
			
			x = coords.x;
			y = coords.y;
			
			this.reversedX = false;
		}
		
		this.element.style.top = y + "px";
		this.element.style.left = x + "px";
		
		this.container.appendChild(this.element);
		
		if(typeof this.renderedCallback === "function"){
			this.renderedCallback();
		}
		
		this._fitToScreen(x, y, parentEl, parentOffset, position);
		
		this.visible = true;
		
		this.subscribe("table-destroy", this.destroyBinding);
		
		this.element.addEventListener("mousedown", (e) => {
			e.stopPropagation();
		});
		
		return this;
	}
	
	_fitToScreen(x, y, parentEl, parentOffset, position){
		var scrollTop = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
		
		//move menu to start on right edge if it is too close to the edge of the screen
		if((x + this.element.offsetWidth) >= this.container.offsetWidth || this.reversedX){
			this.element.style.left = "";
			
			if(parentEl){
				this.element.style.right = (this.container.offsetWidth - parentOffset.left) + "px";
			}else {
				this.element.style.right = (this.container.offsetWidth - x) + "px";
			}
			
			this.reversedX = true;
		}
		
		//move menu to start on bottom edge if it is too close to the edge of the screen
		if((y + this.element.offsetHeight) > Math.max(this.container.offsetHeight, scrollTop ? this.container.scrollHeight : 0)) {
			if(parentEl){
				switch(position){
					case "bottom":
						this.element.style.top = (parseInt(this.element.style.top) - this.element.offsetHeight - parentEl.offsetHeight - 1) + "px";
						break;
					
					default:
						this.element.style.top = (parseInt(this.element.style.top) - this.element.offsetHeight + parentEl.offsetHeight + 1) + "px";
				}
				
			}else {
				this.element.style.top = (parseInt(this.element.style.top) - this.element.offsetHeight) + "px";
			}
		}
	}
	
	isVisible(){
		return this.visible;
	}
	
	hideOnBlur(callback){
		this.blurable = true;
		
		if(this.visible){
			setTimeout(() => {
				if(this.visible){
					this.table.rowManager.element.addEventListener("scroll", this.blurEvent);
					this.subscribe("cell-editing", this.blurEvent);
					document.body.addEventListener("click", this.blurEvent);
					document.body.addEventListener("contextmenu", this.blurEvent);
					document.body.addEventListener("mousedown", this.blurEvent);
					window.addEventListener("resize", this.blurEvent);
					document.body.addEventListener("keydown", this.escEvent);

					this.blurEventsBound = true;
				}
			}, 100);
			
			this.blurCallback = callback;
		}
		
		return this;
	}
	
	_escapeCheck(e){
		if(e.keyCode == 27){
			this.hide();
		}
	}
	
	blockHide(){
		this.hideable = false;
	}
	
	restoreHide(){
		this.hideable = true;
	}
	
	hide(silent = false){
		if(this.visible && this.hideable){
			if(this.blurable && this.blurEventsBound){
				document.body.removeEventListener("keydown", this.escEvent);
				document.body.removeEventListener("click", this.blurEvent);
				document.body.removeEventListener("contextmenu", this.blurEvent);
				document.body.removeEventListener("mousedown", this.blurEvent);
				window.removeEventListener("resize", this.blurEvent);
				this.table.rowManager.element.removeEventListener("scroll", this.blurEvent);
				this.unsubscribe("cell-editing", this.blurEvent);

				this.blurEventsBound = false;
			}
			
			if(this.childPopup){
				this.childPopup.hide();
			}
			
			if(this.parent){
				this.parent.childPopup = null;
			}
			
			if(this.element.parentNode){
				this.element.parentNode.removeChild(this.element);
			}
			
			this.visible = false;
			
			if(this.blurCallback && !silent){
				this.blurCallback();
			}
			
			this.unsubscribe("table-destroy", this.destroyBinding);
		}
		
		return this;
	}
	
	child(element){
		if(this.childPopup){
			this.childPopup.hide();
		}
		
		this.childPopup = new Popup(this.table, element, this);
		
		return this.childPopup;
	}
}

class Module extends CoreFeature{
	
	constructor(table, name){
		super(table);
		
		this._handler = null;
	}
	
	initialize(){
		// setup module when table is initialized, to be overridden in module
	}
	
	
	///////////////////////////////////
	////// Options Registration ///////
	///////////////////////////////////
	
	registerTableOption(key, value){
		this.table.optionsList.register(key, value);
	}
	
	registerColumnOption(key, value){
		this.table.columnManager.optionsList.register(key, value);
	}
	
	///////////////////////////////////
	/// Public Function Registration ///
	///////////////////////////////////
	
	registerTableFunction(name, func){
		if(typeof this.table[name] === "undefined"){
			this.table[name] = (...args) => {
				this.table.initGuard(name);
				
				return func(...args);
			};
		}else {
			console.warn("Unable to bind table function, name already in use", name);
		}
	}
	
	registerComponentFunction(component, func, handler){
		return this.table.componentFunctionBinder.bind(component, func, handler);
	}
	
	///////////////////////////////////
	////////// Data Pipeline //////////
	///////////////////////////////////
	
	registerDataHandler(handler, priority){
		this.table.rowManager.registerDataPipelineHandler(handler, priority);
		this._handler = handler;
	}
	
	registerDisplayHandler(handler, priority){
		this.table.rowManager.registerDisplayPipelineHandler(handler, priority);
		this._handler = handler;
	}
	
	displayRows(adjust){
		var index = this.table.rowManager.displayRows.length - 1, 
		lookupIndex;
		
		if(this._handler){
			lookupIndex = this.table.rowManager.displayPipeline.findIndex((item) => {
				return item.handler === this._handler;
			});

			if(lookupIndex > -1){
				index = lookupIndex;
			}
		}
		
		if(adjust){
			index = index + adjust;
		}

		if(this._handler){
			if(index > -1){
				return this.table.rowManager.getDisplayRows(index);
			}else {
				return this.activeRows();
			}
		}	
	}
	
	activeRows(){
		return this.table.rowManager.activeRows;
	}
	
	refreshData(renderInPosition, handler){
		if(!handler){
			handler = this._handler;
		}
		
		if(handler){
			this.table.rowManager.refreshActiveData(handler, false, renderInPosition);
		}
	}
	
	///////////////////////////////////
	//////// Footer Management ////////
	///////////////////////////////////
	
	footerAppend(element){
		return this.table.footerManager.append(element);
	}
	
	footerPrepend(element){
		return this.table.footerManager.prepend(element);
	}
	
	footerRemove(element){
		return this.table.footerManager.remove(element);
	} 
	
	///////////////////////////////////
	//////// Popups Management ////////
	///////////////////////////////////
	
	popup(menuEl, menuContainer){
		return new Popup(this.table, menuEl, menuContainer);
	}
	
	///////////////////////////////////
	//////// Alert Management ////////
	///////////////////////////////////
	
	alert(content, type){
		return this.table.alertManager.alert(content, type);
	}
	
	clearAlert(){
		return this.table.alertManager.clear();
	}
	
}

var defaultAccessors = {};

class Accessor extends Module{

	constructor(table){
		super(table);

		this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"]; //list of accessor types

		this.registerColumnOption("accessor");
		this.registerColumnOption("accessorParams");
		this.registerColumnOption("accessorData");
		this.registerColumnOption("accessorDataParams");
		this.registerColumnOption("accessorDownload");
		this.registerColumnOption("accessorDownloadParams");
		this.registerColumnOption("accessorClipboard");
		this.registerColumnOption("accessorClipboardParams");
		this.registerColumnOption("accessorPrint");
		this.registerColumnOption("accessorPrintParams");
		this.registerColumnOption("accessorHtmlOutput");
		this.registerColumnOption("accessorHtmlOutputParams");
	}

	initialize(){
		this.subscribe("column-layout", this.initializeColumn.bind(this));
		this.subscribe("row-data-retrieve", this.transformRow.bind(this));
	}

	//initialize column accessor
	initializeColumn(column){
		var match = false,
		config = {};

		this.allowedTypes.forEach((type) => {
			var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)),
			accessor;

			if(column.definition[key]){
				accessor = this.lookupAccessor(column.definition[key]);

				if(accessor){
					match = true;

					config[key] = {
						accessor:accessor,
						params: column.definition[key + "Params"] || {},
					};
				}
			}
		});

		if(match){
			column.modules.accessor = config;
		}
	}

	lookupAccessor(value){
		var accessor = false;

		//set column accessor
		switch(typeof value){
			case "string":
				if(Accessor.accessors[value]){
					accessor = Accessor.accessors[value];
				}else {
					console.warn("Accessor Error - No such accessor found, ignoring: ", value);
				}
				break;

			case "function":
				accessor = value;
				break;
		}

		return accessor;
	}

	//apply accessor to row
	transformRow(row, type){
		var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)),
		rowComponent = row.getComponent();

		//clone data object with deep copy to isolate internal data from returned result
		var data = Helpers.deepClone(row.data || {});

		this.table.columnManager.traverse(function(column){
			var value, accessor, params, colComponent;

			if(column.modules.accessor){

				accessor = column.modules.accessor[key] || column.modules.accessor.accessor || false;

				if(accessor){
					value = column.getFieldValue(data);

					if(value != "undefined"){
						colComponent = column.getComponent();
						params = typeof accessor.params === "function" ? accessor.params(value, data, type, colComponent, rowComponent) : accessor.params;
						column.setFieldValue(data, accessor.accessor(value, data, type, params, colComponent, rowComponent));
					}
				}
			}
		});

		return data;
	}
}

//load defaults
Accessor.moduleName = "accessor";
Accessor.accessors = defaultAccessors;

var defaultConfig = {
	method: "GET",
};

function generateParamsList(data, prefix){
	var output = [];

	prefix = prefix || "";

	if(Array.isArray(data)){
		data.forEach((item, i) => {
			output = output.concat(generateParamsList(item, prefix ? prefix + "[" + i + "]" : i));
		});
	}else if (typeof data === "object"){
		for (var key in data){
			output = output.concat(generateParamsList(data[key], prefix ? prefix + "[" + key + "]" : key));
		}
	}else {
		output.push({key:prefix, value:data});
	}

	return output;
}

function serializeParams(params){
	var output = generateParamsList(params),
	encoded = [];

	output.forEach(function(item){
		encoded.push(encodeURIComponent(item.key) + "=" + encodeURIComponent(item.value));
	});

	return encoded.join("&");
}

function urlBuilder(url, config, params){
	if(url){
		if(params && Object.keys(params).length){
			if(!config.method || config.method.toLowerCase() == "get"){
				config.method = "get";

				url += (url.includes("?") ? "&" : "?") + serializeParams(params);
			}
		}
	}

	return url;
}

function defaultLoaderPromise(url, config, params){
	var contentType;

	return new Promise((resolve, reject) => {
		//set url
		url = this.urlGenerator.call(this.table, url, config, params);

		//set body content if not GET request
		if(config.method.toUpperCase() != "GET"){
			contentType = typeof this.table.options.ajaxContentType === "object" ?  this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType];
			if(contentType){

				for(var key in contentType.headers){
					if(!config.headers){
						config.headers = {};
					}

					if(typeof config.headers[key] === "undefined"){
						config.headers[key] = contentType.headers[key];
					}
				}

				config.body = contentType.body.call(this, url, config, params);

			}else {
				console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
			}
		}

		if(url){
			//configure headers
			if(typeof config.headers === "undefined"){
				config.headers = {};
			}

			if(typeof config.headers.Accept === "undefined"){
				config.headers.Accept = "application/json";
			}

			if(typeof config.headers["X-Requested-With"] === "undefined"){
				config.headers["X-Requested-With"] = "XMLHttpRequest";
			}

			if(typeof config.mode === "undefined"){
				config.mode = "cors";
			}

			if(config.mode == "cors"){
				if(typeof config.headers["Origin"] === "undefined"){
					config.headers["Origin"] = window.location.origin;
				}
        
				if(typeof config.credentials === "undefined"){
					config.credentials = 'same-origin';
				}
			}else {
				if(typeof config.credentials === "undefined"){
					config.credentials = 'include';
				}
			}

			//send request
			fetch(url, config)
				.then((response)=>{
					if(response.ok) {
						response.json()
							.then((data)=>{
								resolve(data);
							}).catch((error)=>{
								reject(error);
								console.warn("Ajax Load Error - Invalid JSON returned", error);
							});
					}else {
						console.error("Ajax Load Error - Connection Error: " + response.status, response.statusText);
						reject(response);
					}
				})
				.catch((error)=>{
					console.error("Ajax Load Error - Connection Error: ", error);
					reject(error);
				});
		}else {
			console.warn("Ajax Load Error - No URL Set");
			resolve([]);
		}
	});
}

function generateParamsList$1(data, prefix){
	var output = [];

	prefix = prefix || "";

	if(Array.isArray(data)){
		data.forEach((item, i) => {
			output = output.concat(generateParamsList$1(item, prefix ? prefix + "[" + i + "]" : i));
		});
	}else if (typeof data === "object"){
		for (var key in data){
			output = output.concat(generateParamsList$1(data[key], prefix ? prefix + "[" + key + "]" : key));
		}
	}else {
		output.push({key:prefix, value:data});
	}

	return output;
}

var defaultContentTypeFormatters = {
	"json":{
		headers:{
			'Content-Type': 'application/json',
		},
		body:function(url, config, params){
			return JSON.stringify(params);
		},
	},
	"form":{
		headers:{
		},
		body:function(url, config, params){

			var output = generateParamsList$1(params),
			form = new FormData();

			output.forEach(function(item){
				form.append(item.key, item.value);
			});

			return form;
		},
	},
};

class Ajax extends Module{
	
	constructor(table){
		super(table);
		
		this.config = {}; //hold config object for ajax request
		this.url = ""; //request URL
		this.urlGenerator = false;
		this.params = false; //request parameters
		
		this.loaderPromise = false;
		
		this.registerTableOption("ajaxURL", false); //url for ajax loading
		this.registerTableOption("ajaxURLGenerator", false);
		this.registerTableOption("ajaxParams", {});  //params for ajax loading
		this.registerTableOption("ajaxConfig", "get"); //ajax request type
		this.registerTableOption("ajaxContentType", "form"); //ajax request type
		this.registerTableOption("ajaxRequestFunc", false); //promise function
		
		this.registerTableOption("ajaxRequesting", function(){});
		this.registerTableOption("ajaxResponse", false);
		
		this.contentTypeFormatters = Ajax.contentTypeFormatters;
	}
	
	//initialize setup options
	initialize(){
		this.loaderPromise = this.table.options.ajaxRequestFunc || Ajax.defaultLoaderPromise;
		this.urlGenerator = this.table.options.ajaxURLGenerator || Ajax.defaultURLGenerator;
		
		if(this.table.options.ajaxURL){
			this.setUrl(this.table.options.ajaxURL);
		}


		this.setDefaultConfig(this.table.options.ajaxConfig);
		
		this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this));
		
		this.subscribe("data-loading", this.requestDataCheck.bind(this));
		this.subscribe("data-params", this.requestParams.bind(this));
		this.subscribe("data-load", this.requestData.bind(this));
	}
	
	requestParams(data, config, silent, params){
		var ajaxParams = this.table.options.ajaxParams;
		
		if(ajaxParams){
			if(typeof ajaxParams === "function"){
				ajaxParams = ajaxParams.call(this.table);
			}
			
			params = Object.assign(Object.assign({}, ajaxParams), params);
		}		
		
		return params;
	}
	
	requestDataCheck(data, params, config, silent){
		return !!((!data && this.url) || typeof data === "string");
	}
	
	requestData(url, params, config, silent, previousData){
		var ajaxConfig;
		
		if(!previousData && this.requestDataCheck(url)){
			if(url){
				this.setUrl(url);
			}
			
			ajaxConfig = this.generateConfig(config);
			
			return this.sendRequest(this.url, params, ajaxConfig);
		}else {
			return previousData;
		}
	}
	
	setDefaultConfig(config = {}){
		this.config = Object.assign({}, Ajax.defaultConfig);

		if(typeof config == "string"){
			this.config.method = config;
		}else {
			Object.assign(this.config, config);
		}
	}
	
	//load config object
	generateConfig(config = {}){
		var ajaxConfig = Object.assign({}, this.config);
		
		if(typeof config == "string"){
			ajaxConfig.method = config;
		}else {
			Object.assign(ajaxConfig, config);
		}
		
		return ajaxConfig;
	}
	
	//set request url
	setUrl(url){
		this.url = url;
	}
	
	//get request url
	getUrl(){
		return this.url;
	}
	
	//send ajax request
	sendRequest(url, params, config){
		if(this.table.options.ajaxRequesting.call(this.table, url, params) !== false){
			return this.loaderPromise(url, config, params)
				.then((data)=>{
					if(this.table.options.ajaxResponse){
						data = this.table.options.ajaxResponse.call(this.table, url, params, data);
					}
				
					return data;
				});
		}else {
			return Promise.reject();
		}
	}
}

Ajax.moduleName = "ajax";

//load defaults
Ajax.defaultConfig = defaultConfig;
Ajax.defaultURLGenerator = urlBuilder;
Ajax.defaultLoaderPromise = defaultLoaderPromise;
Ajax.contentTypeFormatters = defaultContentTypeFormatters;

var defaultPasteActions = {
	replace:function(data){
		return this.table.setData(data);
	},
	update:function(data){
		return this.table.updateOrAddData(data);
	},
	insert:function(data){
		return this.table.addData(data);
	},
	range:function(data){
		var rows = [],
		range = this.table.modules.selectRange.activeRange,
		singleCell = false,
		bounds, startCell, startRow, rowWidth, dataLength;

		dataLength = data.length;
		
		if(range){
			bounds = range.getBounds();
			startCell = bounds.start;
			
			if(bounds.start === bounds.end){
				singleCell = true;
			}
			
			if(startCell){
				rows = this.table.rowManager.activeRows.slice();
				startRow = rows.indexOf(startCell.row);

				if(singleCell){
					rowWidth = data.length;
				}else {
					rowWidth = (rows.indexOf(bounds.end.row) - startRow) + 1;
				}
				
				
				if(startRow >-1){
					this.table.blockRedraw();
					
					rows = rows.slice(startRow, startRow + rowWidth);
					
					rows.forEach((row, i) => {
						row.updateData(data[i % dataLength]);
					});
					
					this.table.restoreRedraw();
				}
			}
		}
		
		return rows;
	}
};

var defaultPasteParsers = {
	table:function(clipboard){
		var data = [],
		headerFindSuccess = true,
		columns = this.table.columnManager.columns,
		columnMap = [],
		rows = [];
		
		//get data from clipboard into array of columns and rows.
		clipboard = clipboard.split("\n");
		
		clipboard.forEach(function(row){
			data.push(row.split("\t"));
		});
		
		if(data.length && !(data.length === 1 && data[0].length < 2)){
			
			//check if headers are present by title
			data[0].forEach(function(value){
				var column = columns.find(function(column){
					return value && column.definition.title && value.trim() && column.definition.title.trim() === value.trim();
				});
				
				if(column){
					columnMap.push(column);
				}else {
					headerFindSuccess = false;
				}
			});
			
			//check if column headers are present by field
			if(!headerFindSuccess){
				headerFindSuccess = true;
				columnMap = [];
				
				data[0].forEach(function(value){
					var column = columns.find(function(column){
						return value && column.field && value.trim() && column.field.trim() === value.trim();
					});
					
					if(column){
						columnMap.push(column);
					}else {
						headerFindSuccess = false;
					}
				});
				
				if(!headerFindSuccess){
					columnMap = this.table.columnManager.columnsByIndex;
				}
			}
			
			//remove header row if found
			if(headerFindSuccess){
				data.shift();
			}
			
			data.forEach(function(item){
				var row = {};
				
				item.forEach(function(value, i){
					if(columnMap[i]){
						row[columnMap[i].field] = value;
					}
				});
				
				rows.push(row);
			});
			
			return rows;
		}else {
			return false;
		}
	},
	range:function(clipboard){
		var data = [],
		rows = [],
		range = this.table.modules.selectRange.activeRange,
		singleCell = false,
		bounds, startCell, colWidth, columnMap, startCol;
		
		if(range){
			bounds = range.getBounds();
			startCell = bounds.start;

			if(bounds.start === bounds.end){
				singleCell = true;
			}
			
			if(startCell){
				//get data from clipboard into array of columns and rows.
				clipboard = clipboard.split("\n");
				
				clipboard.forEach(function(row){
					data.push(row.split("\t"));
				});
				
				if(data.length){
					columnMap = this.table.columnManager.getVisibleColumnsByIndex();
					startCol = columnMap.indexOf(startCell.column);

					if(startCol > -1){
						if(singleCell){
							colWidth = data[0].length;
						}else {
							colWidth = (columnMap.indexOf(bounds.end.column) - startCol) + 1;
						}

						columnMap = columnMap.slice(startCol, startCol + colWidth);

						data.forEach((item) => {
							var row = {};
							var itemLength = item.length;

							columnMap.forEach(function(col, i){
								row[col.field] = item[i % itemLength];
							});
							
							rows.push(row);	
						});

						return rows;
					}				
				}
			}
		}
		
		return false;
	}
};

class Clipboard extends Module{

	constructor(table){
		super(table);

		this.mode = true;
		this.pasteParser = function(){};
		this.pasteAction = function(){};
		this.customSelection = false;
		this.rowRange = false;
		this.blocked = true; //block copy actions not originating from this command

		this.registerTableOption("clipboard", false); //enable clipboard
		this.registerTableOption("clipboardCopyStyled", true); //formatted table data
		this.registerTableOption("clipboardCopyConfig", false); //clipboard config
		this.registerTableOption("clipboardCopyFormatter", false); //DEPRECATED - REMOVE in 5.0
		this.registerTableOption("clipboardCopyRowRange", "active"); //restrict clipboard to visible rows only
		this.registerTableOption("clipboardPasteParser", "table"); //convert pasted clipboard data to rows
		this.registerTableOption("clipboardPasteAction", "insert"); //how to insert pasted data into the table

		this.registerColumnOption("clipboard");
		this.registerColumnOption("titleClipboard");
	}

	initialize(){
		this.mode = this.table.options.clipboard;

		this.rowRange = this.table.options.clipboardCopyRowRange;

		if(this.mode === true || this.mode === "copy"){
			this.table.element.addEventListener("copy", (e) => {
				var plain, html, list;

				if(!this.blocked){
					e.preventDefault();

					if(this.customSelection){
						plain = this.customSelection;

						if(this.table.options.clipboardCopyFormatter){
							plain = this.table.options.clipboardCopyFormatter("plain", plain);
						}
					}else {

						list = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard");

						html = this.table.modules.export.generateHTMLTable(list);
						plain = html ? this.generatePlainContent(list) : "";

						if(this.table.options.clipboardCopyFormatter){
							plain = this.table.options.clipboardCopyFormatter("plain", plain);
							html = this.table.options.clipboardCopyFormatter("html", html);
						}
					}

					if (window.clipboardData && window.clipboardData.setData) {
						window.clipboardData.setData('Text', plain);
					} else if (e.clipboardData && e.clipboardData.setData) {
						e.clipboardData.setData('text/plain', plain);
						if(html){
							e.clipboardData.setData('text/html', html);
						}
					} else if (e.originalEvent && e.originalEvent.clipboardData.setData) {
						e.originalEvent.clipboardData.setData('text/plain', plain);
						if(html){
							e.originalEvent.clipboardData.setData('text/html', html);
						}
					}

					this.dispatchExternal("clipboardCopied", plain, html);

					this.reset();
				}
			});
		}

		if(this.mode === true || this.mode === "paste"){
			this.table.element.addEventListener("paste", (e) => {
				this.paste(e);
			});
		}

		this.setPasteParser(this.table.options.clipboardPasteParser);
		this.setPasteAction(this.table.options.clipboardPasteAction);

		this.registerTableFunction("copyToClipboard", this.copy.bind(this));
	}

	reset(){
		this.blocked = true;
		this.customSelection = false;
	}

	generatePlainContent (list) {
		var output = [];

		list.forEach((row) => {
			var rowData = [];

			row.columns.forEach((col) => {
				var value = "";

				if(col){

					if(row.type === "group"){
						col.value = col.component.getKey();
					}

					if(col.value === null){
						value = "";
					}else {
						switch(typeof col.value){
							case "object":
								value = JSON.stringify(col.value);
								break;

							case "undefined":
								value = "";
								break;

							default:
								value = col.value;
						}
					}
				}

				rowData.push(value);
			});

			output.push(rowData.join("\t"));
		});

		return output.join("\n");
	}

	copy (range, internal) {
		var sel, textRange;
		this.blocked = false;
		this.customSelection = false;
	

		if (this.mode === true || this.mode === "copy") {

			this.rowRange = range || this.table.options.clipboardCopyRowRange;

			if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
				range = document.createRange();
				range.selectNodeContents(this.table.element);
				sel = window.getSelection();

				if (sel.toString() && internal) {
					this.customSelection = sel.toString();
				}

				sel.removeAllRanges();
				sel.addRange(range);
			} else if (typeof document.selection != "undefined" && typeof document.body.createTextRange != "undefined") {
				textRange = document.body.createTextRange();
				textRange.moveToElementText(this.table.element);
				textRange.select();
			}

			document.execCommand('copy');

			if (sel) {
				sel.removeAllRanges();
			}
		}
	}

	//PASTE EVENT HANDLING
	setPasteAction(action){

		switch(typeof action){
			case "string":
				this.pasteAction = Clipboard.pasteActions[action];

				if(!this.pasteAction){
					console.warn("Clipboard Error - No such paste action found:", action);
				}
				break;

			case "function":
				this.pasteAction = action;
				break;
		}
	}

	setPasteParser(parser){
		switch(typeof parser){
			case "string":
				this.pasteParser = Clipboard.pasteParsers[parser];

				if(!this.pasteParser){
					console.warn("Clipboard Error - No such paste parser found:", parser);
				}
				break;

			case "function":
				this.pasteParser = parser;
				break;
		}
	}

	paste(e){
		var data, rowData, rows;

		if(this.checkPasteOrigin(e)){

			data = this.getPasteData(e);

			rowData = this.pasteParser.call(this, data);

			if(rowData){
				e.preventDefault();

				if(this.table.modExists("mutator")){
					rowData = this.mutateData(rowData);
				}

				rows = this.pasteAction.call(this, rowData);

				this.dispatchExternal("clipboardPasted", data, rowData, rows);
			}else {
				this.dispatchExternal("clipboardPasteError", data);
			}
		}
	}

	mutateData(data){
		var output = [];

		if(Array.isArray(data)){
			data.forEach((row) => {
				output.push(this.table.modules.mutator.transformRow(row, "clipboard"));
			});
		}else {
			output = data;
		}

		return output;
	}


	checkPasteOrigin(e){
		var valid = true;
		var blocked = this.confirm("clipboard-paste", [e]);

		if(blocked || !["DIV", "SPAN"].includes(e.target.tagName)){
			valid = false;
		}

		return valid;
	}

	getPasteData(e){
		var data;

		if (window.clipboardData && window.clipboardData.getData) {
			data = window.clipboardData.getData('Text');
		} else if (e.clipboardData && e.clipboardData.getData) {
			data = e.clipboardData.getData('text/plain');
		} else if (e.originalEvent && e.originalEvent.clipboardData.getData) {
			data = e.originalEvent.clipboardData.getData('text/plain');
		}

		return data;
	}
}

Clipboard.moduleName = "clipboard";

//load defaults
Clipboard.pasteActions = defaultPasteActions;
Clipboard.pasteParsers = defaultPasteParsers;

class CalcComponent{
	constructor (row){
		this._row = row;

		return new Proxy(this, {
			get: function(target, name, receiver) {
				if (typeof target[name] !== "undefined") {
					return target[name];
				}else {
					return target._row.table.componentFunctionBinder.handle("row", target._row, name);
				}
			}
		});
	}

	getData(transform){
		return this._row.getData(transform);
	}

	getElement(){
		return this._row.getElement();
	}

	getTable(){
		return this._row.table;
	}

	getCells(){
		var cells = [];

		this._row.getCells().forEach(function(cell){
			cells.push(cell.getComponent());
		});

		return cells;
	}

	getCell(column){
		var cell = this._row.getCell(column);
		return cell ? cell.getComponent() : false;
	}

	_getSelf(){
		return this._row;
	}
}

//public cell object
class CellComponent {

	constructor (cell){
		this._cell = cell;

		return new Proxy(this, {
			get: function(target, name, receiver) {
				if (typeof target[name] !== "undefined") {
					return target[name];
				}else {
					return target._cell.table.componentFunctionBinder.handle("cell", target._cell, name);
				}
			}
		});
	}

	getValue(){
		return this._cell.getValue();
	}

	getOldValue(){
		return this._cell.getOldValue();
	}

	getInitialValue(){
		return this._cell.initialValue;
	}

	getElement(){
		return this._cell.getElement();
	}

	getRow(){
		return this._cell.row.getComponent();
	}

	getData(transform){
		return this._cell.row.getData(transform);
	}
	getType(){
		return "cell";
	}
	getField(){
		return this._cell.column.getField();
	}

	getColumn(){
		return this._cell.column.getComponent();
	}

	setValue(value, mutate){
		if(typeof mutate == "undefined"){
			mutate = true;
		}

		this._cell.setValue(value, mutate);
	}

	restoreOldValue(){
		this._cell.setValueActual(this._cell.getOldValue());
	}

	restoreInitialValue(){
		this._cell.setValueActual(this._cell.initialValue);
	}

	checkHeight(){
		this._cell.checkHeight();
	}

	getTable(){
		return this._cell.table;
	}

	_getSelf(){
		return this._cell;
	}
}

class Cell extends CoreFeature{
	constructor(column, row){
		super(column.table);

		this.table = column.table;
		this.column = column;
		this.row = row;
		this.element = null;
		this.value = null;
		this.initialValue;
		this.oldValue = null;
		this.modules = {};

		this.height = null;
		this.width = null;
		this.minWidth = null;

		this.component = null;

		this.loaded = false; //track if the cell has been added to the DOM yet

		this.build();
	}

	//////////////// Setup Functions /////////////////
	//generate element
	build(){
		this.generateElement();

		this.setWidth();

		this._configureCell();

		this.setValueActual(this.column.getFieldValue(this.row.data));

		this.initialValue = this.value;
	}

	generateElement(){
		this.element = document.createElement('div');
		this.element.className = "tabulator-cell";
		this.element.setAttribute("role", "gridcell");
	}

	_configureCell(){
		var element = this.element,
		field = this.column.getField(),
		vertAligns = {
			top:"flex-start",
			bottom:"flex-end",
			middle:"center",
		},
		hozAligns = {
			left:"flex-start",
			right:"flex-end",
			center:"center",
		};

		//set text alignment
		element.style.textAlign = this.column.hozAlign;

		if(this.column.vertAlign){
			element.style.display = "inline-flex";

			element.style.alignItems = vertAligns[this.column.vertAlign] || "";

			if(this.column.hozAlign){
				element.style.justifyContent = hozAligns[this.column.hozAlign] || "";
			}
		}

		if(field){
			element.setAttribute("tabulator-field", field);
		}

		//add class to cell if needed
		if(this.column.definition.cssClass){
			var classNames = this.column.definition.cssClass.split(" ");
			classNames.forEach((className) => {
				element.classList.add(className);
			});
		}

		this.dispatch("cell-init", this);

		//hide cell if not visible
		if(!this.column.visible){
			this.hide();
		}
	}

	//generate cell contents
	_generateContents(){
		var val;

		val = this.chain("cell-format", this, null, () => {
			return this.element.innerHTML = this.value;
		});

		switch(typeof val){
			case "object":
				if(val instanceof Node){

					//clear previous cell contents
					while(this.element.firstChild) this.element.removeChild(this.element.firstChild);

					this.element.appendChild(val);
				}else {
					this.element.innerHTML = "";

					if(val != null){
						console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", val);
					}
				}
				break;
			case "undefined":
				this.element.innerHTML = "";
				break;
			default:
				this.element.innerHTML = val;
		}
	}

	cellRendered(){
		this.dispatch("cell-rendered", this);
	}

	//////////////////// Getters ////////////////////
	getElement(containerOnly){
		if(!this.loaded){
			this.loaded = true;
			if(!containerOnly){
				this.layoutElement();
			}
		}

		return this.element;
	}

	getValue(){
		return this.value;
	}

	getOldValue(){
		return this.oldValue;
	}

	//////////////////// Actions ////////////////////
	setValue(value, mutate, force){
		var changed = this.setValueProcessData(value, mutate, force);

		if(changed){
			this.dispatch("cell-value-updated", this);

			this.cellRendered();

			if(this.column.definition.cellEdited){
				this.column.definition.cellEdited.call(this.table, this.getComponent());
			}

			this.dispatchExternal("cellEdited", this.getComponent());

			if(this.subscribedExternal("dataChanged")){
				this.dispatchExternal("dataChanged", this.table.rowManager.getData());
			}
		}
	}

	setValueProcessData(value, mutate, force){
		var changed = false;

		if(this.value !== value || force){

			changed = true;

			if(mutate){
				value = this.chain("cell-value-changing", [this, value], null, value);
			}
		}

		this.setValueActual(value);

		if(changed){
			this.dispatch("cell-value-changed", this);
		}

		return changed;
	}

	setValueActual(value){
		this.oldValue = this.value;

		this.value = value;

		this.dispatch("cell-value-save-before", this);

		this.column.setFieldValue(this.row.data, value);

		this.dispatch("cell-value-save-after", this);

		if(this.loaded){
			this.layoutElement();
		}
	}

	layoutElement(){
		this._generateContents();

		this.dispatch("cell-layout", this);
	}

	setWidth(){
		this.width = this.column.width;
		this.element.style.width = this.column.widthStyled;
	}

	clearWidth(){
		this.width = "";
		this.element.style.width = "";
	}

	getWidth(){
		return this.width || this.element.offsetWidth;
	}

	setMinWidth(){
		this.minWidth = this.column.minWidth;
		this.element.style.minWidth = this.column.minWidthStyled;
	}

	setMaxWidth(){
		this.maxWidth = this.column.maxWidth;
		this.element.style.maxWidth = this.column.maxWidthStyled;
	}

	checkHeight(){
		// var height = this.element.css("height");
		this.row.reinitializeHeight();
	}

	clearHeight(){
		this.element.style.height = "";
		this.height = null;

		this.dispatch("cell-height", this, "");
	}

	setHeight(){
		this.height = this.row.height;
		this.element.style.height = this.row.heightStyled;

		this.dispatch("cell-height", this, this.row.heightStyled);
	}

	getHeight(){
		return this.height || this.element.offsetHeight;
	}

	show(){
		this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
	}

	hide(){
		this.element.style.display = "none";
	}

	delete(){
		this.dispatch("cell-delete", this);

		if(!this.table.rowManager.redrawBlock && this.element.parentNode){
			this.element.parentNode.removeChild(this.element);
		}

		this.element = false;
		this.column.deleteCell(this);
		this.row.deleteCell(this);
		this.calcs = {};
	}

	getIndex(){
		return this.row.getCellIndex(this);
	}

	//////////////// Object Generation /////////////////
	getComponent(){
		if(!this.component){
			this.component = new CellComponent(this);
		}

		return this.component;
	}
}

//public column object
class ColumnComponent {
	constructor (column){
		this._column = column;
		this.type = "ColumnComponent";

		return new Proxy(this, {
			get: function(target, name, receiver) {
				if (typeof target[name] !== "undefined") {
					return target[name];
				}else {
					return target._column.table.componentFunctionBinder.handle("column", target._column, name);
				}
			}
		});
	}

	getElement(){
		return this._column.getElement();
	}

	getDefinition(){
		return this._column.getDefinition();
	}

	getField(){
		return this._column.getField();
	}

	getTitleDownload() {
		return this._column.getTitleDownload();
	}

	getCells(){
		var cells = [];

		this._column.cells.forEach(function(cell){
			cells.push(cell.getComponent());
		});

		return cells;
	}

	isVisible(){
		return this._column.visible;
	}

	show(){
		if(this._column.isGroup){
			this._column.columns.forEach(function(column){
				column.show();
			});
		}else {
			this._column.show();
		}
	}

	hide(){
		if(this._column.isGroup){
			this._column.columns.forEach(function(column){
				column.hide();
			});
		}else {
			this._column.hide();
		}
	}

	toggle(){
		if(this._column.visible){
			this.hide();
		}else {
			this.show();
		}
	}

	delete(){
		return this._column.delete();
	}

	getSubColumns(){
		var output = [];

		if(this._column.columns.length){
			this._column.columns.forEach(function(column){
				output.push(column.getComponent());
			});
		}

		return output;
	}

	getParentColumn(){
		return this._column.parent instanceof Column ? this._column.parent.getComponent() : false;
	}

	_getSelf(){
		return this._column;
	}

	scrollTo(position, ifVisible){
		return this._column.table.columnManager.scrollToColumn(this._column, position, ifVisible);
	}

	getTable(){
		return this._column.table;
	}

	move(to, after){
		var toColumn = this._column.table.columnManager.findColumn(to);

		if(toColumn){
			this._column.table.columnManager.moveColumn(this._column, toColumn, after);
		}else {
			console.warn("Move Error - No matching column found:", toColumn);
		}
	}

	getNextColumn(){
		var nextCol = this._column.nextColumn();

		return nextCol ? nextCol.getComponent() : false;
	}

	getPrevColumn(){
		var prevCol = this._column.prevColumn();

		return prevCol ? prevCol.getComponent() : false;
	}

	updateDefinition(updates){
		return this._column.updateDefinition(updates);
	}

	getWidth(){
		return this._column.getWidth();
	}

	setWidth(width){
		var result;

		if(width === true){
			result =  this._column.reinitializeWidth(true);
		}else {
			result =  this._column.setWidth(width);
		}

		this._column.table.columnManager.rerenderColumns(true);

		return result;
	}
}

var defaultColumnOptions = {
	"title": undefined,
	"field": undefined,
	"columns": undefined,
	"visible": undefined,
	"hozAlign": undefined,
	"vertAlign": undefined,
	"width": undefined,
	"minWidth": 40,
	"maxWidth": undefined,
	"maxInitialWidth": undefined,
	"cssClass": undefined,
	"variableHeight": undefined,
	"headerVertical": undefined,
	"headerHozAlign": undefined,
	"headerWordWrap": false,
	"editableTitle": undefined,
};

class Column extends CoreFeature{

	constructor(def, parent){
		super(parent.table);

		this.definition = def; //column definition
		this.parent = parent; //hold parent object
		this.type = "column"; //type of element
		this.columns = []; //child columns
		this.cells = []; //cells bound to this column
		this.element = this.createElement(); //column header element
		this.contentElement = false;
		this.titleHolderElement = false;
		this.titleElement = false;
		this.groupElement = this.createGroupElement(); //column group holder element
		this.isGroup = false;
		this.hozAlign = ""; //horizontal text alignment
		this.vertAlign = ""; //vert text alignment

		//multi dimensional filed handling
		this.field ="";
		this.fieldStructure = "";
		this.getFieldValue = "";
		this.setFieldValue = "";

		this.titleDownload = null;
		this.titleFormatterRendered = false;

		this.mapDefinitions();

		this.setField(this.definition.field);

		this.modules = {}; //hold module variables;

		this.width = null; //column width
		this.widthStyled = ""; //column width pre-styled to improve render efficiency
		this.maxWidth = null; //column maximum width
		this.maxWidthStyled = ""; //column maximum pre-styled to improve render efficiency
		this.maxInitialWidth = null;
		this.minWidth = null; //column minimum width
		this.minWidthStyled = ""; //column minimum pre-styled to improve render efficiency
		this.widthFixed = false; //user has specified a width for this column

		this.visible = true; //default visible state

		this.component = null;

		//initialize column
		if(this.definition.columns){

			this.isGroup = true;

			this.definition.columns.forEach((def, i) => {
				var newCol = new Column(def, this);
				this.attachColumn(newCol);
			});

			this.checkColumnVisibility();
		}else {
			parent.registerColumnField(this);
		}

		this._initialize();
	}

	createElement (){
		var el = document.createElement("div");

		el.classList.add("tabulator-col");
		el.setAttribute("role", "columnheader");
		el.setAttribute("aria-sort", "none");

		switch(this.table.options.columnHeaderVertAlign){
			case "middle":
				el.style.justifyContent = "center";
				break;
			case "bottom":
				el.style.justifyContent = "flex-end";
				break;
		}

		return el;
	}

	createGroupElement (){
		var el = document.createElement("div");

		el.classList.add("tabulator-col-group-cols");

		return el;
	}

	mapDefinitions(){
		var defaults = this.table.options.columnDefaults;

		//map columnDefaults onto column definitions
		if(defaults){
			for(let key in defaults){
				if(typeof this.definition[key] === "undefined"){
					this.definition[key] = defaults[key];
				}
			}
		}

		this.definition = this.table.columnManager.optionsList.generate(Column.defaultOptionList, this.definition);
	}

	checkDefinition(){
		Object.keys(this.definition).forEach((key) => {
			if(Column.defaultOptionList.indexOf(key) === -1){
				console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", key);
			}
		});
	}

	setField(field){
		this.field = field;
		this.fieldStructure = field ? (this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator) : [field]) : [];
		this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData;
		this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
	}

	//register column position with column manager
	registerColumnPosition(column){
		this.parent.registerColumnPosition(column);
	}

	//register column position with column manager
	registerColumnField(column){
		this.parent.registerColumnField(column);
	}

	//trigger position registration
	reRegisterPosition(){
		if(this.isGroup){
			this.columns.forEach(function(column){
				column.reRegisterPosition();
			});
		}else {
			this.registerColumnPosition(this);
		}
	}

	//build header element
	_initialize(){
		var def = this.definition;

		while(this.element.firstChild) this.element.removeChild(this.element.firstChild);

		if(def.headerVertical){
			this.element.classList.add("tabulator-col-vertical");

			if(def.headerVertical === "flip"){
				this.element.classList.add("tabulator-col-vertical-flip");
			}
		}

		this.contentElement = this._buildColumnHeaderContent();

		this.element.appendChild(this.contentElement);

		if(this.isGroup){
			this._buildGroupHeader();
		}else {
			this._buildColumnHeader();
		}

		this.dispatch("column-init", this);
	}

	//build header element for header
	_buildColumnHeader(){
		var def = this.definition;

		this.dispatch("column-layout", this);

		//set column visibility
		if(typeof def.visible != "undefined"){
			if(def.visible){
				this.show(true);
			}else {
				this.hide(true);
			}
		}

		//assign additional css classes to column header
		if(def.cssClass){
			var classNames = def.cssClass.split(" ");
			classNames.forEach((className) => {
				this.element.classList.add(className);
			});
		}

		if(def.field){
			this.element.setAttribute("tabulator-field", def.field);
		}

		//set min width if present
		this.setMinWidth(parseInt(def.minWidth));

		if (def.maxInitialWidth) {
			this.maxInitialWidth = parseInt(def.maxInitialWidth);
		}
		
		if(def.maxWidth){
			this.setMaxWidth(parseInt(def.maxWidth));
		}

		this.reinitializeWidth();

		//set horizontal text alignment
		this.hozAlign = this.definition.hozAlign;
		this.vertAlign = this.definition.vertAlign;

		this.titleElement.style.textAlign = this.definition.headerHozAlign;
	}

	_buildColumnHeaderContent(){
		var contentElement = document.createElement("div");
		contentElement.classList.add("tabulator-col-content");

		this.titleHolderElement = document.createElement("div");
		this.titleHolderElement.classList.add("tabulator-col-title-holder");

		contentElement.appendChild(this.titleHolderElement);

		this.titleElement = this._buildColumnHeaderTitle();

		this.titleHolderElement.appendChild(this.titleElement);

		return contentElement;
	}

	//build title element of column
	_buildColumnHeaderTitle(){
		var def = this.definition;

		var titleHolderElement = document.createElement("div");
		titleHolderElement.classList.add("tabulator-col-title");
		
		if(def.headerWordWrap){
			titleHolderElement.classList.add("tabulator-col-title-wrap");
		}

		if(def.editableTitle){
			var titleElement = document.createElement("input");
			titleElement.classList.add("tabulator-title-editor");

			titleElement.addEventListener("click", (e) => {
				e.stopPropagation();
				titleElement.focus();
			});

			titleElement.addEventListener("mousedown", (e) => {
				e.stopPropagation();
			});

			titleElement.addEventListener("change", () => {
				def.title = titleElement.value;
				this.dispatchExternal("columnTitleChanged", this.getComponent());
			});

			titleHolderElement.appendChild(titleElement);

			if(def.field){
				this.langBind("columns|" + def.field, (text) => {
					titleElement.value = text || (def.title || "&nbsp;");
				});
			}else {
				titleElement.value  = def.title || "&nbsp;";
			}

		}else {
			if(def.field){
				this.langBind("columns|" + def.field, (text) => {
					this._formatColumnHeaderTitle(titleHolderElement, text || (def.title || "&nbsp;"));
				});
			}else {
				this._formatColumnHeaderTitle(titleHolderElement, def.title || "&nbsp;");
			}
		}

		return titleHolderElement;
	}

	_formatColumnHeaderTitle(el, title){
		var contents = this.chain("column-format", [this, title, el], null, () => {
			return title;
		});

		switch(typeof contents){
			case "object":
				if(contents instanceof Node){
					el.appendChild(contents);
				}else {
					el.innerHTML = "";
					console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", contents);
				}
				break;
			case "undefined":
				el.innerHTML = "";
				break;
			default:
				el.innerHTML = contents;
		}
	}

	//build header element for column group
	_buildGroupHeader(){
		this.element.classList.add("tabulator-col-group");
		this.element.setAttribute("role", "columngroup");
		this.element.setAttribute("aria-title", this.definition.title);

		//asign additional css classes to column header
		if(this.definition.cssClass){
			var classNames = this.definition.cssClass.split(" ");
			classNames.forEach((className) => {
				this.element.classList.add(className);
			});
		}

		this.titleElement.style.textAlign = this.definition.headerHozAlign;

		this.element.appendChild(this.groupElement);
	}

	//flat field lookup
	_getFlatData(data){
		return data[this.field];
	}

	//nested field lookup
	_getNestedData(data){
		var dataObj = data,
		structure = this.fieldStructure,
		length = structure.length,
		output;

		for(let i = 0; i < length; i++){

			dataObj = dataObj[structure[i]];

			output = dataObj;

			if(!dataObj){
				break;
			}
		}

		return output;
	}

	//flat field set
	_setFlatData(data, value){
		if(this.field){
			data[this.field] = value;
		}
	}

	//nested field set
	_setNestedData(data, value){
		var dataObj = data,
		structure = this.fieldStructure,
		length = structure.length;

		for(let i = 0; i < length; i++){

			if(i == length -1){
				dataObj[structure[i]] = value;
			}else {
				if(!dataObj[structure[i]]){
					if(typeof value !== "undefined"){
						dataObj[structure[i]] = {};
					}else {
						break;
					}
				}

				dataObj = dataObj[structure[i]];
			}
		}
	}

	//attach column to this group
	attachColumn(column){
		if(this.groupElement){
			this.columns.push(column);
			this.groupElement.appendChild(column.getElement());

			column.columnRendered();
		}else {
			console.warn("Column Warning - Column being attached to another column instead of column group");
		}
	}

	//vertically align header in column
	verticalAlign(alignment, height){

		//calculate height of column header and group holder element
		var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : (height || this.parent.getHeadersElement().clientHeight);
		// var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : this.parent.getHeadersElement().clientHeight;

		this.element.style.height = parentHeight + "px";

		this.dispatch("column-height", this, this.element.style.height);

		if(this.isGroup){
			this.groupElement.style.minHeight = (parentHeight - this.contentElement.offsetHeight) + "px";
		}

		//vertically align cell contents
		// if(!this.isGroup && alignment !== "top"){
		// 	if(alignment === "bottom"){
		// 		this.element.style.paddingTop = (this.element.clientHeight - this.contentElement.offsetHeight) + "px";
		// 	}else{
		// 		this.element.style.paddingTop = ((this.element.clientHeight - this.contentElement.offsetHeight) / 2) + "px";
		// 	}
		// }

		this.columns.forEach(function(column){
			column.verticalAlign(alignment);
		});
	}

	//clear vertical alignment
	clearVerticalAlign(){
		this.element.style.paddingTop = "";
		this.element.style.height = "";
		this.element.style.minHeight = "";
		this.groupElement.style.minHeight = "";

		this.columns.forEach(function(column){
			column.clearVerticalAlign();
		});

		this.dispatch("column-height", this, "");
	}

	//// Retrieve Column Information ////
	//return column header element
	getElement(){
		return this.element;
	}

	//return column group element
	getGroupElement(){
		return this.groupElement;
	}

	//return field name
	getField(){
		return this.field;
	}

	getTitleDownload() {
		return this.titleDownload;
	}

	//return the first column in a group
	getFirstColumn(){
		if(!this.isGroup){
			return this;
		}else {
			if(this.columns.length){
				return this.columns[0].getFirstColumn();
			}else {
				return false;
			}
		}
	}

	//return the last column in a group
	getLastColumn(){
		if(!this.isGroup){
			return this;
		}else {
			if(this.columns.length){
				return this.columns[this.columns.length -1].getLastColumn();
			}else {
				return false;
			}
		}
	}

	//return all columns in a group
	getColumns(traverse){
		var columns = [];

		if(traverse){
			this.columns.forEach((column) => {
				columns.push(column);
					
				columns = columns.concat(column.getColumns(true));
			});
		}else {
			columns = this.columns;
		}
		
		return columns;
	}

	//return all columns in a group
	getCells(){
		return this.cells;
	}

	//retrieve the top column in a group of columns
	getTopColumn(){
		if(this.parent.isGroup){
			return this.parent.getTopColumn();
		}else {
			return this;
		}
	}

	//return column definition object
	getDefinition(updateBranches){
		var colDefs = [];

		if(this.isGroup && updateBranches){
			this.columns.forEach(function(column){
				colDefs.push(column.getDefinition(true));
			});

			this.definition.columns = colDefs;
		}

		return this.definition;
	}

	//////////////////// Actions ////////////////////
	checkColumnVisibility(){
		var visible = false;

		this.columns.forEach(function(column){
			if(column.visible){
				visible = true;
			}
		});

		if(visible){
			this.show();
			this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
		}else {
			this.hide();
		}
	}

	//show column
	show(silent, responsiveToggle){
		if(!this.visible){
			this.visible = true;

			this.element.style.display = "";

			if(this.parent.isGroup){
				this.parent.checkColumnVisibility();
			}

			this.cells.forEach(function(cell){
				cell.show();
			});

			if(!this.isGroup && this.width === null){
				this.reinitializeWidth();
			}

			this.table.columnManager.verticalAlignHeaders();

			this.dispatch("column-show", this, responsiveToggle);

			if(!silent){
				this.dispatchExternal("columnVisibilityChanged", this.getComponent(), true);
			}

			if(this.parent.isGroup){
				this.parent.matchChildWidths();
			}

			if(!this.silent){
				this.table.columnManager.rerenderColumns();
			}
		}
	}

	//hide column
	hide(silent, responsiveToggle){
		if(this.visible){
			this.visible = false;

			this.element.style.display = "none";

			this.table.columnManager.verticalAlignHeaders();

			if(this.parent.isGroup){
				this.parent.checkColumnVisibility();
			}

			this.cells.forEach(function(cell){
				cell.hide();
			});

			this.dispatch("column-hide", this, responsiveToggle);

			if(!silent){
				this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
			}

			if(this.parent.isGroup){
				this.parent.matchChildWidths();
			}

			if(!this.silent){
				this.table.columnManager.rerenderColumns();
			}
		}
	}

	matchChildWidths(){
		var childWidth = 0;

		if(this.contentElement && this.columns.length){
			this.columns.forEach(function(column){
				if(column.visible){
					childWidth += column.getWidth();
				}
			});

			this.contentElement.style.maxWidth = (childWidth - 1) + "px";

			if(this.parent.isGroup){
				this.parent.matchChildWidths();
			}
		}
	}

	removeChild(child){
		var index = this.columns.indexOf(child);

		if(index > -1){
			this.columns.splice(index, 1);
		}

		if(!this.columns.length){
			this.delete();
		}
	}

	setWidth(width){
		this.widthFixed = true;
		this.setWidthActual(width);
	}

	setWidthActual(width){
		if(isNaN(width)){
			width = Math.floor((this.table.element.clientWidth/100) * parseInt(width));
		}

		width = Math.max(this.minWidth, width);

		if(this.maxWidth){
			width = Math.min(this.maxWidth, width);
		}

		this.width = width;
		this.widthStyled = width ? width + "px" : "";

		this.element.style.width = this.widthStyled;

		if(!this.isGroup){
			this.cells.forEach(function(cell){
				cell.setWidth();
			});
		}

		if(this.parent.isGroup){
			this.parent.matchChildWidths();
		}

		this.dispatch("column-width", this);
	}

	checkCellHeights(){
		var rows = [];

		this.cells.forEach(function(cell){
			if(cell.row.heightInitialized){
				if(cell.row.getElement().offsetParent !== null){
					rows.push(cell.row);
					cell.row.clearCellHeight();
				}else {
					cell.row.heightInitialized = false;
				}
			}
		});

		rows.forEach(function(row){
			row.calcHeight();
		});

		rows.forEach(function(row){
			row.setCellHeight();
		});
	}

	getWidth(){
		var width = 0;

		if(this.isGroup){
			this.columns.forEach(function(column){
				if(column.visible){
					width += column.getWidth();
				}
			});
		}else {
			width = this.width;
		}

		return width;
	}

	getLeftOffset(){
		var offset = this.element.offsetLeft;

		if(this.parent.isGroup){
			offset += this.parent.getLeftOffset();
		}

		return offset;
	}

	getHeight(){
		return Math.ceil(this.element.getBoundingClientRect().height);
	}

	setMinWidth(minWidth){
		if(this.maxWidth && minWidth > this.maxWidth){
			minWidth = this.maxWidth;

			console.warn("the minWidth ("+ minWidth + "px) for column '" + this.field + "' cannot be bigger that its maxWidth ("+ this.maxWidthStyled + ")");
		}

		this.minWidth = minWidth;
		this.minWidthStyled = minWidth ? minWidth + "px" : "";

		this.element.style.minWidth = this.minWidthStyled;

		this.cells.forEach(function(cell){
			cell.setMinWidth();
		});
	}

	setMaxWidth(maxWidth){
		if(this.minWidth && maxWidth < this.minWidth){
			maxWidth = this.minWidth;

			console.warn("the maxWidth ("+ maxWidth + "px) for column '" + this.field + "' cannot be smaller that its minWidth ("+ this.minWidthStyled + ")");
		}

		this.maxWidth = maxWidth;
		this.maxWidthStyled = maxWidth ? maxWidth + "px" : "";

		this.element.style.maxWidth = this.maxWidthStyled;

		this.cells.forEach(function(cell){
			cell.setMaxWidth();
		});
	}

	delete(){
		return new Promise((resolve, reject) => {
			if(this.isGroup){
				this.columns.forEach(function(column){
					column.delete();
				});
			}

			this.dispatch("column-delete", this);

			var cellCount = this.cells.length;

			for(let i = 0; i < cellCount; i++){
				this.cells[0].delete();
			}

			if(this.element.parentNode){
				this.element.parentNode.removeChild(this.element);
			}

			this.element = false;
			this.contentElement = false;
			this.titleElement = false;
			this.groupElement = false;

			if(this.parent.isGroup){
				this.parent.removeChild(this);
			}

			this.table.columnManager.deregisterColumn(this);

			this.table.columnManager.rerenderColumns(true);

			this.dispatch("column-deleted", this);

			resolve();
		});
	}

	columnRendered(){
		if(this.titleFormatterRendered){
			this.titleFormatterRendered();
		}

		this.dispatch("column-rendered", this);
	}

	//////////////// Cell Management /////////////////
	//generate cell for this column
	generateCell(row){
		var cell = new Cell(this, row);

		this.cells.push(cell);

		return cell;
	}

	nextColumn(){
		var index = this.table.columnManager.findColumnIndex(this);
		return index > -1 ? this._nextVisibleColumn(index + 1) : false;
	}

	_nextVisibleColumn(index){
		var column = this.table.columnManager.getColumnByIndex(index);
		return !column || column.visible ? column : this._nextVisibleColumn(index + 1);
	}

	prevColumn(){
		var index = this.table.columnManager.findColumnIndex(this);
		return index > -1 ? this._prevVisibleColumn(index - 1) : false;
	}

	_prevVisibleColumn(index){
		var column = this.table.columnManager.getColumnByIndex(index);
		return !column || column.visible ? column : this._prevVisibleColumn(index - 1);
	}

	reinitializeWidth(force){
		this.widthFixed = false;

		//set width if present
		if(typeof this.definition.width !== "undefined" && !force){
			// maxInitialWidth ignored here as width specified
			this.setWidth(this.definition.width);
		}

		this.dispatch("column-width-fit-before", this);

		this.fitToData(force);

		this.dispatch("column-width-fit-after", this);
	}

	//set column width to maximum cell width for non group columns
	fitToData(force){
		if(this.isGroup){
			return;
		}

		if(!this.widthFixed){
			this.element.style.width = "";

			this.cells.forEach((cell) => {
				cell.clearWidth();
			});
		}

		var maxWidth = this.element.offsetWidth;

		if(!this.width || !this.widthFixed){
			this.cells.forEach((cell) => {
				var width = cell.getWidth();

				if(width > maxWidth){
					maxWidth = width;
				}
			});

			if(maxWidth){
				var setTo = maxWidth + 1;
				if (this.maxInitialWidth && !force) {
					setTo = Math.min(setTo, this.maxInitialWidth);
				}
				this.setWidthActual(setTo);
			}
		}
	}

	updateDefinition(updates){
		var definition;

		if(!this.isGroup){
			if(!this.parent.isGroup){
				definition = Object.assign({}, this.getDefinition());
				definition = Object.assign(definition, updates);

				return this.table.columnManager.addColumn(definition, false, this)
					.then((column) => {

						if(definition.field == this.field){
							this.field = false; //clear field name to prevent deletion of duplicate column from arrays
						}

						return this.delete()
							.then(() => {
								return column.getComponent();
							});

					});
			}else {
				console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
				return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
			}
		}else {
			console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
			return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
		}
	}

	deleteCell(cell){
		var index = this.cells.indexOf(cell);

		if(index > -1){
			this.cells.splice(index, 1);
		}
	}

	//////////////// Object Generation /////////////////
	getComponent(){
		if(!this.component){
			this.component = new ColumnComponent(this);
		}

		return this.component;
	}

	getPosition(){
		return this.table.columnManager.getVisibleColumnsByIndex().indexOf(this) + 1;
	}
}

Column.defaultOptionList = defaultColumnOptions;

//public row object
class RowComponent {

	constructor (row){
		this._row = row;

		return new Proxy(this, {
			get: function(target, name, receiver) {
				if (typeof target[name] !== "undefined") {
					return target[name];
				}else {
					return target._row.table.componentFunctionBinder.handle("row", target._row, name);
				}
			}
		});
	}

	getData(transform){
		return this._row.getData(transform);
	}

	getElement(){
		return this._row.getElement();
	}

	getCells(){
		var cells = [];

		this._row.getCells().forEach(function(cell){
			cells.push(cell.getComponent());
		});

		return cells;
	}

	getCell(column){
		var cell = this._row.getCell(column);
		return cell ? cell.getComponent() : false;
	}

	getIndex(){
		return this._row.getData("data")[this._row.table.options.index];
	}

	getPosition(){
		return this._row.getPosition();
	}

	watchPosition(callback){
		return this._row.watchPosition(callback);
	}

	delete(){
		return this._row.delete();
	}

	scrollTo(position, ifVisible){
		return this._row.table.rowManager.scrollToRow(this._row, position, ifVisible);
	}

	move(to, after){
		this._row.moveToRow(to, after);
	}

	update(data){
		return this._row.updateData(data);
	}

	normalizeHeight(){
		this._row.normalizeHeight(true);
	}

	_getSelf(){
		return this._row;
	}

	reformat(){
		return this._row.reinitialize();
	}

	getTable(){
		return this._row.table;
	}

	getNextRow(){
		var row = this._row.nextRow();
		return row ? row.getComponent() : row;
	}

	getPrevRow(){
		var row = this._row.prevRow();
		return row ? row.getComponent() : row;
	}
}

class Row extends CoreFeature{
	constructor (data, parent, type = "row"){
		super(parent.table);
		
		this.parent = parent;
		this.data = {};
		this.type = type; //type of element
		this.element = false;
		this.modules = {}; //hold module variables;
		this.cells = [];
		this.height = 0; //hold element height
		this.heightStyled = ""; //hold element height pre-styled to improve render efficiency
		this.manualHeight = false; //user has manually set row height
		this.outerHeight = 0; //hold elements outer height
		this.initialized = false; //element has been rendered
		this.heightInitialized = false; //element has resized cells to fit
		this.position = 0; //store position of element in row list
		this.positionWatchers = [];
		
		this.component = null;
		
		this.created = false;
		
		this.setData(data);
	}
	
	create(){
		if(!this.created){
			this.created = true;
			this.generateElement();
		}
	}
	
	createElement (){
		var el = document.createElement("div");
		
		el.classList.add("tabulator-row");
		el.setAttribute("role", "row");
		
		this.element = el;
	}
	
	getElement(){
		this.create();
		return this.element;
	}
	
	detachElement(){
		if (this.element && this.element.parentNode){
			this.element.parentNode.removeChild(this.element);
		}
	}
	
	generateElement(){
		this.createElement();
		this.dispatch("row-init", this);
	}
	
	generateCells(){
		this.cells = this.table.columnManager.generateCells(this);
	}
	
	//functions to setup on first render
	initialize(force, inFragment){
		this.create();
		
		if(!this.initialized || force){
			
			this.deleteCells();
			
			while(this.element.firstChild) this.element.removeChild(this.element.firstChild);
			
			this.dispatch("row-layout-before", this);
			
			this.generateCells();
			
			this.initialized = true;
			
			this.table.columnManager.renderer.renderRowCells(this, inFragment);
			
			if(force){
				this.normalizeHeight();
			}
			
			this.dispatch("row-layout", this);
			
			if(this.table.options.rowFormatter){
				this.table.options.rowFormatter(this.getComponent());
			}
			
			this.dispatch("row-layout-after", this);
		}else {
			this.table.columnManager.renderer.rerenderRowCells(this, inFragment);
		}
	}

	rendered(){
		this.cells.forEach((cell) => {
			cell.cellRendered();
		});
	}
	
	reinitializeHeight(){
		this.heightInitialized = false;
		
		if(this.element && this.element.offsetParent !== null){
			this.normalizeHeight(true);
		}
	}

	deinitialize(){
		this.initialized = false;
	}
	
	deinitializeHeight(){
		this.heightInitialized = false;
	}
	
	reinitialize(children){
		this.initialized = false;
		this.heightInitialized = false;
		
		if(!this.manualHeight){
			this.height = 0;
			this.heightStyled = "";
		}
		
		if(this.element && this.element.offsetParent !== null){
			this.initialize(true);
		}
		
		this.dispatch("row-relayout", this);
	}
	
	//get heights when doing bulk row style calcs in virtual DOM
	calcHeight(force){
		var maxHeight = 0,
		minHeight;
		
		if(this.table.options.rowHeight){
			this.height = this.table.options.rowHeight;
		}else {
			minHeight = this.table.options.resizableRows ? this.element.clientHeight : 0;
			
			this.cells.forEach(function(cell){
				var height = cell.getHeight();
				if(height > maxHeight){
					maxHeight = height;
				}
			});
			
			if(force){
				this.height = Math.max(maxHeight, minHeight);
			}else {
				this.height = this.manualHeight ? this.height : Math.max(maxHeight, minHeight);
			}
		}
		
		this.heightStyled = this.height ? this.height + "px" : "";
		this.outerHeight = this.element.offsetHeight;
	}
	
	//set of cells
	setCellHeight(){
		this.cells.forEach(function(cell){
			cell.setHeight();
		});
		
		this.heightInitialized = true;
	}
	
	clearCellHeight(){
		this.cells.forEach(function(cell){
			cell.clearHeight();
		});
	}
	
	//normalize the height of elements in the row
	normalizeHeight(force){
		if(force && !this.table.options.rowHeight){
			this.clearCellHeight();
		}
		
		this.calcHeight(force);
		
		this.setCellHeight();
	}
	
	//set height of rows
	setHeight(height, force){
		if(this.height != height || force){
			
			this.manualHeight = true;
			
			this.height = height;
			this.heightStyled = height ? height + "px" : "";
			
			this.setCellHeight();
			
			// this.outerHeight = this.element.outerHeight();
			this.outerHeight = this.element.offsetHeight;
		}
	}
	
	//return rows outer height
	getHeight(){
		return this.outerHeight;
	}
	
	//return rows outer Width
	getWidth(){
		return this.element.offsetWidth;
	}
	
	//////////////// Cell Management /////////////////
	deleteCell(cell){
		var index = this.cells.indexOf(cell);
		
		if(index > -1){
			this.cells.splice(index, 1);
		}
	}
	
	//////////////// Data Management /////////////////
	setData(data){
		this.data = this.chain("row-data-init-before", [this, data], undefined, data);
		
		this.dispatch("row-data-init-after", this);
	}
	
	//update the rows data
	updateData(updatedData){
		var visible = this.element && Helpers.elVisible(this.element),
		tempData = {},
		newRowData;
		
		return new Promise((resolve, reject) => {
			
			if(typeof updatedData === "string"){
				updatedData = JSON.parse(updatedData);
			}
			
			this.dispatch("row-data-save-before", this);
			
			if(this.subscribed("row-data-changing")){
				tempData = Object.assign(tempData, this.data);
				tempData = Object.assign(tempData, updatedData);
			}
			
			newRowData = this.chain("row-data-changing", [this, tempData, updatedData], null, updatedData);
			
			//set data
			for (let attrname in newRowData) {
				this.data[attrname] = newRowData[attrname];
			}
			
			this.dispatch("row-data-save-after", this);
			
			//update affected cells only
			for (let attrname in updatedData) {
				
				let columns = this.table.columnManager.getColumnsByFieldRoot(attrname);
				
				columns.forEach((column) => {
					let cell = this.getCell(column.getField());
					
					if(cell){
						let value = column.getFieldValue(newRowData);
						if(cell.getValue() !== value){
							cell.setValueProcessData(value);
							
							if(visible){
								cell.cellRendered();
							}
						}
					}
				});
			}
			
			//Partial reinitialization if visible
			if(visible){
				this.normalizeHeight(true);
				
				if(this.table.options.rowFormatter){
					this.table.options.rowFormatter(this.getComponent());
				}
			}else {
				this.initialized = false;
				this.height = 0;
				this.heightStyled = "";
			}
			
			this.dispatch("row-data-changed", this, visible, updatedData);
			
			//this.reinitialize();
			
			this.dispatchExternal("rowUpdated", this.getComponent());
			
			if(this.subscribedExternal("dataChanged")){
				this.dispatchExternal("dataChanged", this.table.rowManager.getData());
			}
			
			resolve();
		});
	}
	
	getData(transform){
		if(transform){
			return this.chain("row-data-retrieve", [this, transform], null, this.data);
		}
		
		return this.data;
	}
	
	getCell(column){
		var match = false;
		
		column = this.table.columnManager.findColumn(column);
		
		if(!this.initialized && this.cells.length === 0){
			this.generateCells();
		}
		
		match = this.cells.find(function(cell){
			return cell.column === column;
		});
		
		return match;
	}
	
	getCellIndex(findCell){
		return this.cells.findIndex(function(cell){
			return cell === findCell;
		});
	}
	
	findCell(subject){
		return this.cells.find((cell) => {
			return cell.element === subject;
		});
	}
	
	getCells(){
		if(!this.initialized && this.cells.length === 0){
			this.generateCells();
		}
		
		return this.cells;
	}
	
	nextRow(){
		var row = this.table.rowManager.nextDisplayRow(this, true);
		return row || false;
	}
	
	prevRow(){
		var row = this.table.rowManager.prevDisplayRow(this, true);
		return row || false;
	}
	
	moveToRow(to, before){
		var toRow = this.table.rowManager.findRow(to);
		
		if(toRow){
			this.table.rowManager.moveRowActual(this, toRow, !before);
			this.table.rowManager.refreshActiveData("display", false, true);
		}else {
			console.warn("Move Error - No matching row found:", to);
		}
	}
	
	///////////////////// Actions  /////////////////////
	delete(){
		this.dispatch("row-delete", this);
		
		this.deleteActual();
		
		return Promise.resolve();
	}
	
	deleteActual(blockRedraw){
		this.detachModules();
		
		this.table.rowManager.deleteRow(this, blockRedraw);
		
		this.deleteCells();
		
		this.initialized = false;
		this.heightInitialized = false;
		this.element = false;
		
		this.dispatch("row-deleted", this);
	}
	
	detachModules(){
		this.dispatch("row-deleting", this);
	}
	
	deleteCells(){
		var cellCount = this.cells.length;
		
		for(let i = 0; i < cellCount; i++){
			this.cells[0].delete();
		}
	}
	
	wipe(){
		this.detachModules();
		this.deleteCells();
		
		if(this.element){
			while(this.element.firstChild) this.element.removeChild(this.element.firstChild);
			
			if(this.element.parentNode){
				this.element.parentNode.removeChild(this.element);
			}
		}
		
		this.element = false;
		this.modules = {};
	}

	isDisplayed(){
		return this.table.rowManager.getDisplayRows().includes(this);
	}

	getPosition(){
		return this.isDisplayed() ? this.position : false;
	}

	setPosition(position){
		if(position != this.position){
			this.position = position;

			this.positionWatchers.forEach((callback) => {
				callback(this.position);
			});
		}
	}

	watchPosition(callback){
		this.positionWatchers.push(callback);

		callback(this.position);
	}
	
	getGroup(){
		return this.modules.group || false;
	}
	
	//////////////// Object Generation /////////////////
	getComponent(){
		if(!this.component){
			this.component = new RowComponent(this);
		}
		
		return this.component;
	}
}

var defaultCalculations = {
	"avg":function(values, data, calcParams){
		var output = 0,
		precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : 2;

		if(values.length){
			output = values.reduce(function(sum, value){
				return Number(sum) + Number(value);
			});

			output = output / values.length;

			output = precision !== false ? output.toFixed(precision) : output;
		}

		return parseFloat(output).toString();
	},
	"max":function(values, data, calcParams){
		var output = null,
		precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;

		values.forEach(function(value){

			value = Number(value);

			if(value > output || output === null){
				output = value;
			}
		});

		return output !== null ? (precision !== false ? output.toFixed(precision) : output) : "";
	},
	"min":function(values, data, calcParams){
		var output = null,
		precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;

		values.forEach(function(value){

			value = Number(value);

			if(value < output || output === null){
				output = value;
			}
		});

		return output !== null ? (precision !== false ? output.toFixed(precision) : output) : "";
	},
	"sum":function(values, data, calcParams){
		var output = 0,
		precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;

		if(values.length){
			values.forEach(function(value){
				value = Number(value);

				output += !isNaN(value) ? Number(value) : 0;
			});
		}

		return precision !== false ? output.toFixed(precision) : output;
	},
	"concat":function(values, data, calcParams){
		var output = 0;

		if(values.length){
			output = values.reduce(function(sum, value){
				return String(sum) + String(value);
			});
		}

		return output;
	},
	"count":function(values, data, calcParams){
		var output = 0;

		if(values.length){
			values.forEach(function(value){
				if(value){
					output ++;
				}
			});
		}

		return output;
	},
	"unique":function(values, data, calcParams){
		var unique = values.filter((value, index) => {
			return (values || value === 0) && values.indexOf(value) === index;
		});

		return unique.length;
	},
};

class ColumnCalcs extends Module{
	
	constructor(table){
		super(table);
		
		this.topCalcs = [];
		this.botCalcs = [];
		this.genColumn = false;
		this.topElement = this.createElement();
		this.botElement = this.createElement();
		this.topRow = false;
		this.botRow = false;
		this.topInitialized = false;
		this.botInitialized = false;
		
		this.blocked = false;
		this.recalcAfterBlock = false;
		
		this.registerTableOption("columnCalcs", true);
		
		this.registerColumnOption("topCalc");
		this.registerColumnOption("topCalcParams");
		this.registerColumnOption("topCalcFormatter");
		this.registerColumnOption("topCalcFormatterParams");
		this.registerColumnOption("bottomCalc");
		this.registerColumnOption("bottomCalcParams");
		this.registerColumnOption("bottomCalcFormatter");
		this.registerColumnOption("bottomCalcFormatterParams");
	}
	
	createElement (){
		var el = document.createElement("div");
		el.classList.add("tabulator-calcs-holder");
		return el;
	}
	
	initialize(){
		this.genColumn = new Column({field:"value"}, this);
		
		this.subscribe("cell-value-changed", this.cellValueChanged.bind(this));
		this.subscribe("column-init", this.initializeColumnCheck.bind(this));
		this.subscribe("row-deleted", this.rowsUpdated.bind(this));
		this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
		this.subscribe("row-added", this.rowsUpdated.bind(this));
		this.subscribe("column-moved", this.recalcActiveRows.bind(this));
		this.subscribe("column-add", this.recalcActiveRows.bind(this));
		this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this));
		this.subscribe("table-redraw", this.tableRedraw.bind(this));
		this.subscribe("rows-visible", this.visibleRows.bind(this));
		this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
		
		this.subscribe("redraw-blocked", this.blockRedraw.bind(this));
		this.subscribe("redraw-restored", this.restoreRedraw.bind(this));

		this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this));
		this.subscribe("column-resized", this.resizeHolderWidth.bind(this));
		this.subscribe("column-show", this.resizeHolderWidth.bind(this));
		this.subscribe("column-hide", this.resizeHolderWidth.bind(this));
		
		this.registerTableFunction("getCalcResults", this.getResults.bind(this));
		this.registerTableFunction("recalc", this.userRecalc.bind(this));


		this.resizeHolderWidth();
	}

	resizeHolderWidth(){
		this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
	}

	
	tableRedraw(force){
		this.recalc(this.table.rowManager.activeRows);
		
		if(force){
			this.redraw();
		}
	}
	
	blockRedraw(){
		this.blocked = true;
		this.recalcAfterBlock = false;
	}
	
	
	restoreRedraw(){
		this.blocked = false;
		
		if(this.recalcAfterBlock){
			this.recalcAfterBlock = false;
			this.recalcActiveRowsRefresh();
		}
	}
	
	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////
	userRecalc(){
		this.recalc(this.table.rowManager.activeRows);
	}
	
	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////
	
	blockCheck(){
		if(this.blocked){
			this.recalcAfterBlock = true;
		}
		
		return this.blocked;
	}
	
	visibleRows(viewable, rows){
		if(this.topRow){
			rows.unshift(this.topRow);
		}
		
		if(this.botRow){
			rows.push(this.botRow);
		}
		
		return rows;
	}
	
	rowsUpdated(row){
		if(this.table.options.groupBy){
			this.recalcRowGroup(row);
		}else {
			this.recalcActiveRows();
		}
	}
	
	recalcActiveRowsRefresh(){
		if(this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree){
			this.recalcAll();
		}else {
			this.recalcActiveRows();
		}
	}
	
	recalcActiveRows(){
		this.recalc(this.table.rowManager.activeRows);
	}
	
	cellValueChanged(cell){
		if(cell.column.definition.topCalc || cell.column.definition.bottomCalc){
			if(this.table.options.groupBy){
				if(this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both"){
					this.recalcActiveRows();
				}
				
				if(this.table.options.columnCalcs != "table"){
					this.recalcRowGroup(cell.row);
				}
			}else {
				this.recalcActiveRows();
			}
		}
	}
	
	initializeColumnCheck(column){
		if(column.definition.topCalc || column.definition.bottomCalc){
			this.initializeColumn(column);
		}
	}
	
	//initialize column calcs
	initializeColumn(column){
		var def = column.definition;
		
		var config = {
			topCalcParams:def.topCalcParams || {},
			botCalcParams:def.bottomCalcParams || {},
		};
		
		if(def.topCalc){
			
			switch(typeof def.topCalc){
				case "string":
					if(ColumnCalcs.calculations[def.topCalc]){
						config.topCalc = ColumnCalcs.calculations[def.topCalc];
					}else {
						console.warn("Column Calc Error - No such calculation found, ignoring: ", def.topCalc);
					}
					break;
				
				case "function":
					config.topCalc = def.topCalc;
					break;
				
			}
			
			if(config.topCalc){
				column.modules.columnCalcs = config;
				this.topCalcs.push(column);
				
				if(this.table.options.columnCalcs != "group"){
					this.initializeTopRow();
				}
			}
			
		}
		
		if(def.bottomCalc){
			switch(typeof def.bottomCalc){
				case "string":
					if(ColumnCalcs.calculations[def.bottomCalc]){
						config.botCalc = ColumnCalcs.calculations[def.bottomCalc];
					}else {
						console.warn("Column Calc Error - No such calculation found, ignoring: ", def.bottomCalc);
					}
					break;
				
				case "function":
					config.botCalc = def.bottomCalc;
					break;
				
			}
			
			if(config.botCalc){
				column.modules.columnCalcs = config;
				this.botCalcs.push(column);
				
				if(this.table.options.columnCalcs != "group"){
					this.initializeBottomRow();
				}
			}
		}
		
	}
	
	//dummy functions to handle being mock column manager
	registerColumnField(){}
	
	removeCalcs(){
		var changed = false;
		
		if(this.topInitialized){
			this.topInitialized = false;
			this.topElement.parentNode.removeChild(this.topElement);
			changed = true;
		}
		
		if(this.botInitialized){
			this.botInitialized = false;
			this.footerRemove(this.botElement);
			changed = true;
		}
		
		if(changed){
			this.table.rowManager.adjustTableSize();
		}
	}
	
	reinitializeCalcs(){
		if(this.topCalcs.length){
			this.initializeTopRow();
		}

		if(this.botCalcs.length){
			this.initializeBottomRow();
		}
	}
	
	initializeTopRow(){
		var	fragment = document.createDocumentFragment();
		
		if(!this.topInitialized){

			fragment.appendChild(document.createElement("br"));
			fragment.appendChild(this.topElement);

			this.table.columnManager.getContentsElement().insertBefore(fragment, this.table.columnManager.headersElement.nextSibling);
			this.topInitialized = true;
		}
	}
	
	initializeBottomRow(){
		if(!this.botInitialized){
			this.footerPrepend(this.botElement);
			this.botInitialized = true;
		}
	}
	
	scrollHorizontal(left){
		if(this.botInitialized && this.botRow){
			this.botElement.scrollLeft = left;
		}
	}
	
	recalc(rows){
		var data, row;
		
		if(!this.blockCheck()){
			if(this.topInitialized || this.botInitialized){
				data = this.rowsToData(rows);
				
				if(this.topInitialized){
					if(this.topRow){
						this.topRow.deleteCells();
					}
					
					row = this.generateRow("top", data);
					this.topRow = row;
					while(this.topElement.firstChild) this.topElement.removeChild(this.topElement.firstChild);
					this.topElement.appendChild(row.getElement());
					row.initialize(true);
				}
				
				if(this.botInitialized){
					if(this.botRow){
						this.botRow.deleteCells();
					}
					
					row = this.generateRow("bottom", data);
					this.botRow = row;
					while(this.botElement.firstChild) this.botElement.removeChild(this.botElement.firstChild);
					this.botElement.appendChild(row.getElement());
					row.initialize(true);
				}
				
				this.table.rowManager.adjustTableSize();
				
				//set resizable handles
				if(this.table.modExists("frozenColumns")){
					this.table.modules.frozenColumns.layout();
				}
			}
		}
	}
	
	recalcRowGroup(row){
		this.recalcGroup(this.table.modules.groupRows.getRowGroup(row));
	}
	
	recalcAll(){
		if(this.topCalcs.length || this.botCalcs.length){
			if(this.table.options.columnCalcs !== "group"){
				this.recalcActiveRows();
			}
			
			if(this.table.options.groupBy && this.table.options.columnCalcs !== "table"){
				
				var groups = this.table.modules.groupRows.getChildGroups();
				
				groups.forEach((group) => {
					this.recalcGroup(group);
				});
			}
		}
	}
	
	recalcGroup(group){
		var data, rowData;
		
		if(!this.blockCheck()){
			if(group){
				if(group.calcs){
					if(group.calcs.bottom){
						data = this.rowsToData(group.rows);
						rowData = this.generateRowData("bottom", data);
						
						group.calcs.bottom.updateData(rowData);
						group.calcs.bottom.reinitialize();
					}
					
					if(group.calcs.top){
						data = this.rowsToData(group.rows);
						rowData = this.generateRowData("top", data);
						
						group.calcs.top.updateData(rowData);
						group.calcs.top.reinitialize();
					}
				}
			}
		}
	}
	
	//generate top stats row
	generateTopRow(rows){
		return this.generateRow("top", this.rowsToData(rows));
	}
	//generate bottom stats row
	generateBottomRow(rows){
		return this.generateRow("bottom", this.rowsToData(rows));
	}
	
	rowsToData(rows){
		var data = [];
		
		rows.forEach((row) => {
			data.push(row.getData());
			
			if(this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs){
				if(row.modules.dataTree && row.modules.dataTree.open){
					var children = this.rowsToData(this.table.modules.dataTree.getFilteredTreeChildren(row));
					data = data.concat(children);
				}
			}
		});
		
		return data;
	}
	
	//generate stats row
	generateRow(pos, data){
		var rowData = this.generateRowData(pos, data),
		row;
		
		if(this.table.modExists("mutator")){
			this.table.modules.mutator.disable();
		}
		
		row = new Row(rowData, this, "calc");
		
		if(this.table.modExists("mutator")){
			this.table.modules.mutator.enable();
		}
		
		row.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + pos);
		
		row.component = false;
		
		row.getComponent = () => {
			if(!row.component){
				row.component = new CalcComponent(row);
			}
			
			return row.component;
		};
		
		row.generateCells = () => {
			
			var cells = [];
			
			this.table.columnManager.columnsByIndex.forEach((column) => {
				
				//set field name of mock column
				this.genColumn.setField(column.getField());
				this.genColumn.hozAlign = column.hozAlign;
				
				if(column.definition[pos + "CalcFormatter"] && this.table.modExists("format")){
					this.genColumn.modules.format = {
						formatter: this.table.modules.format.getFormatter(column.definition[pos + "CalcFormatter"]),
						params: column.definition[pos + "CalcFormatterParams"] || {},
					};
				}else {
					this.genColumn.modules.format = {
						formatter: this.table.modules.format.getFormatter("plaintext"),
						params:{}
					};
				}
				
				//ensure css class definition is replicated to calculation cell
				this.genColumn.definition.cssClass = column.definition.cssClass;
				
				//generate cell and assign to correct column
				var cell = new Cell(this.genColumn, row);
				cell.getElement();
				cell.column = column;
				cell.setWidth();
				
				column.cells.push(cell);
				cells.push(cell);
				
				if(!column.visible){
					cell.hide();
				}
			});
			
			row.cells = cells;
		};
		
		return row;
	}
	
	//generate stats row
	generateRowData(pos, data){
		var rowData = {},
		calcs = pos == "top" ? this.topCalcs : this.botCalcs,
		type = pos == "top" ? "topCalc" : "botCalc",
		params, paramKey;
		
		calcs.forEach(function(column){
			var values = [];
			
			if(column.modules.columnCalcs && column.modules.columnCalcs[type]){
				data.forEach(function(item){
					values.push(column.getFieldValue(item));
				});
				
				paramKey = type + "Params";
				params = typeof column.modules.columnCalcs[paramKey] === "function" ? column.modules.columnCalcs[paramKey](values, data) : column.modules.columnCalcs[paramKey];
				
				column.setFieldValue(rowData, column.modules.columnCalcs[type](values, data, params));
			}
		});
		
		return rowData;
	}
	
	hasTopCalcs(){
		return	!!(this.topCalcs.length);
	}
	
	hasBottomCalcs(){
		return	!!(this.botCalcs.length);
	}
	
	//handle table redraw
	redraw(){
		if(this.topRow){
			this.topRow.normalizeHeight(true);
		}
		if(this.botRow){
			this.botRow.normalizeHeight(true);
		}
	}
	
	//return the calculated
	getResults(){
		var results = {},
		groups;
		
		if(this.table.options.groupBy && this.table.modExists("groupRows")){
			groups = this.table.modules.groupRows.getGroups(true);
			
			groups.forEach((group) => {
				results[group.getKey()] = this.getGroupResults(group);
			});
		}else {
			results = {
				top: this.topRow ? this.topRow.getData() : {},
				bottom: this.botRow ? this.botRow.getData() : {},
			};
		}
		
		return results;
	}
	
	//get results from a group
	getGroupResults(group){
		var groupObj = group._getSelf(),
		subGroups = group.getSubGroups(),
		subGroupResults = {},
		results = {};
		
		subGroups.forEach((subgroup) => {
			subGroupResults[subgroup.getKey()] = this.getGroupResults(subgroup);
		});
		
		results = {
			top: groupObj.calcs.top ? groupObj.calcs.top.getData() : {},
			bottom: groupObj.calcs.bottom ? groupObj.calcs.bottom.getData() : {},
			groups: subGroupResults,
		};
		
		return results;
	}
	
	adjustForScrollbar(width){
		if(this.botRow){
			if(this.table.rtl){
				this.botElement.style.paddingLeft = width + "px";
			}else {
				this.botElement.style.paddingRight = width + "px";
			}
		}
	}
}

ColumnCalcs.moduleName = "columnCalcs";

//load defaults
ColumnCalcs.calculations = defaultCalculations;

class DataTree extends Module{

	constructor(table){
		super(table);

		this.indent = 10;
		this.field = "";
		this.collapseEl = null;
		this.expandEl = null;
		this.branchEl = null;
		this.elementField = false;

		this.startOpen = function(){};

		this.registerTableOption("dataTree", false); //enable data tree
		this.registerTableOption("dataTreeFilter", true); //filter child rows
		this.registerTableOption("dataTreeSort", true); //sort child rows
		this.registerTableOption("dataTreeElementColumn", false);
		this.registerTableOption("dataTreeBranchElement", true);//show data tree branch element
		this.registerTableOption("dataTreeChildIndent", 9); //data tree child indent in px
		this.registerTableOption("dataTreeChildField", "_children");//data tre column field to look for child rows
		this.registerTableOption("dataTreeCollapseElement", false);//data tree row collapse element
		this.registerTableOption("dataTreeExpandElement", false);//data tree row expand element
		this.registerTableOption("dataTreeStartExpanded", false);
		this.registerTableOption("dataTreeChildColumnCalcs", false);//include visible data tree rows in column calculations
		this.registerTableOption("dataTreeSelectPropagate", false);//selecting a parent row selects its children

		//register component functions
		this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this));
		this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this));
		this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this));
		this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this));
		this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this));
		this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this));
		this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
	}

	initialize(){
		if(this.table.options.dataTree){
			var dummyEl = null,
			options = this.table.options;

			this.field = options.dataTreeChildField;
			this.indent = options.dataTreeChildIndent;

			if(this.options("movableRows")){
				console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior");
			}

			if(options.dataTreeBranchElement){

				if(options.dataTreeBranchElement === true){
					this.branchEl = document.createElement("div");
					this.branchEl.classList.add("tabulator-data-tree-branch");
				}else {
					if(typeof options.dataTreeBranchElement === "string"){
						dummyEl = document.createElement("div");
						dummyEl.innerHTML = options.dataTreeBranchElement;
						this.branchEl = dummyEl.firstChild;
					}else {
						this.branchEl = options.dataTreeBranchElement;
					}
				}
			}else {
				this.branchEl = document.createElement("div");
				this.branchEl.classList.add("tabulator-data-tree-branch-empty");
			}

			if(options.dataTreeCollapseElement){
				if(typeof options.dataTreeCollapseElement === "string"){
					dummyEl = document.createElement("div");
					dummyEl.innerHTML = options.dataTreeCollapseElement;
					this.collapseEl = dummyEl.firstChild;
				}else {
					this.collapseEl = options.dataTreeCollapseElement;
				}
			}else {
				this.collapseEl = document.createElement("div");
				this.collapseEl.classList.add("tabulator-data-tree-control");
				this.collapseEl.tabIndex = 0;
				this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>";
			}

			if(options.dataTreeExpandElement){
				if(typeof options.dataTreeExpandElement === "string"){
					dummyEl = document.createElement("div");
					dummyEl.innerHTML = options.dataTreeExpandElement;
					this.expandEl = dummyEl.firstChild;
				}else {
					this.expandEl = options.dataTreeExpandElement;
				}
			}else {
				this.expandEl = document.createElement("div");
				this.expandEl.classList.add("tabulator-data-tree-control");
				this.expandEl.tabIndex = 0;
				this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>";
			}


			switch(typeof options.dataTreeStartExpanded){
				case "boolean":
					this.startOpen = function(row, index){
						return options.dataTreeStartExpanded;
					};
					break;

				case "function":
					this.startOpen = options.dataTreeStartExpanded;
					break;

				default:
					this.startOpen = function(row, index){
						return options.dataTreeStartExpanded[index];
					};
					break;
			}

			this.subscribe("row-init", this.initializeRow.bind(this));
			this.subscribe("row-layout-after", this.layoutRow.bind(this));
			this.subscribe("row-deleted", this.rowDelete.bind(this),0);
			this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10);
			this.subscribe("cell-value-updated", this.cellValueChanged.bind(this));
			this.subscribe("edit-cancelled", this.cellValueChanged.bind(this));
			this.subscribe("column-moving-rows", this.columnMoving.bind(this));
			this.subscribe("table-built", this.initializeElementField.bind(this));
			this.subscribe("table-redrawing", this.tableRedrawing.bind(this));

			this.registerDisplayHandler(this.getRows.bind(this), 30);
		}
	}

	tableRedrawing(force){
		var rows;

		if(force){
			rows = this.table.rowManager.getRows();
			
			rows.forEach((row) => {
				this.reinitializeRowChildren(row);
			});
		}
	}

	initializeElementField(){
		var firstCol = this.table.columnManager.getFirstVisibleColumn();

		this.elementField = this.table.options.dataTreeElementColumn || (firstCol ? firstCol.field : false);
	}
	
	getRowChildren(row){
		return this.getTreeChildren(row, true);
	}

	columnMoving(){
		var rows = [];

		this.table.rowManager.rows.forEach((row) => {
			rows = rows.concat(this.getTreeChildren(row, false, true));
		});

		return rows;
	}

	rowDataChanged(row, visible, updatedData){
		if(this.redrawNeeded(updatedData)){
			this.initializeRow(row);

			if(visible){
				this.layoutRow(row);
				this.refreshData(true);
			}
		}
	}

	cellValueChanged(cell){
		var field = cell.column.getField();

		if(field === this.elementField){
			this.layoutRow(cell.row);
		}
	}

	initializeRow(row){
		var childArray = row.getData()[this.field];
		var isArray = Array.isArray(childArray);

		var children = isArray || (!isArray && typeof childArray === "object" && childArray !== null);

		if(!children && row.modules.dataTree && row.modules.dataTree.branchEl){
			row.modules.dataTree.branchEl.parentNode.removeChild(row.modules.dataTree.branchEl);
		}

		if(!children && row.modules.dataTree && row.modules.dataTree.controlEl){
			row.modules.dataTree.controlEl.parentNode.removeChild(row.modules.dataTree.controlEl);
		}

		row.modules.dataTree = {
			index: row.modules.dataTree ? row.modules.dataTree.index : 0,
			open: children ? (row.modules.dataTree ? row.modules.dataTree.open : this.startOpen(row.getComponent(), 0)) : false,
			controlEl: row.modules.dataTree && children ? row.modules.dataTree.controlEl : false,
			branchEl: row.modules.dataTree && children ? row.modules.dataTree.branchEl : false,
			parent: row.modules.dataTree ? row.modules.dataTree.parent : false,
			children:children,
		};
	}

	reinitializeRowChildren(row){
		var children = this.getTreeChildren(row, false, true);

		children.forEach(function(child){
			child.reinitialize(true);
		});
	}

	layoutRow(row){
		var cell = this.elementField ? row.getCell(this.elementField) : row.getCells()[0],
		el = cell.getElement(),
		config = row.modules.dataTree;

		if(config.branchEl){
			if(config.branchEl.parentNode){
				config.branchEl.parentNode.removeChild(config.branchEl);
			}
			config.branchEl = false;
		}

		if(config.controlEl){
			if(config.controlEl.parentNode){
				config.controlEl.parentNode.removeChild(config.controlEl);
			}
			config.controlEl = false;
		}

		this.generateControlElement(row, el);

		row.getElement().classList.add("tabulator-tree-level-" + config.index);

		if(config.index){
			if(this.branchEl){
				config.branchEl = this.branchEl.cloneNode(true);
				el.insertBefore(config.branchEl, el.firstChild);

				if(this.table.rtl){
					config.branchEl.style.marginRight = (((config.branchEl.offsetWidth + config.branchEl.style.marginLeft) * (config.index - 1)) + (config.index * this.indent)) + "px";
				}else {
					config.branchEl.style.marginLeft = (((config.branchEl.offsetWidth + config.branchEl.style.marginRight) * (config.index - 1)) + (config.index * this.indent)) + "px";
				}
			}else {

				if(this.table.rtl){
					el.style.paddingRight = parseInt(window.getComputedStyle(el, null).getPropertyValue('padding-right')) + (config.index * this.indent) + "px";
				}else {
					el.style.paddingLeft = parseInt(window.getComputedStyle(el, null).getPropertyValue('padding-left')) + (config.index * this.indent) + "px";
				}
			}
		}
	}

	generateControlElement(row, el){
		var config = row.modules.dataTree,
		oldControl = config.controlEl;

		el = el || row.getCells()[0].getElement();

		if(config.children !== false){

			if(config.open){
				config.controlEl = this.collapseEl.cloneNode(true);
				config.controlEl.addEventListener("click", (e) => {
					e.stopPropagation();
					this.collapseRow(row);
				});
			}else {
				config.controlEl = this.expandEl.cloneNode(true);
				config.controlEl.addEventListener("click", (e) => {
					e.stopPropagation();
					this.expandRow(row);
				});
			}

			config.controlEl.addEventListener("mousedown", (e) => {
				e.stopPropagation();
			});

			if(oldControl && oldControl.parentNode === el){
				oldControl.parentNode.replaceChild(config.controlEl,oldControl);
			}else {
				el.insertBefore(config.controlEl, el.firstChild);
			}
		}
	}

	getRows(rows){
		var output = [];

		rows.forEach((row, i) => {
			var config, children;

			output.push(row);

			if(row instanceof Row){

				row.create();

				config = row.modules.dataTree;

				if(!config.index && config.children !== false){
					children = this.getChildren(row);

					children.forEach((child) => {
						child.create();
						output.push(child);
					});
				}
			}
		});

		return output;
	}

	getChildren(row, allChildren){
		var config = row.modules.dataTree,
		children = [],
		output = [];

		if(config.children !== false && (config.open || allChildren)){
			if(!Array.isArray(config.children)){
				config.children = this.generateChildren(row);
			}

			if(this.table.modExists("filter") && this.table.options.dataTreeFilter){
				children = this.table.modules.filter.filter(config.children);
			}else {
				children = config.children;
			}

			if(this.table.modExists("sort") && this.table.options.dataTreeSort){
				this.table.modules.sort.sort(children);
			}

			children.forEach((child) => {
				output.push(child);

				var subChildren = this.getChildren(child);

				subChildren.forEach((sub) => {
					output.push(sub);
				});
			});
		}

		return output;
	}

	generateChildren(row){
		var children = [];

		var childArray = row.getData()[this.field];

		if(!Array.isArray(childArray)){
			childArray = [childArray];
		}

		childArray.forEach((childData) => {
			var childRow = new Row(childData || {}, this.table.rowManager);

			childRow.create();

			childRow.modules.dataTree.index = row.modules.dataTree.index + 1;
			childRow.modules.dataTree.parent = row;

			if(childRow.modules.dataTree.children){
				childRow.modules.dataTree.open = this.startOpen(childRow.getComponent(), childRow.modules.dataTree.index);
			}
			children.push(childRow);
		});

		return children;
	}

	expandRow(row, silent){
		var config = row.modules.dataTree;

		if(config.children !== false){
			config.open = true;

			row.reinitialize();

			this.refreshData(true);

			this.dispatchExternal("dataTreeRowExpanded", row.getComponent(), row.modules.dataTree.index);
		}
	}

	collapseRow(row){
		var config = row.modules.dataTree;

		if(config.children !== false){
			config.open = false;

			row.reinitialize();

			this.refreshData(true);

			this.dispatchExternal("dataTreeRowCollapsed", row.getComponent(), row.modules.dataTree.index);
		}
	}

	toggleRow(row){
		var config = row.modules.dataTree;

		if(config.children !== false){
			if(config.open){
				this.collapseRow(row);
			}else {
				this.expandRow(row);
			}
		}
	}

	isRowExpanded(row){
		return row.modules.dataTree.open;
	}

	getTreeParent(row){
		return row.modules.dataTree.parent ? row.modules.dataTree.parent.getComponent() : false;
	}

	getTreeParentRoot(row){
		return row.modules.dataTree && row.modules.dataTree.parent ? this.getTreeParentRoot(row.modules.dataTree.parent) : row;
	}

	getFilteredTreeChildren(row){
		var config = row.modules.dataTree,
		output = [], children;

		if(config.children){

			if(!Array.isArray(config.children)){
				config.children = this.generateChildren(row);
			}

			if(this.table.modExists("filter") && this.table.options.dataTreeFilter){
				children = this.table.modules.filter.filter(config.children);
			}else {
				children = config.children;
			}

			children.forEach((childRow) => {
				if(childRow instanceof Row){
					output.push(childRow);
				}
			});
		}

		return output;
	}

	rowDelete(row){
		var parent = row.modules.dataTree.parent,
		childIndex;

		if(parent){
			childIndex = this.findChildIndex(row, parent);

			if(childIndex !== false){
				parent.data[this.field].splice(childIndex, 1);
			}

			if(!parent.data[this.field].length){
				delete parent.data[this.field];
			}

			this.initializeRow(parent);
			this.layoutRow(parent);
		}

		this.refreshData(true);
	}

	addTreeChildRow(row, data, top, index){
		var childIndex = false;

		if(typeof data === "string"){
			data = JSON.parse(data);
		}

		if(!Array.isArray(row.data[this.field])){
			row.data[this.field] = [];

			row.modules.dataTree.open = this.startOpen(row.getComponent(), row.modules.dataTree.index);
		}

		if(typeof index !== "undefined"){
			childIndex = this.findChildIndex(index, row);

			if(childIndex !== false){
				row.data[this.field].splice((top ? childIndex : childIndex + 1), 0, data);
			}
		}

		if(childIndex === false){
			if(top){
				row.data[this.field].unshift(data);
			}else {
				row.data[this.field].push(data);
			}
		}

		this.initializeRow(row);
		this.layoutRow(row);

		this.refreshData(true);
	}

	findChildIndex(subject, parent){
		var match = false;

		if(typeof subject == "object"){

			if(subject instanceof Row){
				//subject is row element
				match = subject.data;
			}else if(subject instanceof RowComponent){
				//subject is public row component
				match = subject._getSelf().data;
			}else if(typeof HTMLElement !== "undefined" && subject instanceof HTMLElement){
				if(parent.modules.dataTree){
					match = parent.modules.dataTree.children.find((childRow) => {
						return childRow instanceof Row ? childRow.element === subject : false;
					});

					if(match){
						match = match.data;
					}
				}
			}else if(subject === null){
				match = false;
			}

		}else if(typeof subject == "undefined"){
			match = false;
		}else {
			//subject should be treated as the index of the row
			match = parent.data[this.field].find((row) => {
				return row.data[this.table.options.index] == subject;
			});
		}

		if(match){

			if(Array.isArray(parent.data[this.field])){
				match = parent.data[this.field].indexOf(match);
			}

			if(match == -1){
				match = false;
			}
		}

		//catch all for any other type of input

		return match;
	}

	getTreeChildren(row, component, recurse){
		var config = row.modules.dataTree,
		output = [];

		if(config && config.children){

			if(!Array.isArray(config.children)){
				config.children = this.generateChildren(row);
			}

			config.children.forEach((childRow) => {
				if(childRow instanceof Row){
					output.push(component ? childRow.getComponent() : childRow);

					if(recurse){
						output = output.concat(this.getTreeChildren(childRow, component, recurse));
					}
				}
			});
		}

		return output;
	}

	getChildField(){
		return this.field;
	}

	redrawNeeded(data){
		return (this.field ? typeof data[this.field] !== "undefined" : false) || (this.elementField ? typeof data[this.elementField] !== "undefined" : false);
	}
}

DataTree.moduleName = "dataTree";

function csv(list, options = {}, setFileContents){
	var delimiter = options.delimiter ? options.delimiter : ",",
	fileContents = [],
	headers = [];

	list.forEach((row) => {
		var item = [];

		switch(row.type){
			case "group":
				console.warn("Download Warning - CSV downloader cannot process row groups");
				break;

			case "calc":
				console.warn("Download Warning - CSV downloader cannot process column calculations");
				break;

			case "header":
				row.columns.forEach((col, i) => {
					if(col && col.depth === 1){
						headers[i] = typeof col.value == "undefined"  || col.value === null ? "" : ('"' + String(col.value).split('"').join('""') + '"');
					}
				});
				break;

			case "row":
				row.columns.forEach((col) => {

					if(col){

						switch(typeof col.value){
							case "object":
								col.value = col.value !== null ? JSON.stringify(col.value) : "";
								break;

							case "undefined":
								col.value = "";
								break;
						}

						item.push('"' + String(col.value).split('"').join('""') + '"');
					}
				});

				fileContents.push(item.join(delimiter));
				break;
		}
	});

	if(headers.length){
		fileContents.unshift(headers.join(delimiter));
	}

	fileContents = fileContents.join("\n");

	if(options.bom){
		fileContents = "\ufeff" + fileContents;
	}

	setFileContents(fileContents, "text/csv");
}

function json(list, options, setFileContents){
	var fileContents = [];

	list.forEach((row) => {
		var item = {};

		switch(row.type){
			case "header":
				break;

			case "group":
				console.warn("Download Warning - JSON downloader cannot process row groups");
				break;

			case "calc":
				console.warn("Download Warning - JSON downloader cannot process column calculations");
				break;

			case "row":
				row.columns.forEach((col) => {
					if(col){
						item[col.component.getTitleDownload() || col.component.getField()] = col.value;
					}
				});

				fileContents.push(item);
				break;
		}
	});

	fileContents = JSON.stringify(fileContents, null, '\t');

	setFileContents(fileContents, "application/json");
}

function pdf(list, options = {}, setFileContents){
	var header = [],
	body = [],
	autoTableParams = {},
	rowGroupStyles = options.rowGroupStyles || {
		fontStyle: "bold",
		fontSize: 12,
		cellPadding: 6,
		fillColor: 220,
	},
	rowCalcStyles = options.rowCalcStyles || {
		fontStyle: "bold",
		fontSize: 10,
		cellPadding: 4,
		fillColor: 232,
	},
	jsPDFParams = options.jsPDF || {},
	title = options.title ? options.title : "";

	if(!jsPDFParams.orientation){
		jsPDFParams.orientation = options.orientation || "landscape";
	}

	if(!jsPDFParams.unit){
		jsPDFParams.unit = "pt";
	}

	//parse row list
	list.forEach((row) => {
		switch(row.type){
			case "header":
				header.push(parseRow(row));
				break;

			case "group":
				body.push(parseRow(row, rowGroupStyles));
				break;

			case "calc":
				body.push(parseRow(row, rowCalcStyles));
				break;

			case "row":
				body.push(parseRow(row));
				break;
		}
	});

	function parseRow(row, styles){
		var rowData = [];

		row.columns.forEach((col) =>{
			var cell;

			if(col){
				switch(typeof col.value){
					case "object":
						col.value = col.value !== null ? JSON.stringify(col.value) : "";
						break;

					case "undefined":
						col.value = "";
						break;
				}

				cell = {
					content:col.value,
					colSpan:col.width,
					rowSpan:col.height,
				};

				if(styles){
					cell.styles = styles;
				}

				rowData.push(cell);
			}
		});

		return rowData;
	}


	//configure PDF
	var doc = new jspdf.jsPDF(jsPDFParams); //set document to landscape, better for most tables

	if(options.autoTable){
		if(typeof options.autoTable === "function"){
			autoTableParams = options.autoTable(doc) || {};
		}else {
			autoTableParams = options.autoTable;
		}
	}

	if(title){
		autoTableParams.didDrawPage = function(data) {
			doc.text(title, 40, 30);
		};
	}

	autoTableParams.head = header;
	autoTableParams.body = body;

	doc.autoTable(autoTableParams);

	if(options.documentProcessing){
		options.documentProcessing(doc);
	}

	setFileContents(doc.output("arraybuffer"), "application/pdf");
}

function xlsx(list, options, setFileContents){
	var self = this,
	sheetName = options.sheetName || "Sheet1",
	workbook = XLSX.utils.book_new(),
	tableFeatures = new CoreFeature(this),
	compression =  'compress' in options ? options.compress : true,
	writeOptions = options.writeOptions || {bookType:'xlsx', bookSST:true, compression},
	output;

	writeOptions.type = 'binary';

	workbook.SheetNames = [];
	workbook.Sheets = {};

	function generateSheet(){
		var rows = [],
		merges = [],
		worksheet = {},
		range = {s: {c:0, r:0}, e: {c:(list[0] ? list[0].columns.reduce((a, b) => a + (b && b.width ? b.width : 1), 0) : 0), r:list.length }};

		//parse row list
		list.forEach((row, i) => {
			var rowData = [];

			row.columns.forEach(function(col, j){

				if(col){
					rowData.push(!(col.value instanceof Date) && typeof col.value === "object" ? JSON.stringify(col.value) : col.value);

					if(col.width > 1 || col.height > -1){
						if(col.height > 1 || col.width > 1){
							merges.push({s:{r:i,c:j},e:{r:i + col.height - 1,c:j + col.width - 1}});
						}
					}
				}else {
					rowData.push("");
				}
			});

			rows.push(rowData);
		});

		//convert rows to worksheet
		XLSX.utils.sheet_add_aoa(worksheet, rows);

		worksheet['!ref'] = XLSX.utils.encode_range(range);

		if(merges.length){
			worksheet["!merges"] = merges;
		}

		return worksheet;
	}

	if(options.sheetOnly){
		setFileContents(generateSheet());
		return;
	}

	if(options.sheets){
		for(var sheet in options.sheets){

			if(options.sheets[sheet] === true){
				workbook.SheetNames.push(sheet);
				workbook.Sheets[sheet] = generateSheet();
			}else {

				workbook.SheetNames.push(sheet);

				tableFeatures.commsSend(options.sheets[sheet], "download", "intercept",{
					type:"xlsx",
					options:{sheetOnly:true},
					active:self.active,
					intercept:function(data){
						workbook.Sheets[sheet] = data;
					}
				});
			}
		}
	}else {
		workbook.SheetNames.push(sheetName);
		workbook.Sheets[sheetName] = generateSheet();
	}

	if(options.documentProcessing){
		workbook = options.documentProcessing(workbook);
	}

	//convert workbook to binary array
	function s2ab(s) {
		var buf = new ArrayBuffer(s.length);
		var view = new Uint8Array(buf);
		for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;
		return buf;
	}

	output = XLSX.write(workbook, writeOptions);

	setFileContents(s2ab(output), "application/octet-stream");
}

function html(list, options, setFileContents){
	if(this.modExists("export", true)){
		setFileContents(this.modules.export.generateHTMLTable(list), "text/html");
	}
}

function jsonLines (list, options, setFileContents) {
	const fileContents = [];

	list.forEach((row) => {
		const item = {};

		switch (row.type) {
			case "header":
				break;

			case "group":
				console.warn("Download Warning - JSON downloader cannot process row groups");
				break;

			case "calc":
				console.warn("Download Warning - JSON downloader cannot process column calculations");
				break;

			case "row":
				row.columns.forEach((col) => {
					if (col) {
						item[col.component.getTitleDownload() || col.component.getField()] = col.value;
					}
				});

				fileContents.push(JSON.stringify(item));
				break;
		}
	});

	setFileContents(fileContents.join("\n"), "application/x-ndjson");
}

var defaultDownloaders = {
	csv:csv,
	json:json,
	jsonLines:jsonLines,
	pdf:pdf,
	xlsx:xlsx,
	html:html,
};

class Download extends Module{

	constructor(table){
		super(table);

		this.registerTableOption("downloadEncoder", function(data, mimeType){
			return new Blob([data],{type:mimeType});
		}); //function to manipulate download data
		this.registerTableOption("downloadReady", undefined); //warn of function deprecation
		this.registerTableOption("downloadConfig", {}); //download config
		this.registerTableOption("downloadRowRange", "active"); //restrict download to active rows only

		this.registerColumnOption("download");
		this.registerColumnOption("titleDownload");
	}

	initialize(){
		this.deprecatedOptionsCheck();

		this.registerTableFunction("download", this.download.bind(this));
		this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
	}

	deprecatedOptionsCheck(){
		this.deprecationCheck("downloadReady", "downloadEncoder");
	}	

	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////

	downloadToTab(type, filename, options, active){
		this.download(type, filename, options, active, true);
	}

	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////

	//trigger file download
	download(type, filename, options, range, interceptCallback){
		var downloadFunc = false;

		function buildLink(data, mime){
			if(interceptCallback){
				if(interceptCallback === true){
					this.triggerDownload(data, mime, type, filename, true);
				}else {
					interceptCallback(data);
				}

			}else {
				this.triggerDownload(data, mime, type, filename);
			}
		}

		if(typeof type == "function"){
			downloadFunc = type;
		}else {
			if(Download.downloaders[type]){
				downloadFunc = Download.downloaders[type];
			}else {
				console.warn("Download Error - No such download type found: ", type);
			}
		}

		if(downloadFunc){
			var list = this.generateExportList(range);

			downloadFunc.call(this.table, list , options || {}, buildLink.bind(this));
		}
	}

	generateExportList(range){
		var list = this.table.modules.export.generateExportList(this.table.options.downloadConfig, false, range || this.table.options.downloadRowRange, "download");

		//assign group header formatter
		var groupHeader = this.table.options.groupHeaderDownload;

		if(groupHeader && !Array.isArray(groupHeader)){
			groupHeader = [groupHeader];
		}

		list.forEach((row) => {
			var group;

			if(row.type === "group"){
				group = row.columns[0];

				if(groupHeader && groupHeader[row.indent]){
					group.value = groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
				}
			}
		});

		return list;
	}

	triggerDownload(data, mime, type, filename, newTab){
		var element = document.createElement('a'),
		blob = this.table.options.downloadEncoder(data, mime);

		if(blob){
			if(newTab){
				window.open(window.URL.createObjectURL(blob));
			}else {
				filename = filename || "Tabulator." + (typeof type === "function" ? "txt" : type);
				
				if(navigator.msSaveOrOpenBlob){
					navigator.msSaveOrOpenBlob(blob, filename);
				}else {
					element.setAttribute('href', window.URL.createObjectURL(blob));

					//set file title
					element.setAttribute('download', filename);

					//trigger download
					element.style.display = 'none';
					document.body.appendChild(element);
					element.click();

					//remove temporary link element
					document.body.removeChild(element);
				}
			}

			this.dispatchExternal("downloadComplete");
		}
	}

	commsReceived(table, action, data){
		switch(action){
			case "intercept":
				this.download(data.type, "", data.options, data.active, data.intercept);
				break;
		}
	}
}

Download.moduleName = "download";

//load defaults
Download.downloaders = defaultDownloaders;

function maskInput(el, options){
	var mask = options.mask,
	maskLetter = typeof options.maskLetterChar !== "undefined" ? options.maskLetterChar : "A",
	maskNumber = typeof options.maskNumberChar !== "undefined" ? options.maskNumberChar : "9",
	maskWildcard = typeof options.maskWildcardChar !== "undefined" ? options.maskWildcardChar : "*";

	function fillSymbols(index){
		var symbol = mask[index];
		if(typeof symbol !== "undefined" && symbol !== maskWildcard && symbol !== maskLetter && symbol !== maskNumber){
			el.value = el.value + "" + symbol;
			fillSymbols(index+1);
		}
	}

	el.addEventListener("keydown", (e) => {
		var index = el.value.length,
		char = e.key;

		if(e.keyCode > 46 && !e.ctrlKey && !e.metaKey){
			if(index >= mask.length){
				e.preventDefault();
				e.stopPropagation();
				return false;
			}else {
				switch(mask[index]){
					case maskLetter:
						if(char.toUpperCase() == char.toLowerCase()){
							e.preventDefault();
							e.stopPropagation();
							return false;
						}
						break;

					case maskNumber:
						if(isNaN(char)){
							e.preventDefault();
							e.stopPropagation();
							return false;
						}
						break;

					case maskWildcard:
						break;

					default:
						if(char !== mask[index]){
							e.preventDefault();
							e.stopPropagation();
							return false;
						}
				}
			}
		}

		return;
	});

	el.addEventListener("keyup", (e) => {
		if(e.keyCode > 46){
			if(options.maskAutoFill){
				fillSymbols(el.value.length);
			}
		}
	});


	if(!el.placeholder){
		el.placeholder = mask;
	}

	if(options.maskAutoFill){
		fillSymbols(el.value.length);
	}
}

//input element
function input(cell, onRendered, success, cancel, editorParams){
	//create and style input
	var cellValue = cell.getValue(),
	input = document.createElement("input");

	input.setAttribute("type", editorParams.search ? "search" : "text");

	input.style.padding = "4px";
	input.style.width = "100%";
	input.style.boxSizing = "border-box";

	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}

	input.value = typeof cellValue !== "undefined" ? cellValue : "";

	onRendered(function(){
		if(cell.getType() === "cell"){
			input.focus({preventScroll: true});
			input.style.height = "100%";

			if(editorParams.selectContents){
				input.select();
			}
		}
	});

	function onChange(e){
		if(((cellValue === null || typeof cellValue === "undefined") && input.value !== "") || input.value !== cellValue){
			if(success(input.value)){
				cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
			}
		}else {
			cancel();
		}
	}

	//submit new value on blur or change
	input.addEventListener("change", onChange);
	input.addEventListener("blur", onChange);

	//submit new value on enter
	input.addEventListener("keydown", function(e){
		switch(e.keyCode){
			// case 9:
			case 13:
				onChange();
				break;

			case 27:
				cancel();
				break;

			case 35:
			case 36:
				e.stopPropagation();
				break;
		}
	});

	if(editorParams.mask){
		maskInput(input, editorParams);
	}

	return input;
}

//resizable text area element
function textarea(cell, onRendered, success, cancel, editorParams){
	var cellValue = cell.getValue(),
	vertNav = editorParams.verticalNavigation || "hybrid",
	value = String(cellValue !== null && typeof cellValue !== "undefined"  ? cellValue : ""),
	input = document.createElement("textarea"),
	scrollHeight = 0;

	//create and style input
	input.style.display = "block";
	input.style.padding = "2px";
	input.style.height = "100%";
	input.style.width = "100%";
	input.style.boxSizing = "border-box";
	input.style.whiteSpace = "pre-wrap";
	input.style.resize = "none";

	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}

	input.value = value;

	onRendered(function(){
		if(cell.getType() === "cell"){
			input.focus({preventScroll: true});
			input.style.height = "100%";

			input.scrollHeight;
			input.style.height = input.scrollHeight + "px";
			cell.getRow().normalizeHeight();

			if(editorParams.selectContents){
				input.select();
			}
		}
	});

	function onChange(e){

		if(((cellValue === null || typeof cellValue === "undefined") && input.value !== "") || input.value !== cellValue){

			if(success(input.value)){
				cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
			}

			setTimeout(function(){
				cell.getRow().normalizeHeight();
			},300);
		}else {
			cancel();
		}
	}

	//submit new value on blur or change
	input.addEventListener("change", onChange);
	input.addEventListener("blur", onChange);

	input.addEventListener("keyup", function(){

		input.style.height = "";

		var heightNow = input.scrollHeight;

		input.style.height = heightNow + "px";

		if(heightNow != scrollHeight){
			scrollHeight = heightNow;
			cell.getRow().normalizeHeight();
		}
	});

	input.addEventListener("keydown", function(e){

		switch(e.keyCode){

			case 13:
				if(e.shiftKey && editorParams.shiftEnterSubmit){
					onChange();
				}
				break;

			case 27:
				cancel();
				break;

			case 38: //up arrow
				if(vertNav == "editor" || (vertNav == "hybrid" && input.selectionStart)){
					e.stopImmediatePropagation();
					e.stopPropagation();
				}

				break;

			case 40: //down arrow
				if(vertNav == "editor" || (vertNav == "hybrid" && input.selectionStart !== input.value.length)){
					e.stopImmediatePropagation();
					e.stopPropagation();
				}
				break;

			case 35:
			case 36:
				e.stopPropagation();
				break;
		}
	});

	if(editorParams.mask){
		maskInput(input, editorParams);
	}

	return input;
}

//input element with type of number
function number(cell, onRendered, success, cancel, editorParams){
	var cellValue = cell.getValue(),
	vertNav = editorParams.verticalNavigation || "editor",
	input = document.createElement("input");

	input.setAttribute("type", "number");

	if(typeof editorParams.max != "undefined"){
		input.setAttribute("max", editorParams.max);
	}

	if(typeof editorParams.min != "undefined"){
		input.setAttribute("min", editorParams.min);
	}

	if(typeof editorParams.step != "undefined"){
		input.setAttribute("step", editorParams.step);
	}

	//create and style input
	input.style.padding = "4px";
	input.style.width = "100%";
	input.style.boxSizing = "border-box";

	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}

	input.value = cellValue;

	var blurFunc = function(e){
		onChange();
	};

	onRendered(function () {
		if(cell.getType() === "cell"){
			//submit new value on blur
			input.removeEventListener("blur", blurFunc);

			input.focus({preventScroll: true});
			input.style.height = "100%";

			//submit new value on blur
			input.addEventListener("blur", blurFunc);

			if(editorParams.selectContents){
				input.select();
			}
		}
	});

	function onChange(){
		var value = input.value;

		if(!isNaN(value) && value !==""){
			value = Number(value);
		}

		if(value !== cellValue){
			if(success(value)){
				cellValue = value; //persist value if successfully validated incase editor is used as header filter
			}
		}else {
			cancel();
		}
	}

	//submit new value on enter
	input.addEventListener("keydown", function(e){
		switch(e.keyCode){
			case 13:
			// case 9:
				onChange();
				break;

			case 27:
				cancel();
				break;

			case 38: //up arrow
			case 40: //down arrow
				if(vertNav == "editor"){
					e.stopImmediatePropagation();
					e.stopPropagation();
				}
				break;

			case 35:
			case 36:
				e.stopPropagation();
				break;
		}
	});

	if(editorParams.mask){
		maskInput(input, editorParams);
	}

	return input;
}

//input element with type of number
function range(cell, onRendered, success, cancel, editorParams){
	var cellValue = cell.getValue(),
	input = document.createElement("input");
	
	input.setAttribute("type", "range");
	
	if (typeof editorParams.max != "undefined") {
		input.setAttribute("max", editorParams.max);
	}
	
	if (typeof editorParams.min != "undefined") {
		input.setAttribute("min", editorParams.min);
	}
	
	if (typeof editorParams.step != "undefined") {
		input.setAttribute("step", editorParams.step);
	}
	
	//create and style input
	input.style.padding = "4px";
	input.style.width = "100%";
	input.style.boxSizing = "border-box";
	
	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}
	
	input.value = cellValue;
	
	onRendered(function () {
		if(cell.getType() === "cell"){
			input.focus({preventScroll: true});
			input.style.height = "100%";
		}
	});
	
	function onChange(){
		var value = input.value;
		
		if(!isNaN(value) && value !==""){
			value = Number(value);
		}
		
		if(value != cellValue){
			if(success(value)){
				cellValue = value; //persist value if successfully validated incase editor is used as header filter
			}
		}else {
			cancel();
		}
	}
	
	//submit new value on blur
	input.addEventListener("blur", function(e){
		onChange();
	});
	
	//submit new value on enter
	input.addEventListener("keydown", function(e){
		switch(e.keyCode){
			case 13:
			// case 9:
				onChange();
				break;
			
			case 27:
				cancel();
				break;
		}
	});
	
	return input;
}

//input element
function date(cell, onRendered, success, cancel, editorParams){
	var inputFormat = editorParams.format,
	vertNav = editorParams.verticalNavigation || "editor",
	DT = inputFormat ? (window.DateTime || luxon.DateTime) : null;
	
	//create and style input
	var cellValue = cell.getValue(),
	input = document.createElement("input");
	
	function convertDate(value){
		var newDatetime;
		
		if(DT.isDateTime(value)){
			newDatetime = value;
		}else if(inputFormat === "iso"){
			newDatetime = DT.fromISO(String(value));
		}else {
			newDatetime = DT.fromFormat(String(value), inputFormat);
		}
		
		return newDatetime.toFormat("yyyy-MM-dd");
	}
	
	input.type = "date";
	input.style.padding = "4px";
	input.style.width = "100%";
	input.style.boxSizing = "border-box";

	if(editorParams.max){
		input.setAttribute("max", inputFormat ? convertDate(editorParams.max) : editorParams.max);
	}

	if(editorParams.min){
		input.setAttribute("min", inputFormat ? convertDate(editorParams.min) : editorParams.min);
	}
	
	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}
	
	cellValue = typeof cellValue !== "undefined" ? cellValue : "";
	
	if(inputFormat){
		if(DT){		
			cellValue = convertDate(cellValue);			
		}else {
			console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
		}
	}
	
	input.value = cellValue;
	
	onRendered(function(){
		if(cell.getType() === "cell"){
			input.focus({preventScroll: true});
			input.style.height = "100%";
			
			if(editorParams.selectContents){
				input.select();
			}
		}
	});
	
	function onChange(){
		var value = input.value,
		luxDate;
		
		if(((cellValue === null || typeof cellValue === "undefined") && value !== "") || value !== cellValue){
			
			if(value && inputFormat){
				luxDate = DT.fromFormat(String(value), "yyyy-MM-dd");

				switch(inputFormat){
					case true:
						value = luxDate;
						break;

					case "iso":
						value = luxDate.toISO();
						break;

					default:
						value = luxDate.toFormat(inputFormat);
				}
			}
			
			if(success(value)){
				cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
			}
		}else {
			cancel();
		}
	}
	
	//submit new value on blur
	input.addEventListener("blur", function(e) {
		if (e.relatedTarget || e.rangeParent || e.explicitOriginalTarget !== input) {
			onChange(); // only on a "true" blur; not when focusing browser's date/time picker
		}
	});
	
	//submit new value on enter
	input.addEventListener("keydown", function(e){
		switch(e.keyCode){
			// case 9:
			case 13:
				onChange();
				break;
			
			case 27:
				cancel();
				break;
			
			case 35:
			case 36:
				e.stopPropagation();
				break;
			
			case 38: //up arrow
			case 40: //down arrow
				if(vertNav == "editor"){
					e.stopImmediatePropagation();
					e.stopPropagation();
				}
				break;
		}
	});
	
	return input;
}

//input element
function time(cell, onRendered, success, cancel, editorParams){
	var inputFormat = editorParams.format,
	vertNav = editorParams.verticalNavigation || "editor",
	DT = inputFormat ? (window.DateTime || luxon.DateTime) : null, 
	newDatetime;
	
	//create and style input
	var cellValue = cell.getValue(),
	input = document.createElement("input");
	
	input.type = "time";
	input.style.padding = "4px";
	input.style.width = "100%";
	input.style.boxSizing = "border-box";
	
	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}
	
	cellValue = typeof cellValue !== "undefined" ? cellValue : "";
	
	if(inputFormat){
		if(DT){
			if(DT.isDateTime(cellValue)){
				newDatetime = cellValue;
			}else if(inputFormat === "iso"){
				newDatetime = DT.fromISO(String(cellValue));
			}else {
				newDatetime = DT.fromFormat(String(cellValue), inputFormat);
			}
			
			cellValue = newDatetime.toFormat("HH:mm");
			
		}else {
			console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
		}
	}

	console.log("val", cellValue);
	
	input.value = cellValue;
	
	onRendered(function(){
		if(cell.getType() == "cell"){
			input.focus({preventScroll: true});
			input.style.height = "100%";
			
			if(editorParams.selectContents){
				input.select();
			}
		}
	});
	
	function onChange(){
		var value = input.value,
		luxTime;
		
		if(((cellValue === null || typeof cellValue === "undefined") && value !== "") || value !== cellValue){
			
			if(value && inputFormat){
				luxTime = DT.fromFormat(String(value), "hh:mm");

				switch(inputFormat){
					case true:
						value = luxTime;
						break;

					case "iso":
						value = luxTime.toISO();
						break;

					default:
						value = luxTime.toFormat(inputFormat);
				}
			}
			
			if(success(value)){
				cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
			}
		}else {
			cancel();
		}
	}
	
	//submit new value on blur
	input.addEventListener("blur", function(e) {
		if (e.relatedTarget || e.rangeParent || e.explicitOriginalTarget !== input) {
			onChange(); // only on a "true" blur; not when focusing browser's date/time picker
		}
	});
	
	//submit new value on enter
	input.addEventListener("keydown", function(e){
		switch(e.keyCode){
			// case 9:
			case 13:
				onChange();
				break;
			
			case 27:
				cancel();
				break;
			
			case 35:
			case 36:
				e.stopPropagation();
				break;

			case 38: //up arrow
			case 40: //down arrow
				if(vertNav == "editor"){
					e.stopImmediatePropagation();
					e.stopPropagation();
				}
				break;
		}
	});
	
	return input;
}

//input element
function datetime(cell, onRendered, success, cancel, editorParams){
	var inputFormat = editorParams.format,
	vertNav = editorParams.verticalNavigation || "editor",
	DT = inputFormat ? (window.DateTime || luxon.DateTime) : null, 
	newDatetime;
	
	//create and style input
	var cellValue = cell.getValue(),
	input = document.createElement("input");
	
	input.type = "datetime-local";
	input.style.padding = "4px";
	input.style.width = "100%";
	input.style.boxSizing = "border-box";
	
	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}
	
	cellValue = typeof cellValue !== "undefined" ? cellValue : "";
	
	if(inputFormat){
		if(DT){
			if(DT.isDateTime(cellValue)){
				newDatetime = cellValue;
			}else if(inputFormat === "iso"){
				newDatetime = DT.fromISO(String(cellValue));
			}else {
				newDatetime = DT.fromFormat(String(cellValue), inputFormat);
			}
			
			cellValue = newDatetime.toFormat("yyyy-MM-dd")  + "T" + newDatetime.toFormat("HH:mm");
		}else {
			console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js");
		}
	}
	
	input.value = cellValue;
	
	onRendered(function(){
		if(cell.getType() === "cell"){
			input.focus({preventScroll: true});
			input.style.height = "100%";
			
			if(editorParams.selectContents){
				input.select();
			}
		}
	});
	
	function onChange(){
		var value = input.value,
		luxDateTime;
		
		if(((cellValue === null || typeof cellValue === "undefined") && value !== "") || value !== cellValue){

			if(value && inputFormat){
				luxDateTime = DT.fromISO(String(value));

				switch(inputFormat){
					case true:
						value = luxDateTime;
						break;

					case "iso":
						value = luxDateTime.toISO();
						break;

					default:
						value = luxDateTime.toFormat(inputFormat);
				}
			}
			
			if(success(value)){
				cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
			}
		}else {
			cancel();
		}
	}
	
	//submit new value on blur
	input.addEventListener("blur", function(e) {
		if (e.relatedTarget || e.rangeParent || e.explicitOriginalTarget !== input) {
			onChange(); // only on a "true" blur; not when focusing browser's date/time picker
		}
	});
	
	//submit new value on enter
	input.addEventListener("keydown", function(e){
		switch(e.keyCode){
			// case 9:
			case 13:
				onChange();
				break;
			
			case 27:
				cancel();
				break;
			
			case 35:
			case 36:
				e.stopPropagation();
				break;

			case 38: //up arrow
			case 40: //down arrow
				if(vertNav == "editor"){
					e.stopImmediatePropagation();
					e.stopPropagation();
				}
				break;
		}
	});
	
	return input;
}

class Edit{
	constructor(editor, cell, onRendered, success, cancel, editorParams){
		this.edit = editor;
		this.table = editor.table;
		this.cell = cell;
		this.params = this._initializeParams(editorParams);
		
		this.data = [];
		this.displayItems = [];
		this.currentItems = [];
		this.focusedItem = null;
		
		this.input = this._createInputElement();
		this.listEl = this._createListElement();
		
		this.initialValues = null; 
		
		this.isFilter = cell.getType() === "header";
		
		this.filterTimeout = null;
		this.filtered = false;
		this.typing = false;
		
		this.values = []; 
		this.popup = null;  
		
		this.listIteration = 0;
		
		this.lastAction="";
		this.filterTerm="";
		
		this.blurable = true;
		
		this.actions = {
			success:success,
			cancel:cancel
		};
		
		this._deprecatedOptionsCheck();
		this._initializeValue();
		
		onRendered(this._onRendered.bind(this));
	}
	
	_deprecatedOptionsCheck(){
		if(this.params.listItemFormatter){
			this.cell.getTable().deprecationAdvisor.msg("The listItemFormatter editor param has been deprecated, please see the latest editor documentation for updated options");
		}
		
		if(this.params.sortValuesList){
			this.cell.getTable().deprecationAdvisor.msg("The sortValuesList editor param has been deprecated, please see the latest editor documentation for updated options");
		}
		
		if(this.params.searchFunc){
			this.cell.getTable().deprecationAdvisor.msg("The searchFunc editor param has been deprecated, please see the latest editor documentation for updated options");
		}
		
		if(this.params.searchingPlaceholder){
			this.cell.getTable().deprecationAdvisor.msg("The searchingPlaceholder editor param has been deprecated, please see the latest editor documentation for updated options");
		}
	}
	
	_initializeValue(){
		var initialValue = this.cell.getValue();
		
		if(typeof initialValue === "undefined" && typeof this.params.defaultValue !== "undefined"){
			initialValue = this.params.defaultValue;
		}
		
		this.initialValues = this.params.multiselect ? initialValue : [initialValue];
		
		if(this.isFilter){
			this.input.value = this.initialValues ? this.initialValues.join(",") : "";
			this.headerFilterInitialListGen();            
		}
	}
	
	_onRendered(){
		var cellEl = this.cell.getElement();
		
		function clickStop(e){
			e.stopPropagation();
		}	
		
		if(!this.isFilter){
			this.input.style.height = "100%";
			this.input.focus({preventScroll: true});
		}
		
		
		cellEl.addEventListener("click", clickStop);
		
		setTimeout(() => {
			cellEl.removeEventListener("click", clickStop);
		}, 1000);
		
		this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
	}
	
	_createListElement(){
		var listEl = document.createElement("div");
		listEl.classList.add("tabulator-edit-list");
		
		listEl.addEventListener("mousedown", this._preventBlur.bind(this));
		listEl.addEventListener("keydown", this._inputKeyDown.bind(this));
		
		return listEl;
	}
	
	_setListWidth(){
		var element = this.isFilter ? this.input : this.cell.getElement();
		
		this.listEl.style.minWidth = element.offsetWidth + "px";
		
		if(this.params.maxWidth){
			if(this.params.maxWidth === true){
				this.listEl.style.maxWidth = element.offsetWidth + "px";
			}else if(typeof this.params.maxWidth === "number"){
				this.listEl.style.maxWidth = this.params.maxWidth + "px";
			}else {
				this.listEl.style.maxWidth = this.params.maxWidth;
			}
		}
		
	}
	
	_createInputElement(){
		var attribs = this.params.elementAttributes;
		var input = document.createElement("input");
		
		input.setAttribute("type", this.params.clearable ? "search" : "text");
		
		input.style.padding = "4px";
		input.style.width = "100%";
		input.style.boxSizing = "border-box";
		
		if(!this.params.autocomplete){
			input.style.cursor = "default";
			input.style.caretColor = "transparent";
			// input.readOnly = (this.edit.currentCell != false);
		}
		
		if(attribs && typeof attribs == "object"){
			for (let key in attribs){
				if(key.charAt(0) == "+"){
					key = key.slice(1);
					input.setAttribute(key, input.getAttribute(key) + attribs["+" + key]);
				}else {
					input.setAttribute(key, attribs[key]);
				}
			}
		}
		
		if(this.params.mask){
			maskInput(input, this.params);
		}
		
		this._bindInputEvents(input);
		
		return input;
	}
	
	_initializeParams(params){
		var valueKeys = ["values", "valuesURL", "valuesLookup"],
		valueCheck;
		
		params = Object.assign({}, params);
		
		params.verticalNavigation = params.verticalNavigation || "editor";
		params.placeholderLoading = typeof params.placeholderLoading === "undefined" ? "Searching ..." : params.placeholderLoading;
		params.placeholderEmpty = typeof params.placeholderEmpty === "undefined" ? "No Results Found" : params.placeholderEmpty;
		params.filterDelay = typeof params.filterDelay === "undefined" ? 300 : params.filterDelay;
		
		params.emptyValue = Object.keys(params).includes("emptyValue") ? params.emptyValue : "";
		
		valueCheck = Object.keys(params).filter(key => valueKeys.includes(key)).length;
		
		if(!valueCheck){
			console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set");
		}else if(valueCheck > 1){
			console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor");
		}
		
		if(params.autocomplete){
			if(params.multiselect){
				params.multiselect = false;
				console.warn("list editor config error - multiselect option is not available when autocomplete is enabled");
			}
		}else {
			if(params.freetext){
				params.freetext = false;
				console.warn("list editor config error - freetext option is only available when autocomplete is enabled");
			}
			
			if(params.filterFunc){
				params.filterFunc = false;
				console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled");
			}
			
			if(params.filterRemote){
				params.filterRemote = false;
				console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled");
			}
			
			if(params.mask){
				params.mask = false;
				console.warn("list editor config error - mask option is only available when autocomplete is enabled");
			}
			
			if(params.allowEmpty){
				params.allowEmpty = false;
				console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled");
			}
			
			if(params.listOnEmpty){
				params.listOnEmpty = false;
				console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled");
			}
		}
		
		if(params.filterRemote && !(typeof params.valuesLookup === "function" || params.valuesURL)){
			params.filterRemote = false;
			console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source");
		}
		return params;
	}
	//////////////////////////////////////
	////////// Event Handling ////////////
	//////////////////////////////////////
	
	_bindInputEvents(input){
		input.addEventListener("focus", this._inputFocus.bind(this));
		input.addEventListener("click", this._inputClick.bind(this));
		input.addEventListener("blur", this._inputBlur.bind(this));
		input.addEventListener("keydown", this._inputKeyDown.bind(this));
		input.addEventListener("search", this._inputSearch.bind(this));
		
		if(this.params.autocomplete){
			input.addEventListener("keyup", this._inputKeyUp.bind(this));
		}
	}
	
	
	_inputFocus(e){
		this.rebuildOptionsList();
	}
	
	_filter(){
		if(this.params.filterRemote){
			clearTimeout(this.filterTimeout);
			
			this.filterTimeout = setTimeout(() => {
				this.rebuildOptionsList();
			}, this.params.filterDelay);
		}else {
			this._filterList();
		}
	}
	
	_inputClick(e){
		e.stopPropagation();
	}
	
	_inputBlur(e){
		if(this.blurable){
			if(this.popup){
				this.popup.hide();
			}else {
				this._resolveValue(true);
			}
		}
	}
	
	_inputSearch(){
		this._clearChoices();
	}
	
	_inputKeyDown(e){
		switch(e.keyCode){
			
			case 38: //up arrow
				this._keyUp(e);
				break;
			
			case 40: //down arrow
				this._keyDown(e);
				break;
			
			case 37: //left arrow
			case 39: //right arrow
				this._keySide(e);
				break;
			
			case 13: //enter
				this._keyEnter();
				break;
			
			case 27: //escape
				this._keyEsc();
				break;
			
			case 36: //home
			case 35: //end
				this._keyHomeEnd(e);
				break;
			
			case 9: //tab
				this._keyTab(e);
				break;
			
			default:
				this._keySelectLetter(e);
		}
	}
	
	_inputKeyUp(e){
		switch(e.keyCode){
			case 38: //up arrow
			case 37: //left arrow
			case 39: //up arrow
			case 40: //right arrow
			case 13: //enter
			case 27: //escape
				break;
			
			default:
				this._keyAutoCompLetter(e);
		}
	}
	
	_preventPopupBlur(){
		if(this.popup){
			this.popup.blockHide();
		}
		
		setTimeout(() =>{
			if(this.popup){
				this.popup.restoreHide();
			}
		}, 10);
	}
	
	_preventBlur(){
		this.blurable = false;
		
		setTimeout(() =>{
			this.blurable = true;
		}, 10);
	}
	
	//////////////////////////////////////
	//////// Keyboard Navigation /////////
	//////////////////////////////////////
	
	_keyTab(e){
		if(this.params.autocomplete && this.lastAction === "typing"){
			this._resolveValue(true);
		}else {
			if(this.focusedItem){
				this._chooseItem(this.focusedItem, true);
			}
		}
	}
	
	_keyUp(e){
		var index = this.displayItems.indexOf(this.focusedItem);
		
		if(this.params.verticalNavigation == "editor" || (this.params.verticalNavigation == "hybrid" && index)){
			e.stopImmediatePropagation();
			e.stopPropagation();
			e.preventDefault();
			
			if(index > 0){
				this._focusItem(this.displayItems[index - 1]);
			}
		}
	}
	
	_keyDown(e){
		var index = this.displayItems.indexOf(this.focusedItem);
		
		if(this.params.verticalNavigation == "editor" || (this.params.verticalNavigation == "hybrid" && index < this.displayItems.length - 1)){
			e.stopImmediatePropagation();
			e.stopPropagation();
			e.preventDefault();
			
			if(index < this.displayItems.length - 1){
				if(index == -1){
					this._focusItem(this.displayItems[0]);
				}else {
					this._focusItem(this.displayItems[index + 1]);
				}
			}
		}
	}
	
	_keySide(e){
		if(!this.params.autocomplete){
			e.stopImmediatePropagation();
			e.stopPropagation();
			e.preventDefault();
		}
	}
	
	_keyEnter(e){
		if(this.params.autocomplete && this.lastAction === "typing"){
			this._resolveValue(true);
		}else {
			if(this.focusedItem){
				this._chooseItem(this.focusedItem);
			}
		}
	}
	
	_keyEsc(e){
		this._cancel();
	}
	
	_keyHomeEnd(e){
		if(this.params.autocomplete){
			//prevent table navigation while using input element
			e.stopImmediatePropagation();
		}
	}
	
	_keySelectLetter(e){
		if(!this.params.autocomplete){
			// if(this.edit.currentCell === false){
			e.preventDefault();
			// }
			
			if(e.keyCode >= 38 && e.keyCode <= 90){
				this._scrollToValue(e.keyCode);
			}
		}
	}
	
	_keyAutoCompLetter(e){
		this._filter();
		this.lastAction = "typing";
		this.typing = true;
	}
	
	
	_scrollToValue(char){
		clearTimeout(this.filterTimeout);
		
		var character = String.fromCharCode(char).toLowerCase();
		this.filterTerm += character.toLowerCase();
		
		var match = this.displayItems.find((item) => {
			return typeof item.label !== "undefined" && item.label.toLowerCase().startsWith(this.filterTerm);
		});
		
		if(match){
			this._focusItem(match);
		}
		
		this.filterTimeout = setTimeout(() => {
			this.filterTerm = "";
		}, 800);
	}
	
	_focusItem(item){
		this.lastAction = "focus";
		
		if(this.focusedItem && this.focusedItem.element){
			this.focusedItem.element.classList.remove("focused");
		}
		
		this.focusedItem = item;
		
		if(item && item.element){
			item.element.classList.add("focused");
			item.element.scrollIntoView({behavior: 'smooth', block: 'nearest', inline: 'start'});
		}
	}
	
	
	//////////////////////////////////////
	/////// Data List Generation /////////
	//////////////////////////////////////
	headerFilterInitialListGen(){
		this._generateOptions(true);
	}
	
	rebuildOptionsList(){
		this._generateOptions()
			.then(this._sortOptions.bind(this))
			.then(this._buildList.bind(this))
			.then(this._showList.bind(this))
			.catch((e) => {
				if(!Number.isInteger(e)){
					console.error("List generation error", e);
				}
			});
	}
	
	_filterList(){
		this._buildList(this._filterOptions());
		this._showList();
	}
	
	_generateOptions(silent){
		var values = [];
		var iteration = ++ this.listIteration;
		
		this.filtered = false;
		
		if(this.params.values){
			values = this.params.values;
		}else if (this.params.valuesURL){
			values = this._ajaxRequest(this.params.valuesURL, this.input.value);
		}else {
			if(typeof this.params.valuesLookup === "function"){
				values = this.params.valuesLookup(this.cell, this.input.value);
			}else if(this.params.valuesLookup){
				values = this._uniqueColumnValues(this.params.valuesLookupField);
			}
		}
		
		if(values instanceof Promise){
			if(!silent){
				this._addPlaceholder(this.params.placeholderLoading);
			}
			
			return values.then()
				.then((responseValues) => {
					if(this.listIteration === iteration){
						return this._parseList(responseValues);
					}else {
						return Promise.reject(iteration);
					}
				});
		}else {
			return Promise.resolve(this._parseList(values));
		}
	}
	
	_addPlaceholder(contents){
		var placeholder = document.createElement("div");
		
		if(typeof contents === "function"){
			contents = contents(this.cell.getComponent(), this.listEl);
		}
		
		if(contents){
			this._clearList();
			
			if(contents instanceof HTMLElement){
				placeholder = contents;
			}else {
				placeholder.classList.add("tabulator-edit-list-placeholder");
				placeholder.innerHTML = contents;
			}
			
			this.listEl.appendChild(placeholder);
			
			this._showList();
		}
	}
	
	_ajaxRequest(url, term){
		var params = this.params.filterRemote ? {term:term} : {};
		url = urlBuilder(url, {}, params);
		
		return fetch(url)
			.then((response)=>{
				if(response.ok) {
					return response.json()
						.catch((error)=>{
							console.warn("List Ajax Load Error - Invalid JSON returned", error);
							return Promise.reject(error);
						});
				}else {
					console.error("List Ajax Load Error - Connection Error: " + response.status, response.statusText);
					return Promise.reject(response);
				}
			})
			.catch((error)=>{
				console.error("List Ajax Load Error - Connection Error: ", error);
				return Promise.reject(error);
			});
	}
	
	_uniqueColumnValues(field){
		var output = {},
		data = this.table.getData(this.params.valuesLookup),
		column;
		
		if(field){
			column = this.table.columnManager.getColumnByField(field);
		}else {
			column = this.cell.getColumn()._getSelf();
		}
		
		if(column){
			data.forEach((row) => {
				var val = column.getFieldValue(row);
				
				if(val !== null && typeof val !== "undefined" && val !== ""){
					output[val] = true;
				}
			});
		}else {
			console.warn("unable to find matching column to create select lookup list:", field);
			output = [];
		}
		
		return Object.keys(output);
	}
	
	
	_parseList(inputValues){
		var data = [];
		
		if(!Array.isArray(inputValues)){
			inputValues = Object.entries(inputValues).map(([key, value]) => {
				return {
					label:value,
					value:key,
				};
			});
		}
		
		inputValues.forEach((value) => {
			if(typeof value !== "object"){
				value = {
					label:value,
					value:value,
				};
			}
			
			this._parseListItem(value, data, 0);
		});
		
		if(!this.currentItems.length && this.params.freetext){
			this.input.value = this.initialValues;
			this.typing = true;
			this.lastAction = "typing";
		}
		
		this.data = data;
		
		return data;    
	}
	
	_parseListItem(option, data, level){
		var item = {};
		
		if(option.options){
			item = this._parseListGroup(option, level + 1);
		}else {
			item = {
				label:option.label,
				value:option.value,
				itemParams:option.itemParams,
				elementAttributes: option.elementAttributes,
				element:false,
				selected:false,
				visible:true,
				level:level,
				original:option,
			};
			
			if(this.initialValues && this.initialValues.indexOf(option.value) > -1){
				this._chooseItem(item, true);
			}
		}
		
		data.push(item);
	}
	
	_parseListGroup(option, level){
		var item = {
			label:option.label,
			group:true,
			itemParams:option.itemParams,
			elementAttributes:option.elementAttributes,
			element:false,
			visible:true,
			level:level,
			options:[],
			original:option,
		};
		
		option.options.forEach((child) => {
			this._parseListItem(child, item.options, level);
		});
		
		return item;
	}
	
	_sortOptions(options){
		var sorter;
		
		if(this.params.sort){
			sorter = typeof this.params.sort === "function" ? this.params.sort : this._defaultSortFunction.bind(this);
			
			this._sortGroup(sorter, options);
		}
		
		return options;
	}
	
	_sortGroup(sorter, options){
		options.sort((a,b) => {
			return sorter(a.label, b.label, a.value, b.value, a.original, b.original);
		});
		
		options.forEach((option) => {
			if(option.group){
				this._sortGroup(sorter, option.options);
			}
		});
	}
	
	_defaultSortFunction(as, bs){
		var a, b, a1, b1, i= 0, L, rx = /(\d+)|(\D+)/g, rd = /\d/;
		var emptyAlign = 0;
		
		if(this.params.sort === "desc"){
			[as, bs] = [bs, as];
		}
		
		//handle empty values
		if(!as && as!== 0){
			emptyAlign =  !bs && bs!== 0 ? 0 : -1;
		}else if(!bs && bs!== 0){
			emptyAlign =  1;
		}else {
			if(isFinite(as) && isFinite(bs)) return as - bs;
			a = String(as).toLowerCase();
			b = String(bs).toLowerCase();
			if(a === b) return 0;
			if(!(rd.test(a) && rd.test(b))) return a > b ? 1 : -1;
			a = a.match(rx);
			b = b.match(rx);
			L = a.length > b.length ? b.length : a.length;
			while(i < L){
				a1= a[i];
				b1= b[i++];
				if(a1 !== b1){
					if(isFinite(a1) && isFinite(b1)){
						if(a1.charAt(0) === "0") a1 = "." + a1;
						if(b1.charAt(0) === "0") b1 = "." + b1;
						return a1 - b1;
					}
					else return a1 > b1 ? 1 : -1;
				}
			}
			
			return a.length > b.length;
		}
		
		return emptyAlign;
	}
	
	_filterOptions(){
		var filterFunc = this.params.filterFunc || this._defaultFilterFunc,
		term = this.input.value;
		
		if(term){
			this.filtered = true;
			
			this.data.forEach((item) => {
				this._filterItem(filterFunc, term, item);
			});
		}else {
			this.filtered = false;
		}
		
		return this.data;
	}
	
	_filterItem(func, term, item){
		var matches = false;
		
		if(!item.group){
			item.visible = func(term, item.label, item.value, item.original);
		}else {
			item.options.forEach((option) => {
				if(this._filterItem(func, term, option)){
					matches = true;
				}
			});
			
			item.visible = matches;
		}
		
		return item.visible;
	}
	
	_defaultFilterFunc(term, label, value, item){
		term = String(term).toLowerCase();
		
		if(label !== null && typeof label !== "undefined"){
			if(String(label).toLowerCase().indexOf(term) > -1 || String(value).toLowerCase().indexOf(term) > -1){
				return true;
			}
		}
		
		return false;
	}
	
	//////////////////////////////////////
	/////////// Display List /////////////
	//////////////////////////////////////
	
	_clearList(){
		while(this.listEl.firstChild) this.listEl.removeChild(this.listEl.firstChild);
		
		this.displayItems = [];
	}
	
	_buildList(data){
		this._clearList();
		
		data.forEach((option) => {
			this._buildItem(option);
		});
		
		if(!this.displayItems.length){
			this._addPlaceholder(this.params.placeholderEmpty);
		}  
	}
	
	_buildItem(item){
		var el = item.element,
		contents;
		
		if(!this.filtered || item.visible){
			
			if(!el){
				el = document.createElement("div");
				el.tabIndex = 0;
				
				contents = this.params.itemFormatter ? this.params.itemFormatter(item.label, item.value, item.original, el) : item.label;
				
				if(contents instanceof HTMLElement){
					el.appendChild(contents);
				}else {
					el.innerHTML = contents;
				}
				
				if(item.group){
					el.classList.add("tabulator-edit-list-group");
				}else {
					el.classList.add("tabulator-edit-list-item");
				}
				
				el.classList.add("tabulator-edit-list-group-level-" + item.level);
				
				if(item.elementAttributes && typeof item.elementAttributes == "object"){
					for (let key in item.elementAttributes){
						if(key.charAt(0) == "+"){
							key = key.slice(1);
							el.setAttribute(key, this.input.getAttribute(key) + item.elementAttributes["+" + key]);
						}else {
							el.setAttribute(key, item.elementAttributes[key]);
						}
					}
				}
				
				if(item.group){
					el.addEventListener("click", this._groupClick.bind(this, item));
				}else {
					el.addEventListener("click", this._itemClick.bind(this, item));
				}
				
				el.addEventListener("mousedown", this._preventBlur.bind(this));
				
				item.element = el;
			}
			
			this._styleItem(item);
			
			this.listEl.appendChild(el);
			
			if(item.group){
				item.options.forEach((option) => {
					this._buildItem(option);
				});
			}else {
				this.displayItems.push(item);
			}
		}
	}
	
	_showList(){
		var startVis = this.popup && this.popup.isVisible();
		
		if(this.input.parentNode){
			if(this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty){
				if(this.popup){
					this.popup.hide(true);
				}
				return;
			}
			
			this._setListWidth();
			
			if(!this.popup){
				this.popup = this.edit.popup(this.listEl);
			}
			
			this.popup.show(this.cell.getElement(), "bottom");
			
			if(!startVis){
				setTimeout(() => {
					this.popup.hideOnBlur(this._resolveValue.bind(this, true));
				}, 10);
			}
		}
	}
	
	_styleItem(item){
		if(item && item.element){
			if(item.selected){
				item.element.classList.add("active");
			}else {
				item.element.classList.remove("active");
			}
		}
	}
	
	//////////////////////////////////////
	///////// User Interaction ///////////
	//////////////////////////////////////
	
	_itemClick(item, e){
		e.stopPropagation();
		
		this._chooseItem(item);
	}
	
	_groupClick(item, e){
		e.stopPropagation();
	}
	
	
	//////////////////////////////////////
	////// Current Item Management ///////
	//////////////////////////////////////
	
	_cancel(){
		this.popup.hide(true);
		this.actions.cancel();
	}
	
	_clearChoices(){
		this.typing = true;
		
		this.currentItems.forEach((item) => {
			item.selected = false;
			this._styleItem(item);
		});
		
		this.currentItems = [];
		
		this.focusedItem = null;
	}
	
	_chooseItem(item, silent){
		var index;
		
		this.typing = false;
		
		if(this.params.multiselect){
			index = this.currentItems.indexOf(item);
			
			if(index > -1){
				this.currentItems.splice(index, 1);
				item.selected = false;
			}else {
				this.currentItems.push(item);
				item.selected = true;
			}
			
			this.input.value = this.currentItems.map(item => item.label).join(",");
			
			this._styleItem(item);
			
		}else {
			this.currentItems = [item];
			item.selected = true;
			
			this.input.value = item.label;
			
			this._styleItem(item);
			
			if(!silent){
				this._resolveValue();
			}
		}
		
		this._focusItem(item);
	}
	
	_resolveValue(blur){
		var output, initialValue;
		
		if(this.popup){
			this.popup.hide(true);
		}
		
		if(this.params.multiselect){
			output = this.currentItems.map(item => item.value);
		}else {
			if(blur && this.params.autocomplete && this.typing){
				if(this.params.freetext || (this.params.allowEmpty && this.input.value === "")){
					output = this.input.value;
				}else {
					this.actions.cancel();
					return;
				}
			}else {
				if(this.currentItems[0]){
					output = this.currentItems[0].value;
				}else {
					initialValue = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues;
					
					if(initialValue === null || typeof initialValue === "undefined" || initialValue === ""){
						output = initialValue;
					}else {
						output = this.params.emptyValue;
					}
				}
				
			}
		}
		
		if(output === ""){
			output = this.params.emptyValue;
		}
		
		this.actions.success(output);
		
		if(this.isFilter){
			this.initialValues = output && !Array.isArray(output) ? [output] : output;
			this.currentItems = [];
		}
	}
	
}

function select(cell, onRendered, success, cancel, editorParams){

	this.deprecationMsg("The select editor has been deprecated, please use the new list editor");

	var list = new Edit(this, cell, onRendered, success, cancel, editorParams);

	return list.input;
}

function list(cell, onRendered, success, cancel, editorParams){
	var list = new Edit(this, cell, onRendered, success, cancel, editorParams);

	return list.input;
}

function autocomplete(cell, onRendered, success, cancel, editorParams){

	this.deprecationMsg("The autocomplete editor has been deprecated, please use the new list editor with the 'autocomplete' editorParam");

	editorParams.autocomplete = true;

	var list = new Edit(this, cell, onRendered, success, cancel, editorParams);

	return list.input;
}

//star rating
function star(cell, onRendered, success, cancel, editorParams){
	var self = this,
	element = cell.getElement(),
	value = cell.getValue(),
	maxStars = element.getElementsByTagName("svg").length || 5,
	size = element.getElementsByTagName("svg")[0] ? element.getElementsByTagName("svg")[0].getAttribute("width") : 14,
	stars = [],
	starsHolder = document.createElement("div"),
	star = document.createElementNS('http://www.w3.org/2000/svg', "svg");


	//change star type
	function starChange(val){
		stars.forEach(function(star, i){
			if(i < val){
				if(self.table.browser == "ie"){
					star.setAttribute("class", "tabulator-star-active");
				}else {
					star.classList.replace("tabulator-star-inactive", "tabulator-star-active");
				}

				star.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
			}else {
				if(self.table.browser == "ie"){
					star.setAttribute("class", "tabulator-star-inactive");
				}else {
					star.classList.replace("tabulator-star-active", "tabulator-star-inactive");
				}

				star.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
			}
		});
	}

	//build stars
	function buildStar(i){

		var starHolder =  document.createElement("span");
		var nextStar = star.cloneNode(true);

		stars.push(nextStar);

		starHolder.addEventListener("mouseenter", function(e){
			e.stopPropagation();
			e.stopImmediatePropagation();
			starChange(i);
		});

		starHolder.addEventListener("mousemove", function(e){
			e.stopPropagation();
			e.stopImmediatePropagation();
		});

		starHolder.addEventListener("click", function(e){
			e.stopPropagation();
			e.stopImmediatePropagation();
			success(i);
			element.blur();
		});

		starHolder.appendChild(nextStar);
		starsHolder.appendChild(starHolder);

	}

	//handle keyboard navigation value change
	function changeValue(val){
		value = val;
		starChange(val);
	}

	//style cell
	element.style.whiteSpace = "nowrap";
	element.style.overflow = "hidden";
	element.style.textOverflow = "ellipsis";

	//style holding element
	starsHolder.style.verticalAlign = "middle";
	starsHolder.style.display = "inline-block";
	starsHolder.style.padding = "4px";

	//style star
	star.setAttribute("width", size);
	star.setAttribute("height", size);
	star.setAttribute("viewBox", "0 0 512 512");
	star.setAttribute("xml:space", "preserve");
	star.style.padding = "0 1px";

	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				starsHolder.setAttribute(key, starsHolder.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				starsHolder.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}

	//create correct number of stars
	for(var i=1;i<= maxStars;i++){
		buildStar(i);
	}

	//ensure value does not exceed number of stars
	value = Math.min(parseInt(value), maxStars);

	// set initial styling of stars
	starChange(value);

	starsHolder.addEventListener("mousemove", function(e){
		starChange(0);
	});

	starsHolder.addEventListener("click", function(e){
		success(0);
	});

	element.addEventListener("blur", function(e){
		cancel();
	});

	//allow key based navigation
	element.addEventListener("keydown", function(e){
		switch(e.keyCode){
			case 39: //right arrow
				changeValue(value + 1);
				break;

			case 37: //left arrow
				changeValue(value - 1);
				break;

			case 13: //enter
				success(value);
				break;

			case 27: //escape
				cancel();
				break;
		}
	});

	return starsHolder;
}

//draggable progress bar
function progress(cell, onRendered, success, cancel, editorParams){
	var element = cell.getElement(),
	max = typeof editorParams.max === "undefined" ? ((element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("max")) || 100) : editorParams.max,
	min = typeof editorParams.min === "undefined" ? ((element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("min")) || 0) : editorParams.min,
	percent = (max - min) / 100,
	value = cell.getValue() || 0,
	handle = document.createElement("div"),
	bar = document.createElement("div"),
	mouseDrag, mouseDragWidth;

	//set new value
	function updateValue(){
		var style = window.getComputedStyle(element, null);

		var calcVal = (percent * Math.round(bar.offsetWidth / ((element.clientWidth - parseInt(style.getPropertyValue("padding-left")) - parseInt(style.getPropertyValue("padding-right")))/100))) + min;
		success(calcVal);
		element.setAttribute("aria-valuenow", calcVal);
		element.setAttribute("aria-label", value);
	}

	//style handle
	handle.style.position = "absolute";
	handle.style.right = "0";
	handle.style.top = "0";
	handle.style.bottom = "0";
	handle.style.width = "5px";
	handle.classList.add("tabulator-progress-handle");

	//style bar
	bar.style.display = "inline-block";
	bar.style.position = "relative";
	// bar.style.top = "8px";
	// bar.style.bottom = "8px";
	// bar.style.left = "4px";
	// bar.style.marginRight = "4px";
	bar.style.height = "100%";
	bar.style.backgroundColor = "#488CE9";
	bar.style.maxWidth = "100%";
	bar.style.minWidth = "0%";

	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				bar.setAttribute(key, bar.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				bar.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}

	//style cell
	element.style.padding = "4px 4px";

	//make sure value is in range
	value = Math.min(parseFloat(value), max);
	value = Math.max(parseFloat(value), min);

	//workout percentage
	value = Math.round((value - min) / percent);
	// bar.style.right = value + "%";
	bar.style.width = value + "%";

	element.setAttribute("aria-valuemin", min);
	element.setAttribute("aria-valuemax", max);

	bar.appendChild(handle);

	handle.addEventListener("mousedown", function(e){
		mouseDrag = e.screenX;
		mouseDragWidth = bar.offsetWidth;
	});

	handle.addEventListener("mouseover", function(){
		handle.style.cursor = "ew-resize";
	});

	element.addEventListener("mousemove", function(e){
		if(mouseDrag){
			bar.style.width = (mouseDragWidth + e.screenX - mouseDrag) + "px";
		}
	});

	element.addEventListener("mouseup", function(e){
		if(mouseDrag){
			e.stopPropagation();
			e.stopImmediatePropagation();

			mouseDrag = false;
			mouseDragWidth = false;

			updateValue();
		}
	});

	//allow key based navigation
	element.addEventListener("keydown", function(e){
		switch(e.keyCode){
			case 39: //right arrow
				e.preventDefault();
				bar.style.width = (bar.clientWidth + element.clientWidth/100) + "px";
				break;

			case 37: //left arrow
				e.preventDefault();
				bar.style.width = (bar.clientWidth - element.clientWidth/100) + "px";
				break;

			case 9: //tab
			case 13: //enter
				updateValue();
				break;

			case 27: //escape
				cancel();
				break;

		}
	});

	element.addEventListener("blur", function(){
		cancel();
	});

	return bar;
}

//checkbox
function tickCross(cell, onRendered, success, cancel, editorParams){
	var value = cell.getValue(),
	input = document.createElement("input"),
	tristate = editorParams.tristate,
	indetermValue = typeof editorParams.indeterminateValue === "undefined" ? null : editorParams.indeterminateValue,
	indetermState = false,
	trueValueSet = Object.keys(editorParams).includes("trueValue"),
	falseValueSet = Object.keys(editorParams).includes("falseValue");
	
	input.setAttribute("type", "checkbox");
	input.style.marginTop = "5px";
	input.style.boxSizing = "border-box";
	
	if(editorParams.elementAttributes && typeof editorParams.elementAttributes == "object"){
		for (let key in editorParams.elementAttributes){
			if(key.charAt(0) == "+"){
				key = key.slice(1);
				input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
			}else {
				input.setAttribute(key, editorParams.elementAttributes[key]);
			}
		}
	}
	
	input.value = value;
	
	if(tristate && (typeof value === "undefined" || value === indetermValue || value === "")){
		indetermState = true;
		input.indeterminate = true;
	}
	
	if(this.table.browser != "firefox" && this.table.browser != "safari"){ //prevent blur issue on mac firefox
		onRendered(function(){
			if(cell.getType() === "cell"){
				input.focus({preventScroll: true});
			}
		});
	}
	
	input.checked = trueValueSet ? value === editorParams.trueValue : (value === true || value === "true" || value === "True" || value === 1);
	
	function setValue(blur){
		var checkedValue = input.checked;
		
		if(trueValueSet && checkedValue){
			checkedValue = editorParams.trueValue;
		}else if(falseValueSet && !checkedValue){
			checkedValue = editorParams.falseValue;
		}
		
		if(tristate){
			if(!blur){
				if(input.checked && !indetermState){
					input.checked = false;
					input.indeterminate = true;
					indetermState = true;
					return indetermValue;
				}else {
					indetermState = false;
					return checkedValue;
				}
			}else {
				if(indetermState){
					return indetermValue;
				}else {
					return checkedValue;
				}
			}
		}else {
			return checkedValue;
		}
	}
	
	//submit new value on blur
	input.addEventListener("change", function(e){
		success(setValue());
	});

	input.addEventListener("blur", function(e){
		success(setValue(true));
	});
	
	//submit new value on enter
	input.addEventListener("keydown", function(e){
		if(e.keyCode == 13){
			success(setValue());
		}
		if(e.keyCode == 27){
			cancel();
		}
	});
	
	return input;
}

var defaultEditors = {
	input:input,
	textarea:textarea,
	number:number,
	range:range,
	date:date,
	time:time,
	datetime:datetime,
	select:select,
	list:list,
	autocomplete:autocomplete,
	star:star,
	progress:progress,
	tickCross:tickCross,
};

class Edit$1 extends Module{
	
	constructor(table){
		super(table);
		
		this.currentCell = false; //hold currently editing cell
		this.mouseClick = false; //hold mousedown state to prevent click binding being overridden by editor opening
		this.recursionBlock = false; //prevent focus recursion
		this.invalidEdit = false;
		this.editedCells = [];
		
		this.editors = Edit$1.editors;
		
		this.registerColumnOption("editable");
		this.registerColumnOption("editor");
		this.registerColumnOption("editorParams");
		
		this.registerColumnOption("cellEditing");
		this.registerColumnOption("cellEdited");
		this.registerColumnOption("cellEditCancelled");
		
		this.registerTableOption("editTriggerEvent", "focus");
		
		this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this));
		this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this));
		this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this));
		this.registerTableFunction("navigateNext", this.navigateNext.bind(this));
		this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this));
		this.registerTableFunction("navigateRight", this.navigateRight.bind(this));
		this.registerTableFunction("navigateUp", this.navigateUp.bind(this));
		this.registerTableFunction("navigateDown", this.navigateDown.bind(this));
		
		this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this));
		this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this));
		this.registerComponentFunction("cell", "edit", this.editCell.bind(this));
		this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this));
		
		this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this));
		this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this));
		this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this));
		this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this));
		this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this));
		this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
	}
	
	initialize(){
		this.subscribe("cell-init", this.bindEditor.bind(this));
		this.subscribe("cell-delete", this.clearEdited.bind(this));
		this.subscribe("cell-value-changed", this.updateCellClass.bind(this));
		this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
		this.subscribe("column-delete", this.columnDeleteCheck.bind(this));
		this.subscribe("row-deleting", this.rowDeleteCheck.bind(this));
		this.subscribe("row-layout", this.rowEditableCheck.bind(this));
		this.subscribe("data-refreshing", this.cancelEdit.bind(this));
		this.subscribe("clipboard-paste", this.pasteBlocker.bind(this));
		
		this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, undefined));
		this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this));
		
		
		// this.subscribe("keybinding-nav-left", this.navigateLeft.bind(this, undefined));
		// this.subscribe("keybinding-nav-right", this.navigateRight.bind(this, undefined));
		this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, undefined));
		this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, undefined));
	}
	
	
	///////////////////////////////////
	///////// Paste Negation //////////
	///////////////////////////////////
	
	pasteBlocker(e){
		if(this.currentCell){
			return true;
		}
	}
	
	
	///////////////////////////////////
	////// Keybinding Functions ///////
	///////////////////////////////////
	
	keybindingNavigateNext(e){
		var cell = this.currentCell,
		newRow = this.options("tabEndNewRow");

		if(cell){
			if(!this.navigateNext(cell, e)){
				if(newRow){
					cell.getElement().firstChild.blur();
					
					if(!this.invalidEdit){
						
						if(newRow === true){
							newRow = this.table.addRow({});
						}else {
							if(typeof newRow == "function"){
								newRow = this.table.addRow(newRow(cell.row.getComponent()));
							}else {
								newRow = this.table.addRow(Object.assign({}, newRow));
							}
						}
						
						newRow.then(() => {
							setTimeout(() => {
								cell.getComponent().navigateNext();
							});
						});
					}
				}
			}
		}
	}
	
	///////////////////////////////////
	///////// Cell Functions //////////
	///////////////////////////////////
	
	cellIsEdited(cell){
		return !! cell.modules.edit && cell.modules.edit.edited;
	}
	
	cellCancelEdit(cell){
		if(cell === this.currentCell){
			this.table.modules.edit.cancelEdit();
		}else {
			console.warn("Cancel Editor Error - This cell is not currently being edited ");
		}
	}
	
	
	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////
	updateCellClass(cell){
		if(this.allowEdit(cell)) {
			cell.getElement().classList.add("tabulator-editable");
		}
		else {
			cell.getElement().classList.remove("tabulator-editable");
		}
	}
	
	clearCellEdited(cells){
		if(!cells){
			cells = this.table.modules.edit.getEditedCells();
		}
		
		if(!Array.isArray(cells)){
			cells = [cells];
		}
		
		cells.forEach((cell) => {
			this.table.modules.edit.clearEdited(cell._getSelf());
		});
	}
	
	navigatePrev(cell = this.currentCell, e){
		var nextCell, prevRow;
		
		if(cell){
			
			if(e){
				e.preventDefault();
			}
			
			nextCell = this.navigateLeft();
			
			if(nextCell){
				return true;
			}else {
				prevRow = this.table.rowManager.prevDisplayRow(cell.row, true);
				
				if(prevRow){
					nextCell = this.findPrevEditableCell(prevRow, prevRow.cells.length);
					
					if(nextCell){
						nextCell.getComponent().edit();
						return true;
					}
				}
			}
		}
		
		return false;
	}
	
	navigateNext(cell = this.currentCell, e){
		var nextCell, nextRow;
		
		if(cell){
			
			if(e){
				e.preventDefault();
			}
			
			nextCell = this.navigateRight();
			
			if(nextCell){
				return true;
			}else {
				nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
				
				if(nextRow){
					nextCell = this.findNextEditableCell(nextRow, -1);
					
					if(nextCell){
						nextCell.getComponent().edit();
						return true;
					}
				}
			}
		}
		
		return false;
	}
	
	navigateLeft(cell = this.currentCell, e){
		var index, nextCell;
		
		if(cell){
			
			if(e){
				e.preventDefault();
			}
			
			index = cell.getIndex();
			nextCell = this.findPrevEditableCell(cell.row, index);
			
			if(nextCell){
				nextCell.getComponent().edit();
				return true;
			}
		}
		
		return false;
	}
	
	navigateRight(cell = this.currentCell, e){
		var index, nextCell;
		
		if(cell){
			
			if(e){
				e.preventDefault();
			}
			
			index = cell.getIndex();
			nextCell = this.findNextEditableCell(cell.row, index);
			
			if(nextCell){
				nextCell.getComponent().edit();
				return true;
			}
		}
		
		return false;
	}
	
	navigateUp(cell = this.currentCell, e){
		var index, nextRow;
		
		if(cell){
			
			if(e){
				e.preventDefault();
			}
			
			index = cell.getIndex();
			nextRow = this.table.rowManager.prevDisplayRow(cell.row, true);
			
			if(nextRow){
				nextRow.cells[index].getComponent().edit();
				return true;
			}
		}
		
		return false;
	}
	
	navigateDown(cell = this.currentCell, e){
		var index, nextRow;
		
		if(cell){
			
			if(e){
				e.preventDefault();
			}
			
			index = cell.getIndex();
			nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);
			
			if(nextRow){
				nextRow.cells[index].getComponent().edit();
				return true;
			}
		}
		
		return false;
	}
	
	findNextEditableCell(row, index){
		var nextCell = false;
		
		if(index < row.cells.length-1){
			for(var i = index+1; i < row.cells.length; i++){
				let cell = row.cells[i];
				
				if(cell.column.modules.edit && Helpers.elVisible(cell.getElement())){
					let allowEdit = this.allowEdit(cell);
					
					if(allowEdit){
						nextCell = cell;
						break;
					}
				}
			}
		}
		
		return nextCell;
	}
	
	findPrevEditableCell(row, index){
		var prevCell = false;
		
		if(index > 0){
			for(var i = index-1; i >= 0; i--){
				let cell = row.cells[i];
				
				if(cell.column.modules.edit && Helpers.elVisible(cell.getElement())){
					let allowEdit = this.allowEdit(cell);
					
					if(allowEdit){
						prevCell = cell;
						break;
					}
				}
			}
		}
		
		return prevCell;
	}
	
	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////
	
	initializeColumnCheck(column){
		if(typeof column.definition.editor !== "undefined"){
			this.initializeColumn(column);
		}
	}
	
	columnDeleteCheck(column){
		if(this.currentCell && this.currentCell.column === column){
			this.cancelEdit();
		}
	}
	
	rowDeleteCheck(row){
		if(this.currentCell && this.currentCell.row === row){
			this.cancelEdit();
		}
	}
	
	rowEditableCheck(row){
		row.getCells().forEach((cell) => {
			if(cell.column.modules.edit && typeof cell.column.modules.edit.check === "function"){
				this.updateCellClass(cell);
			}
		});
	}
	
	//initialize column editor
	initializeColumn(column){
		var config = {
			editor:false,
			blocked:false,
			check:column.definition.editable,
			params:column.definition.editorParams || {}
		};
		
		//set column editor
		switch(typeof column.definition.editor){
			case "string":
				if(this.editors[column.definition.editor]){
					config.editor = this.editors[column.definition.editor];
				}else {
					console.warn("Editor Error - No such editor found: ", column.definition.editor);
				}
				break;
			
			case "function":
				config.editor = column.definition.editor;
				break;
			
			case "boolean":
				if(column.definition.editor === true){
					if(typeof column.definition.formatter !== "function"){
						if(this.editors[column.definition.formatter]){
							config.editor = this.editors[column.definition.formatter];
						}else {
							config.editor = this.editors["input"];
						}
					}else {
						console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", column.definition.formatter);
					}
				}
				break;
		}
		
		if(config.editor){
			column.modules.edit = config;
		}
	}
	
	getCurrentCell(){
		return this.currentCell ? this.currentCell.getComponent() : false;
	}
	
	clearEditor(cancel){
		var cell = this.currentCell,
		cellEl;
		
		this.invalidEdit = false;
		
		if(cell){
			this.currentCell = false;
			
			cellEl = cell.getElement();
			
			this.dispatch("edit-editor-clear", cell, cancel);
			
			cellEl.classList.remove("tabulator-editing");
			
			while(cellEl.firstChild) cellEl.removeChild(cellEl.firstChild);
			
			cell.row.getElement().classList.remove("tabulator-editing");
			
			cell.table.element.classList.remove("tabulator-editing");
		}
	}
	
	cancelEdit(){
		if(this.currentCell){
			var cell = this.currentCell;
			var component = this.currentCell.getComponent();
			
			this.clearEditor(true);
			cell.setValueActual(cell.getValue());
			cell.cellRendered();
			
			if(cell.column.definition.editor == "textarea" || cell.column.definition.variableHeight){
				cell.row.normalizeHeight(true);
			}
			
			if(cell.column.definition.cellEditCancelled){
				cell.column.definition.cellEditCancelled.call(this.table, component);
			}
			
			this.dispatch("edit-cancelled", cell);
			this.dispatchExternal("cellEditCancelled", component);
		}
	}
	
	//return a formatted value for a cell
	bindEditor(cell){
		if(cell.column.modules.edit){
			var self = this,
			element = cell.getElement(true);
			
			this.updateCellClass(cell);
			element.setAttribute("tabindex", 0);
			
			element.addEventListener("mousedown", function(e){
				if (e.button === 2) {
					e.preventDefault();
				}else {
					self.mouseClick = true;
				}
			});

			if(this.options("editTriggerEvent") === "dblclick"){
				element.addEventListener("dblclick", function(e){
					if(!element.classList.contains("tabulator-editing")){
						element.focus({preventScroll: true});
						self.edit(cell, e, false);
					}
				});
			}
			
			
			if(this.options("editTriggerEvent") === "focus" || this.options("editTriggerEvent") === "click"){
				element.addEventListener("click", function(e){
					if(!element.classList.contains("tabulator-editing")){
						element.focus({preventScroll: true});
						self.edit(cell, e, false);
					}
				});
			}
			
			if(this.options("editTriggerEvent") === "focus"){
				element.addEventListener("focus", function(e){
					if(!self.recursionBlock){
						self.edit(cell, e, false);
					}
				});
			}
		}
	}
	
	focusCellNoEvent(cell, block){
		this.recursionBlock = true;
		
		if(!(block && this.table.browser === "ie")){
			cell.getElement().focus({preventScroll: true});
		}
		
		this.recursionBlock = false;
	}
	
	editCell(cell, forceEdit){
		this.focusCellNoEvent(cell);
		this.edit(cell, false, forceEdit);
	}
	
	focusScrollAdjust(cell){
		if(this.table.rowManager.getRenderMode() == "virtual"){
			var topEdge = this.table.rowManager.element.scrollTop,
			bottomEdge = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop,
			rowEl = cell.row.getElement();
			
			if(rowEl.offsetTop < topEdge){
				this.table.rowManager.element.scrollTop -= (topEdge - rowEl.offsetTop);
			}else {
				if(rowEl.offsetTop + rowEl.offsetHeight  > bottomEdge){
					this.table.rowManager.element.scrollTop += (rowEl.offsetTop + rowEl.offsetHeight - bottomEdge);
				}
			}
			
			var leftEdge = this.table.rowManager.element.scrollLeft,
			rightEdge = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft,
			cellEl = cell.getElement();
			
			if(this.table.modExists("frozenColumns")){
				leftEdge += parseInt(this.table.modules.frozenColumns.leftMargin || 0);
				rightEdge -= parseInt(this.table.modules.frozenColumns.rightMargin || 0);
			}
			
			if(this.table.options.renderHorizontal === "virtual"){
				leftEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
				rightEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
			}
			
			if(cellEl.offsetLeft < leftEdge){
				this.table.rowManager.element.scrollLeft -= (leftEdge - cellEl.offsetLeft);
			}else {
				if(cellEl.offsetLeft + cellEl.offsetWidth  > rightEdge){
					this.table.rowManager.element.scrollLeft += (cellEl.offsetLeft + cellEl.offsetWidth - rightEdge);
				}
			}
		}
	}
	
	allowEdit(cell) {
		var check = cell.column.modules.edit ? true : false;
		
		if(cell.column.modules.edit){
			switch(typeof cell.column.modules.edit.check){
				case "function":
					if(cell.row.initialized){
						check = cell.column.modules.edit.check(cell.getComponent());
					}
					break;
				
				case "string":
					check = !!cell.row.data[cell.column.modules.edit.check];
					break;
				
				case "boolean":
					check = cell.column.modules.edit.check;
					break;
			}
		}
		
		return check;
	}
	
	edit(cell, e, forceEdit){
		var self = this,
		allowEdit = true,
		rendered = function(){},
		element = cell.getElement(),
		editFinished = false,
		cellEditor, component, params;

		//prevent editing if another cell is refusing to leave focus (eg. validation fail)
		
		if(this.currentCell){
			if(!this.invalidEdit && this.currentCell !== cell){
				this.cancelEdit();
			}
			return;
		}
		
		//handle successful value change
		function success(value){
			if(self.currentCell === cell && !editFinished){
				var valid = self.chain("edit-success", [cell, value], true, true);

				if(valid === true || self.table.options.validationMode === "highlight"){

					editFinished = true;

					self.clearEditor();
					
					if(!cell.modules.edit){
						cell.modules.edit = {};
					}
					
					cell.modules.edit.edited = true;
					
					if(self.editedCells.indexOf(cell) == -1){
						self.editedCells.push(cell);
					}
					
					cell.setValue(value, true);

					return valid === true;
				}else {
					editFinished = true;
					self.invalidEdit = true;
					self.focusCellNoEvent(cell, true);
					rendered();

					setTimeout(() => {
						editFinished = false;
					}, 10);
					return false;
				}
			}
		}
		
		//handle aborted edit
		function cancel(){
			// editFinished = true;

			if(self.currentCell === cell && !editFinished){
				self.cancelEdit();
			}
		}
		
		function onRendered(callback){
			rendered = callback;
		}
		
		if(!cell.column.modules.edit.blocked){
			if(e){
				e.stopPropagation();
			}
			
			allowEdit = this.allowEdit(cell);
			
			if(allowEdit || forceEdit){
				self.cancelEdit();
				
				self.currentCell = cell;
				
				this.focusScrollAdjust(cell);
				
				component = cell.getComponent();
				
				if(this.mouseClick){
					this.mouseClick = false;
					
					if(cell.column.definition.cellClick){
						cell.column.definition.cellClick.call(this.table, e, component);
					}
				}
				
				if(cell.column.definition.cellEditing){
					cell.column.definition.cellEditing.call(this.table, component);
				}
				
				this.dispatch("cell-editing", cell);
				this.dispatchExternal("cellEditing", component);
				
				params = typeof cell.column.modules.edit.params === "function" ? cell.column.modules.edit.params(component) : cell.column.modules.edit.params;
				
				cellEditor = cell.column.modules.edit.editor.call(self, component, onRendered, success, cancel, params);
				
				//if editor returned, add to DOM, if false, abort edit
				if(this.currentCell && cellEditor !== false){
					if(cellEditor instanceof Node){
						element.classList.add("tabulator-editing");
						cell.row.getElement().classList.add("tabulator-editing");
						cell.table.element.classList.add("tabulator-editing");
						while(element.firstChild) element.removeChild(element.firstChild);
						element.appendChild(cellEditor);
						
						//trigger onRendered Callback
						rendered();
						
						//prevent editing from triggering rowClick event
						var children = element.children;
						
						for (var i = 0; i < children.length; i++) {
							children[i].addEventListener("click", function(e){
								e.stopPropagation();
							});
						}
					}else {
						console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", cellEditor);
						this.blur(element);
						return false;
					}
				}else {
					this.blur(element);
					return false;
				}
				
				return true;
			}else {
				this.mouseClick = false;
				this.blur(element);
				return false;
			}
		}else {
			this.mouseClick = false;
			this.blur(element);
			return false;
		}
	}
	
	blur(element){
		if(!this.confirm("edit-blur", [element]) ){
			element.blur();
		}
	}
	
	getEditedCells(){
		var output = [];
		
		this.editedCells.forEach((cell) => {
			output.push(cell.getComponent());
		});
		
		return output;
	}
	
	clearEdited(cell){
		var editIndex;
		
		if(cell.modules.edit && cell.modules.edit.edited){
			cell.modules.edit.edited = false;
			
			this.dispatch("edit-edited-clear", cell);
		}
		
		editIndex = this.editedCells.indexOf(cell);
		
		if(editIndex > -1){
			this.editedCells.splice(editIndex, 1);
		}
	}
}

Edit$1.moduleName = "edit";

//load defaults
Edit$1.editors = defaultEditors;

class ExportRow{
	constructor(type, columns, component, indent){
		this.type = type;
		this.columns = columns;
		this.component = component || false;
		this.indent = indent || 0;
	}
}

class ExportColumn{
	constructor(value, component, width, height, depth){
		this.value = value;
		this.component = component || false;
		this.width = width;
		this.height = height;
		this.depth = depth;
	}
}

class Export extends Module{
	
	constructor(table){
		super(table);
		
		this.config = {};
		this.cloneTableStyle = true;
		this.colVisProp = "";
		
		this.registerTableOption("htmlOutputConfig", false); //html output config
		
		this.registerColumnOption("htmlOutput");
		this.registerColumnOption("titleHtmlOutput");
	}
	
	initialize(){
		this.registerTableFunction("getHtml", this.getHtml.bind(this));
	}
	
	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////
	
	
	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////
	
	generateExportList(config, style, range, colVisProp){
		this.cloneTableStyle = style;
		this.config = config || {};
		this.colVisProp = colVisProp;

		var headers, body;
		
		if (range === 'range') {
			var columns = this.table.modules.selectRange.selectedColumns();
			headers = this.config.columnHeaders !== false
				? this.headersToExportRows(this.generateColumnGroupHeaders(columns))
				: [];
			body = this.bodyToExportRows(this.rowLookup(range), this.table.modules.selectRange.selectedColumns(true));
		} else {
			headers = this.config.columnHeaders !== false ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [];
			body = this.bodyToExportRows(this.rowLookup(range));
		}

		return headers.concat(body);
	}
	
	generateTable(config, style, range, colVisProp){
		var list = this.generateExportList(config, style, range, colVisProp);
		
		return this.generateTableElement(list);
	}
	
	rowLookup(range){
		var rows = [];
		
		if(typeof range == "function"){
			range.call(this.table).forEach((row) =>{
				row = this.table.rowManager.findRow(row);
				
				if(row){
					rows.push(row);
				}
			});
		}else {
			switch(range){
				case true:
				case "visible":
					rows = this.table.rowManager.getVisibleRows(false, true);
					break;
				
				case "all":
					rows = this.table.rowManager.rows;
					break;
				
				case "selected":
					rows = this.table.modules.selectRow.selectedRows;
					break;

				case "range":
					rows = this.table.modules.selectRange.selectedRows();
					break;

				case "active":
				default:
					if(this.table.options.pagination){
						rows = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2);
					}else {
						rows = this.table.rowManager.getDisplayRows();
					}
			}
		}
		
		return Object.assign([], rows);
	}
	
	generateColumnGroupHeaders(columns){
		var output = [];
		
		if (!columns) {
			columns = this.config.columnGroups !== false ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
		}
		
		columns.forEach((column) => {
			var colData = this.processColumnGroup(column);
			
			if(colData){
				output.push(colData);
			}
		});

		return output;
	}
	
	processColumnGroup(column){
		var subGroups = column.columns,
		maxDepth = 0,
		title = column.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || column.definition.title;
		
		var groupData = {
			title:title,
			column:column,
			depth:1,
		};
		
		if(subGroups.length){
			groupData.subGroups = [];
			groupData.width = 0;
			
			subGroups.forEach((subGroup) => {
				var subGroupData = this.processColumnGroup(subGroup);
				
				if(subGroupData){
					groupData.width += subGroupData.width;
					groupData.subGroups.push(subGroupData);
					
					if(subGroupData.depth > maxDepth){
						maxDepth = subGroupData.depth;
					}
				}
			});
			
			groupData.depth += maxDepth;
			
			if(!groupData.width){
				return false;
			}
		}else {
			if(this.columnVisCheck(column)){
				groupData.width = 1;
			}else {
				return false;
			}
		}
		
		return groupData;
	}
	
	columnVisCheck(column){
		var visProp = column.definition[this.colVisProp];
		
		if(typeof visProp === "function"){
			visProp = visProp.call(this.table, column.getComponent());
		}
		
		return visProp !== false && (column.visible || (!column.visible && visProp));
	}
	
	headersToExportRows(columns){
		var headers = [],
		headerDepth = 0,
		exportRows = [];
		
		function parseColumnGroup(column, level){
			
			var depth = headerDepth - level;
			
			if(typeof headers[level] === "undefined"){
				headers[level] = [];
			}
			
			column.height = column.subGroups ? 1 : (depth - column.depth) + 1;
			
			headers[level].push(column);
			
			if(column.height > 1){
				for(let i = 1; i < column.height; i ++){
					
					if(typeof headers[level + i] === "undefined"){
						headers[level + i] = [];
					}
					
					headers[level + i].push(false);
				}
			}
			
			if(column.width > 1){
				for(let i = 1; i < column.width; i ++){
					headers[level].push(false);
				}
			}
			
			if(column.subGroups){
				column.subGroups.forEach(function(subGroup){
					parseColumnGroup(subGroup, level+1);
				});
			}
		}
		
		//calculate maximum header depth
		columns.forEach(function(column){
			if(column.depth > headerDepth){
				headerDepth = column.depth;
			}
		});
		
		columns.forEach(function(column){
			parseColumnGroup(column,0);
		});
		
		headers.forEach((header) => {
			var columns = [];
			
			header.forEach((col) => {
				if(col){
					let title = typeof col.title === "undefined" ? "" : col.title;
					columns.push(new ExportColumn(title, col.column.getComponent(), col.width, col.height, col.depth));
				}else {
					columns.push(null);
				}
			});
			
			exportRows.push(new ExportRow("header", columns));
		});
		
		return exportRows;
	}
	
	bodyToExportRows(rows, columns = []){
		var exportRows = [];
		
		if (columns.length === 0) {
			this.table.columnManager.columnsByIndex.forEach((column) => {
				if (this.columnVisCheck(column)) {
					columns.push(column.getComponent());
				}
			});
		}
		
		if(this.config.columnCalcs !== false && this.table.modExists("columnCalcs")){
			if(this.table.modules.columnCalcs.topInitialized){
				rows.unshift(this.table.modules.columnCalcs.topRow);
			}
			
			if(this.table.modules.columnCalcs.botInitialized){
				rows.push(this.table.modules.columnCalcs.botRow);
			}
		}

		rows = rows.filter((row) => {
			switch(row.type){
				case "group":
					return this.config.rowGroups !== false;
				
				case "calc":
					return this.config.columnCalcs !== false;
				
				case "row":
					return !(this.table.options.dataTree && this.config.dataTree === false && row.modules.dataTree.parent);
			}
			
			return true;
		});
		
		rows.forEach((row, i) => {
			var rowData = row.getData(this.colVisProp);
			var exportCols = [];
			var indent = 0;
			
			switch(row.type){
				case "group":
					indent = row.level;
					exportCols.push(new ExportColumn(row.key, row.getComponent(), columns.length, 1));
					break;
				
				case "calc" :
				case "row" :
					columns.forEach((col) => {
						exportCols.push(new ExportColumn(col._column.getFieldValue(rowData), col, 1, 1));
					});
				
					if(this.table.options.dataTree && this.config.dataTree !== false){
						indent = row.modules.dataTree.index;
					}
					break;
			}
			
			exportRows.push(new ExportRow(row.type, exportCols, row.getComponent(), indent));
		});
		
		return exportRows;
	}
	
	generateTableElement(list){
		var table = document.createElement("table"),
		headerEl = document.createElement("thead"),
		bodyEl = document.createElement("tbody"),
		styles = this.lookupTableStyles(),
		rowFormatter = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))],
		setup = {};
		
		setup.rowFormatter = rowFormatter !== null ? rowFormatter : this.table.options.rowFormatter;
		
		if(this.table.options.dataTree &&this.config.dataTree !== false && this.table.modExists("columnCalcs")){
			setup.treeElementField = this.table.modules.dataTree.elementField;
		}
		
		//assign group header formatter
		setup.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))];
		
		if(setup.groupHeader && !Array.isArray(setup.groupHeader)){
			setup.groupHeader = [setup.groupHeader];
		}
		
		table.classList.add("tabulator-print-table");
		
		this.mapElementStyles(this.table.columnManager.getHeadersElement(), headerEl, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
		
		
		if(list.length > 1000){
			console.warn("It may take a long time to render an HTML table with more than 1000 rows");
		}
		
		list.forEach((row, i) => {
			let rowEl;
			
			switch(row.type){
				case "header":
					headerEl.appendChild(this.generateHeaderElement(row, setup, styles));
					break;
				
				case "group":
					bodyEl.appendChild(this.generateGroupElement(row, setup, styles));
					break;
				
				case "calc":
					bodyEl.appendChild(this.generateCalcElement(row, setup, styles));
					break;
				
				case "row":
					rowEl = this.generateRowElement(row, setup, styles);
				
					this.mapElementStyles(((i % 2) && styles.evenRow) ? styles.evenRow : styles.oddRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
					bodyEl.appendChild(rowEl);
					break;
			}
		});
		
		if(headerEl.innerHTML){
			table.appendChild(headerEl);
		}
		
		table.appendChild(bodyEl);
		
		
		this.mapElementStyles(this.table.element, table, ["border-top", "border-left", "border-right", "border-bottom"]);
		return table;
	}
	
	lookupTableStyles(){
		var styles = {};
		
		//lookup row styles
		if(this.cloneTableStyle && window.getComputedStyle){
			styles.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)");
			styles.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)");
			styles.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs");
			styles.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)");
			styles.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0];
			
			if(styles.firstRow){
				styles.styleCells = styles.firstRow.getElementsByClassName("tabulator-cell");
				styles.firstCell = styles.styleCells[0];
				styles.lastCell = styles.styleCells[styles.styleCells.length - 1];
			}
		}
		
		return styles;
	}
	
	generateHeaderElement(row, setup, styles){
		var rowEl = document.createElement("tr");
		
		row.columns.forEach((column) => {
			if(column){
				var cellEl = document.createElement("th");
				var classNames = column.component._column.definition.cssClass ? column.component._column.definition.cssClass.split(" ") : [];
				
				cellEl.colSpan = column.width;
				cellEl.rowSpan = column.height;
				
				cellEl.innerHTML = column.value;
				
				if(this.cloneTableStyle){
					cellEl.style.boxSizing = "border-box";
				}
				
				classNames.forEach(function(className) {
					cellEl.classList.add(className);
				});
				
				this.mapElementStyles(column.component.getElement(), cellEl, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
				this.mapElementStyles(column.component._column.contentElement, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
				
				if(column.component._column.visible){
					this.mapElementStyles(column.component.getElement(), cellEl, ["width"]);
				}else {
					if(column.component._column.definition.width){
						cellEl.style.width = column.component._column.definition.width + "px";
					}
				}
				
				if(column.component._column.parent){
					this.mapElementStyles(column.component._column.parent.groupElement, cellEl, ["border-top"]);
				}
				
				rowEl.appendChild(cellEl);
			}
		});
		
		return rowEl;
	}
	
	generateGroupElement(row, setup, styles){
		
		var rowEl = document.createElement("tr"),
		cellEl = document.createElement("td"),
		group = row.columns[0];
		
		rowEl.classList.add("tabulator-print-table-row");
		
		if(setup.groupHeader && setup.groupHeader[row.indent]){
			group.value = setup.groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
		}else {
			if(setup.groupHeader !== false){
				group.value = row.component._group.generator(group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
			}
		}
		
		cellEl.colSpan = group.width;
		cellEl.innerHTML = group.value;
		
		rowEl.classList.add("tabulator-print-table-group");
		rowEl.classList.add("tabulator-group-level-" + row.indent);
		
		if(group.component.isVisible()){
			rowEl.classList.add("tabulator-group-visible");
		}
		
		this.mapElementStyles(styles.firstGroup, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
		this.mapElementStyles(styles.firstGroup, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
		
		rowEl.appendChild(cellEl);
		
		return rowEl;
	}
	
	generateCalcElement(row, setup, styles){
		var rowEl = this.generateRowElement(row, setup, styles);
		
		rowEl.classList.add("tabulator-print-table-calcs");
		this.mapElementStyles(styles.calcRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
		
		return rowEl;
	}
	
	generateRowElement(row, setup, styles){
		var rowEl = document.createElement("tr");
		
		rowEl.classList.add("tabulator-print-table-row");
		
		row.columns.forEach((col, i) => {
			if(col){
				var cellEl = document.createElement("td"),
				column = col.component._column,
				table =  this.table,
				index = table.columnManager.findColumnIndex(column),
				value = col.value,
				cellStyle;
				
				var cellWrapper = {
					modules:{},
					getValue:function(){
						return value;
					},
					getField:function(){
						return column.definition.field;
					},
					getElement:function(){
						return cellEl;
					},
					getType:function(){
						return "cell";
					},
					getColumn:function(){
						return column.getComponent();
					},
					getData:function(){
						return row.component.getData();
					},
					getRow:function(){
						return row.component;
					},
					getTable:function(){
						return table;
					},
					getComponent:function(){
						return cellWrapper;
					},
					column:column,
				};
				
				var classNames = column.definition.cssClass ? column.definition.cssClass.split(" ") : [];
				
				classNames.forEach(function(className) {
					cellEl.classList.add(className);
				});
				
				if(this.table.modExists("format") && this.config.formatCells !== false){
					value = this.table.modules.format.formatExportValue(cellWrapper, this.colVisProp);
				}else {
					switch(typeof value){
						case "object":
							value = value !== null ? JSON.stringify(value) : "";
							break;
						
						case "undefined":
							value = "";
							break;
					}
				}
				
				if(value instanceof Node){
					cellEl.appendChild(value);
				}else {
					cellEl.innerHTML = value;
				}
				
				cellStyle = styles.styleCells && styles.styleCells[index] ? styles.styleCells[index] : styles.firstCell;
				
				if(cellStyle){
					this.mapElementStyles(cellStyle, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"]);
					
					if(column.definition.align){
						cellEl.style.textAlign = column.definition.align;
					}
				}
				
				if(this.table.options.dataTree && this.config.dataTree !== false){
					if((setup.treeElementField && setup.treeElementField == column.field) || (!setup.treeElementField && i == 0)){
						if(row.component._row.modules.dataTree.controlEl){
							cellEl.insertBefore(row.component._row.modules.dataTree.controlEl.cloneNode(true), cellEl.firstChild);
						}
						if(row.component._row.modules.dataTree.branchEl){
							cellEl.insertBefore(row.component._row.modules.dataTree.branchEl.cloneNode(true), cellEl.firstChild);
						}
					}
				}
				
				rowEl.appendChild(cellEl);
				
				if(cellWrapper.modules.format && cellWrapper.modules.format.renderedCallback){
					cellWrapper.modules.format.renderedCallback();
				}
			}
		});
		
		if(setup.rowFormatter && row.type === "row" && this.config.formatCells !== false){
			let formatComponent = Object.assign(row.component);

			formatComponent.getElement = function(){return rowEl;};

			setup.rowFormatter(row.component);
		}
		
		return rowEl;
	}
	
	generateHTMLTable(list){
		var holder = document.createElement("div");
		
		holder.appendChild(this.generateTableElement(list));
		
		return holder.innerHTML;
	}
	
	getHtml(visible, style, config, colVisProp){
		var list = this.generateExportList(config || this.table.options.htmlOutputConfig, style, visible, colVisProp || "htmlOutput");
		
		return this.generateHTMLTable(list);
	}
	
	mapElementStyles(from, to, props){
		if(this.cloneTableStyle && from && to){
			
			var lookup = {
				"background-color" : "backgroundColor",
				"color" : "fontColor",
				"width" : "width",
				"font-weight" : "fontWeight",
				"font-family" : "fontFamily",
				"font-size" : "fontSize",
				"text-align" : "textAlign",
				"border-top" : "borderTop",
				"border-left" : "borderLeft",
				"border-right" : "borderRight",
				"border-bottom" : "borderBottom",
				"padding-top" : "paddingTop",
				"padding-left" : "paddingLeft",
				"padding-right" : "paddingRight",
				"padding-bottom" : "paddingBottom",
			};
			
			if(window.getComputedStyle){
				var fromStyle = window.getComputedStyle(from);
				
				props.forEach(function(prop){
					if(!to.style[lookup[prop]]){
						to.style[lookup[prop]] = fromStyle.getPropertyValue(prop);
					}
				});
			}
		}
	}
}

Export.moduleName = "export";

var defaultFilters = {

	//equal to
	"=":function(filterVal, rowVal, rowData, filterParams){
		return rowVal == filterVal ? true : false;
	},

	//less than
	"<":function(filterVal, rowVal, rowData, filterParams){
		return rowVal < filterVal ? true : false;
	},

	//less than or equal to
	"<=":function(filterVal, rowVal, rowData, filterParams){
		return rowVal <= filterVal ? true : false;
	},

	//greater than
	">":function(filterVal, rowVal, rowData, filterParams){
		return rowVal > filterVal ? true : false;
	},

	//greater than or equal to
	">=":function(filterVal, rowVal, rowData, filterParams){
		return rowVal >= filterVal ? true : false;
	},

	//not equal to
	"!=":function(filterVal, rowVal, rowData, filterParams){
		return rowVal != filterVal ? true : false;
	},

	"regex":function(filterVal, rowVal, rowData, filterParams){

		if(typeof filterVal == "string"){
			filterVal = new RegExp(filterVal);
		}

		return filterVal.test(rowVal);
	},

	//contains the string
	"like":function(filterVal, rowVal, rowData, filterParams){
		if(filterVal === null || typeof filterVal === "undefined"){
			return rowVal === filterVal ? true : false;
		}else {
			if(typeof rowVal !== 'undefined' && rowVal !== null){
				return String(rowVal).toLowerCase().indexOf(filterVal.toLowerCase()) > -1;
			}
			else {
				return false;
			}
		}
	},

	//contains the keywords
	"keywords":function(filterVal, rowVal, rowData, filterParams){
		var keywords = filterVal.toLowerCase().split(typeof filterParams.separator === "undefined" ? " " : filterParams.separator),
		value = String(rowVal === null || typeof rowVal === "undefined" ? "" : rowVal).toLowerCase(),
		matches = [];

		keywords.forEach((keyword) =>{
			if(value.includes(keyword)){
				matches.push(true);
			}
		});

		return filterParams.matchAll ? matches.length === keywords.length : !!matches.length;
	},

	//starts with the string
	"starts":function(filterVal, rowVal, rowData, filterParams){
		if(filterVal === null || typeof filterVal === "undefined"){
			return rowVal === filterVal ? true : false;
		}else {
			if(typeof rowVal !== 'undefined' && rowVal !== null){
				return String(rowVal).toLowerCase().startsWith(filterVal.toLowerCase());
			}
			else {
				return false;
			}
		}
	},

	//ends with the string
	"ends":function(filterVal, rowVal, rowData, filterParams){
		if(filterVal === null || typeof filterVal === "undefined"){
			return rowVal === filterVal ? true : false;
		}else {
			if(typeof rowVal !== 'undefined' && rowVal !== null){
				return String(rowVal).toLowerCase().endsWith(filterVal.toLowerCase());
			}
			else {
				return false;
			}
		}
	},

	//in array
	"in":function(filterVal, rowVal, rowData, filterParams){
		if(Array.isArray(filterVal)){
			return filterVal.length ? filterVal.indexOf(rowVal) > -1 : true;
		}else {
			console.warn("Filter Error - filter value is not an array:", filterVal);
			return false;
		}
	},
};

class Filter extends Module{

	constructor(table){
		super(table);

		this.filterList = []; //hold filter list
		this.headerFilters = {}; //hold column filters
		this.headerFilterColumns = []; //hold columns that use header filters

		this.prevHeaderFilterChangeCheck = "";
		this.prevHeaderFilterChangeCheck = "{}";

		this.changed = false; //has filtering changed since last render
		this.tableInitialized = false;

		this.registerTableOption("filterMode", "local"); //local or remote filtering

		this.registerTableOption("initialFilter", false); //initial filtering criteria
		this.registerTableOption("initialHeaderFilter", false); //initial header filtering criteria
		this.registerTableOption("headerFilterLiveFilterDelay", 300); //delay before updating column after user types in header filter
		this.registerTableOption("placeholderHeaderFilter", false); //placeholder when header filter is empty

		this.registerColumnOption("headerFilter");
		this.registerColumnOption("headerFilterPlaceholder");
		this.registerColumnOption("headerFilterParams");
		this.registerColumnOption("headerFilterEmptyCheck");
		this.registerColumnOption("headerFilterFunc");
		this.registerColumnOption("headerFilterFuncParams");
		this.registerColumnOption("headerFilterLiveFilter");

		this.registerTableFunction("searchRows", this.searchRows.bind(this));
		this.registerTableFunction("searchData", this.searchData.bind(this));

		this.registerTableFunction("setFilter", this.userSetFilter.bind(this));
		this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this));
		this.registerTableFunction("addFilter", this.userAddFilter.bind(this));
		this.registerTableFunction("getFilters", this.getFilters.bind(this));
		this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this));
		this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this));
		this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this));
		this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this));
		this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this));
		this.registerTableFunction("clearFilter", this.userClearFilter.bind(this));
		this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this));

		this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this));
		this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this));
		this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this));
		this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
	}

	initialize(){
		this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this));
		this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this));
		this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this));
		this.subscribe("table-built", this.tableBuilt.bind(this));
		this.subscribe("placeholder", this.generatePlaceholder.bind(this));

		if(this.table.options.filterMode === "remote"){
			this.subscribe("data-params", this.remoteFilterParams.bind(this));
		}

		this.registerDataHandler(this.filter.bind(this), 10);
	}

	tableBuilt(){
		if(this.table.options.initialFilter){
			this.setFilter(this.table.options.initialFilter);
		}

		if(this.table.options.initialHeaderFilter){
			this.table.options.initialHeaderFilter.forEach((item) => {

				var column = this.table.columnManager.findColumn(item.field);

				if(column){
					this.setHeaderFilterValue(column, item.value);
				}else {
					console.warn("Column Filter Error - No matching column found:", item.field);
					return false;
				}
			});
		}

		this.tableInitialized = true;
	}

	remoteFilterParams(data, config, silent, params){
		params.filter = this.getFilters(true, true);
		return params;
	}

	generatePlaceholder(text){
		if(this.table.options.placeholderHeaderFilter && Object.keys(this.headerFilters).length){
			return this.table.options.placeholderHeaderFilter;
		}
	}

	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////

	//set standard filters
	userSetFilter(field, type, value, params){
		this.setFilter(field, type, value, params);
		this.refreshFilter();
	}

	//set standard filters
	userRefreshFilter(){
		this.refreshFilter();
	}

	//add filter to array
	userAddFilter(field, type, value, params){
		this.addFilter(field, type, value, params);
		this.refreshFilter();
	}

	userSetHeaderFilterFocus(field){
		var column = this.table.columnManager.findColumn(field);

		if(column){
			this.setHeaderFilterFocus(column);
		}else {
			console.warn("Column Filter Focus Error - No matching column found:", field);
			return false;
		}
	}

	userGetHeaderFilterValue(field) {
		var column = this.table.columnManager.findColumn(field);

		if(column){
			return this.getHeaderFilterValue(column);
		}else {
			console.warn("Column Filter Error - No matching column found:", field);
		}
	}

	userSetHeaderFilterValue(field, value){
		var column = this.table.columnManager.findColumn(field);

		if(column){
			this.setHeaderFilterValue(column, value);
		}else {
			console.warn("Column Filter Error - No matching column found:", field);
			return false;
		}
	}

	//remove filter from array
	userRemoveFilter(field, type, value){
		this.removeFilter(field, type, value);
		this.refreshFilter();
	}

	//clear filters
	userClearFilter(all){
		this.clearFilter(all);
		this.refreshFilter();
	}

	//clear header filters
	userClearHeaderFilter(){
		this.clearHeaderFilter();
		this.refreshFilter();
	}


	//search for specific row components
	searchRows(field, type, value){
		return this.search("rows", field, type, value);
	}

	//search for specific data
	searchData(field, type, value){
		return this.search("data", field, type, value);
	}

	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////

	initializeColumnHeaderFilter(column){
		var def = column.definition;

		if(def.headerFilter){
			this.initializeColumn(column);
		}
	}

	//initialize column header filter
	initializeColumn(column, value){
		var self = this,
		field = column.getField();

		//handle successfully value change
		function success(value){
			var filterType = (column.modules.filter.tagType == "input" && column.modules.filter.attrType == "text") || column.modules.filter.tagType == "textarea" ? "partial" : "match",
			type = "",
			filterChangeCheck = "",
			filterFunc;

			if(typeof column.modules.filter.prevSuccess === "undefined" || column.modules.filter.prevSuccess !== value){

				column.modules.filter.prevSuccess = value;

				if(!column.modules.filter.emptyFunc(value)){
					column.modules.filter.value = value;

					switch(typeof column.definition.headerFilterFunc){
						case "string":
							if(Filter.filters[column.definition.headerFilterFunc]){
								type = column.definition.headerFilterFunc;
								filterFunc = function(data){
									var params = column.definition.headerFilterFuncParams || {};
									var fieldVal = column.getFieldValue(data);

									params = typeof params === "function" ? params(value, fieldVal, data) : params;

									return Filter.filters[column.definition.headerFilterFunc](value, fieldVal, data, params);
								};
							}else {
								console.warn("Header Filter Error - Matching filter function not found: ", column.definition.headerFilterFunc);
							}
							break;

						case "function":
							filterFunc = function(data){
								var params = column.definition.headerFilterFuncParams || {};
								var fieldVal = column.getFieldValue(data);

								params = typeof params === "function" ? params(value, fieldVal, data) : params;

								return column.definition.headerFilterFunc(value, fieldVal, data, params);
							};

							type = filterFunc;
							break;
					}

					if(!filterFunc){
						switch(filterType){
							case "partial":
								filterFunc = function(data){
									var colVal = column.getFieldValue(data);

									if(typeof colVal !== 'undefined' && colVal !== null){
										return String(colVal).toLowerCase().indexOf(String(value).toLowerCase()) > -1;
									}else {
										return false;
									}
								};
								type = "like";
								break;

							default:
								filterFunc = function(data){
									return column.getFieldValue(data) == value;
								};
								type = "=";
						}
					}

					self.headerFilters[field] = {value:value, func:filterFunc, type:type};
				}else {
					delete self.headerFilters[field];
				}

				column.modules.filter.value = value;

				filterChangeCheck = JSON.stringify(self.headerFilters);

				if(self.prevHeaderFilterChangeCheck !== filterChangeCheck){
					self.prevHeaderFilterChangeCheck = filterChangeCheck;

					self.trackChanges();
					self.refreshFilter();
				}
			}

			return true;
		}

		column.modules.filter = {
			success:success,
			attrType:false,
			tagType:false,
			emptyFunc:false,
		};

		this.generateHeaderFilterElement(column);
	}

	generateHeaderFilterElement(column, initialValue, reinitialize){
		var self = this,
		success = column.modules.filter.success,
		field = column.getField(),
		filterElement, editor, editorElement, cellWrapper, typingTimer, searchTrigger, params, onRenderedCallback;

		column.modules.filter.value = initialValue;

		//handle aborted edit
		function cancel(){}

		function onRendered(callback){
			onRenderedCallback = callback;
		}

		if(column.modules.filter.headerElement && column.modules.filter.headerElement.parentNode){
			column.contentElement.removeChild(column.modules.filter.headerElement.parentNode);
		}

		if(field){

			//set empty value function
			column.modules.filter.emptyFunc = column.definition.headerFilterEmptyCheck || function(value){
				return !value && value !== 0;
			};

			filterElement = document.createElement("div");
			filterElement.classList.add("tabulator-header-filter");

			//set column editor
			switch(typeof column.definition.headerFilter){
				case "string":
					if(self.table.modules.edit.editors[column.definition.headerFilter]){
						editor = self.table.modules.edit.editors[column.definition.headerFilter];

						if((column.definition.headerFilter === "tick" || column.definition.headerFilter === "tickCross") && !column.definition.headerFilterEmptyCheck){
							column.modules.filter.emptyFunc = function(value){
								return value !== true && value !== false;
							};
						}
					}else {
						console.warn("Filter Error - Cannot build header filter, No such editor found: ", column.definition.editor);
					}
					break;

				case "function":
					editor = column.definition.headerFilter;
					break;

				case "boolean":
					if(column.modules.edit && column.modules.edit.editor){
						editor = column.modules.edit.editor;
					}else {
						if(column.definition.formatter && self.table.modules.edit.editors[column.definition.formatter]){
							editor = self.table.modules.edit.editors[column.definition.formatter];

							if((column.definition.formatter === "tick" || column.definition.formatter === "tickCross") && !column.definition.headerFilterEmptyCheck){
								column.modules.filter.emptyFunc = function(value){
									return value !== true && value !== false;
								};
							}
						}else {
							editor = self.table.modules.edit.editors["input"];
						}
					}
					break;
			}

			if(editor){

				cellWrapper = {
					getValue:function(){
						return typeof initialValue !== "undefined" ? initialValue : "";
					},
					getField:function(){
						return column.definition.field;
					},
					getElement:function(){
						return filterElement;
					},
					getColumn:function(){
						return column.getComponent();
					},
					getTable:() => {
						return this.table;
					},
					getType:() => {
						return "header";
					},
					getRow:function(){
						return {
							normalizeHeight:function(){

							}
						};
					}
				};

				params = column.definition.headerFilterParams || {};

				params = typeof params === "function" ? params.call(self.table, cellWrapper) : params;

				editorElement = editor.call(this.table.modules.edit, cellWrapper, onRendered, success, cancel, params);

				if(!editorElement){
					console.warn("Filter Error - Cannot add filter to " + field + " column, editor returned a value of false");
					return;
				}

				if(!(editorElement instanceof Node)){
					console.warn("Filter Error - Cannot add filter to " + field + " column, editor should return an instance of Node, the editor returned:", editorElement);
					return;
				}

				//set Placeholder Text
				self.langBind("headerFilters|columns|" + column.definition.field, function(value){
					editorElement.setAttribute("placeholder", typeof value !== "undefined" && value ? value : (column.definition.headerFilterPlaceholder || self.langText("headerFilters|default")));
				});

				//focus on element on click
				editorElement.addEventListener("click", function(e){
					e.stopPropagation();
					editorElement.focus();
				});

				editorElement.addEventListener("focus", (e) => {
					var left = this.table.columnManager.contentsElement.scrollLeft;

					var headerPos = this.table.rowManager.element.scrollLeft;

					if(left !== headerPos){
						this.table.rowManager.scrollHorizontal(left);
						this.table.columnManager.scrollHorizontal(left);
					}
				});

				//live update filters as user types
				typingTimer = false;

				searchTrigger = function(e){
					if(typingTimer){
						clearTimeout(typingTimer);
					}

					typingTimer = setTimeout(function(){
						success(editorElement.value);
					},self.table.options.headerFilterLiveFilterDelay);
				};

				column.modules.filter.headerElement = editorElement;
				column.modules.filter.attrType = editorElement.hasAttribute("type") ? editorElement.getAttribute("type").toLowerCase() : "" ;
				column.modules.filter.tagType = editorElement.tagName.toLowerCase();

				if(column.definition.headerFilterLiveFilter !== false){

					if (
						!(
							column.definition.headerFilter === 'autocomplete' ||
							column.definition.headerFilter === 'tickCross' ||
							((column.definition.editor === 'autocomplete' ||
								column.definition.editor === 'tickCross') &&
							column.definition.headerFilter === true)
						)
					) {
						editorElement.addEventListener("keyup", searchTrigger);
						editorElement.addEventListener("search", searchTrigger);


						//update number filtered columns on change
						if(column.modules.filter.attrType == "number"){
							editorElement.addEventListener("change", function(e){
								success(editorElement.value);
							});
						}

						//change text inputs to search inputs to allow for clearing of field
						if(column.modules.filter.attrType == "text" && this.table.browser !== "ie"){
							editorElement.setAttribute("type", "search");
						// editorElement.off("change blur"); //prevent blur from triggering filter and preventing selection click
						}

					}

					//prevent input and select elements from propagating click to column sorters etc
					if(column.modules.filter.tagType == "input" || column.modules.filter.tagType == "select" || column.modules.filter.tagType == "textarea"){
						editorElement.addEventListener("mousedown",function(e){
							e.stopPropagation();
						});
					}
				}

				filterElement.appendChild(editorElement);

				column.contentElement.appendChild(filterElement);

				if(!reinitialize){
					self.headerFilterColumns.push(column);
				}

				if(onRenderedCallback){
					onRenderedCallback();
				}
			}
		}else {
			console.warn("Filter Error - Cannot add header filter, column has no field set:", column.definition.title);
		}
	}

	//hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
	hideHeaderFilterElements(){
		this.headerFilterColumns.forEach(function(column){
			if(column.modules.filter && column.modules.filter.headerElement){
				column.modules.filter.headerElement.style.display = 'none';
			}
		});
	}

	//show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
	showHeaderFilterElements(){
		this.headerFilterColumns.forEach(function(column){
			if(column.modules.filter && column.modules.filter.headerElement){
				column.modules.filter.headerElement.style.display = '';
			}
		});
	}

	//programmatically set focus of header filter
	setHeaderFilterFocus(column){
		if(column.modules.filter && column.modules.filter.headerElement){
			column.modules.filter.headerElement.focus();
		}else {
			console.warn("Column Filter Focus Error - No header filter set on column:", column.getField());
		}
	}

	//programmatically get value of header filter
	getHeaderFilterValue(column){
		if(column.modules.filter && column.modules.filter.headerElement){
			return column.modules.filter.value;
		} else {
			console.warn("Column Filter Error - No header filter set on column:", column.getField());
		}
	}

	//programmatically set value of header filter
	setHeaderFilterValue(column, value){
		if (column){
			if(column.modules.filter && column.modules.filter.headerElement){
				this.generateHeaderFilterElement(column, value, true);
				column.modules.filter.success(value);
			}else {
				console.warn("Column Filter Error - No header filter set on column:", column.getField());
			}
		}
	}

	reloadHeaderFilter(column){
		if (column){
			if(column.modules.filter && column.modules.filter.headerElement){
				this.generateHeaderFilterElement(column, column.modules.filter.value, true);
			}else {
				console.warn("Column Filter Error - No header filter set on column:", column.getField());
			}
		}
	}

	refreshFilter(){
		if(this.tableInitialized){
			if(this.table.options.filterMode === "remote"){
				this.reloadData(null, false, false);
			}else {
				this.refreshData(true);
			}
		}

		//TODO - Persist left position of row manager
		// left = this.scrollLeft;
		// this.scrollHorizontal(left);
	}

	//check if the filters has changed since last use
	trackChanges(){
		this.changed = true;
		this.dispatch("filter-changed");
	}

	//check if the filters has changed since last use
	hasChanged(){
		var changed = this.changed;
		this.changed = false;
		return changed;
	}

	//set standard filters
	setFilter(field, type, value, params){
		this.filterList = [];

		if(!Array.isArray(field)){
			field = [{field:field, type:type, value:value, params:params}];
		}

		this.addFilter(field);
	}

	//add filter to array
	addFilter(field, type, value, params){
		var changed = false;

		if(!Array.isArray(field)){
			field = [{field:field, type:type, value:value, params:params}];
		}

		field.forEach((filter) => {
			filter = this.findFilter(filter);

			if(filter){
				this.filterList.push(filter);
				changed = true;
			}
		});

		if(changed){
			this.trackChanges();
		}
	}

	findFilter(filter){
		var column;

		if(Array.isArray(filter)){
			return this.findSubFilters(filter);
		}

		var filterFunc = false;

		if(typeof filter.field == "function"){
			filterFunc = function(data){
				return filter.field(data, filter.type || {});// pass params to custom filter function
			};
		}else {

			if(Filter.filters[filter.type]){

				column = this.table.columnManager.getColumnByField(filter.field);

				if(column){
					filterFunc = function(data){
						return Filter.filters[filter.type](filter.value, column.getFieldValue(data), data, filter.params || {});
					};
				}else {
					filterFunc = function(data){
						return Filter.filters[filter.type](filter.value, data[filter.field], data, filter.params || {});
					};
				}


			}else {
				console.warn("Filter Error - No such filter type found, ignoring: ", filter.type);
			}
		}

		filter.func = filterFunc;

		return filter.func ? filter : false;
	}

	findSubFilters(filters){
		var output = [];

		filters.forEach((filter) => {
			filter = this.findFilter(filter);

			if(filter){
				output.push(filter);
			}
		});

		return output.length ? output : false;
	}

	//get all filters
	getFilters(all, ajax){
		var output = [];

		if(all){
			output = this.getHeaderFilters();
		}

		if(ajax){
			output.forEach(function(item){
				if(typeof item.type == "function"){
					item.type = "function";
				}
			});
		}

		output = output.concat(this.filtersToArray(this.filterList, ajax));

		return output;
	}

	//filter to Object
	filtersToArray(filterList, ajax){
		var output = [];

		filterList.forEach((filter) => {
			var item;

			if(Array.isArray(filter)){
				output.push(this.filtersToArray(filter, ajax));
			}else {
				item = {field:filter.field, type:filter.type, value:filter.value};

				if(ajax){
					if(typeof item.type == "function"){
						item.type = "function";
					}
				}

				output.push(item);
			}
		});

		return output;
	}

	//get all filters
	getHeaderFilters(){
		var output = [];

		for(var key in this.headerFilters){
			output.push({field:key, type:this.headerFilters[key].type, value:this.headerFilters[key].value});
		}

		return output;
	}

	//remove filter from array
	removeFilter(field, type, value){
		if(!Array.isArray(field)){
			field = [{field:field, type:type, value:value}];
		}

		field.forEach((filter) => {
			var index = -1;

			if(typeof filter.field == "object"){
				index = this.filterList.findIndex((element) => {
					return filter === element;
				});
			}else {
				index = this.filterList.findIndex((element) => {
					return filter.field === element.field && filter.type === element.type  && filter.value === element.value;
				});
			}

			if(index > -1){
				this.filterList.splice(index, 1);
			}else {
				console.warn("Filter Error - No matching filter type found, ignoring: ", filter.type);
			}
		});

		this.trackChanges();
	}

	//clear filters
	clearFilter(all){
		this.filterList = [];

		if(all){
			this.clearHeaderFilter();
		}

		this.trackChanges();
	}

	//clear header filters
	clearHeaderFilter(){
		this.headerFilters = {};
		this.prevHeaderFilterChangeCheck = "{}";

		this.headerFilterColumns.forEach((column) => {
			if(typeof column.modules.filter.value !== "undefined"){
				delete column.modules.filter.value;
			}
			column.modules.filter.prevSuccess = undefined;
			this.reloadHeaderFilter(column);
		});

		this.trackChanges();
	}

	//search data and return matching rows
	search (searchType, field, type, value){
		var activeRows = [],
		filterList = [];

		if(!Array.isArray(field)){
			field = [{field:field, type:type, value:value}];
		}

		field.forEach((filter) => {
			filter = this.findFilter(filter);

			if(filter){
				filterList.push(filter);
			}
		});

		this.table.rowManager.rows.forEach((row) => {
			var match = true;

			filterList.forEach((filter) => {
				if(!this.filterRecurse(filter, row.getData())){
					match = false;
				}
			});

			if(match){
				activeRows.push(searchType === "data" ? row.getData("data") : row.getComponent());
			}

		});

		return activeRows;
	}

	//filter row array
	filter(rowList, filters){
		var activeRows = [],
		activeRowComponents = [];

		if(this.subscribedExternal("dataFiltering")){
			this.dispatchExternal("dataFiltering", this.getFilters(true));
		}

		if(this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length)){

			rowList.forEach((row) => {
				if(this.filterRow(row)){
					activeRows.push(row);
				}
			});

		}else {
			activeRows = rowList.slice(0);
		}

		if(this.subscribedExternal("dataFiltered")){

			activeRows.forEach((row) => {
				activeRowComponents.push(row.getComponent());
			});

			this.dispatchExternal("dataFiltered", this.getFilters(true), activeRowComponents);
		}

		return activeRows;
	}

	//filter individual row
	filterRow(row, filters){
		var match = true,
		data = row.getData();

		this.filterList.forEach((filter) => {
			if(!this.filterRecurse(filter, data)){
				match = false;
			}
		});


		for(var field in this.headerFilters){
			if(!this.headerFilters[field].func(data)){
				match = false;
			}
		}

		return match;
	}

	filterRecurse(filter, data){
		var match = false;

		if(Array.isArray(filter)){
			filter.forEach((subFilter) => {
				if(this.filterRecurse(subFilter, data)){
					match = true;
				}
			});
		}else {
			match = filter.func(data);
		}

		return match;
	}
}

Filter.moduleName = "filter";

//load defaults
Filter.filters = defaultFilters;

function plaintext(cell, formatterParams, onRendered){
	return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}

function html$1(cell, formatterParams, onRendered){
	return cell.getValue();
}

function textarea$1(cell, formatterParams, onRendered){
	cell.getElement().style.whiteSpace = "pre-wrap";
	return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}

function money(cell, formatterParams, onRendered){
	var floatVal = parseFloat(cell.getValue()),
	sign = "",
	number, integer, decimal, rgx, value;

	var decimalSym = formatterParams.decimal || ".";
	var thousandSym = formatterParams.thousand || ",";
	var negativeSign = formatterParams.negativeSign || "-";
	var symbol = formatterParams.symbol || "";
	var after = !!formatterParams.symbolAfter;
	var precision = typeof formatterParams.precision !== "undefined" ? formatterParams.precision : 2;

	if(isNaN(floatVal)){
		return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
	}

	if(floatVal < 0){
		floatVal = Math.abs(floatVal);
		sign = negativeSign;
	}

	number = precision !== false ? floatVal.toFixed(precision) : floatVal;
	number = String(number).split(".");

	integer = number[0];
	decimal = number.length > 1 ? decimalSym + number[1] : "";

	if (formatterParams.thousand !== false) {
		rgx = /(\d+)(\d{3})/;

		while (rgx.test(integer)){
			integer = integer.replace(rgx, "$1" + thousandSym + "$2");
		}
	}

	value = integer + decimal;
	
	if(sign === true){
		value = "(" + value  + ")";
		return after ? value + symbol : symbol + value;
	}else {
		return after ? sign + value + symbol : sign + symbol + value;
	}
}

function link(cell, formatterParams, onRendered){
	var value = cell.getValue(),
	urlPrefix = formatterParams.urlPrefix || "",
	download = formatterParams.download,
	label = value,
	el = document.createElement("a"),
	data;

	function labelTraverse(path, data){
		var item = path.shift(),
		value = data[item];
		
		if(path.length && typeof value === "object"){
			return labelTraverse(path, value);
		}

		return value;
	}

	if(formatterParams.labelField){
		data = cell.getData();
		label = labelTraverse(formatterParams.labelField.split(this.table.options.nestedFieldSeparator), data);
	}

	if(formatterParams.label){
		switch(typeof formatterParams.label){
			case "string":
				label = formatterParams.label;
				break;

			case "function":
				label = formatterParams.label(cell);
				break;
		}
	}

	if(label){
		if(formatterParams.urlField){
			data = cell.getData();

			value = Helpers.retrieveNestedData(this.table.options.nestedFieldSeparator, formatterParams.urlField, data);
		}

		if(formatterParams.url){
			switch(typeof formatterParams.url){
				case "string":
					value = formatterParams.url;
					break;

				case "function":
					value = formatterParams.url(cell);
					break;
			}
		}

		el.setAttribute("href", urlPrefix + value);

		if(formatterParams.target){
			el.setAttribute("target", formatterParams.target);
		}

		if(formatterParams.download){

			if(typeof download == "function"){
				download = download(cell);
			}else {
				download = download === true ? "" : download;
			}

			el.setAttribute("download", download);
		}

		el.innerHTML = this.emptyToSpace(this.sanitizeHTML(label));

		return el;
	}else {
		return "&nbsp;";
	}
}

function image(cell, formatterParams, onRendered){
	var el = document.createElement("img"),
	src = cell.getValue();

	if(formatterParams.urlPrefix){
		src = formatterParams.urlPrefix + cell.getValue();
	}

	if(formatterParams.urlSuffix){
		src = src + formatterParams.urlSuffix;
	}

	el.setAttribute("src", src);

	switch(typeof formatterParams.height){
		case "number":
			el.style.height = formatterParams.height + "px";
			break;

		case "string":
			el.style.height = formatterParams.height;
			break;
	}

	switch(typeof formatterParams.width){
		case "number":
			el.style.width = formatterParams.width + "px";
			break;

		case "string":
			el.style.width = formatterParams.width;
			break;
	}

	el.addEventListener("load", function(){
		cell.getRow().normalizeHeight();
	});

	return el;
}

function tickCross$1(cell, formatterParams, onRendered){
	var value = cell.getValue(),
	element = cell.getElement(),
	empty = formatterParams.allowEmpty,
	truthy = formatterParams.allowTruthy,
	trueValueSet = Object.keys(formatterParams).includes("trueValue"),
	tick = typeof formatterParams.tickElement !== "undefined" ? formatterParams.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>',
	cross = typeof formatterParams.crossElement !== "undefined" ? formatterParams.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';

	if((trueValueSet && value === formatterParams.trueValue) || (!trueValueSet && ((truthy && value) || (value === true || value === "true" || value === "True" || value === 1 || value === "1")))){
		element.setAttribute("aria-checked", true);
		return tick || "";
	}else {
		if(empty && (value === "null" || value === "" || value === null || typeof value === "undefined")){
			element.setAttribute("aria-checked", "mixed");
			return "";
		}else {
			element.setAttribute("aria-checked", false);
			return cross || "";
		}
	}
}

function datetime$1(cell, formatterParams, onRendered){
	var DT = window.DateTime || luxon.DateTime;
	var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
	var	outputFormat = formatterParams.outputFormat || "dd/MM/yyyy HH:mm:ss";
	var	invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
	var value = cell.getValue();

	if(typeof DT != "undefined"){
		var newDatetime;

		if(DT.isDateTime(value)){
			newDatetime = value;
		}else if(inputFormat === "iso"){
			newDatetime = DT.fromISO(String(value));
		}else {
			newDatetime = DT.fromFormat(String(value), inputFormat);
		}

		if(newDatetime.isValid){
			if(formatterParams.timezone){
				newDatetime = newDatetime.setZone(formatterParams.timezone);
			}

			return newDatetime.toFormat(outputFormat);
		}else {
			if(invalid === true || !value){
				return value;
			}else if(typeof invalid === "function"){
				return invalid(value);
			}else {
				return invalid;
			}
		}
	}else {
		console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
	}
}

function datetimediff (cell, formatterParams, onRendered) {
	var DT = window.DateTime || luxon.DateTime;
	var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
	var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
	var suffix = typeof formatterParams.suffix !== "undefined" ? formatterParams.suffix : false;
	var unit = typeof formatterParams.unit !== "undefined" ? formatterParams.unit : "days";
	var humanize = typeof formatterParams.humanize !== "undefined" ? formatterParams.humanize : false;
	var date = typeof formatterParams.date !== "undefined" ? formatterParams.date : DT.now();
	var value = cell.getValue();

	if(typeof DT != "undefined"){
		var newDatetime;

		if(DT.isDateTime(value)){
			newDatetime = value;
		}else if(inputFormat === "iso"){
			newDatetime = DT.fromISO(String(value));
		}else {
			newDatetime = DT.fromFormat(String(value), inputFormat);
		}

		if (newDatetime.isValid){
			if(humanize){
				return newDatetime.diff(date, unit).toHuman()  + (suffix ? " " + suffix : "");
			}else {
				return parseInt(newDatetime.diff(date, unit)[unit]) + (suffix ? " " + suffix : "");
			}
		} else {

			if (invalid === true) {
				return value;
			} else if (typeof invalid === "function") {
				return invalid(value);
			} else {
				return invalid;
			}
		}
	}else {
		console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
	}
}

function lookup (cell, formatterParams, onRendered) {
	var value = cell.getValue();

	if (typeof formatterParams[value] === "undefined") {
		console.warn('Missing display value for ' + value);
		return value;
	}

	return formatterParams[value];
}

function star$1(cell, formatterParams, onRendered){
	var value = cell.getValue(),
	element = cell.getElement(),
	maxStars = formatterParams && formatterParams.stars ? formatterParams.stars : 5,
	stars = document.createElement("span"),
	star = document.createElementNS('http://www.w3.org/2000/svg', "svg"),
	starActive = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>',
	starInactive = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';

	//style stars holder
	stars.style.verticalAlign = "middle";

	//style star
	star.setAttribute("width", "14");
	star.setAttribute("height", "14");
	star.setAttribute("viewBox", "0 0 512 512");
	star.setAttribute("xml:space", "preserve");
	star.style.padding = "0 1px";

	value = value && !isNaN(value) ? parseInt(value) : 0;

	value = Math.max(0, Math.min(value, maxStars));

	for(var i=1;i<= maxStars;i++){
		var nextStar = star.cloneNode(true);
		nextStar.innerHTML = i <= value ? starActive : starInactive;

		stars.appendChild(nextStar);
	}

	element.style.whiteSpace = "nowrap";
	element.style.overflow = "hidden";
	element.style.textOverflow = "ellipsis";

	element.setAttribute("aria-label", value);

	return stars;
}

function traffic(cell, formatterParams, onRendered){
	var value = this.sanitizeHTML(cell.getValue()) || 0,
	el = document.createElement("span"),
	max = formatterParams && formatterParams.max ? formatterParams.max : 100,
	min = formatterParams && formatterParams.min ? formatterParams.min : 0,
	colors = formatterParams && typeof formatterParams.color !== "undefined" ? formatterParams.color : ["red", "orange", "green"],
	color = "#666666",
	percent, percentValue;

	if(isNaN(value) || typeof cell.getValue() === "undefined"){
		return;
	}

	el.classList.add("tabulator-traffic-light");

	//make sure value is in range
	percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
	percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min;

	//workout percentage
	percent = (max - min) / 100;
	percentValue = Math.round((percentValue - min) / percent);

	//set color
	switch(typeof colors){
		case "string":
			color = colors;
			break;
		case "function":
			color = colors(value);
			break;
		case "object":
			if(Array.isArray(colors)){
				var unit = 100 / colors.length;
				var index = Math.floor(percentValue / unit);

				index = Math.min(index, colors.length - 1);
				index = Math.max(index, 0);
				color = colors[index];
				break;
			}
	}

	el.style.backgroundColor = color;

	return el;
}

function progress$1(cell, formatterParams = {}, onRendered){ //progress bar
	var value = this.sanitizeHTML(cell.getValue()) || 0,
	element = cell.getElement(),
	max = formatterParams.max ? formatterParams.max : 100,
	min = formatterParams.min ? formatterParams.min : 0,
	legendAlign = formatterParams.legendAlign ? formatterParams.legendAlign : "center",
	percent, percentValue, color, legend, legendColor;

	//make sure value is in range
	percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
	percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min;

	//workout percentage
	percent = (max - min) / 100;
	percentValue = Math.round((percentValue - min) / percent);

	//set bar color
	switch(typeof formatterParams.color){
		case "string":
			color = formatterParams.color;
			break;
		case "function":
			color = formatterParams.color(value);
			break;
		case "object":
			if(Array.isArray(formatterParams.color)){
				let unit = 100 / formatterParams.color.length;
				let index = Math.floor(percentValue / unit);

				index = Math.min(index, formatterParams.color.length - 1);
				index = Math.max(index, 0);
				color = formatterParams.color[index];
				break;
			}
		default:
			color = "#2DC214";
	}

	//generate legend
	switch(typeof formatterParams.legend){
		case "string":
			legend = formatterParams.legend;
			break;
		case "function":
			legend = formatterParams.legend(value);
			break;
		case "boolean":
			legend = value;
			break;
		default:
			legend = false;
	}

	//set legend color
	switch(typeof formatterParams.legendColor){
		case "string":
			legendColor = formatterParams.legendColor;
			break;
		case "function":
			legendColor = formatterParams.legendColor(value);
			break;
		case "object":
			if(Array.isArray(formatterParams.legendColor)){
				let unit = 100 / formatterParams.legendColor.length;
				let index = Math.floor(percentValue / unit);

				index = Math.min(index, formatterParams.legendColor.length - 1);
				index = Math.max(index, 0);
				legendColor = formatterParams.legendColor[index];
			}
			break;
		default:
			legendColor = "#000";
	}

	element.style.minWidth = "30px";
	element.style.position = "relative";

	element.setAttribute("aria-label", percentValue);

	var barEl = document.createElement("div");
	barEl.style.display = "inline-block";
	barEl.style.width = percentValue + "%";
	barEl.style.backgroundColor = color;
	barEl.style.height = "100%";

	barEl.setAttribute('data-max', max);
	barEl.setAttribute('data-min', min);

	var barContainer = document.createElement("div");
	barContainer.style.position = "relative";
	barContainer.style.width = "100%";
	barContainer.style.height = "100%";

	if(legend){
		var legendEl = document.createElement("div");
		legendEl.style.position = "absolute";
		legendEl.style.top = 0;
		legendEl.style.left = 0;
		legendEl.style.textAlign = legendAlign;
		legendEl.style.width = "100%";
		legendEl.style.color = legendColor;
		legendEl.innerHTML = legend;
	}

	onRendered(function(){

		//handle custom element needed if formatter is to be included in printed/downloaded output
		if(!(cell instanceof CellComponent)){
			var holderEl = document.createElement("div");
			holderEl.style.position = "absolute";
			holderEl.style.top = "4px";
			holderEl.style.bottom = "4px";
			holderEl.style.left = "4px";
			holderEl.style.right = "4px";

			element.appendChild(holderEl);

			element = holderEl;
		}

		element.appendChild(barContainer);
		barContainer.appendChild(barEl);

		if(legend){
			barContainer.appendChild(legendEl);
		}
	});

	return "";
}

function color(cell, formatterParams, onRendered){
	cell.getElement().style.backgroundColor = this.sanitizeHTML(cell.getValue());
	return "";
}

function buttonTick(cell, formatterParams, onRendered){
	return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}

function buttonCross(cell, formatterParams, onRendered){
	return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}

function rownum(cell, formatterParams, onRendered){
	var content = document.createElement("span");
	var row = cell.getRow();
	var table = cell.getTable();

	row.watchPosition((position) => {
		if (formatterParams.relativeToPage) {
			position += table.modules.page.getPageSize() * (table.modules.page.getPage() - 1);
		}
		content.innerText = position;
	});
	
	return content;
}

function handle(cell, formatterParams, onRendered){
	cell.getElement().classList.add("tabulator-row-handle");
	return "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}

function responsiveCollapse(cell, formatterParams, onRendered){
	var el = document.createElement("div"),
	config = cell.getRow()._row.modules.responsiveLayout;

	el.classList.add("tabulator-responsive-collapse-toggle");
	
	el.innerHTML = `<svg class='tabulator-responsive-collapse-toggle-open' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12" fill="none" stroke-width="3" stroke-linecap="round" />
  <line y1="7" x1="12" y2="17" x2="12" fill="none" stroke-width="3" stroke-linecap="round" />
</svg>

<svg class='tabulator-responsive-collapse-toggle-close' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12"  fill="none" stroke-width="3" stroke-linecap="round" />
</svg>`;

	cell.getElement().classList.add("tabulator-row-handle");

	function toggleList(isOpen){
		var collapseEl = config.element;

		config.open = isOpen;

		if(collapseEl){

			if(config.open){
				el.classList.add("open");
				collapseEl.style.display = '';
			}else {
				el.classList.remove("open");
				collapseEl.style.display = 'none';
			}
		}
	}

	el.addEventListener("click", function(e){
		e.stopImmediatePropagation();
		toggleList(!config.open);
		cell.getTable().rowManager.adjustTableSize();
	});

	toggleList(config.open);

	return el;
}

function rowSelection(cell, formatterParams, onRendered){
	var checkbox = document.createElement("input");
	var blocked = false;

	checkbox.type = 'checkbox';

	checkbox.setAttribute("aria-label", "Select Row");
	
	if(this.table.modExists("selectRow", true)){

		checkbox.addEventListener("click", (e) => {
			e.stopPropagation();
		});

		if(typeof cell.getRow == 'function'){
			var row = cell.getRow();

			if(row instanceof RowComponent){

				checkbox.addEventListener("change", (e) => {
					if(this.table.options.selectableRowsRangeMode === "click"){
						if(!blocked){
							row.toggleSelect();
						}else {
							blocked = false;
						}
					}else {
						row.toggleSelect();
					}
				});

				if(this.table.options.selectableRowsRangeMode === "click"){
					checkbox.addEventListener("click", (e) => {
						blocked = true;
						this.table.modules.selectRow.handleComplexRowClick(row._row, e);
					});
				}

				checkbox.checked = row.isSelected && row.isSelected();
				this.table.modules.selectRow.registerRowSelectCheckbox(row, checkbox);
			}else {
				checkbox = "";
			}
		}else {
			checkbox.addEventListener("change", (e) => {
				if(this.table.modules.selectRow.selectedRows.length){
					this.table.deselectRow();
				}else {
					this.table.selectRow(formatterParams.rowRange);
				}
			});

			this.table.modules.selectRow.registerHeaderSelectCheckbox(checkbox);
		}
	}

	return checkbox;
}

var defaultFormatters = {
	plaintext:plaintext,
	html:html$1,
	textarea:textarea$1,
	money:money,
	link:link,
	image:image,
	tickCross:tickCross$1,
	datetime:datetime$1,
	datetimediff:datetimediff,
	lookup:lookup,
	star:star$1,
	traffic:traffic,
	progress:progress$1,
	color:color,
	buttonTick:buttonTick,
	buttonCross:buttonCross,
	rownum:rownum,
	handle:handle,
	responsiveCollapse:responsiveCollapse,
	rowSelection:rowSelection,
};

class Format extends Module{
	
	constructor(table){
		super(table);
		
		this.registerColumnOption("formatter");
		this.registerColumnOption("formatterParams");
		
		this.registerColumnOption("formatterPrint");
		this.registerColumnOption("formatterPrintParams");
		this.registerColumnOption("formatterClipboard");
		this.registerColumnOption("formatterClipboardParams");
		this.registerColumnOption("formatterHtmlOutput");
		this.registerColumnOption("formatterHtmlOutputParams");
		this.registerColumnOption("titleFormatter");
		this.registerColumnOption("titleFormatterParams");
	}
	
	initialize(){
		this.subscribe("cell-format", this.formatValue.bind(this));
		this.subscribe("cell-rendered", this.cellRendered.bind(this));
		this.subscribe("column-layout", this.initializeColumn.bind(this));
		this.subscribe("column-format", this.formatHeader.bind(this));
	}
	
	//initialize column formatter
	initializeColumn(column){
		column.modules.format = this.lookupFormatter(column, "");
		
		if(typeof column.definition.formatterPrint !== "undefined"){
			column.modules.format.print = this.lookupFormatter(column, "Print");
		}
		
		if(typeof column.definition.formatterClipboard !== "undefined"){
			column.modules.format.clipboard = this.lookupFormatter(column, "Clipboard");
		}
		
		if(typeof column.definition.formatterHtmlOutput !== "undefined"){
			column.modules.format.htmlOutput = this.lookupFormatter(column, "HtmlOutput");
		}
	}
	
	lookupFormatter(column, type){
		var config = {params:column.definition["formatter" + type + "Params"] || {}},
		formatter = column.definition["formatter" + type];
		
		//set column formatter
		switch(typeof formatter){
			case "string":
				if(Format.formatters[formatter]){
					config.formatter = Format.formatters[formatter];
				}else {
					console.warn("Formatter Error - No such formatter found: ", formatter);
					config.formatter = Format.formatters.plaintext;
				}
				break;
			
			case "function":
				config.formatter = formatter;
				break;
			
			default:
				config.formatter = Format.formatters.plaintext;
				break;
		}
		
		return config;
	}
	
	cellRendered(cell){
		if(cell.modules.format && cell.modules.format.renderedCallback && !cell.modules.format.rendered){
			cell.modules.format.renderedCallback();
			cell.modules.format.rendered = true;
		}
	}
	
	//return a formatted value for a column header
	formatHeader(column, title, el){
		var formatter, params, onRendered, mockCell;
		
		if(column.definition.titleFormatter){
			formatter = this.getFormatter(column.definition.titleFormatter);
			
			onRendered = (callback) => {
				column.titleFormatterRendered = callback;
			};
			
			mockCell = {
				getValue:function(){
					return title;
				},
				getElement:function(){
					return el;
				},
				getType:function(){
					return "header";
				},
				getColumn:function(){
					return column.getComponent();
				},
				getTable:() => {
					return this.table;
				}
			};
			
			params = column.definition.titleFormatterParams || {};
			
			params = typeof params === "function" ? params() : params;
			
			return formatter.call(this, mockCell, params, onRendered);
		}else {
			return title;
		}
	}
	
	
	//return a formatted value for a cell
	formatValue(cell){
		var component = cell.getComponent(),
		params = typeof cell.column.modules.format.params === "function" ? cell.column.modules.format.params(component) : cell.column.modules.format.params;
		
		function onRendered(callback){
			if(!cell.modules.format){
				cell.modules.format = {};
			}
			
			cell.modules.format.renderedCallback = callback;
			cell.modules.format.rendered = false;
		}
		
		return cell.column.modules.format.formatter.call(this, component, params, onRendered);
	}
	
	formatExportValue(cell, type){
		var formatter = cell.column.modules.format[type],
		params;
		
		if(formatter){
			params = typeof formatter.params === "function" ? formatter.params(cell.getComponent()) : formatter.params;
			
			function onRendered(callback){
				if(!cell.modules.format){
					cell.modules.format = {};
				}
				
				cell.modules.format.renderedCallback = callback;
				cell.modules.format.rendered = false;
			}
			
			return formatter.formatter.call(this, cell.getComponent(), params, onRendered);
			
		}else {
			return this.formatValue(cell);
		}
	}
	
	sanitizeHTML(value){
		if(value){
			var entityMap = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&#39;',
				'/': '&#x2F;',
				'`': '&#x60;',
				'=': '&#x3D;'
			};
			
			return String(value).replace(/[&<>"'`=/]/g, function (s) {
				return entityMap[s];
			});
		}else {
			return value;
		}
	}
	
	emptyToSpace(value){
		return value === null || typeof value === "undefined" || value === "" ? "&nbsp;" : value;
	}
	
	//get formatter for cell
	getFormatter(formatter){
		switch(typeof formatter){
			case "string":
				if(Format.formatters[formatter]){
					formatter = Format.formatters[formatter];
				}else {
					console.warn("Formatter Error - No such formatter found: ", formatter);
					formatter = Format.formatters.plaintext;
				}
				break;
			
			case "function":
			//Custom formatter Function, do nothing
				break;
			
			default:
				formatter = Format.formatters.plaintext;
				break;
		}
		
		return formatter;
	}
}

Format.moduleName = "format";

//load defaults
Format.formatters = defaultFormatters;

class FrozenColumns extends Module{
	
	constructor(table){
		super(table);
		
		this.leftColumns = [];
		this.rightColumns = [];
		this.initializationMode = "left";
		this.active = false;
		this.blocked = true;
		
		this.registerColumnOption("frozen");
	}
	
	//reset initial state
	reset(){
		this.initializationMode = "left";
		this.leftColumns = [];
		this.rightColumns = [];
		this.active = false;
	}
	
	initialize(){
		this.subscribe("cell-layout", this.layoutCell.bind(this));
		this.subscribe("column-init", this.initializeColumn.bind(this));
		this.subscribe("column-width", this.layout.bind(this));
		this.subscribe("row-layout-after", this.layoutRow.bind(this));
		this.subscribe("table-layout", this.layout.bind(this));
		this.subscribe("columns-loading", this.reset.bind(this));
		
		this.subscribe("column-add", this.reinitializeColumns.bind(this));
		this.subscribe("column-deleted", this.reinitializeColumns.bind(this));
		this.subscribe("column-hide", this.reinitializeColumns.bind(this));
		this.subscribe("column-show", this.reinitializeColumns.bind(this));
		this.subscribe("columns-loaded", this.reinitializeColumns.bind(this));
		
		this.subscribe("table-redraw", this.layout.bind(this));
		this.subscribe("layout-refreshing", this.blockLayout.bind(this));
		this.subscribe("layout-refreshed", this.unblockLayout.bind(this));
		this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
	}
	
	blockLayout(){
		this.blocked = true;
	}
	
	unblockLayout(){
		this.blocked = false;
	}
	
	layoutCell(cell){
		this.layoutElement(cell.element, cell.column);
	}
	
	reinitializeColumns(){
		this.reset();
		
		this.table.columnManager.columnsByIndex.forEach((column) => {
			this.initializeColumn(column);
		});

		this.layout();
	}
	
	//initialize specific column
	initializeColumn(column){
		var config = {margin:0, edge:false};
		
		if(!column.isGroup){			
			if(this.frozenCheck(column)){
				config.position = this.initializationMode;
				
				if(this.initializationMode == "left"){
					this.leftColumns.push(column);
				}else {
					this.rightColumns.unshift(column);
				}
				
				this.active = true;
				
				column.modules.frozen = config;
			}else {
				this.initializationMode = "right";
			}
		}
	}
	
	frozenCheck(column){
		if(column.parent.isGroup && column.definition.frozen){
			console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups");
		}
		
		if(column.parent.isGroup){
			return this.frozenCheck(column.parent);
		}else {
			return column.definition.frozen;
		}
	}
	
	//layout calculation rows
	layoutCalcRows(){
		if(this.table.modExists("columnCalcs")){
			if(this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow){
				this.layoutRow(this.table.modules.columnCalcs.topRow);
			}
			
			if(this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow){
				this.layoutRow(this.table.modules.columnCalcs.botRow);
			}
			
			if(this.table.modExists("groupRows")){
				this.layoutGroupCalcs(this.table.modules.groupRows.getGroups());
			}
		}
	}
	
	layoutGroupCalcs(groups){
		groups.forEach((group) => {
			if(group.calcs.top){
				this.layoutRow(group.calcs.top);
			}
			
			if(group.calcs.bottom){
				this.layoutRow(group.calcs.bottom);
			}
			
			if(group.groupList && group.groupList.length){
				this.layoutGroupCalcs(group.groupList);
			}
		});
	}
	
	//calculate column positions and layout headers
	layoutColumnPosition(allCells){
		var leftParents = [];
		
		var leftMargin = 0;
		var rightMargin = 0;
		
		this.leftColumns.forEach((column, i) => {	
			column.modules.frozen.marginValue = leftMargin;
			column.modules.frozen.margin = column.modules.frozen.marginValue + "px";
			
			if(column.visible){
				leftMargin += column.getWidth();
			}
			
			if(i == this.leftColumns.length - 1){
				column.modules.frozen.edge = true;
			}else {
				column.modules.frozen.edge = false;
			}
			
			if(column.parent.isGroup){
				var parentEl = this.getColGroupParentElement(column);
				if(!leftParents.includes(parentEl)){
					this.layoutElement(parentEl, column);
					leftParents.push(parentEl);
				}
				
				parentEl.classList.toggle("tabulator-frozen-left",  column.modules.frozen.edge && column.modules.frozen.position === "left");
				parentEl.classList.toggle("tabulator-frozen-right", column.modules.frozen.edge && column.modules.frozen.position === "right");
			}else {
				this.layoutElement(column.getElement(), column);
			}
			
			if(allCells){
				column.cells.forEach((cell) => {
					this.layoutElement(cell.getElement(true), column);
				});
			}
		});
		
		this.rightColumns.forEach((column, i) => {
			
			column.modules.frozen.marginValue = rightMargin;
			column.modules.frozen.margin = column.modules.frozen.marginValue + "px";
			
			if(column.visible){
				rightMargin += column.getWidth();
			}
			
			if(i == this.rightColumns.length - 1){
				column.modules.frozen.edge = true;
			}else {
				column.modules.frozen.edge = false;
			}
			
			if(column.parent.isGroup){
				this.layoutElement(this.getColGroupParentElement(column), column);
			}else {
				this.layoutElement(column.getElement(), column);
			}
			
			if(allCells){
				column.cells.forEach((cell) => {
					this.layoutElement(cell.getElement(true), column);
				});
			}
		});
	}
	
	getColGroupParentElement(column){
		return column.parent.isGroup ? this.getColGroupParentElement(column.parent) : column.getElement();
	}
	
	//layout columns appropriately
	layout(){	
		if(this.active && !this.blocked){
			//calculate left columns
			this.layoutColumnPosition();
			
			this.reinitializeRows();
			
			this.layoutCalcRows();
		}
	}
	
	reinitializeRows(){
		var visibleRows = this.table.rowManager.getVisibleRows(true);
		var otherRows = this.table.rowManager.getRows().filter(row => !visibleRows.includes(row));
		
		otherRows.forEach((row) =>{
			row.deinitialize();
		});
		
		visibleRows.forEach((row) =>{
			if(row.type === "row"){
				this.layoutRow(row);
			}
		});
	}
	
	layoutRow(row){
		if(this.table.options.layout === "fitDataFill" && this.rightColumns.length){
			this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")";
		}
		
		this.leftColumns.forEach((column) => {
			var cell = row.getCell(column);
			
			if(cell){
				this.layoutElement(cell.getElement(true), column);
			}
		});
		
		this.rightColumns.forEach((column) => {
			var cell = row.getCell(column);
			
			if(cell){
				this.layoutElement(cell.getElement(true), column);
			}
		});
	}
	
	layoutElement(element, column){
		var position;
		
		if(column.modules.frozen && element){
			element.style.position = "sticky";

			if(this.table.rtl){
				position = column.modules.frozen.position === "left" ? "right" : "left";
			}else {
				position = column.modules.frozen.position;
			}
		
			element.style[position] = column.modules.frozen.margin;

			element.classList.add("tabulator-frozen");
			
			element.classList.toggle("tabulator-frozen-left",  column.modules.frozen.edge && column.modules.frozen.position === "left");
			element.classList.toggle("tabulator-frozen-right", column.modules.frozen.edge && column.modules.frozen.position === "right");
		}
	}

	adjustForScrollbar(width){
		if(this.rightColumns.length){
			this.table.columnManager.getContentsElement().style.width = "calc(100% - " + width + "px)";
		}
	}
	
	_calcSpace(columns, index){
		var width = 0;
		
		for (let i = 0; i < index; i++){
			if(columns[i].visible){
				width += columns[i].getWidth();
			}
		}
		
		return width;
	}
}

FrozenColumns.moduleName = "frozenColumns";

class FrozenRows extends Module{

	constructor(table){
		super(table);

		this.topElement = document.createElement("div");
		this.rows = [];

		//register component functions
		this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this));
		this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this));
		this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this));

		//register table options
		this.registerTableOption("frozenRowsField", "id"); //field to choose frozen rows by
		this.registerTableOption("frozenRows", false); //holder for frozen row identifiers
	}

	initialize(){
		var	fragment = document.createDocumentFragment();
		
		this.rows = [];

		this.topElement.classList.add("tabulator-frozen-rows-holder");
		
		fragment.appendChild(document.createElement("br"));
		fragment.appendChild(this.topElement);

		// this.table.columnManager.element.append(this.topElement);
		this.table.columnManager.getContentsElement().insertBefore(fragment, this.table.columnManager.headersElement.nextSibling);

		this.subscribe("row-deleting", this.detachRow.bind(this));
		this.subscribe("rows-visible", this.visibleRows.bind(this));

		this.registerDisplayHandler(this.getRows.bind(this), 10);

		if(this.table.options.frozenRows){
			this.subscribe("data-processed", this.initializeRows.bind(this));
			this.subscribe("row-added", this.initializeRow.bind(this));
			this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this));
			this.subscribe("column-resized", this.resizeHolderWidth.bind(this));
			this.subscribe("column-show", this.resizeHolderWidth.bind(this));
			this.subscribe("column-hide", this.resizeHolderWidth.bind(this));
		}

		this.resizeHolderWidth();
	}

	resizeHolderWidth(){
		this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
	}

	initializeRows(){
		this.table.rowManager.getRows().forEach((row) => {
			this.initializeRow(row);
		});
	}

	initializeRow(row){
		var frozenRows = this.table.options.frozenRows,
		rowType = typeof frozenRows;

		if(rowType === "number"){
			if(row.getPosition() && (row.getPosition() + this.rows.length) <= frozenRows){
				this.freezeRow(row);
			}
		}else if(rowType === "function"){
			if(frozenRows.call(this.table, row.getComponent())){
				this.freezeRow(row);
			}
		}else if(Array.isArray(frozenRows)){
			if(frozenRows.includes(row.data[this.options("frozenRowsField")])){
				this.freezeRow(row);
			}
		}
	}

	isRowFrozen(row){
		var index = this.rows.indexOf(row);
		return index > -1;
	}

	isFrozen(){
		return !!this.rows.length;
	}

	visibleRows(viewable, rows){
		this.rows.forEach((row) => {
			rows.push(row);
		});

		return rows;
	}

	//filter frozen rows out of display data
	getRows(rows){
		var output = rows.slice(0);

		this.rows.forEach(function(row){
			var index = output.indexOf(row);

			if(index > -1){
				output.splice(index, 1);
			}
		});

		return output;
	}

	freezeRow(row){
		if(!row.modules.frozen){
			row.modules.frozen = true;
			this.topElement.appendChild(row.getElement());
			row.initialize();
			row.normalizeHeight();
		
			this.rows.push(row);

			this.refreshData(false, "display");

			this.table.rowManager.adjustTableSize();

			this.styleRows();

		}else {
			console.warn("Freeze Error - Row is already frozen");
		}
	}

	unfreezeRow(row){
		if(row.modules.frozen){

			row.modules.frozen = false;

			this.detachRow(row);

			this.table.rowManager.adjustTableSize();

			this.refreshData(false, "display");

			if(this.rows.length){
				this.styleRows();
			}

		}else {
			console.warn("Freeze Error - Row is already unfrozen");
		}
	}

	detachRow(row){
		var index = this.rows.indexOf(row);

		if(index > -1){
			var rowEl = row.getElement();

			if(rowEl.parentNode){
				rowEl.parentNode.removeChild(rowEl);
			}

			this.rows.splice(index, 1);
		}
	}

	styleRows(row){
		this.rows.forEach((row, i) => {
			this.table.rowManager.styleRow(row, i);
		});
	}
}

FrozenRows.moduleName = "frozenRows";

//public group object
class GroupComponent {
	constructor (group){
		this._group = group;
		this.type = "GroupComponent";

		return new Proxy(this, {
			get: function(target, name, receiver) {
				if (typeof target[name] !== "undefined") {
					return target[name];
				}else {
					return target._group.groupManager.table.componentFunctionBinder.handle("group", target._group, name);
				}
			}
		});
	}

	getKey(){
		return this._group.key;
	}

	getField(){
		return this._group.field;
	}

	getElement(){
		return this._group.element;
	}

	getRows(){
		return this._group.getRows(true);
	}

	getSubGroups(){
		return this._group.getSubGroups(true);
	}

	getParentGroup(){
		return this._group.parent ? this._group.parent.getComponent() : false;
	}

	isVisible(){
		return this._group.visible;
	}

	show(){
		this._group.show();
	}

	hide(){
		this._group.hide();
	}

	toggle(){
		this._group.toggleVisibility();
	}

	scrollTo(position, ifVisible){
		return this._group.groupManager.table.rowManager.scrollToRow(this._group, position, ifVisible);
	}

	_getSelf(){
		return this._group;
	}

	getTable(){
		return this._group.groupManager.table;
	}
}

//Group functions
class Group{
	
	constructor(groupManager, parent, level, key, field, generator, oldGroup){
		this.groupManager = groupManager;
		this.parent = parent;
		this.key = key;
		this.level = level;
		this.field = field;
		this.hasSubGroups = level < (groupManager.groupIDLookups.length - 1);
		this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow;
		this.type = "group"; //type of element
		this.old = oldGroup;
		this.rows = [];
		this.groups = [];
		this.groupList = [];
		this.generator = generator;
		this.element = false;
		this.elementContents = false;
		this.height = 0;
		this.outerHeight = 0;
		this.initialized = false;
		this.calcs = {};
		this.initialized = false;
		this.modules = {};
		this.arrowElement = false;
		
		this.visible = oldGroup ? oldGroup.visible : (typeof groupManager.startOpen[level] !== "undefined" ? groupManager.startOpen[level] : groupManager.startOpen[0]);
		
		this.component = null;
		
		this.createElements();
		this.addBindings();
		
		this.createValueGroups();
	}
	
	wipe(elementsOnly){
		if(!elementsOnly){
			if(this.groupList.length){
				this.groupList.forEach(function(group){
					group.wipe();
				});
			}else {
				this.rows.forEach((row) => {
					if(row.modules){
						delete row.modules.group;
					}
				});
			}
		}
		
		this.element = false;
		this.arrowElement = false;
		this.elementContents = false;
	}
	
	createElements(){
		var arrow = document.createElement("div");
		arrow.classList.add("tabulator-arrow");
		
		this.element = document.createElement("div");
		this.element.classList.add("tabulator-row");
		this.element.classList.add("tabulator-group");
		this.element.classList.add("tabulator-group-level-" + this.level);
		this.element.setAttribute("role", "rowgroup");
		
		this.arrowElement = document.createElement("div");
		this.arrowElement.classList.add("tabulator-group-toggle");
		this.arrowElement.appendChild(arrow);
		
		//setup movable rows
		if(this.groupManager.table.options.movableRows !== false && this.groupManager.table.modExists("moveRow")){
			this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
		}
	}
	
	createValueGroups(){
		var level = this.level + 1;
		if(this.groupManager.allowedValues && this.groupManager.allowedValues[level]){
			this.groupManager.allowedValues[level].forEach((value) => {
				this._createGroup(value, level);
			});
		}
	}
	
	addBindings(){
		var toggleElement;
		
		if(this.groupManager.table.options.groupToggleElement){
			toggleElement = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element;
			
			toggleElement.addEventListener("click", (e) => {
				if(this.groupManager.table.options.groupToggleElement === "arrow"){
					e.stopPropagation();
					e.stopImmediatePropagation();
				}

				//allow click event to propagate before toggling visibility
				setTimeout(() => {
					this.toggleVisibility();
				});
			});
		}
	}
	
	_createGroup(groupID, level){
		var groupKey = level + "_" + groupID;
		var group = new Group(this.groupManager, this, level, groupID,  this.groupManager.groupIDLookups[level].field, this.groupManager.headerGenerator[level] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[groupKey] : false);
		
		this.groups[groupKey] = group;
		this.groupList.push(group);
	}
	
	_addRowToGroup(row){
		
		var level = this.level + 1;
		
		if(this.hasSubGroups){
			var groupID = this.groupManager.groupIDLookups[level].func(row.getData()),
			groupKey = level + "_" + groupID;
			
			if(this.groupManager.allowedValues && this.groupManager.allowedValues[level]){
				if(this.groups[groupKey]){
					this.groups[groupKey].addRow(row);
				}
			}else {
				if(!this.groups[groupKey]){
					this._createGroup(groupID, level);
				}
				
				this.groups[groupKey].addRow(row);
			}
		}
	}
	
	_addRow(row){
		this.rows.push(row);
		row.modules.group = this;
	}
	
	insertRow(row, to, after){
		var data = this.conformRowData({});
		
		row.updateData(data);
		
		var toIndex = this.rows.indexOf(to);
		
		if(toIndex > -1){
			if(after){
				this.rows.splice(toIndex+1, 0, row);
			}else {
				this.rows.splice(toIndex, 0, row);
			}
		}else {
			if(after){
				this.rows.push(row);
			}else {
				this.rows.unshift(row);
			}
		}
		
		row.modules.group = this;
		
		// this.generateGroupHeaderContents();
		
		if(this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table"){
			this.groupManager.table.modules.columnCalcs.recalcGroup(this);
		}
		
		this.groupManager.updateGroupRows(true);
	}
	
	scrollHeader(left){
		if(this.arrowElement){
			this.arrowElement.style.marginLeft = left;
			
			this.groupList.forEach(function(child){
				child.scrollHeader(left);
			});
		}
	}
	
	getRowIndex(row){}
	
	//update row data to match grouping constraints
	conformRowData(data){
		if(this.field){
			data[this.field] = this.key;
		}else {
			console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function");
		}
		
		if(this.parent){
			data = this.parent.conformRowData(data);
		}
		
		return data;
	}
	
	removeRow(row){
		var index = this.rows.indexOf(row);
		var el = row.getElement();
		
		if(index > -1){
			this.rows.splice(index, 1);
		}
		
		if(!this.groupManager.table.options.groupValues && !this.rows.length){
			if(this.parent){
				this.parent.removeGroup(this);
			}else {
				this.groupManager.removeGroup(this);
			}		
			
			this.groupManager.updateGroupRows(true);
			
		}else {
			
			if(el.parentNode){
				el.parentNode.removeChild(el);
			}
			
			if(!this.groupManager.blockRedraw){
				this.generateGroupHeaderContents();
				
				if(this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table"){
					this.groupManager.table.modules.columnCalcs.recalcGroup(this);
				}
			}
			
		}
	}
	
	removeGroup(group){
		var groupKey = group.level + "_" + group.key,
		index;
		
		if(this.groups[groupKey]){
			delete this.groups[groupKey];
			
			index = this.groupList.indexOf(group);
			
			if(index > -1){
				this.groupList.splice(index, 1);
			}
			
			if(!this.groupList.length){
				if(this.parent){
					this.parent.removeGroup(this);
				}else {
					this.groupManager.removeGroup(this);
				}
			}
		}
	}
	
	getHeadersAndRows(){
		var output = [];
		
		output.push(this);
		
		this._visSet();
		
		
		if(this.calcs.top){
			this.calcs.top.detachElement();
			this.calcs.top.deleteCells();
		}
		
		if(this.calcs.bottom){
			this.calcs.bottom.detachElement();
			this.calcs.bottom.deleteCells();
		}
		
		
		
		if(this.visible){
			if(this.groupList.length){
				this.groupList.forEach(function(group){
					output = output.concat(group.getHeadersAndRows());
				});
				
			}else {
				if(this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs()){
					this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
					output.push(this.calcs.top);
				}
				
				output = output.concat(this.rows);
				
				if(this.groupManager.table.options.columnCalcs != "table" &&  this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs()){
					this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
					output.push(this.calcs.bottom);
				}
			}
		}else {
			if(!this.groupList.length && this.groupManager.table.options.columnCalcs != "table"){
				
				if(this.groupManager.table.modExists("columnCalcs")){
					if(this.groupManager.table.modules.columnCalcs.hasTopCalcs()){
						if(this.groupManager.table.options.groupClosedShowCalcs){
							this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
							output.push(this.calcs.top);
						}
					}
					
					if(this.groupManager.table.modules.columnCalcs.hasBottomCalcs()){						
						if(this.groupManager.table.options.groupClosedShowCalcs){
							this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
							output.push(this.calcs.bottom);
						}
					}
				}
			}
			
		}
		
		return output;
	}
	
	getData(visible, transform){
		var output = [];
		
		this._visSet();
		
		if(!visible || (visible && this.visible)){
			this.rows.forEach((row) => {
				output.push(row.getData(transform || "data"));
			});
		}
		
		return output;
	}
	
	getRowCount(){
		var count = 0;
		
		if(this.groupList.length){
			this.groupList.forEach((group) => {
				count += group.getRowCount();
			});
		}else {
			count = this.rows.length;
		}
		return count;
	}

	
	toggleVisibility(){
		if(this.visible){
			this.hide();
		}else {
			this.show();
		}
	}
	
	hide(){
		this.visible = false;
		
		if(this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination){
			
			this.element.classList.remove("tabulator-group-visible");
			
			if(this.groupList.length){
				this.groupList.forEach((group) => {
					
					var rows = group.getHeadersAndRows();
					
					rows.forEach((row) => {
						row.detachElement();
					});
				});
				
			}else {
				this.rows.forEach((row) => {
					var rowEl = row.getElement();
					rowEl.parentNode.removeChild(rowEl);
				});
			}
			
			this.groupManager.updateGroupRows(true);
			
		}else {
			this.groupManager.updateGroupRows(true);
		}
		
		this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), false);
	}
	
	show(){
		this.visible = true;
		
		if(this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination){
			
			this.element.classList.add("tabulator-group-visible");
			
			var prev = this.generateElement();
			
			if(this.groupList.length){
				this.groupList.forEach((group) => {
					var rows = group.getHeadersAndRows();
					
					rows.forEach((row) => {
						var rowEl = row.getElement();
						prev.parentNode.insertBefore(rowEl, prev.nextSibling);
						row.initialize();
						prev = rowEl;
					});
				});
				
			}else {
				this.rows.forEach((row) => {
					var rowEl = row.getElement();
					prev.parentNode.insertBefore(rowEl, prev.nextSibling);
					row.initialize();
					prev = rowEl;
				});
			}
			
			this.groupManager.updateGroupRows(true);
		}else {
			this.groupManager.updateGroupRows(true);
		}
		
		this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), true);
	}
	
	_visSet(){
		var data = [];
		
		if(typeof this.visible == "function"){
			
			this.rows.forEach(function(row){
				data.push(row.getData());
			});
			
			this.visible = this.visible(this.key, this.getRowCount(), data, this.getComponent());
		}
	}
	
	getRowGroup(row){
		var match = false;
		if(this.groupList.length){
			this.groupList.forEach(function(group){
				var result = group.getRowGroup(row);
				
				if(result){
					match = result;
				}
			});
		}else {
			if(this.rows.find(function(item){
				return item === row;
			})){
				match = this;
			}
		}
		
		return match;
	}
	
	getSubGroups(component){
		var output = [];
		
		this.groupList.forEach(function(child){
			output.push(component ? child.getComponent() : child);
		});
		
		return output;
	}
	
	getRows(component, includeChildren){
		var output = [];
		
		if(includeChildren && this.groupList.length){
			this.groupList.forEach((group) => {
				output = output.concat(group.getRows(component, includeChildren));
			});
		}else {
			this.rows.forEach(function(row){
				output.push(component ? row.getComponent() : row);
			});
		}
		
		return output;
	}
	
	generateGroupHeaderContents(){
		var data = [];
		
		var rows = this.getRows(false, true);
		
		rows.forEach(function(row){
			data.push(row.getData());
		});
		
		this.elementContents = this.generator(this.key, this.getRowCount(), data, this.getComponent());
		
		while(this.element.firstChild) this.element.removeChild(this.element.firstChild);
		
		if(typeof this.elementContents === "string"){
			this.element.innerHTML = this.elementContents;
		}else {
			this.element.appendChild(this.elementContents);
		}
		
		this.element.insertBefore(this.arrowElement, this.element.firstChild);
	}
	
	getPath(path = []) {
		path.unshift(this.key);
		if(this.parent) {
			this.parent.getPath(path);
		}
		return path;
	}
	
	////////////// Standard Row Functions //////////////
	
	getElement(){
		return this.elementContents ? this.element : this.generateElement();
	}
	
	generateElement(){
		this.addBindings = false;
		
		this._visSet();
		
		if(this.visible){
			this.element.classList.add("tabulator-group-visible");
		}else {
			this.element.classList.remove("tabulator-group-visible");
		}
		
		for(var i = 0; i < this.element.childNodes.length; ++i){
			this.element.childNodes[i].parentNode.removeChild(this.element.childNodes[i]);
		}
		
		this.generateGroupHeaderContents();
		
		// this.addBindings();
		
		return this.element;
	}
	
	detachElement(){
		if (this.element && this.element.parentNode){
			this.element.parentNode.removeChild(this.element);
		}
	}
	
	//normalize the height of elements in the row
	normalizeHeight(){
		this.setHeight(this.element.clientHeight);
	}
	
	initialize(force){
		if(!this.initialized || force){
			this.normalizeHeight();
			this.initialized = true;
		}
	}
	
	reinitialize(){
		this.initialized = false;
		this.height = 0;
		
		if(Helpers.elVisible(this.element)){
			this.initialize(true);
		}
	}
	
	setHeight(height){
		if(this.height != height){
			this.height = height;
			this.outerHeight = this.element.offsetHeight;
		}
	}
	
	//return rows outer height
	getHeight(){
		return this.outerHeight;
	}
	
	getGroup(){
		return this;
	}
	
	reinitializeHeight(){}
	
	calcHeight(){}
	
	setCellHeight(){}
	
	clearCellHeight(){}
	
	deinitializeHeight(){}

	rendered(){}
	
	//////////////// Object Generation /////////////////
	getComponent(){
		if(!this.component){
			this.component = new GroupComponent(this);
		}
		
		return this.component;
	}
}

class GroupRows extends Module{
	
	constructor(table){
		super(table);
		
		this.groupIDLookups = false; //enable table grouping and set field to group by
		this.startOpen = [function(){return false;}]; //starting state of group
		this.headerGenerator = [function(){return "";}];
		this.groupList = []; //ordered list of groups
		this.allowedValues = false;
		this.groups = {}; //hold row groups
		
		this.displayHandler = this.getRows.bind(this);

		this.blockRedraw = false;
		
		//register table options
		this.registerTableOption("groupBy", false); //enable table grouping and set field to group by
		this.registerTableOption("groupStartOpen", true); //starting state of group
		this.registerTableOption("groupValues", false);
		this.registerTableOption("groupUpdateOnCellEdit", false);
		this.registerTableOption("groupHeader", false); //header generation function
		this.registerTableOption("groupHeaderPrint", null);
		this.registerTableOption("groupHeaderClipboard", null);
		this.registerTableOption("groupHeaderHtmlOutput", null);
		this.registerTableOption("groupHeaderDownload", null);
		this.registerTableOption("groupToggleElement", "arrow");
		this.registerTableOption("groupClosedShowCalcs", false);
		
		//register table functions
		this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this));
		this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this));
		this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this));
		this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this));
		this.registerTableFunction("getGroups", this.userGetGroups.bind(this));
		this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this));
		
		//register component functions
		this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
	}
	
	//initialize group configuration
	initialize(){
		this.subscribe("table-destroy", this._blockRedrawing.bind(this));
		this.subscribe("rows-wipe", this._blockRedrawing.bind(this));
		this.subscribe("rows-wiped", this._restore_redrawing.bind(this));

		if(this.table.options.groupBy){
			if(this.table.options.groupUpdateOnCellEdit){
				this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
				this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0);
			}
			
			this.subscribe("table-built", this.configureGroupSetup.bind(this));
			
			this.subscribe("row-deleting", this.rowDeleting.bind(this));
			this.subscribe("row-deleted", this.rowsUpdated.bind(this));
			this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this));
			this.subscribe("rows-wipe", this.wipe.bind(this));
			this.subscribe("rows-added", this.rowsUpdated.bind(this));
			this.subscribe("row-moving", this.rowMoving.bind(this));
			this.subscribe("row-adding-index", this.rowAddingIndex.bind(this));
			
			this.subscribe("rows-sample", this.rowSample.bind(this));
			
			this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this));
			
			this.registerDisplayHandler(this.displayHandler, 20);
			
			this.initialized = true;
		}
	}
	
	_blockRedrawing(){
		this.blockRedraw = true;
	}

	_restore_redrawing(){
		this.blockRedraw = false;
	}

	configureGroupSetup(){
		if(this.table.options.groupBy){
			var groupBy = this.table.options.groupBy,
			startOpen = this.table.options.groupStartOpen,
			groupHeader = this.table.options.groupHeader;
			
			this.allowedValues = this.table.options.groupValues;
			
			if(Array.isArray(groupBy) && Array.isArray(groupHeader) && groupBy.length > groupHeader.length){
				console.warn("Error creating group headers, groupHeader array is shorter than groupBy array");
			}
			
			this.headerGenerator = [function(){return "";}];
			this.startOpen = [function(){return false;}]; //starting state of group
			
			this.langBind("groups|item", (langValue, lang) => {
				this.headerGenerator[0] = (value, count, data) => { //header layout function
					return (typeof value === "undefined" ? "" : value) + "<span>(" + count + " " + ((count === 1) ? langValue : lang.groups.items) + ")</span>";
				};
			});
			
			this.groupIDLookups = [];
			
			if(groupBy){
				if(this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both"){
					this.table.modules.columnCalcs.removeCalcs();
				}
			}else {
				if(this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group"){
					
					var cols = this.table.columnManager.getRealColumns();
					
					cols.forEach((col) => {
						if(col.definition.topCalc){
							this.table.modules.columnCalcs.initializeTopRow();
						}
						
						if(col.definition.bottomCalc){
							this.table.modules.columnCalcs.initializeBottomRow();
						}
					});
				}
			}
			
			if(!Array.isArray(groupBy)){
				groupBy = [groupBy];
			}
			
			groupBy.forEach((group, i) => {
				var lookupFunc, column;
				
				if(typeof group == "function"){
					lookupFunc = group;
				}else {
					column = this.table.columnManager.getColumnByField(group);
					
					if(column){
						lookupFunc = function(data){
							return column.getFieldValue(data);
						};
					}else {
						lookupFunc = function(data){
							return data[group];
						};
					}
				}
				
				this.groupIDLookups.push({
					field: typeof group === "function" ? false : group,
					func:lookupFunc,
					values:this.allowedValues ? this.allowedValues[i] : false,
				});
			});
			
			if(startOpen){
				if(!Array.isArray(startOpen)){
					startOpen = [startOpen];
				}
				
				startOpen.forEach((level) => {
				});
				
				this.startOpen = startOpen;
			}
			
			if(groupHeader){
				this.headerGenerator = Array.isArray(groupHeader) ? groupHeader : [groupHeader];
			}
		}else {
			this.groupList = [];
			this.groups = {};
		}
	}
	
	rowSample(rows, prevValue){
		if(this.table.options.groupBy){
			var group = this.getGroups(false)[0];
			
			prevValue.push(group.getRows(false)[0]);
		}
		
		return prevValue;
	}
	
	virtualRenderFill(){
		var el = this.table.rowManager.tableElement;
		var rows = this.table.rowManager.getVisibleRows();
		
		if(this.table.options.groupBy){
			rows = rows.filter((row) => {
				return row.type !== "group";
			});
			
			el.style.minWidth = !rows.length ? this.table.columnManager.getWidth() + "px" : "";
		}else {
			return rows;
		}
	}
	
	rowAddingIndex(row, index, top){
		if(this.table.options.groupBy){
			this.assignRowToGroup(row);
			
			var groupRows = row.modules.group.rows;
			
			if(groupRows.length > 1){
				if(!index || (index && groupRows.indexOf(index) == -1)){
					if(top){
						if(groupRows[0] !== row){
							index = groupRows[0];
							this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top);
						}
					}else {
						if(groupRows[groupRows.length -1] !== row){
							index = groupRows[groupRows.length -1];
							this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top);
						}
					}
				}else {
					this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top);
				}
			}
			
			return index;
		}
	}
	
	trackChanges(){
		this.dispatch("group-changed");
	}
	
	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////
	
	setGroupBy(groups){
		this.table.options.groupBy = groups;
		
		if(!this.initialized){
			this.initialize();
		}
		
		this.configureGroupSetup();

		if(!groups && this.table.modExists("columnCalcs") && this.table.options.columnCalcs === true){
			this.table.modules.columnCalcs.reinitializeCalcs();
		}
		
		this.refreshData();
		
		this.trackChanges();
	}
	
	setGroupValues(groupValues){
		this.table.options.groupValues = groupValues;
		this.configureGroupSetup();
		this.refreshData();
		
		this.trackChanges();
	}
	
	setGroupStartOpen(values){
		this.table.options.groupStartOpen = values;
		this.configureGroupSetup();
		
		if(this.table.options.groupBy){
			this.refreshData();
			
			this.trackChanges();
		}else {
			console.warn("Grouping Update - cant refresh view, no groups have been set");
		}
	}
	
	setGroupHeader(values){
		this.table.options.groupHeader = values;
		this.configureGroupSetup();
		
		if(this.table.options.groupBy){
			this.refreshData();
			
			this.trackChanges();
		}else {
			console.warn("Grouping Update - cant refresh view, no groups have been set");
		}
	}
	
	userGetGroups(values){
		return this.getGroups(true);
	}
	
	// get grouped table data in the same format as getData()
	userGetGroupedData(){
		return this.table.options.groupBy ? this.getGroupedData() : this.getData();
	}
	
	
	///////////////////////////////////////
	///////// Component Functions /////////
	///////////////////////////////////////
	
	rowGetGroup(row){
		return row.modules.group ? row.modules.group.getComponent() : false;
	}
	
	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////
	
	rowMoving(from, to, after){
		if(this.table.options.groupBy){
			if(!after && to instanceof Group){
				to = this.table.rowManager.prevDisplayRow(from) || to;
			}
			
			var toGroup = to instanceof Group ? to : to.modules.group;
			var fromGroup = from instanceof Group ? from : from.modules.group;
			
			if(toGroup === fromGroup){
				this.table.rowManager.moveRowInArray(toGroup.rows, from, to, after);
			}else {
				if(fromGroup){
					fromGroup.removeRow(from);
				}
				
				toGroup.insertRow(from, to, after);
			}
		}
	}
	
	
	rowDeleting(row){
		//remove from group
		if(this.table.options.groupBy && row.modules.group){
			row.modules.group.removeRow(row);
		}
	}
	
	rowsUpdated(row){
		if(this.table.options.groupBy){
			this.updateGroupRows(true);
		}	
	}
	
	cellUpdated(cell){
		if(this.table.options.groupBy){
			this.reassignRowToGroup(cell.row);
		}
	}
	
	//return appropriate rows with group headers
	getRows(rows){
		if(this.table.options.groupBy && this.groupIDLookups.length){
			
			this.dispatchExternal("dataGrouping");
			
			this.generateGroups(rows);
			
			if(this.subscribedExternal("dataGrouped")){
				this.dispatchExternal("dataGrouped", this.getGroups(true));
			}
			
			return this.updateGroupRows();
			
		}else {
			return rows.slice(0);
		}
	}
	
	getGroups(component){
		var groupComponents = [];
		
		this.groupList.forEach(function(group){
			groupComponents.push(component ? group.getComponent() : group);
		});
		
		return groupComponents;
	}
	
	getChildGroups(group){
		var groupComponents = [];
		
		if(!group){
			group = this;
		}
		
		group.groupList.forEach((child) => {
			if(child.groupList.length){
				groupComponents = groupComponents.concat(this.getChildGroups(child));
			}else {
				groupComponents.push(child);
			}
		});
		
		return groupComponents;
	}
	
	wipe(){
		if(this.table.options.groupBy){
			this.groupList.forEach(function(group){
				group.wipe();
			});
			
			this.groupList = [];
			this.groups = {};
		}
	}
	
	pullGroupListData(groupList) {
		var groupListData = [];
		
		groupList.forEach((group) => {
			var groupHeader = {};
			groupHeader.level = 0;
			groupHeader.rowCount = 0;
			groupHeader.headerContent = "";
			var childData = [];
			
			if (group.hasSubGroups) {
				childData = this.pullGroupListData(group.groupList);
				
				groupHeader.level = group.level;
				groupHeader.rowCount = childData.length - group.groupList.length; // data length minus number of sub-headers
				groupHeader.headerContent = group.generator(group.key, groupHeader.rowCount, group.rows, group);
				
				groupListData.push(groupHeader);
				groupListData = groupListData.concat(childData);
			}
			
			else {
				groupHeader.level = group.level;
				groupHeader.headerContent = group.generator(group.key, group.rows.length, group.rows, group);
				groupHeader.rowCount = group.getRows().length;
				
				groupListData.push(groupHeader);
				
				group.getRows().forEach((row) => {
					groupListData.push(row.getData("data"));
				});
			}
		});
		
		return groupListData;
	}
	
	getGroupedData(){
		
		return this.pullGroupListData(this.groupList);
	}
	
	getRowGroup(row){
		var match = false;
		
		if(this.options("dataTree")){
			row = this.table.modules.dataTree.getTreeParentRoot(row);
		}
		
		this.groupList.forEach((group) => {
			var result = group.getRowGroup(row);
			
			if(result){
				match = result;
			}
		});
		
		return match;
	}
	
	countGroups(){
		return this.groupList.length;
	}
	
	generateGroups(rows){
		var oldGroups = this.groups;
		
		this.groups = {};
		this.groupList = [];
		
		if(this.allowedValues && this.allowedValues[0]){
			this.allowedValues[0].forEach((value) => {
				this.createGroup(value, 0, oldGroups);
			});
			
			rows.forEach((row) => {
				this.assignRowToExistingGroup(row, oldGroups);
			});
		}else {
			rows.forEach((row) => {
				this.assignRowToGroup(row, oldGroups);
			});
		}
		
		Object.values(oldGroups).forEach((group) => {
			group.wipe(true);
		});	
	}
	
	
	createGroup(groupID, level, oldGroups){
		var groupKey = level + "_" + groupID,
		group;
		
		oldGroups = oldGroups || [];
		
		group = new Group(this, false, level, groupID, this.groupIDLookups[0].field, this.headerGenerator[0], oldGroups[groupKey]);
		
		this.groups[groupKey] = group;
		this.groupList.push(group);
	}
	
	assignRowToExistingGroup(row, oldGroups){
		var groupID = this.groupIDLookups[0].func(row.getData()),
		groupKey = "0_" + groupID;
		
		if(this.groups[groupKey]){
			this.groups[groupKey].addRow(row);
		}
	}
	
	assignRowToGroup(row, oldGroups){
		var groupID = this.groupIDLookups[0].func(row.getData()),
		newGroupNeeded = !this.groups["0_" + groupID];
		
		if(newGroupNeeded){
			this.createGroup(groupID, 0, oldGroups);
		}
		
		this.groups["0_" + groupID].addRow(row);
		
		return !newGroupNeeded;
	}
	
	reassignRowToGroup(row){
		if(row.type === "row"){
			var oldRowGroup = row.modules.group,
			oldGroupPath = oldRowGroup.getPath(),
			newGroupPath = this.getExpectedPath(row),
			samePath;
			
			// figure out if new group path is the same as old group path
			samePath = (oldGroupPath.length == newGroupPath.length) && oldGroupPath.every((element, index) => {
				return element === newGroupPath[index];
			});
			
			// refresh if they new path and old path aren't the same (aka the row's groupings have changed)
			if(!samePath) {
				oldRowGroup.removeRow(row);
				this.assignRowToGroup(row, this.groups);
				this.refreshData(true);
			}
		}
	}
	
	getExpectedPath(row) {
		var groupPath = [], rowData = row.getData();
		
		this.groupIDLookups.forEach((groupId) => {
			groupPath.push(groupId.func(rowData));
		});
		
		return groupPath;
	}
	
	updateGroupRows(force){
		var output = [];

		if(!this.blockRedraw){
			this.groupList.forEach((group) => {
				output = output.concat(group.getHeadersAndRows());
			});
			
			if(force){
				this.refreshData(true);
			}
		}
		
		return output;
	}
	
	scrollHeaders(left){
		if(this.table.options.groupBy){
			if(this.table.options.renderHorizontal === "virtual"){
				left -= this.table.columnManager.renderer.vDomPadLeft;
			}
			
			left = left + "px";
			
			this.groupList.forEach((group) => {
				group.scrollHeader(left);
			});
		}
	}
	
	removeGroup(group){
		var groupKey = group.level + "_" + group.key,
		index;
		
		if(this.groups[groupKey]){
			delete this.groups[groupKey];
			
			index = this.groupList.indexOf(group);
			
			if(index > -1){
				this.groupList.splice(index, 1);
			}
		}
	}
	
	checkBasicModeGroupHeaderWidth(){
		var element = this.table.rowManager.tableElement,
		onlyGroupHeaders = true;
		
		this.table.rowManager.getDisplayRows().forEach((row, index) =>{
			this.table.rowManager.styleRow(row, index);
			element.appendChild(row.getElement());
			row.initialize(true);
			
			if(row.type !== "group"){
				onlyGroupHeaders = false;
			}
		});
		
		if(onlyGroupHeaders){
			element.style.minWidth = this.table.columnManager.getWidth() + "px";
		}else {
			element.style.minWidth = "";
		}
	}
	
}

GroupRows.moduleName = "groupRows";

var defaultUndoers = {
	cellEdit: function(action){
		action.component.setValueProcessData(action.data.oldValue);
		action.component.cellRendered();
	},

	rowAdd: function(action){
		action.component.deleteActual();

		this.table.rowManager.checkPlaceholder();
	},

	rowDelete: function(action){
		var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);

		if(this.table.options.groupBy && this.table.modExists("groupRows")){
			this.table.modules.groupRows.updateGroupRows(true);
		}

		this._rebindRow(action.component, newRow);

		this.table.rowManager.checkPlaceholder();
	},

	rowMove: function(action){
		var after = (action.data.posFrom  - action.data.posTo) > 0;

		this.table.rowManager.moveRowActual(action.component, this.table.rowManager.getRowFromPosition(action.data.posFrom), after);

		this.table.rowManager.regenerateRowPositions();
		this.table.rowManager.reRenderInPosition();
	},
};

var defaultRedoers = {
	cellEdit: function(action){
		action.component.setValueProcessData(action.data.newValue);
		action.component.cellRendered();
	},

	rowAdd: function(action){
		var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);

		if(this.table.options.groupBy && this.table.modExists("groupRows")){
			this.table.modules.groupRows.updateGroupRows(true);
		}

		this._rebindRow(action.component, newRow);

		this.table.rowManager.checkPlaceholder();
	},

	rowDelete:function(action){
		action.component.deleteActual();

		this.table.rowManager.checkPlaceholder();
	},

	rowMove: function(action){
		this.table.rowManager.moveRowActual(action.component, this.table.rowManager.getRowFromPosition(action.data.posTo), action.data.after);
		
		this.table.rowManager.regenerateRowPositions();
		this.table.rowManager.reRenderInPosition();
	},
};

class History extends Module{

	constructor(table){
		super(table);

		this.history = [];
		this.index = -1;

		this.registerTableOption("history", false); //enable edit history
	}

	initialize(){
		if(this.table.options.history){
			this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
			this.subscribe("cell-delete", this.clearComponentHistory.bind(this));
			this.subscribe("row-delete", this.rowDeleted.bind(this));
			this.subscribe("rows-wipe", this.clear.bind(this));
			this.subscribe("row-added", this.rowAdded.bind(this));
			this.subscribe("row-move", this.rowMoved.bind(this));
		}

		this.registerTableFunction("undo", this.undo.bind(this));
		this.registerTableFunction("redo", this.redo.bind(this));
		this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this));
		this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this));
		this.registerTableFunction("clearHistory", this.clear.bind(this));
	}

	rowMoved(from, to, after){
		this.action("rowMove", from, {posFrom:from.getPosition(), posTo:to.getPosition(), to:to, after:after});
	}

	rowAdded(row, data, pos, index){
		this.action("rowAdd", row, {data:data, pos:pos, index:index});
	}

	rowDeleted(row){
		var index, rows;

		if(this.table.options.groupBy){

			rows = row.getComponent().getGroup()._getSelf().rows;
			index = rows.indexOf(row);

			if(index){
				index = rows[index-1];
			}
		}else {
			index = row.table.rowManager.getRowIndex(row);

			if(index){
				index = row.table.rowManager.rows[index-1];
			}
		}

		this.action("rowDelete", row, {data:row.getData(), pos:!index, index:index});
	}

	cellUpdated(cell){
		this.action("cellEdit", cell, {oldValue:cell.oldValue, newValue:cell.value});
	}

	clear(){
		this.history = [];
		this.index = -1;
	}

	action(type, component, data){
		this.history = this.history.slice(0, this.index + 1);

		this.history.push({
			type:type,
			component:component,
			data:data,
		});

		this.index ++;
	}

	getHistoryUndoSize(){
		return this.index + 1;
	}

	getHistoryRedoSize(){
		return this.history.length - (this.index + 1);
	}

	clearComponentHistory(component){
		var index = this.history.findIndex(function(item){
			return item.component === component;
		});

		if(index > -1){
			this.history.splice(index, 1);
			if(index <= this.index){
				this.index--;
			}

			this.clearComponentHistory(component);
		}
	}

	undo(){
		if(this.index > -1){
			let action = this.history[this.index];

			History.undoers[action.type].call(this, action);

			this.index--;

			this.dispatchExternal("historyUndo", action.type, action.component.getComponent(), action.data);

			return true;
		}else {
			console.warn(this.options("history") ? "History Undo Error - No more history to undo" : "History module not enabled");
			return false;
		}
	}

	redo(){
		if(this.history.length-1 > this.index){

			this.index++;

			let action = this.history[this.index];

			History.redoers[action.type].call(this, action);

			this.dispatchExternal("historyRedo", action.type, action.component.getComponent(), action.data);

			return true;
		}else {
			console.warn(this.options("history") ? "History Redo Error - No more history to redo" : "History module not enabled");
			return false;
		}
	}

	//rebind rows to new element after deletion
	_rebindRow(oldRow, newRow){
		this.history.forEach(function(action){
			if(action.component instanceof Row){
				if(action.component === oldRow){
					action.component = newRow;
				}
			}else if(action.component instanceof Cell){
				if(action.component.row === oldRow){
					var field = action.component.column.getField();

					if(field){
						action.component = newRow.getCell(field);
					}

				}
			}
		});
	}
}

History.moduleName = "history";

//load defaults
History.undoers = defaultUndoers;
History.redoers = defaultRedoers;

class HtmlTableImport extends Module{

	constructor(table){
		super(table);

		this.fieldIndex = [];
		this.hasIndex = false;
	}

	initialize(){
		this.tableElementCheck();
	}

	tableElementCheck(){
		if(this.table.originalElement && this.table.originalElement.tagName === "TABLE"){
			if(this.table.originalElement.childNodes.length){
				this.parseTable();
			}else {
				console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element.");
			}
		}
	}

	parseTable(){
		var element = this.table.originalElement,
		options = this.table.options,
		headers = element.getElementsByTagName("th"),
		rows = element.getElementsByTagName("tbody")[0],
		data = [];

		this.hasIndex = false;

		this.dispatchExternal("htmlImporting");

		rows = rows ? rows.getElementsByTagName("tr") : [];

		//check for Tabulator inline options
		this._extractOptions(element, options);

		if(headers.length){
			this._extractHeaders(headers, rows);
		}else {
			this._generateBlankHeaders(headers, rows);
		}

		//iterate through table rows and build data set
		for(var index = 0; index < rows.length; index++){
			var row = rows[index],
			cells = row.getElementsByTagName("td"),
			item = {};

			//create index if the don't exist in table
			if(!this.hasIndex){
				item[options.index] = index;
			}

			for(var i = 0; i < cells.length; i++){
				var cell = cells[i];
				if(typeof this.fieldIndex[i] !== "undefined"){
					item[this.fieldIndex[i]] = cell.innerHTML;
				}
			}

			//add row data to item
			data.push(item);
		}

		options.data = data;

		this.dispatchExternal("htmlImported");
	}

	//extract tabulator attribute options
	_extractOptions(element, options, defaultOptions){
		var attributes = element.attributes;
		var optionsArr = defaultOptions ? Object.keys(defaultOptions) : Object.keys(options);
		var optionsList = {};

		optionsArr.forEach((item) => {
			optionsList[item.toLowerCase()] = item;
		});

		for(var index in attributes){
			var attrib = attributes[index];
			var name;

			if(attrib && typeof attrib == "object" && attrib.name && attrib.name.indexOf("tabulator-") === 0){
				name = attrib.name.replace("tabulator-", "");

				if(typeof optionsList[name] !== "undefined"){
					options[optionsList[name]] = this._attribValue(attrib.value);
				}
			}
		}
	}

	//get value of attribute
	_attribValue(value){
		if(value === "true"){
			return true;
		}

		if(value === "false"){
			return false;
		}

		return value;
	}

	//find column if it has already been defined
	_findCol(title){
		var match = this.table.options.columns.find((column) => {
			return column.title === title;
		});

		return match || false;
	}

	//extract column from headers
	_extractHeaders(headers, rows){
		for(var index = 0; index < headers.length; index++){
			var header = headers[index],
			exists = false,
			col = this._findCol(header.textContent),
			width;

			if(col){
				exists = true;
			}else {
				col = {title:header.textContent.trim()};
			}

			if(!col.field) {
				col.field = header.textContent.trim().toLowerCase().replaceAll(" ", "_");
			}

			width = header.getAttribute("width");

			if(width && !col.width)	{
				col.width = width;
			}

			//check for Tabulator inline options
			this._extractOptions(header, col, this.table.columnManager.optionsList.registeredDefaults);

			this.fieldIndex[index] = col.field;

			if(col.field == this.table.options.index){
				this.hasIndex = true;
			}

			if(!exists){
				this.table.options.columns.push(col);
			}

		}
	}

	//generate blank headers
	_generateBlankHeaders(headers, rows){
		for(var index = 0; index < headers.length; index++){
			var header = headers[index],
			col = {title:"", field:"col" + index};

			this.fieldIndex[index] = col.field;

			var width = header.getAttribute("width");

			if(width){
				col.width = width;
			}

			this.table.options.columns.push(col);
		}
	}
}

HtmlTableImport.moduleName = "htmlTableImport";

function csvImporter(input){
	var data = [],
	row = 0, 
	col = 0,
	inQuote = false;
    
	//Iterate over each character
	for (let index = 0; index < input.length; index++) {
		let char = input[index], 
		nextChar = input[index+1];      
        
		//Initialize empty row
		if(!data[row]){
			data[row] = [];
		}

		//Initialize empty column
		if(!data[row][col]){
			data[row][col] = "";
		}
        
		//Handle quotation mark inside string
		if (char == '"' && inQuote && nextChar == '"') { 
			data[row][col] += char; 
			index++;
			continue; 
		}
        
		//Begin / End Quote
		if (char == '"') { 
			inQuote = !inQuote;
			continue;
		}
        
		//Next column (if not in quote)
		if (char == ',' && !inQuote) { 
			col++;
			continue; 
		}
        
		//New row if new line and not in quote (CRLF) 
		if (char == '\r' && nextChar == '\n' && !inQuote) { 
			col = 0; 
			row++; 
			index++; 
			continue; 
		}
        
		//New row if new line and not in quote (CR or LF) 
		if ((char == '\r' || char == '\n') && !inQuote) { 
			col = 0;
			row++;
			continue; 
		}

		//Normal Character, append to column
		data[row][col] += char;
	}

	return data;
}

function json$1(input){
	try {
		return JSON.parse(input);
	} catch(e) {
		console.warn("JSON Import Error - File contents is invalid JSON", e);
		return Promise.reject();
	}
}

function arrayImporter(input){
	return input;
}

var defaultImporters = {
	csv:csvImporter,
	json:json$1,
	array:arrayImporter,
};

class Import extends Module{
    
	constructor(table){
		super(table);
        
		this.registerTableOption("importFormat");
		this.registerTableOption("importReader", "text");
	}
    
	initialize(){
		this.registerTableFunction("import", this.importFromFile.bind(this));

		if(this.table.options.importFormat){
			this.subscribe("data-loading", this.loadDataCheck.bind(this), 10);
			this.subscribe("data-load", this.loadData.bind(this), 10);
		}
	}

	loadDataCheck(data){
		return this.table.options.importFormat && (typeof data === "string" || (Array.isArray(data) && data.length && Array.isArray(data)));
	}

	loadData(data, params, config, silent, previousData){
		return this.importData(this.lookupImporter(), data)
			.then(this.structureData.bind(this))
			.catch((err) => {
				console.error("Import Error:", err || "Unable to import data");
				return Promise.reject(err);
			});
	}

	lookupImporter(importFormat){
		var importer;
        
		if(!importFormat){
			importFormat = this.table.options.importFormat;
		}
        
		if(typeof importFormat === "string"){
			importer = Import.importers[importFormat];
		}else {
			importer = importFormat;
		}

		if(!importer){
			console.error("Import Error - Importer not found:", importFormat);
		}
        
		return importer;
	}
    
	importFromFile(importFormat, extension){
		var importer = this.lookupImporter(importFormat);
        
		if(importer){
			return this.pickFile(extension)
				.then(this.importData.bind(this, importer))
				.then(this.structureData.bind(this))
				.then(this.setData.bind(this))
				.catch((err) => {
					console.error("Import Error:", err || "Unable to import file");
					return Promise.reject(err);
				});
		}
	}
    
	pickFile(extensions){
		return new Promise((resolve, reject) => {
			var input = document.createElement("input");
			input.type = "file";
			input.accept = extensions;
            
			input.addEventListener("change", (e) => {
				var file = input.files[0],
				reader = new FileReader();
                
				switch(this.table.options.importReader){
					case "buffer":
						reader.readAsArrayBuffer(file);
						break;

					case "binary":
						reader.readAsBinaryString(file);
						break;

					case "url":
						reader.readAsDataURL(file);
						break;

					case "text":
					default:
						reader.readAsText(file);
				}
                  
				reader.onload = (e) => {
					resolve(reader.result);
				};
                
				reader.onerror = (e) => {
					console.warn("File Load Error - Unable to read file");
					reject();
				};
			});
            
			input.click();
		});
	}
    
	importData(importer, fileContents){
		var data = importer.call(this.table, fileContents);
        
		if(data instanceof Promise){
			return data;
		}else {
			return data ? Promise.resolve(data) : Promise.reject();
		}
	}

	structureData(parsedData){
		var data = [];
        
		if(Array.isArray(parsedData) && parsedData.length && Array.isArray(parsedData[0])){
			if(this.table.options.autoColumns){
				data = this.structureArrayToObject(parsedData);
			}else {
				data = this.structureArrayToColumns(parsedData);
			}

			return data;
		}else {
			return parsedData;
		}
	}

	structureArrayToObject(parsedData){
		var columns = parsedData.shift();

		var data = parsedData.map((values) => {
			var row = {};

			columns.forEach((key, i) => {
				row[key] = values[i];
			});

			return row;
		});

		return data;
	}

	structureArrayToColumns(parsedData){
		var data = [],
		columns = this.table.getColumns();

		//remove first row if it is the column names
		if(columns[0] && parsedData[0][0]){
			if(columns[0].getDefinition().title === parsedData[0][0]){
				parsedData.shift();
			}
		}
        
		//convert row arrays to objects
		parsedData.forEach((rowData) => {
			var row = {};

			rowData.forEach((value, index) => {
				var column = columns[index];

				if(column){
					row[column.getField()] = value;
				}
			});

			data.push(row);
		});

		return data;
	}
    
	setData(data){
		return this.table.setData(data);
	}
}

Import.moduleName = "import";

//load defaults
Import.importers = defaultImporters;

class Interaction extends Module{

	constructor(table){
		super(table);

		this.eventMap = {
			//row events
			rowClick:"row-click",
			rowDblClick:"row-dblclick",
			rowContext:"row-contextmenu",
			rowMouseEnter:"row-mouseenter",
			rowMouseLeave:"row-mouseleave",
			rowMouseOver:"row-mouseover",
			rowMouseOut:"row-mouseout",
			rowMouseMove:"row-mousemove",
			rowMouseDown:"row-mousedown",
			rowMouseUp:"row-mouseup",
			rowTap:"row",
			rowDblTap:"row",
			rowTapHold:"row",

			//cell events
			cellClick:"cell-click",
			cellDblClick:"cell-dblclick",
			cellContext:"cell-contextmenu",
			cellMouseEnter:"cell-mouseenter",
			cellMouseLeave:"cell-mouseleave",
			cellMouseOver:"cell-mouseover",
			cellMouseOut:"cell-mouseout",
			cellMouseMove:"cell-mousemove",
			cellMouseDown:"cell-mousedown",
			cellMouseUp:"cell-mouseup",
			cellTap:"cell",
			cellDblTap:"cell",
			cellTapHold:"cell",

			//column header events
			headerClick:"column-click",
			headerDblClick:"column-dblclick",
			headerContext:"column-contextmenu",
			headerMouseEnter:"column-mouseenter",
			headerMouseLeave:"column-mouseleave",
			headerMouseOver:"column-mouseover",
			headerMouseOut:"column-mouseout",
			headerMouseMove:"column-mousemove",
			headerMouseDown:"column-mousedown",
			headerMouseUp:"column-mouseup",
			headerTap:"column",
			headerDblTap:"column",
			headerTapHold:"column",

			//group header
			groupClick:"group-click",
			groupDblClick:"group-dblclick",
			groupContext:"group-contextmenu",
			groupMouseEnter:"group-mouseenter",
			groupMouseLeave:"group-mouseleave",
			groupMouseOver:"group-mouseover",
			groupMouseOut:"group-mouseout",
			groupMouseMove:"group-mousemove",
			groupMouseDown:"group-mousedown",
			groupMouseUp:"group-mouseup",
			groupTap:"group",
			groupDblTap:"group",
			groupTapHold:"group",
		};

		this.subscribers = {};

		this.touchSubscribers = {};

		this.columnSubscribers = {};

		this.touchWatchers = {
			row:{
				tap:null,
				tapDbl:null,
				tapHold:null,
			},
			cell:{
				tap:null,
				tapDbl:null,
				tapHold:null,
			},
			column:{
				tap:null,
				tapDbl:null,
				tapHold:null,
			},
			group:{
				tap:null,
				tapDbl:null,
				tapHold:null,
			}
		};

		this.registerColumnOption("headerClick");
		this.registerColumnOption("headerDblClick");
		this.registerColumnOption("headerContext");
		this.registerColumnOption("headerMouseEnter");
		this.registerColumnOption("headerMouseLeave");
		this.registerColumnOption("headerMouseOver");
		this.registerColumnOption("headerMouseOut");
		this.registerColumnOption("headerMouseMove");
		this.registerColumnOption("headerMouseDown");
		this.registerColumnOption("headerMouseUp");
		this.registerColumnOption("headerTap");
		this.registerColumnOption("headerDblTap");
		this.registerColumnOption("headerTapHold");

		this.registerColumnOption("cellClick");
		this.registerColumnOption("cellDblClick");
		this.registerColumnOption("cellContext");
		this.registerColumnOption("cellMouseEnter");
		this.registerColumnOption("cellMouseLeave");
		this.registerColumnOption("cellMouseOver");
		this.registerColumnOption("cellMouseOut");
		this.registerColumnOption("cellMouseMove");
		this.registerColumnOption("cellMouseDown");
		this.registerColumnOption("cellMouseUp");
		this.registerColumnOption("cellTap");
		this.registerColumnOption("cellDblTap");
		this.registerColumnOption("cellTapHold");

	}

	initialize(){
		this.initializeExternalEvents();

		this.subscribe("column-init", this.initializeColumn.bind(this));
		this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this));
		this.subscribe("scroll-horizontal", this.clearTouchWatchers.bind(this));
		this.subscribe("scroll-vertical", this.clearTouchWatchers.bind(this));
	}

	clearTouchWatchers(){
		var types = Object.values(this.touchWatchers);

		types.forEach((type) => {
			for(let key in type){
				type[key] = null;
			}
		});
	}
		
	cellContentsSelectionFixer(e, cell){
		var range;

		if(this.table.modExists("edit")){
			if (this.table.modules.edit.currentCell === cell){
				return; //prevent instant selection of editor content
			}
		}

		e.preventDefault();

		try{
			if (document.selection) { // IE
				range = document.body.createTextRange();
				range.moveToElementText(cell.getElement());
				range.select();
			} else if (window.getSelection) {
				range = document.createRange();
				range.selectNode(cell.getElement());
				window.getSelection().removeAllRanges();
				window.getSelection().addRange(range);
			}
		}catch(e){}
	}

	initializeExternalEvents(){
		for(let key in this.eventMap){
			this.subscriptionChangeExternal(key, this.subscriptionChanged.bind(this, key));
		}
	}

	subscriptionChanged(key, added){
		if(added){
			if(!this.subscribers[key]){
				if(this.eventMap[key].includes("-")){
					this.subscribers[key] = this.handle.bind(this, key);
					this.subscribe(this.eventMap[key], this.subscribers[key]);
				}else {
					this.subscribeTouchEvents(key);
				}
			}
		}else {
			if(this.eventMap[key].includes("-")){
				if(this.subscribers[key] && !this.columnSubscribers[key]  && !this.subscribedExternal(key)){
					this.unsubscribe(this.eventMap[key], this.subscribers[key]);
					delete this.subscribers[key];
				}
			}else {
				this.unsubscribeTouchEvents(key);
			}
		}
	}


	subscribeTouchEvents(key){
		var type = this.eventMap[key];

		if(!this.touchSubscribers[type + "-touchstart"]){
			this.touchSubscribers[type + "-touchstart"] = this.handleTouch.bind(this, type, "start");
			this.touchSubscribers[type + "-touchend"] = this.handleTouch.bind(this, type, "end");

			this.subscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
			this.subscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
		}

		this.subscribers[key] = true;
	}

	unsubscribeTouchEvents(key){
		var noTouch = true,
		type = this.eventMap[key];

		if(this.subscribers[key] && !this.subscribedExternal(key)){
			delete this.subscribers[key];

			for(let i in this.eventMap){
				if(this.eventMap[i] === type){
					if(this.subscribers[i]){
						noTouch = false;
					}
				}
			}

			if(noTouch){
				this.unsubscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
				this.unsubscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);

				delete this.touchSubscribers[type + "-touchstart"];
				delete this.touchSubscribers[type + "-touchend"];
			}
		}
	}

	initializeColumn(column){
		var def = column.definition;

		for(let key in this.eventMap){
			if(def[key]){
				this.subscriptionChanged(key, true);

				if(!this.columnSubscribers[key]){
					this.columnSubscribers[key] = [];
				}

				this.columnSubscribers[key].push(column);
			}
		}
	}

	handle(action, e, component){
		this.dispatchEvent(action, e, component);
	}

	handleTouch(type, action, e, component){
		var watchers = this.touchWatchers[type];

		if(type === "column"){
			type = "header";
		}

		switch(action){
			case "start":
				watchers.tap = true;

				clearTimeout(watchers.tapHold);

				watchers.tapHold = setTimeout(() => {
					clearTimeout(watchers.tapHold);
					watchers.tapHold = null;

					watchers.tap = null;
					clearTimeout(watchers.tapDbl);
					watchers.tapDbl = null;

					this.dispatchEvent(type + "TapHold", e,  component);
				}, 1000);
				break;

			case "end":
				if(watchers.tap){

					watchers.tap = null;
					this.dispatchEvent(type + "Tap", e,  component);
				}

				if(watchers.tapDbl){
					clearTimeout(watchers.tapDbl);
					watchers.tapDbl = null;

					this.dispatchEvent(type + "DblTap", e,  component);
				}else {
					watchers.tapDbl = setTimeout(() => {
						clearTimeout(watchers.tapDbl);
						watchers.tapDbl = null;
					}, 300);
				}

				clearTimeout(watchers.tapHold);
				watchers.tapHold = null;
				break;
		}
	}

	dispatchEvent(action, e, component){
		var componentObj = component.getComponent(),
		callback;

		if(this.columnSubscribers[action]){

			if(component instanceof Cell){
				callback = component.column.definition[action];
			}else if(component instanceof Column){
				callback = component.definition[action];
			}

			if(callback){
				callback(e, componentObj);
			}
		}

		this.dispatchExternal(action, e, componentObj);
	}
}

Interaction.moduleName = "interaction";

var defaultBindings = {
	navPrev:"shift + 9",
	navNext:9,
	navUp:38,
	navDown:40,
	navLeft:37,
	navRight:39,
	scrollPageUp:33,
	scrollPageDown:34,
	scrollToStart:36,
	scrollToEnd:35,
	undo:["ctrl + 90", "meta + 90"],
	redo:["ctrl + 89", "meta + 89"],
	copyToClipboard:["ctrl + 67", "meta + 67"],

	rangeJumpUp:["ctrl + 38", "meta + 38"],
	rangeJumpDown:["ctrl + 40", "meta + 40"],
	rangeJumpLeft:["ctrl + 37", "meta + 37"],
	rangeJumpRight:["ctrl + 39", "meta + 39"],
	rangeExpandUp:"shift + 38",
	rangeExpandDown:"shift + 40",
	rangeExpandLeft:"shift + 37",
	rangeExpandRight:"shift + 39",
	rangeExpandJumpUp:["ctrl + shift + 38", "meta + shift + 38"],
	rangeExpandJumpDown:["ctrl + shift + 40", "meta + shift + 40"],
	rangeExpandJumpLeft:["ctrl + shift + 37", "meta + shift + 37"],
	rangeExpandJumpRight:["ctrl + shift + 39", "meta + shift + 39"],
};

var defaultActions = {
	keyBlock:function(e){
		e.stopPropagation();
		e.preventDefault();
	},
	scrollPageUp:function(e){
		var rowManager = this.table.rowManager,
		newPos = rowManager.scrollTop - rowManager.element.clientHeight;

		e.preventDefault();

		if(rowManager.displayRowsCount){
			if(newPos >= 0){
				rowManager.element.scrollTop = newPos;
			}else {
				rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
			}
		}

		this.table.element.focus();
	},
	scrollPageDown:function(e){
		var rowManager = this.table.rowManager,
		newPos = rowManager.scrollTop + rowManager.element.clientHeight,
		scrollMax = rowManager.element.scrollHeight;

		e.preventDefault();

		if(rowManager.displayRowsCount){
			if(newPos <= scrollMax){
				rowManager.element.scrollTop = newPos;
			}else {
				rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
			}
		}

		this.table.element.focus();

	},
	scrollToStart:function(e){
		var rowManager = this.table.rowManager;

		e.preventDefault();

		if(rowManager.displayRowsCount){
			rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
		}

		this.table.element.focus();
	},
	scrollToEnd:function(e){
		var rowManager = this.table.rowManager;

		e.preventDefault();

		if(rowManager.displayRowsCount){
			rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
		}

		this.table.element.focus();
	},
	navPrev:function(e){
		this.dispatch("keybinding-nav-prev", e);
	},

	navNext:function(e){
		this.dispatch("keybinding-nav-next", e);
	},

	navLeft:function(e){
		this.dispatch("keybinding-nav-left", e);
	},

	navRight:function(e){
		this.dispatch("keybinding-nav-right", e);
	},

	navUp:function(e){
		this.dispatch("keybinding-nav-up", e);
	},

	navDown:function(e){
		this.dispatch("keybinding-nav-down", e);
	},

	rangeJumpLeft: function(e){
		this.dispatch("keybinding-nav-range", e, "left", true, false);
	},
	rangeJumpRight: function(e){
		this.dispatch("keybinding-nav-range", e, "right", true, false);
	},
	rangeJumpUp: function(e){
		this.dispatch("keybinding-nav-range", e, "up", true, false);
	},
	rangeJumpDown: function(e){
		this.dispatch("keybinding-nav-range", e, "down", true, false);
	},
	rangeExpandLeft: function(e){
		this.dispatch("keybinding-nav-range", e, "left", false, true);
	},
	rangeExpandRight: function(e){
		this.dispatch("keybinding-nav-range", e, "right", false, true);
	},
	rangeExpandUp: function(e){
		this.dispatch("keybinding-nav-range", e, "up", false, true);
	},
	rangeExpandDown: function(e){
		this.dispatch("keybinding-nav-range", e, "down", false, true);
	},
	rangeExpandJumpLeft: function(e){
		this.dispatch("keybinding-nav-range", e, "left", true, true);
	},
	rangeExpandJumpRight: function(e){
		this.dispatch("keybinding-nav-range", e, "right", true, true);
	},
	rangeExpandJumpUp: function(e){
		this.dispatch("keybinding-nav-range", e, "up", true, true);
	},
	rangeExpandJumpDown: function(e){
		this.dispatch("keybinding-nav-range", e, "down", true, true);
	},

	undo:function(e){
		var cell = false;
		if(this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")){

			cell = this.table.modules.edit.currentCell;

			if(!cell){
				e.preventDefault();
				this.table.modules.history.undo();
			}
		}
	},

	redo:function(e){
		var cell = false;
		if(this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")){

			cell = this.table.modules.edit.currentCell;

			if(!cell){
				e.preventDefault();
				this.table.modules.history.redo();
			}
		}
	},

	copyToClipboard:function(e){
		if(!this.table.modules.edit.currentCell){
			if(this.table.modExists("clipboard", true)){
				this.table.modules.clipboard.copy(false, true);
			}
		}
	},
};

class Keybindings extends Module{

	constructor(table){
		super(table);

		this.watchKeys = null;
		this.pressedKeys = null;
		this.keyupBinding = false;
		this.keydownBinding = false;

		this.registerTableOption("keybindings", {}); //array for keybindings
		this.registerTableOption("tabEndNewRow", false); //create new row when tab to end of table
	}

	initialize(){
		var bindings = this.table.options.keybindings,
		mergedBindings = {};

		this.watchKeys = {};
		this.pressedKeys = [];

		if(bindings !== false){
			Object.assign(mergedBindings, Keybindings.bindings);
			Object.assign(mergedBindings, bindings);

			this.mapBindings(mergedBindings);
			this.bindEvents();
		}

		this.subscribe("table-destroy", this.clearBindings.bind(this));
	}

	mapBindings(bindings){
		for(let key in bindings){
			if(Keybindings.actions[key]){
				if(bindings[key]){
					if(typeof bindings[key] !== "object"){
						bindings[key] = [bindings[key]];
					}

					bindings[key].forEach((binding) => {
						var bindingList = Array.isArray(binding) ?  binding : [binding];
						
						bindingList.forEach((item) => {
							this.mapBinding(key, item);
						});						
					});
				}
			}else {
				console.warn("Key Binding Error - no such action:", key);
			}
		}
	}

	mapBinding(action, symbolsList){
		var binding = {
			action: Keybindings.actions[action],
			keys: [],
			ctrl: false,
			shift: false,
			meta: false,
		};

		var symbols = symbolsList.toString().toLowerCase().split(" ").join("").split("+");

		symbols.forEach((symbol) => {
			switch(symbol){
				case "ctrl":
					binding.ctrl = true;
					break;

				case "shift":
					binding.shift = true;
					break;

				case "meta":
					binding.meta = true;
					break;

				default:
					symbol = isNaN(symbol) ? symbol.toUpperCase().charCodeAt(0) : parseInt(symbol);
					binding.keys.push(symbol);

					if(!this.watchKeys[symbol]){
						this.watchKeys[symbol] = [];
					}

					this.watchKeys[symbol].push(binding);
			}
		});
	}

	bindEvents(){
		var self = this;

		this.keyupBinding = function(e){
			var code = e.keyCode;
			var bindings = self.watchKeys[code];

			if(bindings){

				self.pressedKeys.push(code);

				bindings.forEach(function(binding){
					self.checkBinding(e, binding);
				});
			}
		};

		this.keydownBinding = function(e){
			var code = e.keyCode;
			var bindings = self.watchKeys[code];

			if(bindings){

				var index = self.pressedKeys.indexOf(code);

				if(index > -1){
					self.pressedKeys.splice(index, 1);
				}
			}
		};

		this.table.element.addEventListener("keydown", this.keyupBinding);

		this.table.element.addEventListener("keyup", this.keydownBinding);
	}

	clearBindings(){
		if(this.keyupBinding){
			this.table.element.removeEventListener("keydown", this.keyupBinding);
		}

		if(this.keydownBinding){
			this.table.element.removeEventListener("keyup", this.keydownBinding);
		}
	}

	checkBinding(e, binding){
		var match = true;

		if(e.ctrlKey == binding.ctrl && e.shiftKey == binding.shift && e.metaKey == binding.meta){
			binding.keys.forEach((key) => {
				var index = this.pressedKeys.indexOf(key);

				if(index == -1){
					match = false;
				}
			});

			if(match){
				binding.action.call(this, e);
			}

			return true;
		}

		return false;
	}
}

Keybindings.moduleName = "keybindings";

//load defaults
Keybindings.bindings = defaultBindings;
Keybindings.actions = defaultActions;

class Menu extends Module{
	
	constructor(table){
		super(table);
		
		this.menuContainer = null;
		this.nestedMenuBlock = false;
		
		this.currentComponent = null;
		this.rootPopup = null;
		
		this.columnSubscribers = {};
		
		this.registerTableOption("menuContainer", undefined); //deprecated
		
		this.registerTableOption("rowContextMenu", false);
		this.registerTableOption("rowClickMenu", false);
		this.registerTableOption("rowDblClickMenu", false);
		this.registerTableOption("groupContextMenu", false);
		this.registerTableOption("groupClickMenu", false);
		this.registerTableOption("groupDblClickMenu", false);
		
		this.registerColumnOption("headerContextMenu");
		this.registerColumnOption("headerClickMenu");
		this.registerColumnOption("headerDblClickMenu");
		this.registerColumnOption("headerMenu");
		this.registerColumnOption("headerMenuIcon");
		this.registerColumnOption("contextMenu");
		this.registerColumnOption("clickMenu");
		this.registerColumnOption("dblClickMenu");
		
	}
	
	initialize(){
		this.deprecatedOptionsCheck();
		this.initializeRowWatchers();
		this.initializeGroupWatchers();
		
		this.subscribe("column-init", this.initializeColumn.bind(this));
	}
	
	deprecatedOptionsCheck(){
		if(!this.deprecationCheck("menuContainer", "popupContainer")){
			this.table.options.popupContainer = this.table.options.menuContainer;
		}
	}	
	
	initializeRowWatchers(){
		if(this.table.options.rowContextMenu){
			this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
			this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
		}
		
		if(this.table.options.rowClickMenu){
			this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu));
		}
		
		if(this.table.options.rowDblClickMenu){
			this.subscribe("row-dblclick", this.loadMenuEvent.bind(this, this.table.options.rowDblClickMenu));
		}
	}
	
	initializeGroupWatchers(){
		if(this.table.options.groupContextMenu){
			this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
			this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
		}
		
		if(this.table.options.groupClickMenu){
			this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu));
		}
		
		if(this.table.options.groupDblClickMenu){
			this.subscribe("group-dblclick", this.loadMenuEvent.bind(this, this.table.options.groupDblClickMenu));
		}
	}

	initializeColumn(column){
		var	def = column.definition;
		
		//handle column events
		if(def.headerContextMenu && !this.columnSubscribers.headerContextMenu){
			this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu");
			this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu);
			this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"));
		}
		
		if(def.headerClickMenu && !this.columnSubscribers.headerClickMenu){
			this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu");
			this.subscribe("column-click", this.columnSubscribers.headerClickMenu);
		}
		
		if(def.headerDblClickMenu && !this.columnSubscribers.headerDblClickMenu){
			this.columnSubscribers.headerDblClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerDblClickMenu");
			this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickMenu);
		}
		
		if(def.headerMenu){
			this.initializeColumnHeaderMenu(column);
		}
		
		//handle cell events
		if(def.contextMenu && !this.columnSubscribers.contextMenu){
			this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu");
			this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu);
			this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"));
		}
		
		if(def.clickMenu && !this.columnSubscribers.clickMenu){
			this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu");
			this.subscribe("cell-click", this.columnSubscribers.clickMenu);
		}
		
		if(def.dblClickMenu && !this.columnSubscribers.dblClickMenu){
			this.columnSubscribers.dblClickMenu = this.loadMenuTableCellEvent.bind(this, "dblClickMenu");
			this.subscribe("cell-dblclick", this.columnSubscribers.dblClickMenu);
		}
	}
	
	initializeColumnHeaderMenu(column){
		var icon = column.definition.headerMenuIcon,
		headerMenuEl;
		
		headerMenuEl = document.createElement("span");
		headerMenuEl.classList.add("tabulator-header-popup-button");
		
		if(icon){
			if(typeof icon === "function"){
				icon = icon(column.getComponent());
			}
			
			if(icon instanceof HTMLElement){
				headerMenuEl.appendChild(icon);
			}else {
				headerMenuEl.innerHTML = icon;
			}
		}else {
			headerMenuEl.innerHTML = "&vellip;";
		}
		
		headerMenuEl.addEventListener("click", (e) => {
			e.stopPropagation();
			e.preventDefault();
			
			this.loadMenuEvent(column.definition.headerMenu, e, column);
		});
		
		column.titleElement.insertBefore(headerMenuEl, column.titleElement.firstChild);
	}
	
	loadMenuTableCellEvent(option, e, cell){
		if(cell._cell){
			cell = cell._cell;
		}
		
		if(cell.column.definition[option]){
			this.loadMenuEvent(cell.column.definition[option], e, cell);
		}
	}
	
	loadMenuTableColumnEvent(option, e, column){
		if(column._column){
			column = column._column;
		}
		
		if(column.definition[option]){
			this.loadMenuEvent(column.definition[option], e, column);
		}
	}
	
	loadMenuEvent(menu, e, component){
		if(component._group){
			component = component._group;
		}else if(component._row){
			component = component._row;
		}
		
		menu = typeof menu == "function" ? menu.call(this.table, e, component.getComponent()) : menu;
		
		this.loadMenu(e, component, menu);
	}
	
	loadMenu(e, component, menu, parentEl, parentPopup){
		var touch = !(e instanceof MouseEvent),		
		menuEl = document.createElement("div"),
		popup;
		
		menuEl.classList.add("tabulator-menu");
		
		if(!touch){
			e.preventDefault();
		}
		
		//abort if no menu set
		if(!menu || !menu.length){
			return;
		}
		
		if(!parentEl){
			if(this.nestedMenuBlock){
				//abort if child menu already open
				if(this.rootPopup){
					return;
				}
			}else {
				this.nestedMenuBlock = setTimeout(() => {
					this.nestedMenuBlock = false;
				}, 100);
			}
			
			if(this.rootPopup){
				this.rootPopup.hide();	
			}
			
			this.rootPopup = popup = this.popup(menuEl);
			
		}else {
			popup = parentPopup.child(menuEl);
		}
		
		menu.forEach((item) => {
			var itemEl = document.createElement("div"),
			label = item.label,
			disabled = item.disabled;
			
			if(item.separator){
				itemEl.classList.add("tabulator-menu-separator");
			}else {
				itemEl.classList.add("tabulator-menu-item");
				
				if(typeof label == "function"){
					label = label.call(this.table, component.getComponent());
				}
				
				if(label instanceof Node){
					itemEl.appendChild(label);
				}else {
					itemEl.innerHTML = label;
				}
				
				if(typeof disabled == "function"){
					disabled = disabled.call(this.table, component.getComponent());
				}
				
				if(disabled){
					itemEl.classList.add("tabulator-menu-item-disabled");
					itemEl.addEventListener("click", (e) => {
						e.stopPropagation();
					});
				}else {
					if(item.menu && item.menu.length){
						itemEl.addEventListener("click", (e) => {
							e.stopPropagation();
							this.loadMenu(e, component, item.menu, itemEl, popup);
						});
					}else {
						if(item.action){
							itemEl.addEventListener("click", (e) => {
								item.action(e, component.getComponent());
							});
						}
					}
				}
				
				if(item.menu && item.menu.length){
					itemEl.classList.add("tabulator-menu-item-submenu");
				}
			}
			
			menuEl.appendChild(itemEl);
		});
		
		menuEl.addEventListener("click", (e) => {
			if(this.rootPopup){
				this.rootPopup.hide();
			}
		});
		
		popup.show(parentEl || e);
		
		if(popup === this.rootPopup){
			this.rootPopup.hideOnBlur(() => {
				this.rootPopup = null;
				
				if(this.currentComponent){
					this.dispatch("menu-closed", menu, popup);
					this.dispatchExternal("menuClosed", this.currentComponent.getComponent());
					this.currentComponent = null;
				}
			});
			
			this.currentComponent = component;
			
			this.dispatch("menu-opened", menu, popup);
			this.dispatchExternal("menuOpened", component.getComponent());
		}
	}
}

Menu.moduleName = "menu";

class MoveColumns extends Module{
	
	constructor(table){
		super(table);
		
		this.placeholderElement = this.createPlaceholderElement();
		this.hoverElement = false; //floating column header element
		this.checkTimeout = false; //click check timeout holder
		this.checkPeriod = 250; //period to wait on mousedown to consider this a move and not a click
		this.moving = false; //currently moving column
		this.toCol = false; //destination column
		this.toColAfter = false; //position of moving column relative to the destination column
		this.startX = 0; //starting position within header element
		this.autoScrollMargin = 40; //auto scroll on edge when within margin
		this.autoScrollStep = 5; //auto scroll distance in pixels
		this.autoScrollTimeout = false; //auto scroll timeout
		this.touchMove = false;
		
		this.moveHover = this.moveHover.bind(this);
		this.endMove = this.endMove.bind(this);
		
		this.registerTableOption("movableColumns", false); //enable movable columns
	}
	
	createPlaceholderElement(){
		var el = document.createElement("div");
		
		el.classList.add("tabulator-col");
		el.classList.add("tabulator-col-placeholder");
		
		return el;
	}
	
	initialize(){
		if(this.table.options.movableColumns){
			this.subscribe("column-init", this.initializeColumn.bind(this));
			this.subscribe("alert-show", this.abortMove.bind(this));
		}
	}

	abortMove(){
		clearTimeout(this.checkTimeout);
	}
	
	initializeColumn(column){
		var self = this,
		config = {},
		colEl;
		
		if(!column.modules.frozen && !column.isGroup){
			colEl = column.getElement();
			
			config.mousemove = function(e){
				if(column.parent === self.moving.parent){
					if((((self.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(colEl).left) + self.table.columnManager.contentsElement.scrollLeft) > (column.getWidth() / 2)){
						if(self.toCol !== column || !self.toColAfter){
							colEl.parentNode.insertBefore(self.placeholderElement, colEl.nextSibling);
							self.moveColumn(column, true);
						}
					}else {
						if(self.toCol !== column || self.toColAfter){
							colEl.parentNode.insertBefore(self.placeholderElement, colEl);
							self.moveColumn(column, false);
						}
					}
				}
			}.bind(self);
			
			colEl.addEventListener("mousedown", function(e){
				self.touchMove = false;
				if(e.which === 1){
					self.checkTimeout = setTimeout(function(){
						self.startMove(e, column);
					}, self.checkPeriod);
				}
			});
			
			colEl.addEventListener("mouseup", function(e){
				if(e.which === 1){
					if(self.checkTimeout){
						clearTimeout(self.checkTimeout);
					}
				}
			});
			
			self.bindTouchEvents(column);
		}
		
		column.modules.moveColumn = config;
	}
	
	bindTouchEvents(column){
		var colEl = column.getElement(),
		startXMove = false, //shifting center position of the cell
		nextCol, prevCol, nextColWidth, prevColWidth, nextColWidthLast, prevColWidthLast;
		
		colEl.addEventListener("touchstart", (e) => {
			this.checkTimeout = setTimeout(() => {
				this.touchMove = true;
				nextCol = column.nextColumn();
				nextColWidth = nextCol ? nextCol.getWidth()/2 : 0;
				prevCol = column.prevColumn();
				prevColWidth = prevCol ? prevCol.getWidth()/2 : 0;
				nextColWidthLast = 0;
				prevColWidthLast = 0;
				startXMove = false;
				
				this.startMove(e, column);
			}, this.checkPeriod);
		}, {passive: true});
		
		colEl.addEventListener("touchmove", (e) => {
			var diff, moveToCol;
			
			if(this.moving){
				this.moveHover(e);
				
				if(!startXMove){
					startXMove = e.touches[0].pageX;
				}
				
				diff = e.touches[0].pageX - startXMove;
				
				if(diff > 0){
					if(nextCol && diff - nextColWidthLast > nextColWidth){
						moveToCol = nextCol;
						
						if(moveToCol !== column){
							startXMove = e.touches[0].pageX;
							moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement().nextSibling);
							this.moveColumn(moveToCol, true);
						}
					}
				}else {
					if(prevCol && -diff - prevColWidthLast >  prevColWidth){
						moveToCol = prevCol;
						
						if(moveToCol !== column){
							startXMove = e.touches[0].pageX;
							moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement());
							this.moveColumn(moveToCol, false);
						}
					}
				}
				
				if(moveToCol){
					nextCol = moveToCol.nextColumn();
					nextColWidthLast = nextColWidth;
					nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
					prevCol = moveToCol.prevColumn();
					prevColWidthLast = prevColWidth;
					prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
				}
			}
		}, {passive: true});
		
		colEl.addEventListener("touchend", (e) => {
			if(this.checkTimeout){
				clearTimeout(this.checkTimeout);
			}
			if(this.moving){
				this.endMove(e);
			}
		});
	}
	
	startMove(e, column){
		var element = column.getElement(),
		headerElement = this.table.columnManager.getContentsElement(),
		headersElement = this.table.columnManager.getHeadersElement();
		
		this.moving = column;
		this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(element).left;
		
		this.table.element.classList.add("tabulator-block-select");
		
		//create placeholder
		this.placeholderElement.style.width = column.getWidth() + "px";
		this.placeholderElement.style.height = column.getHeight() + "px";
		
		element.parentNode.insertBefore(this.placeholderElement, element);
		element.parentNode.removeChild(element);
		
		//create hover element
		this.hoverElement = element.cloneNode(true);
		this.hoverElement.classList.add("tabulator-moving");
		
		headerElement.appendChild(this.hoverElement);
		
		this.hoverElement.style.left = "0";
		this.hoverElement.style.bottom = (headerElement.clientHeight - headersElement.offsetHeight) + "px";
		
		if(!this.touchMove){
			this._bindMouseMove();
			
			document.body.addEventListener("mousemove", this.moveHover);
			document.body.addEventListener("mouseup", this.endMove);
		}
		
		this.moveHover(e);
	}
	
	_bindMouseMove(){
		this.table.columnManager.columnsByIndex.forEach(function(column){
			if(column.modules.moveColumn.mousemove){
				column.getElement().addEventListener("mousemove", column.modules.moveColumn.mousemove);
			}
		});
	}
	
	_unbindMouseMove(){
		this.table.columnManager.columnsByIndex.forEach(function(column){
			if(column.modules.moveColumn.mousemove){
				column.getElement().removeEventListener("mousemove", column.modules.moveColumn.mousemove);
			}
		});
	}
	
	moveColumn(column, after){
		var movingCells = this.moving.getCells();
		
		this.toCol = column;
		this.toColAfter = after;
		
		if(after){
			column.getCells().forEach(function(cell, i){
				var cellEl = cell.getElement(true);
				
				if(cellEl.parentNode && movingCells[i]){
					cellEl.parentNode.insertBefore(movingCells[i].getElement(), cellEl.nextSibling);
				}
			});
		}else {
			column.getCells().forEach(function(cell, i){
				var cellEl = cell.getElement(true);
				
				if(cellEl.parentNode && movingCells[i]){
					cellEl.parentNode.insertBefore(movingCells[i].getElement(), cellEl);
				}
			});
		}
	}
	
	endMove(e){
		if(e.which === 1 || this.touchMove){
			this._unbindMouseMove();
			
			this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
			this.placeholderElement.parentNode.removeChild(this.placeholderElement);
			this.hoverElement.parentNode.removeChild(this.hoverElement);
			
			this.table.element.classList.remove("tabulator-block-select");
			
			if(this.toCol){
				this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter);
			}
			
			this.moving = false;
			this.toCol = false;
			this.toColAfter = false;
			
			if(!this.touchMove){
				document.body.removeEventListener("mousemove", this.moveHover);
				document.body.removeEventListener("mouseup", this.endMove);
			}
		}
	}
	
	moveHover(e){
		var columnHolder = this.table.columnManager.getContentsElement(),
		scrollLeft = columnHolder.scrollLeft,
		xPos = ((this.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(columnHolder).left) + scrollLeft,
		scrollPos;
		
		this.hoverElement.style.left = (xPos - this.startX) + "px";
		
		if(xPos - scrollLeft < this.autoScrollMargin){
			if(!this.autoScrollTimeout){
				this.autoScrollTimeout = setTimeout(() => {
					scrollPos = Math.max(0,scrollLeft-5);
					this.table.rowManager.getElement().scrollLeft = scrollPos;
					this.autoScrollTimeout = false;
				}, 1);
			}
		}
		
		if(scrollLeft + columnHolder.clientWidth - xPos < this.autoScrollMargin){
			if(!this.autoScrollTimeout){
				this.autoScrollTimeout = setTimeout(() => {
					scrollPos = Math.min(columnHolder.clientWidth, scrollLeft+5);
					this.table.rowManager.getElement().scrollLeft = scrollPos;
					this.autoScrollTimeout = false;
				}, 1);
			}
		}
	}
}

MoveColumns.moduleName = "moveColumn";

class MoveRows extends Module{

	constructor(table){
		super(table);

		this.placeholderElement = this.createPlaceholderElement();
		this.hoverElement = false; //floating row header element
		this.checkTimeout = false; //click check timeout holder
		this.checkPeriod = 150; //period to wait on mousedown to consider this a move and not a click
		this.moving = false; //currently moving row
		this.toRow = false; //destination row
		this.toRowAfter = false; //position of moving row relative to the destination row
		this.hasHandle = false; //row has handle instead of fully movable row
		this.startY = 0; //starting Y position within header element
		this.startX = 0; //starting X position within header element

		this.moveHover = this.moveHover.bind(this);
		this.endMove = this.endMove.bind(this);
		this.tableRowDropEvent = false;

		this.touchMove = false;

		this.connection = false;
		this.connectionSelectorsTables = false;
		this.connectionSelectorsElements = false;
		this.connectionElements = [];
		this.connections = [];

		this.connectedTable = false;
		this.connectedRow = false;

		this.registerTableOption("movableRows", false); //enable movable rows
		this.registerTableOption("movableRowsConnectedTables", false); //tables for movable rows to be connected to
		this.registerTableOption("movableRowsConnectedElements", false); //other elements for movable rows to be connected to
		this.registerTableOption("movableRowsSender", false);
		this.registerTableOption("movableRowsReceiver", "insert");

		this.registerColumnOption("rowHandle");
	}

	createPlaceholderElement(){
		var el = document.createElement("div");

		el.classList.add("tabulator-row");
		el.classList.add("tabulator-row-placeholder");

		return el;
	}

	initialize(){
		if(this.table.options.movableRows){
			this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables;
			this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements;

			this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements;

			this.subscribe("cell-init", this.initializeCell.bind(this));
			this.subscribe("column-init", this.initializeColumn.bind(this));
			this.subscribe("row-init", this.initializeRow.bind(this));
		}
	}

	initializeGroupHeader(group){
		var self = this,
		config = {};

		//inter table drag drop
		config.mouseup = function(e){
			self.tableRowDrop(e, group);
		}.bind(self);

		//same table drag drop
		config.mousemove = function(e){
			var rowEl;

			if(((e.pageY - Helpers.elOffset(group.element).top) + self.table.rowManager.element.scrollTop) > (group.getHeight() / 2)){
				if(self.toRow !== group || !self.toRowAfter){
					rowEl = group.getElement();
					rowEl.parentNode.insertBefore(self.placeholderElement, rowEl.nextSibling);
					self.moveRow(group, true);
				}
			}else {
				if(self.toRow !== group || self.toRowAfter){
					rowEl = group.getElement();
					if(rowEl.previousSibling){
						rowEl.parentNode.insertBefore(self.placeholderElement, rowEl);
						self.moveRow(group, false);
					}
				}
			}
		}.bind(self);

		group.modules.moveRow = config;
	}

	initializeRow(row){
		var self = this,
		config = {},
		rowEl;

		//inter table drag drop
		config.mouseup = function(e){
			self.tableRowDrop(e, row);
		}.bind(self);

		//same table drag drop
		config.mousemove = function(e){
			var rowEl = row.getElement();

			if(((e.pageY - Helpers.elOffset(rowEl).top) + self.table.rowManager.element.scrollTop) > (row.getHeight() / 2)){
				if(self.toRow !== row || !self.toRowAfter){
					rowEl.parentNode.insertBefore(self.placeholderElement, rowEl.nextSibling);
					self.moveRow(row, true);
				}
			}else {
				if(self.toRow !== row || self.toRowAfter){
					rowEl.parentNode.insertBefore(self.placeholderElement, rowEl);
					self.moveRow(row, false);
				}
			}
		}.bind(self);


		if(!this.hasHandle){

			rowEl = row.getElement();

			rowEl.addEventListener("mousedown", function(e){
				if(e.which === 1){
					self.checkTimeout = setTimeout(function(){
						self.startMove(e, row);
					}, self.checkPeriod);
				}
			});

			rowEl.addEventListener("mouseup", function(e){
				if(e.which === 1){
					if(self.checkTimeout){
						clearTimeout(self.checkTimeout);
					}
				}
			});

			this.bindTouchEvents(row, row.getElement());
		}

		row.modules.moveRow = config;
	}

	initializeColumn(column){
		if(column.definition.rowHandle && this.table.options.movableRows !== false){
			this.hasHandle = true;
		}
	}

	initializeCell(cell){
		if(cell.column.definition.rowHandle && this.table.options.movableRows !== false){
			var self = this,
			cellEl = cell.getElement(true);

			cellEl.addEventListener("mousedown", function(e){
				if(e.which === 1){
					self.checkTimeout = setTimeout(function(){
						self.startMove(e, cell.row);
					}, self.checkPeriod);
				}
			});

			cellEl.addEventListener("mouseup", function(e){
				if(e.which === 1){
					if(self.checkTimeout){
						clearTimeout(self.checkTimeout);
					}
				}
			});

			this.bindTouchEvents(cell.row, cellEl);
		}
	}

	bindTouchEvents(row, element){
		var startYMove = false, //shifting center position of the cell
		nextRow, prevRow, nextRowHeight, prevRowHeight, nextRowHeightLast, prevRowHeightLast;

		element.addEventListener("touchstart", (e) => {
			this.checkTimeout = setTimeout(() => {
				this.touchMove = true;
				nextRow = row.nextRow();
				nextRowHeight = nextRow ? nextRow.getHeight()/2 : 0;
				prevRow = row.prevRow();
				prevRowHeight = prevRow ? prevRow.getHeight()/2 : 0;
				nextRowHeightLast = 0;
				prevRowHeightLast = 0;
				startYMove = false;

				this.startMove(e, row);
			}, this.checkPeriod);
		}, {passive: true});
		this.moving, this.toRow, this.toRowAfter;
		element.addEventListener("touchmove", (e) => {

			var diff, moveToRow;

			if(this.moving){
				e.preventDefault();

				this.moveHover(e);

				if(!startYMove){
					startYMove = e.touches[0].pageY;
				}

				diff = e.touches[0].pageY - startYMove;

				if(diff > 0){
					if(nextRow && diff - nextRowHeightLast > nextRowHeight){
						moveToRow = nextRow;

						if(moveToRow !== row){
							startYMove = e.touches[0].pageY;
							moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement().nextSibling);
							this.moveRow(moveToRow, true);
						}
					}
				}else {
					if(prevRow && -diff - prevRowHeightLast >  prevRowHeight){
						moveToRow = prevRow;

						if(moveToRow !== row){
							startYMove = e.touches[0].pageY;
							moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement());
							this.moveRow(moveToRow, false);
						}
					}
				}

				if(moveToRow){
					nextRow = moveToRow.nextRow();
					nextRowHeightLast = nextRowHeight;
					nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
					prevRow = moveToRow.prevRow();
					prevRowHeightLast = prevRowHeight;
					prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
				}
			}
		});

		element.addEventListener("touchend", (e) => {
			if(this.checkTimeout){
				clearTimeout(this.checkTimeout);
			}
			if(this.moving){
				this.endMove(e);
				this.touchMove = false;
			}
		});
	}

	_bindMouseMove(){
		this.table.rowManager.getDisplayRows().forEach((row) => {
			if((row.type === "row" || row.type === "group") && row.modules.moveRow && row.modules.moveRow.mousemove){
				row.getElement().addEventListener("mousemove", row.modules.moveRow.mousemove);
			}
		});
	}

	_unbindMouseMove(){
		this.table.rowManager.getDisplayRows().forEach((row) => {
			if((row.type === "row" || row.type === "group") && row.modules.moveRow && row.modules.moveRow.mousemove){
				row.getElement().removeEventListener("mousemove", row.modules.moveRow.mousemove);
			}
		});
	}

	startMove(e, row){
		var element = row.getElement();

		this.setStartPosition(e, row);

		this.moving = row;

		this.table.element.classList.add("tabulator-block-select");

		//create placeholder
		this.placeholderElement.style.width = row.getWidth() + "px";
		this.placeholderElement.style.height = row.getHeight() + "px";

		if(!this.connection){
			element.parentNode.insertBefore(this.placeholderElement, element);
			element.parentNode.removeChild(element);
		}else {
			this.table.element.classList.add("tabulator-movingrow-sending");
			this.connectToTables(row);
		}

		//create hover element
		this.hoverElement = element.cloneNode(true);
		this.hoverElement.classList.add("tabulator-moving");

		if(this.connection){
			document.body.appendChild(this.hoverElement);
			this.hoverElement.style.left = "0";
			this.hoverElement.style.top = "0";
			this.hoverElement.style.width = this.table.element.clientWidth + "px";
			this.hoverElement.style.whiteSpace = "nowrap";
			this.hoverElement.style.overflow = "hidden";
			this.hoverElement.style.pointerEvents = "none";
		}else {
			this.table.rowManager.getTableElement().appendChild(this.hoverElement);

			this.hoverElement.style.left = "0";
			this.hoverElement.style.top = "0";

			this._bindMouseMove();
		}

		document.body.addEventListener("mousemove", this.moveHover);
		document.body.addEventListener("mouseup", this.endMove);

		this.dispatchExternal("rowMoving", row.getComponent());

		this.moveHover(e);
	}

	setStartPosition(e, row){
		var pageX = this.touchMove ? e.touches[0].pageX : e.pageX,
		pageY = this.touchMove ? e.touches[0].pageY : e.pageY,
		element, position;

		element = row.getElement();
		if(this.connection){
			position = element.getBoundingClientRect();

			this.startX = position.left - pageX + window.pageXOffset;
			this.startY = position.top - pageY + window.pageYOffset;
		}else {
			this.startY = (pageY - element.getBoundingClientRect().top);
		}
	}

	endMove(e){
		if(!e || e.which === 1 || this.touchMove){
			this._unbindMouseMove();

			if(!this.connection){
				this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
				this.placeholderElement.parentNode.removeChild(this.placeholderElement);
			}

			this.hoverElement.parentNode.removeChild(this.hoverElement);

			this.table.element.classList.remove("tabulator-block-select");

			if(this.toRow){
				this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter);
			}else {
				this.dispatchExternal("rowMoveCancelled", this.moving.getComponent());
			}

			this.moving = false;
			this.toRow = false;
			this.toRowAfter = false;

			document.body.removeEventListener("mousemove", this.moveHover);
			document.body.removeEventListener("mouseup", this.endMove);

			if(this.connection){
				this.table.element.classList.remove("tabulator-movingrow-sending");
				this.disconnectFromTables();
			}
		}
	}

	moveRow(row, after){
		this.toRow = row;
		this.toRowAfter = after;
	}

	moveHover(e){
		if(this.connection){
			this.moveHoverConnections.call(this, e);
		}else {
			this.moveHoverTable.call(this, e);
		}
	}

	moveHoverTable(e){
		var rowHolder = this.table.rowManager.getElement(),
		scrollTop = rowHolder.scrollTop,
		yPos = ((this.touchMove ? e.touches[0].pageY : e.pageY) - rowHolder.getBoundingClientRect().top) + scrollTop;
		
		this.hoverElement.style.top = Math.min(yPos - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
	}

	moveHoverConnections(e){
		this.hoverElement.style.left = (this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX)) + "px";
		this.hoverElement.style.top = (this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY)) + "px";
	}

	elementRowDrop(e, element, row){
		this.dispatchExternal("movableRowsElementDrop", e, element, row ? row.getComponent() : false);
	}

	//establish connection with other tables
	connectToTables(row){
		var connectionTables;

		if(this.connectionSelectorsTables){
			connectionTables = this.commsConnections(this.connectionSelectorsTables);

			this.dispatchExternal("movableRowsSendingStart", connectionTables);

			this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
				row:row,
			});
		}

		if(this.connectionSelectorsElements){

			this.connectionElements = [];

			if(!Array.isArray(this.connectionSelectorsElements)){
				this.connectionSelectorsElements = [this.connectionSelectorsElements];
			}

			this.connectionSelectorsElements.forEach((query) => {
				if(typeof query === "string"){
					this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(query)));
				}else {
					this.connectionElements.push(query);
				}
			});

			this.connectionElements.forEach((element) => {
				var dropEvent = (e) => {
					this.elementRowDrop(e, element, this.moving);
				};

				element.addEventListener("mouseup", dropEvent);
				element.tabulatorElementDropEvent = dropEvent;

				element.classList.add("tabulator-movingrow-receiving");
			});
		}
	}

	//disconnect from other tables
	disconnectFromTables(){
		var connectionTables;

		if(this.connectionSelectorsTables){
			connectionTables = this.commsConnections(this.connectionSelectorsTables);

			this.dispatchExternal("movableRowsSendingStop", connectionTables);

			this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect");
		}

		this.connectionElements.forEach((element) => {
			element.classList.remove("tabulator-movingrow-receiving");
			element.removeEventListener("mouseup", element.tabulatorElementDropEvent);
			delete element.tabulatorElementDropEvent;
		});
	}

	//accept incomming connection
	connect(table, row){
		if(!this.connectedTable){
			this.connectedTable = table;
			this.connectedRow = row;

			this.table.element.classList.add("tabulator-movingrow-receiving");

			this.table.rowManager.getDisplayRows().forEach((row) => {
				if(row.type === "row" && row.modules.moveRow && row.modules.moveRow.mouseup){
					row.getElement().addEventListener("mouseup", row.modules.moveRow.mouseup);
				}
			});

			this.tableRowDropEvent = this.tableRowDrop.bind(this);

			this.table.element.addEventListener("mouseup", this.tableRowDropEvent);

			this.dispatchExternal("movableRowsReceivingStart", row, table);

			return true;
		}else {
			console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable);
			return false;
		}
	}

	//close incoming connection
	disconnect(table){
		if(table === this.connectedTable){
			this.connectedTable = false;
			this.connectedRow = false;

			this.table.element.classList.remove("tabulator-movingrow-receiving");

			this.table.rowManager.getDisplayRows().forEach((row) =>{
				if(row.type === "row" && row.modules.moveRow && row.modules.moveRow.mouseup){
					row.getElement().removeEventListener("mouseup", row.modules.moveRow.mouseup);
				}
			});

			this.table.element.removeEventListener("mouseup", this.tableRowDropEvent);

			this.dispatchExternal("movableRowsReceivingStop", table);
		}else {
			console.warn("Move Row Error - trying to disconnect from non connected table");
		}
	}

	dropComplete(table, row, success){
		var sender = false;

		if(success){

			switch(typeof this.table.options.movableRowsSender){
				case "string":
					sender = this.senders[this.table.options.movableRowsSender];
					break;

				case "function":
					sender = this.table.options.movableRowsSender;
					break;
			}

			if(sender){
				sender.call(this, this.moving ? this.moving.getComponent() : undefined, row ? row.getComponent() : undefined, table);
			}else {
				if(this.table.options.movableRowsSender){
					console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender);
				}
			}

			this.dispatchExternal("movableRowsSent", this.moving.getComponent(), row ? row.getComponent() : undefined, table);
		}else {
			this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), row ? row.getComponent() : undefined, table);
		}

		this.endMove();
	}

	tableRowDrop(e, row){
		var receiver = false,
		success = false;

		e.stopImmediatePropagation();

		switch(typeof this.table.options.movableRowsReceiver){
			case "string":
				receiver = this.receivers[this.table.options.movableRowsReceiver];
				break;

			case "function":
				receiver = this.table.options.movableRowsReceiver;
				break;
		}

		if(receiver){
			success = receiver.call(this, this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
		}else {
			console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver);
		}

		if(success){
			this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
		}else {
			this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
		}

		this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
			row:row,
			success:success,
		});
	}

	commsReceived(table, action, data){
		switch(action){
			case "connect":
				return this.connect(table, data.row);

			case "disconnect":
				return this.disconnect(table);

			case "dropcomplete":
				return this.dropComplete(table, data.row, data.success);
		}
	}
}

MoveRows.prototype.receivers = {
	insert:function(fromRow, toRow, fromTable){
		this.table.addRow(fromRow.getData(), undefined, toRow);
		return true;
	},

	add:function(fromRow, toRow, fromTable){
		this.table.addRow(fromRow.getData());
		return true;
	},

	update:function(fromRow, toRow, fromTable){
		if(toRow){
			toRow.update(fromRow.getData());
			return true;
		}

		return false;
	},

	replace:function(fromRow, toRow, fromTable){
		if(toRow){
			this.table.addRow(fromRow.getData(), undefined, toRow);
			toRow.delete();
			return true;
		}

		return false;
	},
};

MoveRows.prototype.senders = {
	delete:function(fromRow, toRow, toTable){
		fromRow.delete();
	}
};

MoveRows.moduleName = "moveRow";

var defaultMutators = {};

class Mutator extends Module{

	constructor(table){
		super(table);

		this.allowedTypes = ["", "data", "edit", "clipboard"]; //list of mutation types
		this.enabled = true;

		this.registerColumnOption("mutator");
		this.registerColumnOption("mutatorParams");
		this.registerColumnOption("mutatorData");
		this.registerColumnOption("mutatorDataParams");
		this.registerColumnOption("mutatorEdit");
		this.registerColumnOption("mutatorEditParams");
		this.registerColumnOption("mutatorClipboard");
		this.registerColumnOption("mutatorClipboardParams");
		this.registerColumnOption("mutateLink");
	}

	initialize(){
		this.subscribe("cell-value-changing", this.transformCell.bind(this));
		this.subscribe("cell-value-changed", this.mutateLink.bind(this));
		this.subscribe("column-layout", this.initializeColumn.bind(this));
		this.subscribe("row-data-init-before", this.rowDataChanged.bind(this));
		this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
	}

	rowDataChanged(row, tempData, updatedData){
		return this.transformRow(tempData, "data", updatedData);
	}

	//initialize column mutator
	initializeColumn(column){
		var match = false,
		config = {};

		this.allowedTypes.forEach((type) => {
			var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)),
			mutator;

			if(column.definition[key]){
				mutator = this.lookupMutator(column.definition[key]);

				if(mutator){
					match = true;

					config[key] = {
						mutator:mutator,
						params: column.definition[key + "Params"] || {},
					};
				}
			}
		});

		if(match){
			column.modules.mutate = config;
		}
	}

	lookupMutator(value){
		var mutator = false;

		//set column mutator
		switch(typeof value){
			case "string":
				if(Mutator.mutators[value]){
					mutator = Mutator.mutators[value];
				}else {
					console.warn("Mutator Error - No such mutator found, ignoring: ", value);
				}
				break;

			case "function":
				mutator = value;
				break;
		}

		return mutator;
	}

	//apply mutator to row
	transformRow(data, type, updatedData){
		var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)),
		value;

		if(this.enabled){

			this.table.columnManager.traverse((column) => {
				var mutator, params, component;

				if(column.modules.mutate){
					mutator = column.modules.mutate[key] || column.modules.mutate.mutator || false;

					if(mutator){
						value = column.getFieldValue(typeof updatedData !== "undefined" ? updatedData : data);

						if((type == "data" && !updatedData)|| typeof value !== "undefined"){
							component = column.getComponent();
							params = typeof mutator.params === "function" ? mutator.params(value, data, type, component) : mutator.params;
							column.setFieldValue(data, mutator.mutator(value, data, type, params, component));
						}
					}
				}
			});
		}

		return data;
	}

	//apply mutator to new cell value
	transformCell(cell, value){
		if(cell.column.modules.mutate){
			var mutator = cell.column.modules.mutate.mutatorEdit || cell.column.modules.mutate.mutator || false,
			tempData = {};

			if(mutator){
				tempData = Object.assign(tempData, cell.row.getData());
				cell.column.setFieldValue(tempData, value);
				return mutator.mutator(value, tempData, "edit", mutator.params, cell.getComponent());
			}
		}

		return value;
	}

	mutateLink(cell){
		var links = cell.column.definition.mutateLink;

		if(links){
			if(!Array.isArray(links)){
				links = [links];
			}

			links.forEach((link) => {
				var linkCell = cell.row.getCell(link);

				if(linkCell){
					linkCell.setValue(linkCell.getValue(), true, true);
				}
			});
		}
	}

	enable(){
		this.enabled = true;
	}

	disable(){
		this.enabled = false;
	}
}

Mutator.moduleName = "mutator";

//load defaults
Mutator.mutators = defaultMutators;

function rows(pageSize, currentRow, currentPage, totalRows, totalPages){
	var el = document.createElement("span"),
	showingEl = document.createElement("span"),
	valueEl = document.createElement("span"),
	ofEl = document.createElement("span"),
	totalEl = document.createElement("span"),
	rowsEl = document.createElement("span");

	this.table.modules.localize.langBind("pagination|counter|showing", (value) => {
		showingEl.innerHTML = value;
	});

	this.table.modules.localize.langBind("pagination|counter|of", (value) => {
		ofEl.innerHTML = value;
	});

	this.table.modules.localize.langBind("pagination|counter|rows", (value) => {
		rowsEl.innerHTML = value;
	});

	if(totalRows){
		valueEl.innerHTML = " " + currentRow + "-" + Math.min((currentRow + pageSize - 1), totalRows) + " ";
		
		totalEl.innerHTML = " " + totalRows + " ";
		
		el.appendChild(showingEl);
		el.appendChild(valueEl);
		el.appendChild(ofEl);
		el.appendChild(totalEl);
		el.appendChild(rowsEl);
	}else {
		valueEl.innerHTML = " 0 ";

		el.appendChild(showingEl);
		el.appendChild(valueEl);
		el.appendChild(rowsEl);
	}
	
	return el;
}

function pages(pageSize, currentRow, currentPage, totalRows, totalPages){

	var el = document.createElement("span"),
	showingEl = document.createElement("span"),
	valueEl = document.createElement("span"),
	ofEl = document.createElement("span"),
	totalEl = document.createElement("span"),
	rowsEl = document.createElement("span");
	
	this.table.modules.localize.langBind("pagination|counter|showing", (value) => {
		showingEl.innerHTML = value;
	});
	
	valueEl.innerHTML = " " + currentPage + " ";
	
	this.table.modules.localize.langBind("pagination|counter|of", (value) => {
		ofEl.innerHTML = value;
	});
	
	totalEl.innerHTML = " " + totalPages + " ";
	
	this.table.modules.localize.langBind("pagination|counter|pages", (value) => {
		rowsEl.innerHTML = value;
	});
	
	el.appendChild(showingEl);
	el.appendChild(valueEl);
	el.appendChild(ofEl);
	el.appendChild(totalEl);
	el.appendChild(rowsEl);
	
	return el;
}

var defaultPageCounters = {
	rows:rows,
	pages:pages,
};

class Page extends Module{
	
	constructor(table){
		super(table);
		
		this.mode = "local";
		this.progressiveLoad = false;
		
		this.element = null;
		this.pageCounterElement = null;
		this.pageCounter = null;
		
		this.size = 0;
		this.page = 1;
		this.count = 5;
		this.max = 1;

		this.remoteRowCountEstimate = null;
		
		this.initialLoad = true;
		this.dataChanging = false; //flag to check if data is being changed by this module
		
		this.pageSizes = [];
		
		this.registerTableOption("pagination", false); //set pagination type
		this.registerTableOption("paginationMode", "local"); //local or remote pagination
		this.registerTableOption("paginationSize", false); //set number of rows to a page
		this.registerTableOption("paginationInitialPage", 1); //initial page to show on load
		this.registerTableOption("paginationCounter", false);  // set pagination counter
		this.registerTableOption("paginationCounterElement", false);  // set pagination counter
		this.registerTableOption("paginationButtonCount", 5);  // set count of page button
		this.registerTableOption("paginationSizeSelector", false); //add pagination size selector element
		this.registerTableOption("paginationElement", false); //element to hold pagination numbers
		// this.registerTableOption("paginationDataSent", {}); //pagination data sent to the server
		// this.registerTableOption("paginationDataReceived", {}); //pagination data received from the server
		this.registerTableOption("paginationAddRow", "page"); //add rows on table or page
		
		this.registerTableOption("progressiveLoad", false); //progressive loading
		this.registerTableOption("progressiveLoadDelay", 0); //delay between requests
		this.registerTableOption("progressiveLoadScrollMargin", 0); //margin before scroll begins
		
		this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this));
		this.registerTableFunction("setPage", this.setPage.bind(this));
		this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this));
		this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this));
		this.registerTableFunction("getPageSize", this.getPageSize.bind(this));
		this.registerTableFunction("previousPage", this.previousPage.bind(this));
		this.registerTableFunction("nextPage", this.nextPage.bind(this));
		this.registerTableFunction("getPage", this.getPage.bind(this));
		this.registerTableFunction("getPageMax", this.getPageMax.bind(this));
		
		//register component functions
		this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
	}
	
	initialize(){
		if(this.table.options.pagination){
			this.subscribe("row-deleted", this.rowsUpdated.bind(this));
			this.subscribe("row-added", this.rowsUpdated.bind(this));
			this.subscribe("data-processed", this.initialLoadComplete.bind(this));
			this.subscribe("table-built", this.calculatePageSizes.bind(this));
			this.subscribe("footer-redraw", this.footerRedraw.bind(this));

			if(this.table.options.paginationAddRow == "page"){
				this.subscribe("row-adding-position", this.rowAddingPosition.bind(this));
			}
			
			if(this.table.options.paginationMode === "remote"){
				this.subscribe("data-params", this.remotePageParams.bind(this));
				this.subscribe("data-loaded", this._parseRemoteData.bind(this));
			}
			
			if(this.table.options.progressiveLoad){
				console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time");
			}
			
			this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40);
			this.registerDisplayHandler(this.getRows.bind(this), 50);
			
			this.createElements();
			this.initializePageCounter();
			this.initializePaginator();
		}else if(this.table.options.progressiveLoad){
			this.subscribe("data-params", this.remotePageParams.bind(this));
			this.subscribe("data-loaded", this._parseRemoteData.bind(this));
			this.subscribe("table-built", this.calculatePageSizes.bind(this));
			this.subscribe("data-processed", this.initialLoadComplete.bind(this));
			
			this.initializeProgressive(this.table.options.progressiveLoad);
			
			if(this.table.options.progressiveLoad === "scroll"){
				this.subscribe("scroll-vertical", this.scrollVertical.bind(this));
			}
		}
	}
	
	rowAddingPosition(row, top){
		var rowManager = this.table.rowManager,
		displayRows = rowManager.getDisplayRows(),
		index;
		
		if(top){
			if(displayRows.length){
				index = displayRows[0];
			}else {
				if(rowManager.activeRows.length){
					index = rowManager.activeRows[rowManager.activeRows.length-1];
					top = false;
				}
			}
		}else {
			if(displayRows.length){
				index = displayRows[displayRows.length - 1];
				top = displayRows.length < this.size ? false : true;
			}
		}
		
		return {index, top};
	}
	
	calculatePageSizes(){
		var testElRow, testElCell;
		
		if(this.table.options.paginationSize){
			this.size = this.table.options.paginationSize;
		}else {
			testElRow = document.createElement("div");
			testElRow.classList.add("tabulator-row");
			testElRow.style.visibility = "hidden";
			
			testElCell = document.createElement("div");
			testElCell.classList.add("tabulator-cell");
			testElCell.innerHTML = "Page Row Test";
			
			testElRow.appendChild(testElCell);
			
			this.table.rowManager.getTableElement().appendChild(testElRow);
			
			this.size = Math.floor(this.table.rowManager.getElement().clientHeight / testElRow.offsetHeight);
			
			this.table.rowManager.getTableElement().removeChild(testElRow);
		}

		this.dispatchExternal("pageSizeChanged", this.size);
		
		this.generatePageSizeSelectList();
	}
	
	initialLoadComplete(){
		this.initialLoad = false;
	}
	
	remotePageParams(data, config, silent, params){
		if(!this.initialLoad){
			if((this.progressiveLoad && !silent) || (!this.progressiveLoad && !this.dataChanging)){
				this.reset(true);
			}
		}
		
		//configure request params
		params.page = this.page;
		
		//set page size if defined
		if(this.size){
			params.size = this.size;
		}
		
		return params;
	}
	
	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////
	
	userSetPageToRow(row){
		if(this.table.options.pagination){
			row = this.table.rowManager.findRow(row);
			
			if(row){
				return this.setPageToRow(row);
			}
		}
		
		return Promise.reject();
	}
	
	userSetPageSize(size){
		if(this.table.options.pagination){
			this.setPageSize(size);
			return this.setPage(1);
		}else {
			return false;
		}
	}
	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////
	
	scrollVertical(top, dir){
		var element, diff, margin;
		if(!dir && !this.table.dataLoader.loading){
			element = this.table.rowManager.getElement();
			diff = element.scrollHeight - element.clientHeight - top;
			margin = this.table.options.progressiveLoadScrollMargin || (element.clientHeight * 2);
			
			if(diff < margin){
				this.nextPage()
					.catch(() => {}); //consume the exception thrown when on the last page
			}
		}
	}
	
	restOnRenderBefore(rows, renderInPosition){
		if(!renderInPosition){
			if(this.mode === "local"){
				this.reset();
			}
		}
		
		return rows;
	}
	
	rowsUpdated(){
		this.refreshData(true, "all");
	}
	
	createElements(){
		var button;
		
		this.element = document.createElement("span");
		this.element.classList.add("tabulator-paginator");
		
		this.pagesElement = document.createElement("span");
		this.pagesElement.classList.add("tabulator-pages");
		
		button = document.createElement("button");
		button.classList.add("tabulator-page");
		button.setAttribute("type", "button");
		button.setAttribute("role", "button");
		button.setAttribute("aria-label", "");
		button.setAttribute("title", "");
		
		this.firstBut = button.cloneNode(true);
		this.firstBut.setAttribute("data-page", "first");
		
		this.prevBut = button.cloneNode(true);
		this.prevBut.setAttribute("data-page", "prev");
		
		this.nextBut = button.cloneNode(true);
		this.nextBut.setAttribute("data-page", "next");
		
		this.lastBut = button.cloneNode(true);
		this.lastBut.setAttribute("data-page", "last");
		
		if(this.table.options.paginationSizeSelector){
			this.pageSizeSelect = document.createElement("select");
			this.pageSizeSelect.classList.add("tabulator-page-size");
		}
	}
	
	generatePageSizeSelectList(){
		var pageSizes = [];
		
		if(this.pageSizeSelect){
			
			if(Array.isArray(this.table.options.paginationSizeSelector)){
				pageSizes = this.table.options.paginationSizeSelector;
				this.pageSizes = pageSizes;
				
				if(this.pageSizes.indexOf(this.size) == -1){
					pageSizes.unshift(this.size);
				}
			}else {
				
				if(this.pageSizes.indexOf(this.size) == -1){
					pageSizes = [];
					
					for (let i = 1; i < 5; i++){
						pageSizes.push(this.size * i);
					}
					
					this.pageSizes = pageSizes;
				}else {
					pageSizes = this.pageSizes;
				}
			}
			
			while(this.pageSizeSelect.firstChild) this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
			
			pageSizes.forEach((item) => {
				var itemEl = document.createElement("option");
				itemEl.value = item;
				
				if(item === true){
					this.langBind("pagination|all", function(value){
						itemEl.innerHTML = value;
					});
				}else {
					itemEl.innerHTML = item;
				}
				
				
				
				this.pageSizeSelect.appendChild(itemEl);
			});
			
			this.pageSizeSelect.value = this.size;
		}
	}
	
	initializePageCounter(){
		var counter = this.table.options.paginationCounter,
		pageCounter = null;
		
		if(counter){
			if(typeof counter === "function"){
				pageCounter = counter;
			}else {
				pageCounter = Page.pageCounters[counter];
			}
			
			if(pageCounter){
				this.pageCounter = pageCounter;
				
				this.pageCounterElement = document.createElement("span");
				this.pageCounterElement.classList.add("tabulator-page-counter");
			}else {
				console.warn("Pagination Error - No such page counter found: ", counter);
			}
		}
	}
	
	//setup pagination
	initializePaginator(hidden){
		var pageSelectLabel, paginationCounterHolder;
		
		if(!hidden){
			//build pagination element
			
			//bind localizations
			this.langBind("pagination|first", (value) => {
				this.firstBut.innerHTML = value;
			});
			
			this.langBind("pagination|first_title", (value) => {
				this.firstBut.setAttribute("aria-label", value);
				this.firstBut.setAttribute("title", value);
			});
			
			this.langBind("pagination|prev", (value) => {
				this.prevBut.innerHTML = value;
			});
			
			this.langBind("pagination|prev_title", (value) => {
				this.prevBut.setAttribute("aria-label", value);
				this.prevBut.setAttribute("title", value);
			});
			
			this.langBind("pagination|next", (value) => {
				this.nextBut.innerHTML = value;
			});
			
			this.langBind("pagination|next_title", (value) => {
				this.nextBut.setAttribute("aria-label", value);
				this.nextBut.setAttribute("title", value);
			});
			
			this.langBind("pagination|last", (value) => {
				this.lastBut.innerHTML = value;
			});
			
			this.langBind("pagination|last_title", (value) => {
				this.lastBut.setAttribute("aria-label", value);
				this.lastBut.setAttribute("title", value);
			});
			
			//click bindings
			this.firstBut.addEventListener("click", () => {
				this.setPage(1);
			});
			
			this.prevBut.addEventListener("click", () => {
				this.previousPage();
			});
			
			this.nextBut.addEventListener("click", () => {
				this.nextPage();
			});
			
			this.lastBut.addEventListener("click", () => {
				this.setPage(this.max);
			});
			
			if(this.table.options.paginationElement){
				this.element = this.table.options.paginationElement;
			}
			
			if(this.pageSizeSelect){
				pageSelectLabel = document.createElement("label");
				
				this.langBind("pagination|page_size", (value) => {
					this.pageSizeSelect.setAttribute("aria-label", value);
					this.pageSizeSelect.setAttribute("title", value);
					pageSelectLabel.innerHTML = value;
				});
				
				this.element.appendChild(pageSelectLabel);
				this.element.appendChild(this.pageSizeSelect);
				
				this.pageSizeSelect.addEventListener("change", (e) => {
					this.setPageSize(this.pageSizeSelect.value == "true" ? true : this.pageSizeSelect.value);
					this.setPage(1);
				});
			}
			
			//append to DOM
			this.element.appendChild(this.firstBut);
			this.element.appendChild(this.prevBut);
			this.element.appendChild(this.pagesElement);
			this.element.appendChild(this.nextBut);
			this.element.appendChild(this.lastBut);
			
			if(!this.table.options.paginationElement){
				if(this.table.options.paginationCounter){

					if(this.table.options.paginationCounterElement){
						if(this.table.options.paginationCounterElement instanceof HTMLElement){
							this.table.options.paginationCounterElement.appendChild(this.pageCounterElement);
						}else if(typeof this.table.options.paginationCounterElement === "string"){
							paginationCounterHolder = document.querySelector(this.table.options.paginationCounterElement);
							
							if(paginationCounterHolder){
								paginationCounterHolder.appendChild(this.pageCounterElement);
							}else {
								console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement);
							}
						}
					}else {
						this.footerAppend(this.pageCounterElement);
					}
					
				}
				
				this.footerAppend(this.element);
			}
			
			this.page = this.table.options.paginationInitialPage;
			this.count = this.table.options.paginationButtonCount;
		}
		
		//set default values
		this.mode = this.table.options.paginationMode;
	}
	
	initializeProgressive(mode){
		this.initializePaginator(true);
		this.mode = "progressive_" + mode;
		this.progressiveLoad = true;
	}
	
	trackChanges(){
		this.dispatch("page-changed");
	}
	
	//calculate maximum page from number of rows
	setMaxRows(rowCount){
		if(!rowCount){
			this.max = 1;
		}else {
			this.max = this.size === true ?  1 : Math.ceil(rowCount/this.size);
		}
		
		if(this.page > this.max){
			this.page = this.max;
		}
	}
	
	//reset to first page without triggering action
	reset(force){
		if(!this.initialLoad){
			if(this.mode == "local" || force){
				this.page = 1;
				this.trackChanges();
			}
		}
	}
	
	//set the maximum page
	setMaxPage(max){
		
		max = parseInt(max);
		
		this.max = max || 1;
		
		if(this.page > this.max){
			this.page = this.max;
			this.trigger();
		}
	}
	
	//set current page number
	setPage(page){
		switch(page){
			case "first":
				return this.setPage(1);
	
			case "prev":
				return this.previousPage();
			
			case "next":
				return this.nextPage();
			
			case "last":
				return this.setPage(this.max);
		}
		
		page = parseInt(page);
		
		if((page > 0 && page <= this.max) || this.mode !== "local"){
			this.page = page;
			
			this.trackChanges();
			
			return this.trigger();
		}else {
			console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", page);
			return Promise.reject();
		}
	}
	
	setPageToRow(row){
		var rows = this.displayRows(-1);
		var index = rows.indexOf(row);
	
		if(index > -1){
			var page = this.size === true ? 1 : Math.ceil((index + 1) / this.size);
			
			return this.setPage(page);
		}else {
			console.warn("Pagination Error - Requested row is not visible");
			return Promise.reject();
		}
	}
	
	setPageSize(size){
		if(size !== true){
			size = parseInt(size);
		}

		if(size > 0){
			this.size = size;
			this.dispatchExternal("pageSizeChanged", size);
		}
		
		if(this.pageSizeSelect){
			// this.pageSizeSelect.value = size;
			this.generatePageSizeSelectList();
		}
		
		this.trackChanges();
	}
	
	_setPageCounter(totalRows, size, currentRow){
		var content;
		
		if(this.pageCounter){

			if(this.mode === "remote"){
				size = this.size;
				currentRow = ((this.page - 1) * this.size) + 1;
				totalRows = this.remoteRowCountEstimate;
			}

			content = this.pageCounter.call(this, size, currentRow, this.page, totalRows, this.max);
			
			switch(typeof content){
				case "object":
					if(content instanceof Node){
					
						//clear previous cell contents
						while(this.pageCounterElement.firstChild) this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);
					
						this.pageCounterElement.appendChild(content);
					}else {
						this.pageCounterElement.innerHTML = "";
					
						if(content != null){
							console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", content);
						}
					}
					break;
				case "undefined":
					this.pageCounterElement.innerHTML = "";
					break;
				default:
					this.pageCounterElement.innerHTML = content;
			}
		}
	}
	
	//setup the pagination buttons
	_setPageButtons(){
		let leftSize = Math.floor((this.count-1) / 2);
		let rightSize = Math.ceil((this.count-1) / 2);
		let min = this.max - this.page + leftSize + 1 < this.count ? this.max-this.count+1: Math.max(this.page-leftSize,1);
		let max = this.page <= rightSize? Math.min(this.count, this.max) :Math.min(this.page+rightSize, this.max);
		
		while(this.pagesElement.firstChild) this.pagesElement.removeChild(this.pagesElement.firstChild);
		
		if(this.page == 1){
			this.firstBut.disabled = true;
			this.prevBut.disabled = true;
		}else {
			this.firstBut.disabled = false;
			this.prevBut.disabled = false;
		}
		
		if(this.page == this.max){
			this.lastBut.disabled = true;
			this.nextBut.disabled = true;
		}else {
			this.lastBut.disabled = false;
			this.nextBut.disabled = false;
		}
		
		for(let i = min; i <= max; i++){
			if(i>0 && i <= this.max){
				this.pagesElement.appendChild(this._generatePageButton(i));
			}
		}
		
		this.footerRedraw();
	}
	
	_generatePageButton(page){
		var button = document.createElement("button");
		
		button.classList.add("tabulator-page");
		if(page == this.page){
			button.classList.add("active");
		}
		
		button.setAttribute("type", "button");
		button.setAttribute("role", "button");
		
		this.langBind("pagination|page_title", (value) => {
			button.setAttribute("aria-label", value + " " + page);
			button.setAttribute("title", value + " " + page);
		});
		
		button.setAttribute("data-page", page);
		button.textContent = page;
		
		button.addEventListener("click", (e) => {
			this.setPage(page);
		});
		
		return button;
	}
	
	//previous page
	previousPage(){
		if(this.page > 1){
			this.page--;
			
			this.trackChanges();
			
			return this.trigger();
			
		}else {
			console.warn("Pagination Error - Previous page would be less than page 1:", 0);
			return Promise.reject();
		}
	}
	
	//next page
	nextPage(){
		if(this.page < this.max){
			this.page++;
			
			this.trackChanges();
			
			return this.trigger();
			
		}else {
			if(!this.progressiveLoad){
				console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1);
			}
			return Promise.reject();
		}
	}
	
	//return current page number
	getPage(){
		return this.page;
	}
	
	//return max page number
	getPageMax(){
		return this.max;
	}
	
	getPageSize(size){
		return this.size;
	}
	
	getMode(){
		return this.mode;
	}
	
	//return appropriate rows for current page
	getRows(data){
		var actualRowPageSize = 0,
		output, start, end, actualStartRow;

		var actualRows = data.filter((row) => {
			return row.type === "row";
		});
		
		if(this.mode == "local"){
			output = [];
			
			this.setMaxRows(data.length);
			
			if(this.size === true){
				start = 0;
				end = data.length;
			}else {
				start = this.size * (this.page - 1);
				end = start + parseInt(this.size);
			}
			
			this._setPageButtons();
			
			for(let i = start; i < end; i++){
				let row = data[i];

				if(row){
					output.push(row);

					if(row.type === "row"){
						if(!actualStartRow){
							actualStartRow = row;
						}	

						actualRowPageSize++;
					}
				}
			}
			
			this._setPageCounter(actualRows.length, actualRowPageSize, actualStartRow ? (actualRows.indexOf(actualStartRow) + 1) : 0);
			
			return output;
		}else {
			this._setPageButtons();
			this._setPageCounter(actualRows.length);
			
			return data.slice(0);
		}
	}
	
	trigger(){
		var left;
		
		switch(this.mode){
			case "local":
				left = this.table.rowManager.scrollLeft;
			
				this.refreshData();
				this.table.rowManager.scrollHorizontal(left);
			
				this.dispatchExternal("pageLoaded", this.getPage());
			
				return Promise.resolve();
			
			case "remote":
				this.dataChanging = true;
				return this.reloadData(null)
					.finally(() => {
						this.dataChanging = false;
					});
			
			case "progressive_load":
			case "progressive_scroll":
				return this.reloadData(null, true);
			
			default:
				console.warn("Pagination Error - no such pagination mode:", this.mode);
				return Promise.reject();
		}
	}
	
	_parseRemoteData(data){
		var margin;
		
		if(typeof data.last_page === "undefined"){
			console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property");
		}
		
		if(data.data){
			this.max = parseInt(data.last_page) || 1;

			this.remoteRowCountEstimate = typeof data.last_row !== "undefined" ? data.last_row : (data.last_page * this.size - (this.page == data.last_page ? (this.size - data.data.length) : 0));
			
			if(this.progressiveLoad){
				switch(this.mode){
					case "progressive_load":
					
						if(this.page == 1){
							this.table.rowManager.setData(data.data, false, this.page == 1);
						}else {
							this.table.rowManager.addRows(data.data);
						}
					
						if(this.page < this.max){
							setTimeout(() => {
								this.nextPage();
							}, this.table.options.progressiveLoadDelay);
						}
						break;
					
					case "progressive_scroll":
						data = this.page === 1 ? data.data : this.table.rowManager.getData().concat(data.data);
					
						this.table.rowManager.setData(data, this.page !== 1, this.page == 1);
					
						margin = this.table.options.progressiveLoadScrollMargin || (this.table.rowManager.element.clientHeight * 2);
					
						if(this.table.rowManager.element.scrollHeight <= (this.table.rowManager.element.clientHeight + margin)){
							if(this.page < this.max){
								setTimeout(() => {
									this.nextPage();
								});
							}
						}
						break;
				}
				
				return false;
			}else {
				// left = this.table.rowManager.scrollLeft;
				this.dispatchExternal("pageLoaded",  this.getPage());
				// this.table.rowManager.scrollHorizontal(left);
				// this.table.columnManager.scrollHorizontal(left);
			}
			
		}else {
			console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
		}
		
		return data.data;
	}
	
	//handle the footer element being redrawn
	footerRedraw(){
		var footer = this.table.footerManager.containerElement;

		if((Math.ceil(footer.clientWidth) - footer.scrollWidth) < 0){
			this.pagesElement.style.display = 'none';
		}else {
			this.pagesElement.style.display = '';
			
			if((Math.ceil(footer.clientWidth) - footer.scrollWidth) < 0){
				this.pagesElement.style.display = 'none';
			}
		}
	}
}

Page.moduleName = "page";

//load defaults
Page.pageCounters = defaultPageCounters;

// read persistance information from storage
var defaultReaders = {
	local:function(id, type){
		var data = localStorage.getItem(id + "-" + type);

		return data ? JSON.parse(data) : false;
	},
	cookie:function(id, type){
		var cookie = document.cookie,
		key = id + "-" + type,
		cookiePos = cookie.indexOf(key + "="),
		end, data;

		//if cookie exists, decode and load column data into tabulator
		if(cookiePos > -1){
			cookie = cookie.slice(cookiePos);

			end = cookie.indexOf(";");

			if(end > -1){
				cookie = cookie.slice(0, end);
			}

			data = cookie.replace(key + "=", "");
		}

		return data ? JSON.parse(data) : false;
	}
};

//write persistence information to storage
var defaultWriters = {
	local:function(id, type, data){
		localStorage.setItem(id + "-" + type, JSON.stringify(data));
	},
	cookie:function(id, type, data){
		var expireDate = new Date();

		expireDate.setDate(expireDate.getDate() + 10000);

		document.cookie = id + "-" + type + "=" + JSON.stringify(data) + "; expires=" + expireDate.toUTCString();
	}
};

class Persistence extends Module{

	constructor(table){
		super(table);

		this.mode = "";
		this.id = "";
		// this.persistProps = ["field", "width", "visible"];
		this.defWatcherBlock = false;
		this.config = {};
		this.readFunc = false;
		this.writeFunc = false;

		this.registerTableOption("persistence", false);
		this.registerTableOption("persistenceID", ""); //key for persistent storage
		this.registerTableOption("persistenceMode", true); //mode for storing persistence information
		this.registerTableOption("persistenceReaderFunc", false); //function for handling persistence data reading
		this.registerTableOption("persistenceWriterFunc", false); //function for handling persistence data writing
	}

	// Test for whether localStorage is available for use.
	localStorageTest() {
		var  testKey =  "_tabulator_test";

		try {
			window.localStorage.setItem( testKey, testKey);
			window.localStorage.removeItem( testKey );
			return true;
		} catch(e) {
			return false;
		}
	}

	//setup parameters
	initialize(){
		if(this.table.options.persistence){
			//determine persistent layout storage type
			var mode = this.table.options.persistenceMode,
			id = this.table.options.persistenceID,
			retrievedData;

			this.mode = mode !== true ?  mode : (this.localStorageTest() ? "local" : "cookie");

			if(this.table.options.persistenceReaderFunc){
				if(typeof this.table.options.persistenceReaderFunc === "function"){
					this.readFunc = this.table.options.persistenceReaderFunc;
				}else {
					if(Persistence.readers[this.table.options.persistenceReaderFunc]){
						this.readFunc = Persistence.readers[this.table.options.persistenceReaderFunc];
					}else {
						console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc);
					}
				}
			}else {
				if(Persistence.readers[this.mode]){
					this.readFunc = Persistence.readers[this.mode];
				}else {
					console.warn("Persistence Read Error - invalid reader set", this.mode);
				}
			}

			if(this.table.options.persistenceWriterFunc){
				if(typeof this.table.options.persistenceWriterFunc === "function"){
					this.writeFunc = this.table.options.persistenceWriterFunc;
				}else {
					if(Persistence.writers[this.table.options.persistenceWriterFunc]){
						this.writeFunc = Persistence.writers[this.table.options.persistenceWriterFunc];
					}else {
						console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc);
					}
				}
			}else {
				if(Persistence.writers[this.mode]){
					this.writeFunc = Persistence.writers[this.mode];
				}else {
					console.warn("Persistence Write Error - invalid writer set", this.mode);
				}
			}

			//set storage tag
			this.id = "tabulator-" + (id || (this.table.element.getAttribute("id") || ""));

			this.config = {
				sort:this.table.options.persistence === true || this.table.options.persistence.sort,
				filter:this.table.options.persistence === true || this.table.options.persistence.filter,
				headerFilter:this.table.options.persistence === true || this.table.options.persistence.headerFilter,
				group:this.table.options.persistence === true || this.table.options.persistence.group,
				page:this.table.options.persistence === true || this.table.options.persistence.page,
				columns:this.table.options.persistence === true ? ["title", "width", "visible"] : this.table.options.persistence.columns,
			};

			//load pagination data if needed
			if(this.config.page){
				retrievedData = this.retrieveData("page");

				if(retrievedData){
					if(typeof retrievedData.paginationSize !== "undefined" && (this.config.page === true || this.config.page.size)){
						this.table.options.paginationSize = retrievedData.paginationSize;
					}

					if(typeof retrievedData.paginationInitialPage !== "undefined" && (this.config.page === true || this.config.page.page)){
						this.table.options.paginationInitialPage = retrievedData.paginationInitialPage;
					}
				}
			}

			//load group data if needed
			if(this.config.group){
				retrievedData = this.retrieveData("group");

				if(retrievedData){
					if(typeof retrievedData.groupBy !== "undefined" && (this.config.group === true || this.config.group.groupBy)){
						this.table.options.groupBy = retrievedData.groupBy;
					}
					if(typeof retrievedData.groupStartOpen !== "undefined" && (this.config.group === true || this.config.group.groupStartOpen)){
						this.table.options.groupStartOpen = retrievedData.groupStartOpen;
					}
					if(typeof retrievedData.groupHeader !== "undefined" && (this.config.group === true || this.config.group.groupHeader)){
						this.table.options.groupHeader = retrievedData.groupHeader;
					}
				}
			}

			if(this.config.columns){
				this.table.options.columns = this.load("columns", this.table.options.columns);
				this.subscribe("column-init", this.initializeColumn.bind(this));
				this.subscribe("column-show", this.save.bind(this, "columns"));
				this.subscribe("column-hide", this.save.bind(this, "columns"));
				this.subscribe("column-moved", this.save.bind(this, "columns"));
			}

			this.subscribe("table-built", this.tableBuilt.bind(this), 0);

			this.subscribe("table-redraw", this.tableRedraw.bind(this));

			this.subscribe("filter-changed", this.eventSave.bind(this, "filter"));
			this.subscribe("filter-changed", this.eventSave.bind(this, "headerFilter"));
			this.subscribe("sort-changed", this.eventSave.bind(this, "sort"));
			this.subscribe("group-changed", this.eventSave.bind(this, "group"));
			this.subscribe("page-changed", this.eventSave.bind(this, "page"));
			this.subscribe("column-resized", this.eventSave.bind(this, "columns"));
			this.subscribe("column-width", this.eventSave.bind(this, "columns"));
			this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
		}

		this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this));
		this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
	}

	eventSave(type){
		if(this.config[type]){
			this.save(type);
		}
	}

	tableBuilt(){
		var sorters, filters, headerFilters;

		if(this.config.sort){
			sorters = this.load("sort");

			if(!sorters === false){
				this.table.options.initialSort = sorters;
			}
		}

		if(this.config.filter){
			filters = this.load("filter");

			if(!filters === false){
				this.table.options.initialFilter = filters;
			}
		}
		if(this.config.headerFilter){
			headerFilters = this.load("headerFilter");

			if(!headerFilters === false){
				this.table.options.initialHeaderFilter = headerFilters;
			}
		}
		
	}

	tableRedraw(force){
		if(force && this.config.columns){
			this.save("columns");
		}
	}

	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////

	getColumnLayout(){
		return this.parseColumns(this.table.columnManager.getColumns());
	}

	setColumnLayout(layout){
		this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, layout, true));
		return true;
	}

	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////

	initializeColumn(column){
		var def, keys;

		if(this.config.columns){
			this.defWatcherBlock = true;

			def = column.getDefinition();

			keys = this.config.columns === true ? Object.keys(def) : this.config.columns;

			keys.forEach((key)=>{
				var props = Object.getOwnPropertyDescriptor(def, key);
				var value = def[key];

				if(props){
					Object.defineProperty(def, key, {
						set: (newValue) => {
							value = newValue;

							if(!this.defWatcherBlock){
								this.save("columns");
							}

							if(props.set){
								props.set(newValue);
							}
						},
						get:() => {
							if(props.get){
								props.get();
							}
							return value;
						}
					});
				}
			});

			this.defWatcherBlock = false;
		}
	}

	//load saved definitions
	load(type, current){
		var data = this.retrieveData(type);

		if(current){
			data = data ? this.mergeDefinition(current, data) : current;
		}

		return data;
	}

	//retrieve data from memory
	retrieveData(type){
		return this.readFunc ? this.readFunc(this.id, type) : false;
	}

	//merge old and new column definitions
	mergeDefinition(oldCols, newCols, mergeAllNew){
		var output = [];

		newCols = newCols || [];

		newCols.forEach((column, to) => {
			var from = this._findColumn(oldCols, column),
			keys;

			if(from){
				if(mergeAllNew){
					keys = Object.keys(column);
				}else if(this.config.columns === true || this.config.columns == undefined){
					keys =  Object.keys(from);
					keys.push("width");
				}else {
					keys = this.config.columns;
				}

				keys.forEach((key)=>{
					if(key !== "columns" && typeof column[key] !== "undefined"){
						from[key] = column[key];
					}
				});

				if(from.columns){
					from.columns = this.mergeDefinition(from.columns, column.columns);
				}

				output.push(from);
			}
		});

		oldCols.forEach((column, i) => {
			var from = this._findColumn(newCols, column);

			if (!from) {
				if(output.length>i){
					output.splice(i, 0, column);
				}else {
					output.push(column);
				}
			}
		});

		return output;
	}

	//find matching columns
	_findColumn(columns, subject){
		var type = subject.columns ? "group" : (subject.field ? "field" : "object");

		return columns.find(function(col){
			switch(type){
				case "group":
					return col.title === subject.title && col.columns.length === subject.columns.length;

				case "field":
					return col.field === subject.field;

				case "object":
					return col === subject;
			}
		});
	}

	//save data
	save(type){
		var data = {};

		switch(type){
			case "columns":
				data = this.parseColumns(this.table.columnManager.getColumns());
				break;

			case "filter":
				data = this.table.modules.filter.getFilters();
				break;

			case "headerFilter":
				data = this.table.modules.filter.getHeaderFilters();
				break;

			case "sort":
				data = this.validateSorters(this.table.modules.sort.getSort());
				break;

			case "group":
				data = this.getGroupConfig();
				break;

			case "page":
				data = this.getPageConfig();
				break;
		}

		if(this.writeFunc){
			this.writeFunc(this.id, type, data);
		}

	}

	//ensure sorters contain no function data
	validateSorters(data){
		data.forEach(function(item){
			item.column = item.field;
			delete item.field;
		});

		return data;
	}

	getGroupConfig(){
		var data = {};

		if(this.config.group){
			if(this.config.group === true || this.config.group.groupBy){
				data.groupBy = this.table.options.groupBy;
			}

			if(this.config.group === true || this.config.group.groupStartOpen){
				data.groupStartOpen = this.table.options.groupStartOpen;
			}

			if(this.config.group === true || this.config.group.groupHeader){
				data.groupHeader = this.table.options.groupHeader;
			}
		}

		return data;
	}

	getPageConfig(){
		var data = {};

		if(this.config.page){
			if(this.config.page === true || this.config.page.size){
				data.paginationSize = this.table.modules.page.getPageSize();
			}

			if(this.config.page === true || this.config.page.page){
				data.paginationInitialPage = this.table.modules.page.getPage();
			}
		}

		return data;
	}


	//parse columns for data to store
	parseColumns(columns){
		var definitions = [],
		excludedKeys = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];

		columns.forEach((column) => {
			var defStore = {},
			colDef = column.getDefinition(),
			keys;

			if(column.isGroup){
				defStore.title = colDef.title;
				defStore.columns = this.parseColumns(column.getColumns());
			}else {
				defStore.field = column.getField();

				if(this.config.columns === true || this.config.columns == undefined){
					keys =  Object.keys(colDef);
					keys.push("width");
					keys.push("visible");
				}else {
					keys = this.config.columns;
				}

				keys.forEach((key)=>{
					switch(key){
						case "width":
							defStore.width = column.getWidth();
							break;
						case "visible":
							defStore.visible = column.visible;
							break;

						default:
							if(typeof colDef[key] !== "function" && excludedKeys.indexOf(key) === -1){
								defStore[key] = colDef[key];
							}
					}
				});
			}

			definitions.push(defStore);
		});

		return definitions;
	}
}

Persistence.moduleName = "persistence";

Persistence.moduleInitOrder = -10;

//load defaults
Persistence.readers = defaultReaders;
Persistence.writers = defaultWriters;

class Popup$1 extends Module{
	
	constructor(table){
		super(table);
		
		this.columnSubscribers = {};
		
		this.registerTableOption("rowContextPopup", false);
		this.registerTableOption("rowClickPopup", false);
		this.registerTableOption("rowDblClickPopup", false);
		this.registerTableOption("groupContextPopup", false);
		this.registerTableOption("groupClickPopup", false);
		this.registerTableOption("groupDblClickPopup", false);
		
		this.registerColumnOption("headerContextPopup");
		this.registerColumnOption("headerClickPopup");
		this.registerColumnOption("headerDblClickPopup");
		this.registerColumnOption("headerPopup");
		this.registerColumnOption("headerPopupIcon");
		this.registerColumnOption("contextPopup");
		this.registerColumnOption("clickPopup");
		this.registerColumnOption("dblClickPopup");

		this.registerComponentFunction("cell", "popup", this._componentPopupCall.bind(this));
		this.registerComponentFunction("column", "popup", this._componentPopupCall.bind(this));
		this.registerComponentFunction("row", "popup", this._componentPopupCall.bind(this));
		this.registerComponentFunction("group", "popup", this._componentPopupCall.bind(this));
		
	}
	
	initialize(){
		this.initializeRowWatchers();
		this.initializeGroupWatchers();
		
		this.subscribe("column-init", this.initializeColumn.bind(this));
	}

	_componentPopupCall(component, contents, position){
		this.loadPopupEvent(contents, null, component, position);
	}
	
	initializeRowWatchers(){
		if(this.table.options.rowContextPopup){
			this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
			this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
		}
		
		if(this.table.options.rowClickPopup){
			this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup));
		}

		if(this.table.options.rowDblClickPopup){
			this.subscribe("row-dblclick", this.loadPopupEvent.bind(this, this.table.options.rowDblClickPopup));
		}
	}
	
	initializeGroupWatchers(){
		if(this.table.options.groupContextPopup){
			this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
			this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
		}
		
		if(this.table.options.groupClickPopup){
			this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup));
		}

		if(this.table.options.groupDblClickPopup){
			this.subscribe("group-dblclick", this.loadPopupEvent.bind(this, this.table.options.groupDblClickPopup));
		}
	}

	initializeColumn(column){
		var def = column.definition;
		
		//handle column events
		if(def.headerContextPopup && !this.columnSubscribers.headerContextPopup){
			this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup");
			this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup);
			this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"));
		}
		
		if(def.headerClickPopup && !this.columnSubscribers.headerClickPopup){
			this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup");
			this.subscribe("column-click", this.columnSubscribers.headerClickPopup);
		
		
		}if(def.headerDblClickPopup && !this.columnSubscribers.headerDblClickPopup){
			this.columnSubscribers.headerDblClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerDblClickPopup");
			this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickPopup);
		}
		
		if(def.headerPopup){
			this.initializeColumnHeaderPopup(column);
		}
		
		//handle cell events
		if(def.contextPopup && !this.columnSubscribers.contextPopup){
			this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup");
			this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup);
			this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"));
		}
		
		if(def.clickPopup && !this.columnSubscribers.clickPopup){
			this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup");
			this.subscribe("cell-click", this.columnSubscribers.clickPopup);
		}

		if(def.dblClickPopup && !this.columnSubscribers.dblClickPopup){
			this.columnSubscribers.dblClickPopup = this.loadPopupTableCellEvent.bind(this, "dblClickPopup");
			this.subscribe("cell-click", this.columnSubscribers.dblClickPopup);
		}
	}
	
	initializeColumnHeaderPopup(column){
		var icon = column.definition.headerPopupIcon,
		headerPopupEl;
		
		headerPopupEl = document.createElement("span");
		headerPopupEl.classList.add("tabulator-header-popup-button");

		if(icon){
			if(typeof icon === "function"){
				icon = icon(column.getComponent());
			}

			if(icon instanceof HTMLElement){
				headerPopupEl.appendChild(icon);
			}else {
				headerPopupEl.innerHTML = icon;
			}
		}else {
			headerPopupEl.innerHTML = "&vellip;";
		}
		
		headerPopupEl.addEventListener("click", (e) => {
			e.stopPropagation();
			e.preventDefault();
			
			this.loadPopupEvent(column.definition.headerPopup, e, column);
		});
		
		column.titleElement.insertBefore(headerPopupEl, column.titleElement.firstChild);
	}
	
	loadPopupTableCellEvent(option, e, cell){
		if(cell._cell){
			cell = cell._cell;
		}
		
		if(cell.column.definition[option]){
			this.loadPopupEvent(cell.column.definition[option], e, cell);
		}
	}
	
	loadPopupTableColumnEvent(option, e, column){
		if(column._column){
			column = column._column;
		}
		
		if(column.definition[option]){
			this.loadPopupEvent(column.definition[option], e, column);
		}
	}
	
	loadPopupEvent(contents, e, component, position){
		var renderedCallback;

		function onRendered(callback){
			renderedCallback = callback;
		}
		
		if(component._group){
			component = component._group;
		}else if(component._row){
			component = component._row;
		}
		
		contents = typeof contents == "function" ? contents.call(this.table, e, component.getComponent(),  onRendered) : contents;
		
		this.loadPopup(e, component, contents, renderedCallback, position);
	}
	
	loadPopup(e, component, contents, renderedCallback, position){
		var touch = !(e instanceof MouseEvent),
		contentsEl, popup;
		
		if(contents instanceof HTMLElement){
			contentsEl = contents;
		}else {
			contentsEl = document.createElement("div");
			contentsEl.innerHTML = contents;
		}
		
		contentsEl.classList.add("tabulator-popup");

		contentsEl.addEventListener("click", (e) =>{
			e.stopPropagation();
		});

		if(!touch){
			e.preventDefault();
		}
		
		popup = this.popup(contentsEl);

		if(typeof renderedCallback === "function"){
			popup.renderCallback(renderedCallback);
		}

		if(e){
			popup.show(e);
		}else {
			popup.show(component.getElement(), position || "center");
		}

		
		popup.hideOnBlur(() => {
			this.dispatchExternal("popupClosed", component.getComponent());
		});



		this.dispatchExternal("popupOpened", component.getComponent());
	}
}

Popup$1.moduleName = "popup";

class Print extends Module{

	constructor(table){
		super(table);

		this.element = false;
		this.manualBlock = false;
		this.beforeprintEventHandler = null;
		this.afterprintEventHandler = null;

		this.registerTableOption("printAsHtml", false); //enable print as html
		this.registerTableOption("printFormatter", false); //printing page formatter
		this.registerTableOption("printHeader", false); //page header contents
		this.registerTableOption("printFooter", false); //page footer contents
		this.registerTableOption("printStyled", true); //enable print as html styling
		this.registerTableOption("printRowRange", "visible"); //restrict print to visible rows only
		this.registerTableOption("printConfig", {}); //print config options

		this.registerColumnOption("print");
		this.registerColumnOption("titlePrint");
	}

	initialize(){
		if(this.table.options.printAsHtml){
			this.beforeprintEventHandler = this.replaceTable.bind(this);
			this.afterprintEventHandler = this.cleanup.bind(this);

			window.addEventListener("beforeprint", this.beforeprintEventHandler );
			window.addEventListener("afterprint", this.afterprintEventHandler);
			this.subscribe("table-destroy", this.destroy.bind(this));
		}

		this.registerTableFunction("print", this.printFullscreen.bind(this));
	}

	destroy(){
		if(this.table.options.printAsHtml){
			window.removeEventListener( "beforeprint", this.beforeprintEventHandler );
			window.removeEventListener( "afterprint", this.afterprintEventHandler );
		}
	}

	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////

	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////

	replaceTable(){
		if(!this.manualBlock){
			this.element = document.createElement("div");
			this.element.classList.add("tabulator-print-table");

			this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print"));

			this.table.element.style.display = "none";

			this.table.element.parentNode.insertBefore(this.element, this.table.element);
		}
	}

	cleanup(){
		document.body.classList.remove("tabulator-print-fullscreen-hide");

		if(this.element && this.element.parentNode){
			this.element.parentNode.removeChild(this.element);
			this.table.element.style.display = "";
		}
	}

	printFullscreen(visible, style, config){
		var scrollX = window.scrollX,
		scrollY = window.scrollY,
		headerEl = document.createElement("div"),
		footerEl = document.createElement("div"),
		tableEl = this.table.modules.export.generateTable(typeof config != "undefined" ? config : this.table.options.printConfig, typeof style != "undefined" ? style : this.table.options.printStyled, visible || this.table.options.printRowRange, "print"),
		headerContent, footerContent;

		this.manualBlock = true;

		this.element = document.createElement("div");
		this.element.classList.add("tabulator-print-fullscreen");

		if(this.table.options.printHeader){
			headerEl.classList.add("tabulator-print-header");

			headerContent = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader;

			if(typeof headerContent == "string"){
				headerEl.innerHTML = headerContent;
			}else {
				headerEl.appendChild(headerContent);
			}

			this.element.appendChild(headerEl);
		}

		this.element.appendChild(tableEl);

		if(this.table.options.printFooter){
			footerEl.classList.add("tabulator-print-footer");

			footerContent = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter;


			if(typeof footerContent == "string"){
				footerEl.innerHTML = footerContent;
			}else {
				footerEl.appendChild(footerContent);
			}

			this.element.appendChild(footerEl);
		}

		document.body.classList.add("tabulator-print-fullscreen-hide");
		document.body.appendChild(this.element);

		if(this.table.options.printFormatter){
			this.table.options.printFormatter(this.element, tableEl);
		}

		window.print();

		this.cleanup();

		window.scrollTo(scrollX, scrollY);

		this.manualBlock = false;
	}
}

Print.moduleName = "print";

class ReactiveData extends Module{
	
	constructor(table){
		super(table);
		
		this.data = false;
		this.blocked = false; //block reactivity while performing update
		this.origFuncs = {}; // hold original data array functions to allow replacement after data is done with
		this.currentVersion = 0;
		
		this.registerTableOption("reactiveData", false); //enable data reactivity
	}
	
	initialize(){
		if(this.table.options.reactiveData){
			this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave"));
			this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave"));
			this.subscribe("row-data-save-before", this.block.bind(this, "rowsave"));
			this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave"));
			this.subscribe("row-data-init-after", this.watchRow.bind(this));
			this.subscribe("data-processing", this.watchData.bind(this));
			this.subscribe("table-destroy", this.unwatchData.bind(this));
		}
	}
	
	watchData(data){
		var self = this,
		version;
		
		this.currentVersion ++;
		
		version = this.currentVersion;
		
		this.unwatchData();
		
		this.data = data;
		
		//override array push function
		this.origFuncs.push = data.push;
		
		Object.defineProperty(this.data, "push", {
			enumerable: false,
			configurable: true,
			value: function(){
				var args = Array.from(arguments),
				result;

				if(!self.blocked && version === self.currentVersion){	
					self.block("data-push");

					args.forEach((arg) => {
						self.table.rowManager.addRowActual(arg, false);
					});
					
					result = self.origFuncs.push.apply(data, arguments);
					
					self.unblock("data-push");
				}
				
				return result;
			}
		});
		
		//override array unshift function
		this.origFuncs.unshift = data.unshift;
		
		Object.defineProperty(this.data, "unshift", {
			enumerable: false,
			configurable: true,
			value: function(){
				var args = Array.from(arguments),
				result;
				
				if(!self.blocked && version === self.currentVersion){
					self.block("data-unshift");
					
					args.forEach((arg) => {
						self.table.rowManager.addRowActual(arg, true);
					});
					
					result = self.origFuncs.unshift.apply(data, arguments);
					
					self.unblock("data-unshift");
				}
				
				return result;
			}
		});
		
		
		//override array shift function
		this.origFuncs.shift = data.shift;
		
		Object.defineProperty(this.data, "shift", {
			enumerable: false,
			configurable: true,
			value: function(){
				var row, result;
				
				if(!self.blocked && version === self.currentVersion){
					self.block("data-shift");
					
					if(self.data.length){
						row = self.table.rowManager.getRowFromDataObject(self.data[0]);
						
						if(row){
							row.deleteActual();
						}
					}

					result = self.origFuncs.shift.call(data);

					self.unblock("data-shift");
				}
				
				return result;
			}
		});
		
		//override array pop function
		this.origFuncs.pop = data.pop;
		
		Object.defineProperty(this.data, "pop", {
			enumerable: false,
			configurable: true,
			value: function(){
				var row, result;
			
				if(!self.blocked && version === self.currentVersion){
					self.block("data-pop");
					
					if(self.data.length){
						row = self.table.rowManager.getRowFromDataObject(self.data[self.data.length - 1]);
						
						if(row){
							row.deleteActual();
						}
					}

					result = self.origFuncs.pop.call(data);
					
					self.unblock("data-pop");
				}

				return result;
			}
		});
		
		
		//override array splice function
		this.origFuncs.splice = data.splice;
		
		Object.defineProperty(this.data, "splice", {
			enumerable: false,
			configurable: true,
			value: function(){
				var args = Array.from(arguments),
				start = args[0] < 0 ? data.length + args[0] : args[0],
				end = args[1],
				newRows = args[2] ? args.slice(2) : false,
				startRow, result;
				
				if(!self.blocked && version === self.currentVersion){
					self.block("data-splice");
					//add new rows
					if(newRows){
						startRow = data[start] ? self.table.rowManager.getRowFromDataObject(data[start]) : false;
						
						if(startRow){
							newRows.forEach((rowData) => {
								self.table.rowManager.addRowActual(rowData, true, startRow, true);
							});
						}else {
							newRows = newRows.slice().reverse();
							
							newRows.forEach((rowData) => {
								self.table.rowManager.addRowActual(rowData, true, false, true);
							});
						}
					}
					
					//delete removed rows
					if(end !== 0){
						var oldRows = data.slice(start, typeof args[1] === "undefined" ? args[1] : start + end);
						
						oldRows.forEach((rowData, i) => {
							var row = self.table.rowManager.getRowFromDataObject(rowData);
							
							if(row){
								row.deleteActual(i !== oldRows.length - 1);
							}
						});
					}
					
					if(newRows || end !== 0){
						self.table.rowManager.reRenderInPosition();
					}

					result = self.origFuncs.splice.apply(data, arguments);
					
					self.unblock("data-splice");
				}
				
				return result ;
			}
		});
	}
	
	unwatchData(){
		if(this.data !== false){
			for(var key in this.origFuncs){
				Object.defineProperty(this.data, key, {
					enumerable: true,
					configurable:true,
					writable:true,
					value: this.origFuncs.key,
				});
			}
		}
	}
	
	watchRow(row){
		var data = row.getData();
		
		for(var key in data){
			this.watchKey(row, data, key);
		}
		
		if(this.table.options.dataTree){
			this.watchTreeChildren(row);
		}
	}
	
	watchTreeChildren (row){
		var self = this,
		childField = row.getData()[this.table.options.dataTreeChildField],
		origFuncs = {};
		
		if(childField){
			
			origFuncs.push = childField.push;
			
			Object.defineProperty(childField, "push", {
				enumerable: false,
				configurable: true,
				value: () => {
					if(!self.blocked){
						self.block("tree-push");
						
						var result = origFuncs.push.apply(childField, arguments);
						this.rebuildTree(row);
						
						self.unblock("tree-push");
					}
					
					return result;
				}
			});
			
			origFuncs.unshift = childField.unshift;
			
			Object.defineProperty(childField, "unshift", {
				enumerable: false,
				configurable: true,
				value: () => {
					if(!self.blocked){
						self.block("tree-unshift");
						
						var result =  origFuncs.unshift.apply(childField, arguments);
						this.rebuildTree(row);
						
						self.unblock("tree-unshift");
					}
					
					return result;
				}
			});
			
			origFuncs.shift = childField.shift;
			
			Object.defineProperty(childField, "shift", {
				enumerable: false,
				configurable: true,
				value: () => {
					if(!self.blocked){
						self.block("tree-shift");
						
						var result =  origFuncs.shift.call(childField);
						this.rebuildTree(row);
						
						self.unblock("tree-shift");
					}
					
					return result;
				}
			});
			
			origFuncs.pop = childField.pop;
			
			Object.defineProperty(childField, "pop", {
				enumerable: false,
				configurable: true,
				value: () => {
					if(!self.blocked){
						self.block("tree-pop");
						
						var result =  origFuncs.pop.call(childField);
						this.rebuildTree(row);
						
						self.unblock("tree-pop");
					}
					
					return result;
				}
			});
			
			origFuncs.splice = childField.splice;
			
			Object.defineProperty(childField, "splice", {
				enumerable: false,
				configurable: true,
				value: () => {
					if(!self.blocked){
						self.block("tree-splice");
						
						var result =  origFuncs.splice.apply(childField, arguments);
						this.rebuildTree(row);
						
						self.unblock("tree-splice");
					}
					
					return result;
				}
			});
		}
	}
	
	rebuildTree(row){
		this.table.modules.dataTree.initializeRow(row);
		this.table.modules.dataTree.layoutRow(row);
		this.table.rowManager.refreshActiveData("tree", false, true);
	}
	
	watchKey(row, data, key){
		var self = this,
		props = Object.getOwnPropertyDescriptor(data, key),
		value = data[key],
		version = this.currentVersion;
		
		Object.defineProperty(data, key, {
			set: (newValue) => {
				value = newValue;
				if(!self.blocked && version === self.currentVersion){
					self.block("key");
					
					var update = {};
					update[key] = newValue;
					row.updateData(update);
					
					self.unblock("key");
				}
				
				if(props.set){
					props.set(newValue);
				}
			},
			get:() => {
				
				if(props.get){
					props.get();
				}
				
				return value;
			}
		});
	}
	
	unwatchRow(row){
		var data = row.getData();
		
		for(var key in data){
			Object.defineProperty(data, key, {
				value:data[key],
			});
		}
	}
	
	block(key){
		if(!this.blocked){
			this.blocked = key;
		}
	}
	
	unblock(key){
		if(this.blocked === key){
			this.blocked = false;
		}
	}
}

ReactiveData.moduleName = "reactiveData";

class ResizeColumns extends Module{
	
	constructor(table){
		super(table);
		
		this.startColumn = false;
		this.startX = false;
		this.startWidth = false;
		this.latestX = false;
		this.handle = null;
		this.initialNextColumn = null;
		this.nextColumn = null;
		
		this.initialized = false;
		this.registerColumnOption("resizable", true);
		this.registerTableOption("resizableColumnFit", false);
	}
	
	initialize(){
		this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
	}
	
	initializeEventWatchers(){
		if(!this.initialized){
			
			this.subscribe("cell-rendered", this.layoutCellHandles.bind(this));
			this.subscribe("cell-delete", this.deInitializeComponent.bind(this));
			
			this.subscribe("cell-height", this.resizeHandle.bind(this));
			this.subscribe("column-moved", this.columnLayoutUpdated.bind(this));
			
			this.subscribe("column-hide", this.deInitializeColumn.bind(this));
			this.subscribe("column-show", this.columnLayoutUpdated.bind(this));
			this.subscribe("column-width", this.columnWidthUpdated.bind(this));
			
			this.subscribe("column-delete", this.deInitializeComponent.bind(this));
			this.subscribe("column-height", this.resizeHandle.bind(this));
			
			this.initialized = true;
		}
	}
	
	
	layoutCellHandles(cell){
		if(cell.row.type === "row"){
			this.deInitializeComponent(cell);
			this.initializeColumn("cell", cell, cell.column, cell.element);
		}
	}
	
	layoutColumnHeader(column){
		if(column.definition.resizable){
			this.initializeEventWatchers();
			this.deInitializeComponent(column);
			this.initializeColumn("header", column, column, column.element);
		}
	}
	
	columnLayoutUpdated(column){
		var prev = column.prevColumn();
		
		this.reinitializeColumn(column);
		
		if(prev){
			this.reinitializeColumn(prev);
		}
	}
	
	columnWidthUpdated(column){
		if(column.modules.frozen){
			if(this.table.modules.frozenColumns.leftColumns.includes(column)){
				this.table.modules.frozenColumns.leftColumns.forEach((col) => {
					this.reinitializeColumn(col);
				});
			}else if(this.table.modules.frozenColumns.rightColumns.includes(column)){
				this.table.modules.frozenColumns.rightColumns.forEach((col) => {
					this.reinitializeColumn(col);
				});
			}
		}
	}

	frozenColumnOffset(column){
		var offset = false;

		if(column.modules.frozen){
			offset = column.modules.frozen.marginValue; 

			if(column.modules.frozen.position === "left"){
				offset += column.getWidth() - 3;
			}else {
				if(offset){
					offset -= 3;
				}
			}
		}

		return offset !== false ? offset + "px" : false;
	}
	
	reinitializeColumn(column){
		var frozenOffset = this.frozenColumnOffset(column);
		
		column.cells.forEach((cell) => {
			if(cell.modules.resize && cell.modules.resize.handleEl){
				if(frozenOffset){
					cell.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
					cell.modules.resize.handleEl.style["z-index"] = 11;
				}
				
				cell.element.after(cell.modules.resize.handleEl);
			}
		});
		
		if(column.modules.resize && column.modules.resize.handleEl){
			if(frozenOffset){
				column.modules.resize.handleEl.style[column.modules.frozen.position] = frozenOffset;
			}
			
			column.element.after(column.modules.resize.handleEl);
		}
	}
	
	initializeColumn(type, component, column, element){
		var self = this,
		variableHeight = false,
		mode = column.definition.resizable,
		config = {},
		nearestColumn = column.getLastColumn();
		
		//set column resize mode
		if(type === "header"){
			variableHeight = column.definition.formatter == "textarea" || column.definition.variableHeight;
			config = {variableHeight:variableHeight};
		}
		
		if((mode === true || mode == type) && this._checkResizability(nearestColumn)){
			
			var handle = document.createElement('span');
			handle.className = "tabulator-col-resize-handle";
			
			handle.addEventListener("click", function(e){
				e.stopPropagation();
			});
			
			var handleDown = function(e){
				self.startColumn = column;
				self.initialNextColumn = self.nextColumn = nearestColumn.nextColumn();
				self._mouseDown(e, nearestColumn, handle);
			};
			
			handle.addEventListener("mousedown", handleDown);
			handle.addEventListener("touchstart", handleDown, {passive: true});
			
			//resize column on  double click
			handle.addEventListener("dblclick", (e) => {
				var oldWidth = nearestColumn.getWidth();
				
				e.stopPropagation();
				nearestColumn.reinitializeWidth(true);
				
				if(oldWidth !== nearestColumn.getWidth()){
					self.dispatch("column-resized", nearestColumn);
					self.table.externalEvents.dispatch("columnResized", nearestColumn.getComponent());
				}
			});
			
			if(column.modules.frozen){
				handle.style.position = "sticky";
				handle.style[column.modules.frozen.position] = this.frozenColumnOffset(column);
			}
			
			config.handleEl = handle;
			
			if(element.parentNode && column.visible){
				element.after(handle);			
			}
		}
		
		component.modules.resize = config;
	}
	
	deInitializeColumn(column){
		this.deInitializeComponent(column);
		
		column.cells.forEach((cell) => {
			this.deInitializeComponent(cell);
		});
	}
	
	deInitializeComponent(component){
		var handleEl;
		
		if(component.modules.resize){
			handleEl = component.modules.resize.handleEl;
			
			if(handleEl && handleEl.parentElement){
				handleEl.parentElement.removeChild(handleEl);
			}
		}
	}
	
	resizeHandle(component, height){
		if(component.modules.resize && component.modules.resize.handleEl){
			component.modules.resize.handleEl.style.height = height;
		}
	}
	
	_checkResizability(column){
		return column.definition.resizable;
	}
	
	_mouseDown(e, column, handle){
		var self = this;
		
		self.table.element.classList.add("tabulator-block-select");
		
		function mouseMove(e){
			var x = typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX,
			startDiff = x - self.startX,
			moveDiff = x - self.latestX,
			blockedBefore, blockedAfter;
			
			self.latestX = x;
			
			if(self.table.rtl){
				startDiff = -startDiff;
				moveDiff = -moveDiff;
			}
			
			blockedBefore = column.width == column.minWidth || column.width == column.maxWidth;
			
			column.setWidth(self.startWidth + startDiff);
			
			blockedAfter = column.width == column.minWidth || column.width == column.maxWidth;
			
			if(moveDiff < 0){
				self.nextColumn = self.initialNextColumn;
			}
			
			if(self.table.options.resizableColumnFit && self.nextColumn && !(blockedBefore && blockedAfter)){
				let colWidth = self.nextColumn.getWidth();
				
				if(moveDiff > 0){
					if(colWidth <= self.nextColumn.minWidth){
						self.nextColumn = self.nextColumn.nextColumn();
					}
				}
				
				if(self.nextColumn){
					self.nextColumn.setWidth(self.nextColumn.getWidth() - moveDiff);
				}
			}
			
			self.table.columnManager.rerenderColumns(true);
			
			if(!self.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight){
				column.checkCellHeights();
			}
		}
		
		function mouseUp(e){
			
			//block editor from taking action while resizing is taking place
			if(self.startColumn.modules.edit){
				self.startColumn.modules.edit.blocked = false;
			}
			
			if(self.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight){
				column.checkCellHeights();
			}
			
			document.body.removeEventListener("mouseup", mouseUp);
			document.body.removeEventListener("mousemove", mouseMove);
			
			handle.removeEventListener("touchmove", mouseMove);
			handle.removeEventListener("touchend", mouseUp);
			
			self.table.element.classList.remove("tabulator-block-select");
			
			if(self.startWidth !== column.getWidth()){
				self.table.columnManager.verticalAlignHeaders();

				self.dispatch("column-resized", column);
				self.table.externalEvents.dispatch("columnResized", column.getComponent());
			}
		}
		
		e.stopPropagation(); //prevent resize from interfering with movable columns
		
		//block editor from taking action while resizing is taking place
		if(self.startColumn.modules.edit){
			self.startColumn.modules.edit.blocked = true;
		}
		
		self.startX = typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX;
		self.latestX = self.startX;
		self.startWidth = column.getWidth();
		
		document.body.addEventListener("mousemove", mouseMove);
		document.body.addEventListener("mouseup", mouseUp);
		handle.addEventListener("touchmove", mouseMove, {passive: true});
		handle.addEventListener("touchend", mouseUp);
	}
}

ResizeColumns.moduleName = "resizeColumns";

class ResizeRows extends Module{

	constructor(table){
		super(table);

		this.startColumn = false;
		this.startY = false;
		this.startHeight = false;
		this.handle = null;
		this.prevHandle = null;

		this.registerTableOption("resizableRows", false); //resizable rows
	}

	initialize(){
		if(this.table.options.resizableRows){
			this.subscribe("row-layout-after", this.initializeRow.bind(this));
		}
	}

	initializeRow(row){
		var self = this,
		rowEl = row.getElement();

		var handle = document.createElement('div');
		handle.className = "tabulator-row-resize-handle";

		var prevHandle = document.createElement('div');
		prevHandle.className = "tabulator-row-resize-handle prev";

		handle.addEventListener("click", function(e){
			e.stopPropagation();
		});

		var handleDown = function(e){
			self.startRow = row;
			self._mouseDown(e, row, handle);
		};

		handle.addEventListener("mousedown", handleDown);
		handle.addEventListener("touchstart", handleDown, {passive: true});

		prevHandle.addEventListener("click", function(e){
			e.stopPropagation();
		});

		var prevHandleDown =  function(e){
			var prevRow = self.table.rowManager.prevDisplayRow(row);

			if(prevRow){
				self.startRow = prevRow;
				self._mouseDown(e, prevRow, prevHandle);
			}
		};

		prevHandle.addEventListener("mousedown",prevHandleDown);
		prevHandle.addEventListener("touchstart",prevHandleDown, {passive: true});

		rowEl.appendChild(handle);
		rowEl.appendChild(prevHandle);
	}

	_mouseDown(e, row, handle){
		var self = this;

		self.table.element.classList.add("tabulator-block-select");

		function mouseMove(e){
			row.setHeight(self.startHeight + ((typeof e.screenY === "undefined" ? e.touches[0].screenY : e.screenY) - self.startY));
		}

		function mouseUp(e){

			// //block editor from taking action while resizing is taking place
			// if(self.startColumn.modules.edit){
			// 	self.startColumn.modules.edit.blocked = false;
			// }

			document.body.removeEventListener("mouseup", mouseMove);
			document.body.removeEventListener("mousemove", mouseMove);

			handle.removeEventListener("touchmove", mouseMove);
			handle.removeEventListener("touchend", mouseUp);

			self.table.element.classList.remove("tabulator-block-select");

			self.dispatchExternal("rowResized", row.getComponent());
		}

		e.stopPropagation(); //prevent resize from interfering with movable columns

		//block editor from taking action while resizing is taking place
		// if(self.startColumn.modules.edit){
		// 	self.startColumn.modules.edit.blocked = true;
		// }

		self.startY = typeof e.screenY === "undefined" ? e.touches[0].screenY : e.screenY;
		self.startHeight = row.getHeight();

		document.body.addEventListener("mousemove", mouseMove);
		document.body.addEventListener("mouseup", mouseUp);

		handle.addEventListener("touchmove", mouseMove, {passive: true});
		handle.addEventListener("touchend", mouseUp);
	}
}

ResizeRows.moduleName = "resizeRows";

class ResizeTable extends Module{
	
	constructor(table){
		super(table);
		
		this.binding = false;
		this.visibilityObserver = false;
		this.resizeObserver = false;
		this.containerObserver = false;
		
		this.tableHeight = 0;
		this.tableWidth = 0;
		this.containerHeight = 0;
		this.containerWidth = 0;
		
		this.autoResize = false;
		
		this.visible = false;
		
		this.initialized = false;
		this.initialRedraw = false;
		
		this.registerTableOption("autoResize", true); //auto resize table
	}
	
	initialize(){
		if(this.table.options.autoResize){
			var table = this.table,
			tableStyle;
			
			this.tableHeight = table.element.clientHeight;
			this.tableWidth = table.element.clientWidth;
			
			if(table.element.parentNode){
				this.containerHeight = table.element.parentNode.clientHeight;
				this.containerWidth = table.element.parentNode.clientWidth;
			}
			
			if(typeof IntersectionObserver !== "undefined" && typeof ResizeObserver !== "undefined" && table.rowManager.getRenderMode() === "virtual"){
				
				this.initializeVisibilityObserver();
				
				this.autoResize = true;
				
				this.resizeObserver = new ResizeObserver((entry) => {
					if(!table.browserMobile || (table.browserMobile && (!table.modules.edit || (table.modules.edit && !table.modules.edit.currentCell)))){
						
						var nodeHeight = Math.floor(entry[0].contentRect.height);
						var nodeWidth = Math.floor(entry[0].contentRect.width);
						
						if(this.tableHeight != nodeHeight || this.tableWidth != nodeWidth){
							this.tableHeight = nodeHeight;
							this.tableWidth = nodeWidth;
							
							if(table.element.parentNode){
								this.containerHeight = table.element.parentNode.clientHeight;
								this.containerWidth = table.element.parentNode.clientWidth;
							}
							
							this.redrawTable();
						}
					}
				});
				
				this.resizeObserver.observe(table.element);
				
				tableStyle = window.getComputedStyle(table.element);
				
				if(this.table.element.parentNode && !this.table.rowManager.fixedHeight && (tableStyle.getPropertyValue("max-height") || tableStyle.getPropertyValue("min-height"))){
					
					this.containerObserver = new ResizeObserver((entry) => {
						if(!table.browserMobile || (table.browserMobile && (!table.modules.edit || (table.modules.edit && !table.modules.edit.currentCell)))){
							
							var nodeHeight = Math.floor(entry[0].contentRect.height);
							var nodeWidth = Math.floor(entry[0].contentRect.width);
							
							if(this.containerHeight != nodeHeight || this.containerWidth != nodeWidth){
								this.containerHeight = nodeHeight;
								this.containerWidth = nodeWidth;
								this.tableHeight = table.element.clientHeight;
								this.tableWidth = table.element.clientWidth;
							}
							
							this.redrawTable();
						}
					});
					
					this.containerObserver.observe(this.table.element.parentNode);
				}
				
				this.subscribe("table-resize", this.tableResized.bind(this));
				
			}else {
				this.binding = function(){
					if(!table.browserMobile || (table.browserMobile && (!table.modules.edit || (table.modules.edit && !table.modules.edit.currentCell)))){
						table.columnManager.rerenderColumns(true);
						table.redraw();
					}
				};
				
				window.addEventListener("resize", this.binding);
			}
			
			this.subscribe("table-destroy", this.clearBindings.bind(this));
		}
	}
	
	initializeVisibilityObserver(){
		this.visibilityObserver = new IntersectionObserver((entries) => {
			this.visible = entries[0].isIntersecting;
			
			if(!this.initialized){
				this.initialized = true;
				this.initialRedraw = !this.visible;
			}else {
				if(this.visible){
					this.redrawTable(this.initialRedraw);
					this.initialRedraw = false;
				}
			}
		});
		
		this.visibilityObserver.observe(this.table.element);
	}
	
	redrawTable(force){
		if(this.initialized && this.visible){
			this.table.columnManager.rerenderColumns(true);
			this.table.redraw(force);
		}
	}
	
	tableResized(){
		this.table.rowManager.redraw();
	}
	
	clearBindings(){
		if(this.binding){
			window.removeEventListener("resize", this.binding);
		}
		
		if(this.resizeObserver){
			this.resizeObserver.unobserve(this.table.element);
		}
		
		if(this.visibilityObserver){
			this.visibilityObserver.unobserve(this.table.element);
		}
		
		if(this.containerObserver){
			this.containerObserver.unobserve(this.table.element.parentNode);
		}
	}
}

ResizeTable.moduleName = "resizeTable";

class ResponsiveLayout extends Module{

	constructor(table){
		super(table);

		this.columns = [];
		this.hiddenColumns = [];
		this.mode = "";
		this.index = 0;
		this.collapseFormatter = [];
		this.collapseStartOpen = true;
		this.collapseHandleColumn = false;

		this.registerTableOption("responsiveLayout", false); //responsive layout flags
		this.registerTableOption("responsiveLayoutCollapseStartOpen", true); //start showing collapsed data
		this.registerTableOption("responsiveLayoutCollapseUseFormatters", true); //responsive layout collapse formatter
		this.registerTableOption("responsiveLayoutCollapseFormatter", false); //responsive layout collapse formatter

		this.registerColumnOption("responsive");
	}

	//generate responsive columns list
	initialize(){
		if(this.table.options.responsiveLayout){
			this.subscribe("column-layout", this.initializeColumn.bind(this));
			this.subscribe("column-show", this.updateColumnVisibility.bind(this));
			this.subscribe("column-hide", this.updateColumnVisibility.bind(this));
			this.subscribe("columns-loaded", this.initializeResponsivity.bind(this));
			this.subscribe("column-moved", this.initializeResponsivity.bind(this));
			this.subscribe("column-add", this.initializeResponsivity.bind(this));
			this.subscribe("column-delete", this.initializeResponsivity.bind(this));

			this.subscribe("table-redrawing", this.tableRedraw.bind(this));
			
			if(this.table.options.responsiveLayout === "collapse"){
				this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this));
				this.subscribe("row-init", this.initializeRow.bind(this));
				this.subscribe("row-layout", this.layoutRow.bind(this));
			}
		}
	}

	tableRedraw(force){
		if(["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1){
			if(!force){
				this.update();
			}
		}
	}

	initializeResponsivity(){
		var columns = [];

		this.mode = this.table.options.responsiveLayout;
		this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData;
		this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen;
		this.hiddenColumns = [];

		//determine level of responsivity for each column
		this.table.columnManager.columnsByIndex.forEach((column, i) => {
			if(column.modules.responsive){
				if(column.modules.responsive.order && column.modules.responsive.visible){
					column.modules.responsive.index = i;
					columns.push(column);

					if(!column.visible && this.mode === "collapse"){
						this.hiddenColumns.push(column);
					}
				}
			}
		});

		//sort list by responsivity
		columns = columns.reverse();
		columns = columns.sort((a, b) => {
			var diff = b.modules.responsive.order - a.modules.responsive.order;
			return diff || (b.modules.responsive.index - a.modules.responsive.index);
		});

		this.columns = columns;

		if(this.mode === "collapse"){
			this.generateCollapsedContent();
		}

		//assign collapse column
		for (let col of this.table.columnManager.columnsByIndex){
			if(col.definition.formatter == "responsiveCollapse"){
				this.collapseHandleColumn = col;
				break;
			}
		}

		if(this.collapseHandleColumn){
			if(this.hiddenColumns.length){
				this.collapseHandleColumn.show();
			}else {
				this.collapseHandleColumn.hide();
			}
		}
	}

	//define layout information
	initializeColumn(column){
		var def = column.getDefinition();

		column.modules.responsive = {order: typeof def.responsive === "undefined" ? 1 : def.responsive, visible:def.visible === false ? false : true};
	}

	initializeRow(row){
		var el;

		if(row.type !== "calc"){
			el = document.createElement("div");
			el.classList.add("tabulator-responsive-collapse");

			row.modules.responsiveLayout = {
				element:el,
				open:this.collapseStartOpen,
			};

			if(!this.collapseStartOpen){
				el.style.display = 'none';
			}
		}
	}

	layoutRow(row){
		var rowEl = row.getElement();

		if(row.modules.responsiveLayout){
			rowEl.appendChild(row.modules.responsiveLayout.element);
			this.generateCollapsedRowContent(row);
		}
	}

	//update column visibility
	updateColumnVisibility(column, responsiveToggle){
		if(!responsiveToggle && column.modules.responsive){
			column.modules.responsive.visible = column.visible;
			this.initializeResponsivity();
		}
	}

	hideColumn(column){
		var colCount = this.hiddenColumns.length;

		column.hide(false, true);

		if(this.mode === "collapse"){
			this.hiddenColumns.unshift(column);
			this.generateCollapsedContent();

			if(this.collapseHandleColumn && !colCount){
				this.collapseHandleColumn.show();
			}
		}
	}

	showColumn(column){
		var index;

		column.show(false, true);
		//set column width to prevent calculation loops on uninitialized columns
		column.setWidth(column.getWidth());

		if(this.mode === "collapse"){
			index = this.hiddenColumns.indexOf(column);

			if(index > -1){
				this.hiddenColumns.splice(index, 1);
			}

			this.generateCollapsedContent();

			if(this.collapseHandleColumn && !this.hiddenColumns.length){
				this.collapseHandleColumn.hide();
			}
		}
	}

	//redraw columns to fit space
	update(){
		var working = true;

		while(working){

			let width = this.table.modules.layout.getMode() == "fitColumns" ? this.table.columnManager.getFlexBaseWidth() : this.table.columnManager.getWidth();

			let diff = (this.table.options.headerVisible ? this.table.columnManager.element.clientWidth : this.table.element.clientWidth) - width;

			if(diff < 0){
				//table is too wide
				let column = this.columns[this.index];

				if(column){
					this.hideColumn(column);
					this.index ++;
				}else {
					working = false;
				}

			}else {

				//table has spare space
				let column = this.columns[this.index -1];

				if(column){
					if(diff > 0){
						if(diff >= column.getWidth()){
							this.showColumn(column);
							this.index --;
						}else {
							working = false;
						}
					}else {
						working = false;
					}
				}else {
					working = false;
				}
			}

			if(!this.table.rowManager.activeRowsCount){
				this.table.rowManager.renderEmptyScroll();
			}
		}
	}

	generateCollapsedContent(){
		var rows = this.table.rowManager.getDisplayRows();

		rows.forEach((row) => {
			this.generateCollapsedRowContent(row);
		});
	}

	generateCollapsedRowContent(row){
		var el, contents;

		if(row.modules.responsiveLayout){
			el = row.modules.responsiveLayout.element;

			while(el.firstChild) el.removeChild(el.firstChild);

			contents = this.collapseFormatter(this.generateCollapsedRowData(row));
			if(contents){
				el.appendChild(contents);
			}
		}
	}

	generateCollapsedRowData(row){
		var data = row.getData(),
		output = [],
		mockCellComponent;

		this.hiddenColumns.forEach((column) => {
			var value = column.getFieldValue(data);

			if(column.definition.title && column.field){
				if(column.modules.format && this.table.options.responsiveLayoutCollapseUseFormatters){

					mockCellComponent = {
						value:false,
						data:{},
						getValue:function(){
							return value;
						},
						getData:function(){
							return data;
						},
						getType:function(){
							return "cell";
						},
						getElement:function(){
							return document.createElement("div");
						},
						getRow:function(){
							return row.getComponent();
						},
						getColumn:function(){
							return column.getComponent();
						},
						getTable:() => {
							return this.table;
						},
					};

					function onRendered(callback){
						callback();
					}

					output.push({
						field: column.field,
						title: column.definition.title,
						value: column.modules.format.formatter.call(this.table.modules.format, mockCellComponent, column.modules.format.params, onRendered)
					});
				}else {
					output.push({
						field: column.field,
						title: column.definition.title,
						value: value
					});
				}
			}
		});

		return output;
	}

	formatCollapsedData(data){
		var list = document.createElement("table");

		data.forEach(function(item){
			var row = document.createElement("tr");
			var titleData = document.createElement("td");
			var valueData = document.createElement("td");
			var node_content;

			var titleHighlight = document.createElement("strong");
			titleData.appendChild(titleHighlight);
			this.langBind("columns|" + item.field, function(text){
				titleHighlight.innerHTML = text || item.title;
			});

			if(item.value instanceof Node){
				node_content = document.createElement("div");
				node_content.appendChild(item.value);
				valueData.appendChild(node_content);
			}else {
				valueData.innerHTML = item.value;
			}

			row.appendChild(titleData);
			row.appendChild(valueData);
			list.appendChild(row);
		}, this);

		return Object.keys(data).length ? list : "";
	}
}

ResponsiveLayout.moduleName = "responsiveLayout";

class SelectRow extends Module{
	
	constructor(table){
		super(table);
		
		this.selecting = false; //flag selecting in progress
		this.lastClickedRow = false; //last clicked row
		this.selectPrev = []; //hold previously selected element for drag drop selection
		this.selectedRows = []; //hold selected rows
		this.headerCheckboxElement = null; // hold header select element
		
		this.registerTableOption("selectableRows", "highlight"); //highlight rows on hover
		this.registerTableOption("selectableRowsRangeMode", "drag");  //highlight rows on hover
		this.registerTableOption("selectableRowsRollingSelection", true); //roll selection once maximum number of selectable rows is reached
		this.registerTableOption("selectableRowsPersistence", true); // maintain selection when table view is updated
		this.registerTableOption("selectableRowsCheck", function(data, row){return true;}); //check whether row is selectable
		
		this.registerTableFunction("selectRow", this.selectRows.bind(this));
		this.registerTableFunction("deselectRow", this.deselectRows.bind(this));
		this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this));
		this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this));
		this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this));
		
		//register component functions
		this.registerComponentFunction("row", "select", this.selectRows.bind(this));
		this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this));
		this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this));
		this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
	}
	
	initialize(){

		this.deprecatedOptionsCheck();

		if(this.table.options.selectableRows === "highlight" && this.table.options.selectableRange){
			this.table.options.selectableRows = false;
		}

		if(this.table.options.selectableRows !== false){
			this.subscribe("row-init", this.initializeRow.bind(this));
			this.subscribe("row-deleting", this.rowDeleted.bind(this));
			this.subscribe("rows-wipe", this.clearSelectionData.bind(this));
			this.subscribe("rows-retrieve", this.rowRetrieve.bind(this));
			
			if(this.table.options.selectableRows && !this.table.options.selectableRowsPersistence){
				this.subscribe("data-refreshing", this.deselectRows.bind(this));
			}
		}
	}

	deprecatedOptionsCheck(){
		this.deprecationCheck("selectable", "selectableRows", true);
		this.deprecationCheck("selectableRollingSelection", "selectableRowsRollingSelection", true);
		this.deprecationCheck("selectableRangeMode", "selectableRowsRangeMode", true);
		this.deprecationCheck("selectablePersistence", "selectableRowsPersistence", true);
		this.deprecationCheck("selectableCheck", "selectableRowsCheck", true);
	}
	
	rowRetrieve(type, prevValue){
		return type === "selected" ? this.selectedRows : prevValue;
	}
	
	rowDeleted(row){
		this._deselectRow(row, true);
	}
	
	clearSelectionData(silent){
		var prevSelected = this.selectedRows.length;

		this.selecting = false;
		this.lastClickedRow = false;
		this.selectPrev = [];
		this.selectedRows = [];
		
		if(prevSelected && silent !== true){
			this._rowSelectionChanged();
		}
	}
	
	initializeRow(row){
		var self = this,
		selectable = self.checkRowSelectability(row),
		element = row.getElement();
		
		// trigger end of row selection
		var endSelect = function(){
			
			setTimeout(function(){
				self.selecting = false;
			}, 50);
			
			document.body.removeEventListener("mouseup", endSelect);
		};
		
		row.modules.select = {selected:false};

		element.classList.toggle("tabulator-selectable", selectable);
		element.classList.toggle("tabulator-unselectable", !selectable);
		
		//set row selection class
		if(self.checkRowSelectability(row)){			
			if(self.table.options.selectableRows && self.table.options.selectableRows != "highlight"){
				if(self.table.options.selectableRowsRangeMode === "click"){
					element.addEventListener("click", this.handleComplexRowClick.bind(this, row));
				}else {
					element.addEventListener("click", function(e){
						if(!self.table.modExists("edit") || !self.table.modules.edit.getCurrentCell()){
							self.table._clearSelection();
						}
						
						if(!self.selecting){
							self.toggleRow(row);
						}
					});
					
					element.addEventListener("mousedown", function(e){
						if(e.shiftKey){
							self.table._clearSelection();
							
							self.selecting = true;
							
							self.selectPrev = [];
							
							document.body.addEventListener("mouseup", endSelect);
							document.body.addEventListener("keyup", endSelect);
							
							self.toggleRow(row);
							
							return false;
						}
					});
					
					element.addEventListener("mouseenter", function(e){
						if(self.selecting){
							self.table._clearSelection();
							self.toggleRow(row);
							
							if(self.selectPrev[1] == row){
								self.toggleRow(self.selectPrev[0]);
							}
						}
					});
					
					element.addEventListener("mouseout", function(e){
						if(self.selecting){
							self.table._clearSelection();
							self.selectPrev.unshift(row);
						}
					});
				}
			}
		}
	}
	
	handleComplexRowClick(row, e){
		if(e.shiftKey){
			this.table._clearSelection();
			this.lastClickedRow = this.lastClickedRow || row;
			
			var lastClickedRowIdx = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow);
			var rowIdx = this.table.rowManager.getDisplayRowIndex(row);
			
			var fromRowIdx = lastClickedRowIdx <= rowIdx ? lastClickedRowIdx : rowIdx;
			var toRowIdx = lastClickedRowIdx >= rowIdx ? lastClickedRowIdx : rowIdx;
			
			var rows = this.table.rowManager.getDisplayRows().slice(0);
			var toggledRows = rows.splice(fromRowIdx, toRowIdx - fromRowIdx + 1);
			
			if(e.ctrlKey || e.metaKey){
				toggledRows.forEach((toggledRow)=>{
					if(toggledRow !== this.lastClickedRow){
						
						if(this.table.options.selectableRows !== true && !this.isRowSelected(row)){
							if(this.selectedRows.length < this.table.options.selectableRows){
								this.toggleRow(toggledRow);
							}
						}else {
							this.toggleRow(toggledRow);
						}
					}
				});
				this.lastClickedRow = row;
			}else {
				this.deselectRows(undefined, true);
				
				if(this.table.options.selectableRows !== true){
					if(toggledRows.length > this.table.options.selectableRows){
						toggledRows = toggledRows.slice(0, this.table.options.selectableRows);
					}
				}
				
				this.selectRows(toggledRows);
			}
			this.table._clearSelection();
		}
		else if(e.ctrlKey || e.metaKey){
			this.toggleRow(row);
			this.lastClickedRow = row;
		}else {
			this.deselectRows(undefined, true);
			this.selectRows(row);
			this.lastClickedRow = row;
		}
	}

	checkRowSelectability(row){
		if(row && row.type === "row"){
			return this.table.options.selectableRowsCheck.call(this.table, row.getComponent());
		}

		return false;
	}
	
	//toggle row selection
	toggleRow(row){
		if(this.checkRowSelectability(row)){
			if(row.modules.select && row.modules.select.selected){
				this._deselectRow(row);
			}else {
				this._selectRow(row);
			}
		}
	}
	
	//select a number of rows
	selectRows(rows){
		var changes = [], 
		rowMatch, change;
		
		switch(typeof rows){
			case "undefined":
				rowMatch = this.table.rowManager.rows;
				break;
			
			case "number":
				rowMatch = this.table.rowManager.findRow(rows);
				break;
				
			case "string":
				rowMatch = this.table.rowManager.findRow(rows);
			
				if(!rowMatch){
					rowMatch = this.table.rowManager.getRows(rows);
				}
				break;
			
			default:
				rowMatch = rows;
				break;
		}

		if(Array.isArray(rowMatch)){
			if(rowMatch.length){
				rowMatch.forEach((row) => {
					change = this._selectRow(row, true, true);

					if(change){
						changes.push(change);
					}
				});

				this._rowSelectionChanged(false, changes);
			}
		}else {
			if(rowMatch){
				this._selectRow(rowMatch, false, true);
			}
		}	
	}
	
	//select an individual row
	_selectRow(rowInfo, silent, force){
		//handle max row count
		if(!isNaN(this.table.options.selectableRows) && this.table.options.selectableRows !== true && !force){
			if(this.selectedRows.length >= this.table.options.selectableRows){
				if(this.table.options.selectableRowsRollingSelection){
					this._deselectRow(this.selectedRows[0]);
				}else {
					return false;
				}
			}
		}
		
		var row = this.table.rowManager.findRow(rowInfo);
		
		if(row){
			if(this.selectedRows.indexOf(row) == -1){
				row.getElement().classList.add("tabulator-selected");
				if(!row.modules.select){
					row.modules.select = {};
				}
				
				row.modules.select.selected = true;
				if(row.modules.select.checkboxEl){
					row.modules.select.checkboxEl.checked = true;
				}
				
				this.selectedRows.push(row);
				
				if(this.table.options.dataTreeSelectPropagate){
					this.childRowSelection(row, true);
				}
				
				this.dispatchExternal("rowSelected", row.getComponent());
				
				this._rowSelectionChanged(silent, row);

				return row;
			}
		}else {
			if(!silent){
				console.warn("Selection Error - No such row found, ignoring selection:" + rowInfo);
			}
		}
	}
	
	isRowSelected(row){
		return this.selectedRows.indexOf(row) !== -1;
	}
	
	//deselect a number of rows
	deselectRows(rows, silent){
		var changes = [], 
		rowMatch, change;
		
		switch(typeof rows){
			case "undefined":
				rowMatch = Object.assign([], this.selectedRows);
				break;

			case "number":
				rowMatch = this.table.rowManager.findRow(rows);
				break;
			
			case "string":
				rowMatch = this.table.rowManager.findRow(rows);
			
				if(!rowMatch){
					rowMatch = this.table.rowManager.getRows(rows);
				}
				break;
			
			default:
				rowMatch = rows;
				break;
		}

		if(Array.isArray(rowMatch)){
			if(rowMatch.length){
				rowMatch.forEach((row) => {
					change = this._deselectRow(row, true, true);

					if(change){
						changes.push(change);
					}
				});

				this._rowSelectionChanged(silent, [], changes);
			}
		}else {
			if(rowMatch){
				this._deselectRow(rowMatch, silent, true);
			}
		}	
	}
	
	//deselect an individual row
	_deselectRow(rowInfo, silent){
		var self = this,
		row = self.table.rowManager.findRow(rowInfo),
		index, element;
		
		if(row){
			index = self.selectedRows.findIndex(function(selectedRow){
				return selectedRow == row;
			});
			
			if(index > -1){

				element = row.getElement();
				
				if(element){
					element.classList.remove("tabulator-selected");
				}
				
				if(!row.modules.select){
					row.modules.select = {};
				}
				
				row.modules.select.selected = false;
				if(row.modules.select.checkboxEl){
					row.modules.select.checkboxEl.checked = false;
				}
				self.selectedRows.splice(index, 1);
				
				if(this.table.options.dataTreeSelectPropagate){
					this.childRowSelection(row, false);
				}
				
				this.dispatchExternal("rowDeselected", row.getComponent());
				
				self._rowSelectionChanged(silent, undefined, row);

				return row;
			}
		}else {
			if(!silent){
				console.warn("Deselection Error - No such row found, ignoring selection:" + rowInfo);
			}
		}
	}
	
	getSelectedData(){
		var data = [];
		
		this.selectedRows.forEach(function(row){
			data.push(row.getData());
		});
		
		return data;
	}
	
	getSelectedRows(){
		var rows = [];
		
		this.selectedRows.forEach(function(row){
			rows.push(row.getComponent());
		});
		
		return rows;
	}
	
	_rowSelectionChanged(silent, selected = [], deselected = []){
		if(this.headerCheckboxElement){
			if(this.selectedRows.length === 0){
				this.headerCheckboxElement.checked = false;
				this.headerCheckboxElement.indeterminate = false;
			} else if(this.table.rowManager.rows.length === this.selectedRows.length){
				this.headerCheckboxElement.checked = true;
				this.headerCheckboxElement.indeterminate = false;
			} else {
				this.headerCheckboxElement.indeterminate = true;
				this.headerCheckboxElement.checked = false;
			}
		}
		
		if(!silent){
			if(!Array.isArray(selected)){
				selected = [selected];
			}

			selected = selected.map(row => row.getComponent());

			if(!Array.isArray(deselected)){
				deselected = [deselected];
			}

			deselected = deselected.map(row => row.getComponent());

			this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows(), selected, deselected);
		}
	}
	
	registerRowSelectCheckbox (row, element) {
		if(!row._row.modules.select){
			row._row.modules.select = {};
		}
		
		row._row.modules.select.checkboxEl = element;
	}
	
	registerHeaderSelectCheckbox (element) {
		this.headerCheckboxElement = element;
	}
	
	childRowSelection(row, select){
		var children = this.table.modules.dataTree.getChildren(row, true);
		
		if(select){
			for(let child of children){
				this._selectRow(child, true);
			}
		}else {
			for(let child of children){
				this._deselectRow(child, true);
			}
		}
	}
}

SelectRow.moduleName = "selectRow";

//sort numbers
function number$1(a, b, aRow, bRow, column, dir, params){
	var alignEmptyValues = params.alignEmptyValues;
	var decimal = params.decimalSeparator;
	var thousand = params.thousandSeparator;
	var emptyAlign = 0;

	a = String(a);
	b = String(b);

	if(thousand){
		a = a.split(thousand).join("");
		b = b.split(thousand).join("");
	}

	if(decimal){
		a = a.split(decimal).join(".");
		b = b.split(decimal).join(".");
	}

	a = parseFloat(a);
	b = parseFloat(b);

	//handle non numeric values
	if(isNaN(a)){
		emptyAlign =  isNaN(b) ? 0 : -1;
	}else if(isNaN(b)){
		emptyAlign =  1;
	}else {
		//compare valid values
		return a - b;
	}

	//fix empty values in position
	if((alignEmptyValues === "top" && dir === "desc") || (alignEmptyValues === "bottom" && dir === "asc")){
		emptyAlign *= -1;
	}

	return emptyAlign;
}

//sort strings
function string(a, b, aRow, bRow, column, dir, params){
	var alignEmptyValues = params.alignEmptyValues;
	var emptyAlign = 0;
	var locale;

	//handle empty values
	if(!a){
		emptyAlign =  !b ? 0 : -1;
	}else if(!b){
		emptyAlign =  1;
	}else {
		//compare valid values
		switch(typeof params.locale){
			case "boolean":
				if(params.locale){
					locale = this.langLocale();
				}
				break;
			case "string":
				locale = params.locale;
				break;
		}

		return String(a).toLowerCase().localeCompare(String(b).toLowerCase(), locale);
	}

	//fix empty values in position
	if((alignEmptyValues === "top" && dir === "desc") || (alignEmptyValues === "bottom" && dir === "asc")){
		emptyAlign *= -1;
	}

	return emptyAlign;
}

//sort datetime
function datetime$2(a, b, aRow, bRow, column, dir, params){
	var DT = window.DateTime || luxon.DateTime;
	var format = params.format || "dd/MM/yyyy HH:mm:ss",
	alignEmptyValues = params.alignEmptyValues,
	emptyAlign = 0;

	if(typeof DT != "undefined"){
		if(!DT.isDateTime(a)){
			if(format === "iso"){
				a = DT.fromISO(String(a));
			}else {
				a = DT.fromFormat(String(a), format);
			}
		}

		if(!DT.isDateTime(b)){
			if(format === "iso"){
				b = DT.fromISO(String(b));
			}else {
				b = DT.fromFormat(String(b), format);
			}
		}

		if(!a.isValid){
			emptyAlign = !b.isValid ? 0 : -1;
		}else if(!b.isValid){
			emptyAlign =  1;
		}else {
			//compare valid values
			return a - b;
		}

		//fix empty values in position
		if((alignEmptyValues === "top" && dir === "desc") || (alignEmptyValues === "bottom" && dir === "asc")){
			emptyAlign *= -1;
		}

		return emptyAlign;

	}else {
		console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
	}
}

//sort date
function date$1(a, b, aRow, bRow, column, dir, params){
	if(!params.format){
		params.format = "dd/MM/yyyy";
	}

	return datetime$2.call(this, a, b, aRow, bRow, column, dir, params);
}

//sort times
function time$1(a, b, aRow, bRow, column, dir, params){
	if(!params.format){
		params.format = "HH:mm";
	}

	return datetime$2.call(this, a, b, aRow, bRow, column, dir, params);
}

//sort booleans
function boolean(a, b, aRow, bRow, column, dir, params){
	var el1 = a === true || a === "true" || a === "True" || a === 1 ? 1 : 0;
	var el2 = b === true || b === "true" || b === "True" || b === 1 ? 1 : 0;

	return el1 - el2;
}

//sort if element contains any data
function array(a, b, aRow, bRow, column, dir, params){
	var type = params.type || "length",
	alignEmptyValues = params.alignEmptyValues,
	emptyAlign = 0;

	function calc(value){
		var result;

		switch(type){
			case "length":
				result = value.length;
				break;

			case "sum":
				result = value.reduce(function(c, d){
					return c + d;
				});
				break;

			case "max":
				result = Math.max.apply(null, value) ;
				break;

			case "min":
				result = Math.min.apply(null, value) ;
				break;

			case "avg":
				result = value.reduce(function(c, d){
					return c + d;
				}) / value.length;
				break;
		}

		return result;
	}

	//handle non array values
	if(!Array.isArray(a)){
		emptyAlign = !Array.isArray(b) ? 0 : -1;
	}else if(!Array.isArray(b)){
		emptyAlign = 1;
	}else {
		return calc(b) - calc(a);
	}

	//fix empty values in position
	if((alignEmptyValues === "top" && dir === "desc") || (alignEmptyValues === "bottom" && dir === "asc")){
		emptyAlign *= -1;
	}

	return emptyAlign;
}

//sort if element contains any data
function exists(a, b, aRow, bRow, column, dir, params){
	var el1 = typeof a == "undefined" ? 0 : 1;
	var el2 = typeof b == "undefined" ? 0 : 1;

	return el1 - el2;
}

//sort alpha numeric strings
function alphanum(as, bs, aRow, bRow, column, dir, params){
	var a, b, a1, b1, i= 0, L, rx = /(\d+)|(\D+)/g, rd = /\d/;
	var alignEmptyValues = params.alignEmptyValues;
	var emptyAlign = 0;

	//handle empty values
	if(!as && as!== 0){
		emptyAlign =  !bs && bs!== 0 ? 0 : -1;
	}else if(!bs && bs!== 0){
		emptyAlign =  1;
	}else {

		if(isFinite(as) && isFinite(bs)) return as - bs;
		a = String(as).toLowerCase();
		b = String(bs).toLowerCase();
		if(a === b) return 0;
		if(!(rd.test(a) && rd.test(b))) return a > b ? 1 : -1;
		a = a.match(rx);
		b = b.match(rx);
		L = a.length > b.length ? b.length : a.length;
		while(i < L){
			a1= a[i];
			b1= b[i++];
			if(a1 !== b1){
				if(isFinite(a1) && isFinite(b1)){
					if(a1.charAt(0) === "0") a1 = "." + a1;
					if(b1.charAt(0) === "0") b1 = "." + b1;
					return a1 - b1;
				}
				else return a1 > b1 ? 1 : -1;
			}
		}

		return a.length > b.length;
	}

	//fix empty values in position
	if((alignEmptyValues === "top" && dir === "desc") || (alignEmptyValues === "bottom" && dir === "asc")){
		emptyAlign *= -1;
	}

	return emptyAlign;
}

var defaultSorters = {
	number:number$1,
	string:string,
	date:date$1,
	time:time$1,
	datetime:datetime$2,
	boolean:boolean,
	array:array,
	exists:exists,
	alphanum:alphanum
};

class Sort extends Module{
	
	constructor(table){
		super(table);
		
		this.sortList = []; //holder current sort
		this.changed = false; //has the sort changed since last render
		
		this.registerTableOption("sortMode", "local"); //local or remote sorting
		
		this.registerTableOption("initialSort", false); //initial sorting criteria
		this.registerTableOption("columnHeaderSortMulti", true); //multiple or single column sorting
		this.registerTableOption("sortOrderReverse", false); //reverse internal sort ordering
		this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>"); //header sort element
		this.registerTableOption("headerSortClickElement", "header"); //element which triggers sort when clicked
		
		this.registerColumnOption("sorter");
		this.registerColumnOption("sorterParams");
		
		this.registerColumnOption("headerSort", true);
		this.registerColumnOption("headerSortStartingDir");
		this.registerColumnOption("headerSortTristate");
		
	}
	
	initialize(){
		this.subscribe("column-layout", this.initializeColumn.bind(this));
		this.subscribe("table-built", this.tableBuilt.bind(this));
		this.registerDataHandler(this.sort.bind(this), 20);
		
		this.registerTableFunction("setSort", this.userSetSort.bind(this));
		this.registerTableFunction("getSorters", this.getSort.bind(this));
		this.registerTableFunction("clearSort", this.clearSort.bind(this));
		
		if(this.table.options.sortMode === "remote"){
			this.subscribe("data-params", this.remoteSortParams.bind(this));
		}
	}
	
	tableBuilt(){
		if(this.table.options.initialSort){
			this.setSort(this.table.options.initialSort);
		}
	}
	
	remoteSortParams(data, config, silent, params){
		var sorters = this.getSort();
		
		sorters.forEach((item) => {
			delete item.column;
		});
		
		params.sort = sorters;
		
		return params;
	}
	
	
	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////
	
	userSetSort(sortList, dir){
		this.setSort(sortList, dir);
		// this.table.rowManager.sorterRefresh();
		this.refreshSort();
	}
	
	clearSort(){
		this.clear();
		// this.table.rowManager.sorterRefresh();
		this.refreshSort();
	}
	
	
	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////
	
	//initialize column header for sorting
	initializeColumn(column){
		var sorter = false,
		colEl,
		arrowEl;
		
		switch(typeof column.definition.sorter){
			case "string":
				if(Sort.sorters[column.definition.sorter]){
					sorter = Sort.sorters[column.definition.sorter];
				}else {
					console.warn("Sort Error - No such sorter found: ", column.definition.sorter);
				}
				break;
			
			case "function":
				sorter = column.definition.sorter;
				break;
		}
		
		column.modules.sort = {
			sorter:sorter, dir:"none",
			params:column.definition.sorterParams || {},
			startingDir:column.definition.headerSortStartingDir || "asc",
			tristate: column.definition.headerSortTristate,
		};
		
		if(column.definition.headerSort !== false){
			
			colEl = column.getElement();
			
			colEl.classList.add("tabulator-sortable");
			
			arrowEl = document.createElement("div");
			arrowEl.classList.add("tabulator-col-sorter");
			
			switch(this.table.options.headerSortClickElement){
				case "icon":
					arrowEl.classList.add("tabulator-col-sorter-element");
					break;
				case "header":
					colEl.classList.add("tabulator-col-sorter-element");
					break;
				default:
					colEl.classList.add("tabulator-col-sorter-element");
					break;
			}
			
			switch(this.table.options.headerSortElement){
				case "function":
				//do nothing
					break;
				
				case "object":
					arrowEl.appendChild(this.table.options.headerSortElement);
					break;
				
				default:
					arrowEl.innerHTML = this.table.options.headerSortElement;
			}
			
			//create sorter arrow
			column.titleHolderElement.appendChild(arrowEl);
			
			column.modules.sort.element = arrowEl;
			
			this.setColumnHeaderSortIcon(column, "none");
			
			if(this.table.options.headerSortClickElement === "icon"){
				arrowEl.addEventListener("mousedown", (e) => {
					e.stopPropagation();
				});
			}
			
			//sort on click
			(this.table.options.headerSortClickElement === "icon" ? arrowEl : colEl).addEventListener("click", (e) => {
				var dir = "",
				sorters=[],
				match = false;
				
				if(column.modules.sort){
					if(column.modules.sort.tristate){
						if(column.modules.sort.dir == "none"){
							dir = column.modules.sort.startingDir;
						}else {
							if(column.modules.sort.dir == column.modules.sort.startingDir){
								dir = column.modules.sort.dir == "asc" ? "desc" : "asc";
							}else {
								dir = "none";
							}
						}
					}else {
						switch(column.modules.sort.dir){
							case "asc":
								dir = "desc";
								break;
							
							case "desc":
								dir = "asc";
								break;
							
							default:
								dir = column.modules.sort.startingDir;
						}
					}
					
					if (this.table.options.columnHeaderSortMulti && (e.shiftKey || e.ctrlKey)) {
						sorters = this.getSort();
						
						match = sorters.findIndex((sorter) => {
							return sorter.field === column.getField();
						});
						
						if(match > -1){
							sorters[match].dir = dir;
							
							match = sorters.splice(match, 1)[0];
							if(dir != "none"){
								sorters.push(match);
							}
						}else {
							if(dir != "none"){
								sorters.push({column:column, dir:dir});
							}
						}
						
						//add to existing sort
						this.setSort(sorters);
					}else {
						if(dir == "none"){
							this.clear();
						}else {
							//sort by column only
							this.setSort(column, dir);
						}
						
					}
					
					// this.table.rowManager.sorterRefresh(!this.sortList.length);
					this.refreshSort();
				}
			});
		}
	}
	
	refreshSort(){
		if(this.table.options.sortMode === "remote"){
			this.reloadData(null, false, false);
		}else {
			this.refreshData(true);
		}
		
		//TODO - Persist left position of row manager
		// left = this.scrollLeft;
		// this.scrollHorizontal(left);
	}
	
	//check if the sorters have changed since last use
	hasChanged(){
		var changed = this.changed;
		this.changed = false;
		return changed;
	}
	
	//return current sorters
	getSort(){
		var self = this,
		sorters = [];
		
		self.sortList.forEach(function(item){
			if(item.column){
				sorters.push({column:item.column.getComponent(), field:item.column.getField(), dir:item.dir});
			}
		});
		
		return sorters;
	}
	
	//change sort list and trigger sort
	setSort(sortList, dir){
		var self = this,
		newSortList = [];
		
		if(!Array.isArray(sortList)){
			sortList = [{column: sortList, dir:dir}];
		}
		
		sortList.forEach(function(item){
			var column;
			
			column = self.table.columnManager.findColumn(item.column);
			
			if(column){
				item.column = column;
				newSortList.push(item);
				self.changed = true;
			}else {
				console.warn("Sort Warning - Sort field does not exist and is being ignored: ", item.column);
			}
			
		});
		
		self.sortList = newSortList;
		
		this.dispatch("sort-changed");
	}
	
	//clear sorters
	clear(){
		this.setSort([]);
	}
	
	//find appropriate sorter for column
	findSorter(column){
		var row = this.table.rowManager.activeRows[0],
		sorter = "string",
		field, value;
		
		if(row){
			row = row.getData();
			field = column.getField();
			
			if(field){
				
				value = column.getFieldValue(row);
				
				switch(typeof value){
					case "undefined":
						sorter = "string";
						break;
					
					case "boolean":
						sorter = "boolean";
						break;
					
					default:
						if(!isNaN(value) && value !== ""){
							sorter = "number";
						}else {
							if(value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)){
								sorter = "alphanum";
							}
						}
						break;
				}
			}
		}
		
		return Sort.sorters[sorter];
	}
	
	//work through sort list sorting data
	sort(data){
		var self = this,
		sortList = this.table.options.sortOrderReverse ? self.sortList.slice().reverse() : self.sortList,
		sortListActual = [],
		rowComponents = [];
		
		if(this.subscribedExternal("dataSorting")){
			this.dispatchExternal("dataSorting", self.getSort());
		}
		
		self.clearColumnHeaders();
		
		if(this.table.options.sortMode !== "remote"){
			
			//build list of valid sorters and trigger column specific callbacks before sort begins
			sortList.forEach(function(item, i){
				var sortObj;
				
				if(item.column){
					sortObj = item.column.modules.sort;
					
					if(sortObj){
						
						//if no sorter has been defined, take a guess
						if(!sortObj.sorter){
							sortObj.sorter = self.findSorter(item.column);
						}
						
						item.params = typeof sortObj.params === "function" ? sortObj.params(item.column.getComponent(), item.dir) : sortObj.params;
						
						sortListActual.push(item);
					}
					
					self.setColumnHeader(item.column, item.dir);
				}
			});
			
			//sort data
			if (sortListActual.length) {
				self._sortItems(data, sortListActual);
			}
			
		}else {
			sortList.forEach(function(item, i){
				self.setColumnHeader(item.column, item.dir);
			});
		}
		
		if(this.subscribedExternal("dataSorted")){
			data.forEach((row) => {
				rowComponents.push(row.getComponent());
			});
			
			this.dispatchExternal("dataSorted", self.getSort(), rowComponents);
		}
		
		return data;
	}
	
	//clear sort arrows on columns
	clearColumnHeaders(){
		this.table.columnManager.getRealColumns().forEach((column) => {
			if(column.modules.sort){
				column.modules.sort.dir = "none";
				column.getElement().setAttribute("aria-sort", "none");
				this.setColumnHeaderSortIcon(column, "none");
			}
		});
	}
	
	//set the column header sort direction
	setColumnHeader(column, dir){
		column.modules.sort.dir = dir;
		column.getElement().setAttribute("aria-sort", dir === "asc" ? "ascending" : "descending");
		this.setColumnHeaderSortIcon(column, dir);
	}
	
	setColumnHeaderSortIcon(column, dir){
		var sortEl = column.modules.sort.element,
		arrowEl;
		
		if(column.definition.headerSort && typeof this.table.options.headerSortElement === "function"){
			while(sortEl.firstChild) sortEl.removeChild(sortEl.firstChild);
			
			arrowEl = this.table.options.headerSortElement.call(this.table, column.getComponent(), dir);
			
			if(typeof arrowEl === "object"){
				sortEl.appendChild(arrowEl);
			}else {
				sortEl.innerHTML = arrowEl;
			}
		}
	}
	
	//sort each item in sort list
	_sortItems(data, sortList){
		var sorterCount = sortList.length - 1;
		
		data.sort((a, b) => {
			var result;
			
			for(var i = sorterCount; i>= 0; i--){
				let sortItem = sortList[i];
				
				result = this._sortRow(a, b, sortItem.column, sortItem.dir, sortItem.params);
				
				if(result !== 0){
					break;
				}
			}
			
			return result;
		});
	}
	
	//process individual rows for a sort function on active data
	_sortRow(a, b, column, dir, params){
		var el1Comp, el2Comp;
		
		//switch elements depending on search direction
		var el1 = dir == "asc" ? a : b;
		var el2 = dir == "asc" ? b : a;
		
		a = column.getFieldValue(el1.getData());
		b = column.getFieldValue(el2.getData());
		
		a = typeof a !== "undefined" ? a : "";
		b = typeof b !== "undefined" ? b : "";
		
		el1Comp = el1.getComponent();
		el2Comp = el2.getComponent();
		
		return column.modules.sort.sorter.call(this, a, b, el1Comp, el2Comp, column.getComponent(), dir, params);
	}
}

Sort.moduleName = "sort";

//load defaults
Sort.sorters = defaultSorters;

class RangeComponent {
	constructor(range) {
		this._range = range;

		return new Proxy(this, {
			get: function (target, name, receiver) {
				if (typeof target[name] !== "undefined") {
					return target[name];
				} else {
					return target._range.table.componentFunctionBinder.handle("range", target._range, name);
				}
			},
		});
	}

	getElement() {
		return this._range.element;
	}

	getData() {
		return this._range.getData();
	}

	getCells() {
		return this._range.getCells(true);
	}

	getStructuredCells() {
		return this._range.getStructuredCells();
	}

	getRows() {
		return this._range.getRows().map((row) => row.getComponent());
	}

	getColumns() {
		return this._range.getColumns().map((column) => column.getComponent());
	}
	
	getBounds() {
		return this._range.getBounds();
	}

	getTopEdge() {
		return this._range.top;
	}

	getBottomEdge() {
		return this._range.bottom;
	}

	getLeftEdge() {
		return this._range.left;
	}

	getRightEdge() {
		return this._range.right;
	}

	setBounds(start, end){
		if(this._range.destroyedGuard("setBounds")){
			this._range.setBounds(start ? start._cell : start, end ? end._cell : end);
		}
	}

	setStartBound(start){
		if(this._range.destroyedGuard("setStartBound")){
			this._range.setEndBound(start ? start._cell : start);
			this._range.rangeManager.layoutElement();
		}
	}

	setEndBound(end){
		if(this._range.destroyedGuard("setEndBound")){
			this._range.setEndBound(end ? end._cell : end);
			this._range.rangeManager.layoutElement();
		}
	}

	clearValues(){
		if(this._range.destroyedGuard("clearValues")){
			this._range.clearValues();
		}
	}

	remove(){
		if(this._range.destroyedGuard("remove")){
			this._range.destroy(true);
		}
	}
}

class Range extends CoreFeature{
	constructor(table, rangeManager, start, end) {
		super(table);
		
		this.rangeManager = rangeManager;
		this.element = null;
		this.initialized = false;
		this.initializing = {
			start:false,
			end:false,
		};
		this.destroyed = false;
		
		this.top = 0;
		this.bottom = 0;
		this.left = 0;
		this.right = 0;
		
		this.table = table;
		this.start = {row:0, col:0};
		this.end = {row:0, col:0};

		if(this.rangeManager.rowHeader){
			this.left = 1;
			this.right = 1;
			this.start.col = 1;
			this.end.col = 1;
		}
		
		this.initElement();
		
		setTimeout(() => {
			this.initBounds(start, end);
		});
	}
	
	initElement(){
		this.element = document.createElement("div");
		this.element.classList.add("tabulator-range");
	}
	
	initBounds(start, end){
		this._updateMinMax();
		
		if(start){
			this.setBounds(start, end || start);
		}
	}
	
	///////////////////////////////////
	///////   Boundary Setup    ///////
	///////////////////////////////////
	
	setStart(row, col) {
		if(this.start.row !== row || this.start.col !== col){
			this.start.row = row;
			this.start.col = col;
			
			this.initializing.start = true;
			this._updateMinMax();
		}
	}
	
	setEnd(row, col) {
		if(this.end.row !== row || this.end.col !== col){
			this.end.row = row;
			this.end.col = col;
			
			this.initializing.end = true;
			this._updateMinMax();
		}
	}
	
	setBounds(start, end, visibleRows){
		if(start){
			this.setStartBound(start);
		}
		
		this.setEndBound(end || start);
		this.rangeManager.layoutElement(visibleRows);
	}
	
	setStartBound(element){
		var row, col;
		
		if (element.type === "column") {
			if(this.rangeManager.columnSelection){
				this.setStart(0, element.getPosition() - 1);
			}
		}else {
			row = element.row.position - 1;
			col = element.column.getPosition() - 1;
			
			if (element.column === this.rangeManager.rowHeader) {
				this.setStart(row, 1);
			} else {
				this.setStart(row, col);
			}
		}
	}
	
	setEndBound(element){
		var rowsCount = this._getTableRows().length,
		row, col, isRowHeader;
		
		if (element.type === "column") {
			if(this.rangeManager.columnSelection){
				if (this.rangeManager.selecting === "column") {
					this.setEnd(rowsCount - 1, element.getPosition() - 1);
				} else if (this.rangeManager.selecting === "cell") {
					this.setEnd(0, element.getPosition() - 1);
				}
			}
		}else {
			row = element.row.position - 1;
			col = element.column.getPosition() - 1;
			isRowHeader = element.column === this.rangeManager.rowHeader;
			
			if (this.rangeManager.selecting === "row") {
				this.setEnd(row, this._getTableColumns().length - 1);
			} else if (this.rangeManager.selecting !== "row" && isRowHeader) {
				this.setEnd(row, 0);
			} else if (this.rangeManager.selecting === "column") {
				this.setEnd(rowsCount - 1, col);
			} else {
				this.setEnd(row, col);
			}
		}
	}
	
	_updateMinMax() {
		this.top = Math.min(this.start.row, this.end.row);
		this.bottom = Math.max(this.start.row, this.end.row);
		this.left = Math.min(this.start.col, this.end.col);
		this.right = Math.max(this.start.col, this.end.col);
		
		if(this.initialized){
			this.dispatchExternal("rangeChanged", this.getComponent());
		}else {
			if(this.initializing.start && this.initializing.end){
				this.initialized = true;
				this.dispatchExternal("rangeAdded", this.getComponent());
			}
		}
	}
	
	_getTableColumns() {
		return this.table.columnManager.getVisibleColumnsByIndex();
	}
	
	_getTableRows() {
		return this.table.rowManager.getDisplayRows();
	}
	
	///////////////////////////////////
	///////      Rendering      ///////
	///////////////////////////////////
	
	layout() {
		var _vDomTop = this.table.rowManager.renderer.vDomTop,
		_vDomBottom = this.table.rowManager.renderer.vDomBottom,
		_vDomLeft = this.table.columnManager.renderer.leftCol,
		_vDomRight = this.table.columnManager.renderer.rightCol,		
		top, bottom, left, right, topLeftCell, bottomRightCell;
		
		if (_vDomTop == null) {
			_vDomTop = 0;
		}
		
		if (_vDomBottom == null) {
			_vDomBottom = Infinity;
		}
		
		if (_vDomLeft == null) {
			_vDomLeft = 0;
		}
		
		if (_vDomRight == null) {
			_vDomRight = Infinity;
		}
		
		if (this.overlaps(_vDomLeft, _vDomTop, _vDomRight, _vDomBottom)) {
			top = Math.max(this.top, _vDomTop);
			bottom = Math.min(this.bottom, _vDomBottom);
			left = Math.max(this.left, _vDomLeft);
			right = Math.min(this.right, _vDomRight);
			
			topLeftCell = this.rangeManager.getCell(top, left);
			bottomRightCell = this.rangeManager.getCell(bottom, right);
			
			this.element.classList.add("tabulator-range-active");
			// this.element.classList.toggle("tabulator-range-active", this === this.rangeManager.activeRange);
			
			this.element.style.left = topLeftCell.row.getElement().offsetLeft + topLeftCell.getElement().offsetLeft + "px";
			this.element.style.top = topLeftCell.row.getElement().offsetTop + "px";
			this.element.style.width = bottomRightCell.getElement().offsetLeft + bottomRightCell.getElement().offsetWidth - topLeftCell.getElement().offsetLeft + "px";
			this.element.style.height = bottomRightCell.row.getElement().offsetTop + bottomRightCell.row.getElement().offsetHeight - topLeftCell.row.getElement().offsetTop + "px";
		}
	}
	
	atTopLeft(cell) {
		return cell.row.position - 1 === this.top && cell.column.getPosition() - 1 === this.left;
	}
	
	atBottomRight(cell) {
		return cell.row.position - 1 === this.bottom && cell.column.getPosition() - 1 === this.right;
	}
	
	occupies(cell) {
		return this.occupiesRow(cell.row) && this.occupiesColumn(cell.column);
	}
	
	occupiesRow(row) {
		return this.top <= row.position - 1 && row.position - 1 <= this.bottom;
	}
	
	occupiesColumn(col) {
		return this.left <= col.getPosition() - 1 && col.getPosition() - 1 <= this.right;
	}
	
	overlaps(left, top, right, bottom) {
		if ((this.left > right || left > this.right) || (this.top > bottom || top > this.bottom)){
			return false;
		}
		
		return true;
	}
	
	getData() {
		var data = [],
		rows = this.getRows(),
		columns = this.getColumns();
		
		rows.forEach((row) => {
			var rowData = row.getData(),
			result = {};
			
			columns.forEach((column) => {
				result[column.field] = rowData[column.field];
			});
			
			data.push(result);
		});
		
		return data;
	}
	
	getCells(structured, component) {
		var cells = [],
		rows = this.getRows(),
		columns = this.getColumns();
		
		if (structured) {
			cells = rows.map((row) => {
				var arr = [];
				
				row.getCells().forEach((cell) => {
					if (columns.includes(cell.column)) {
						arr.push(component ? cell.getComponent() : cell);
					}
				});
				
				return arr;
			});
		} else {
			rows.forEach((row) => {
				row.getCells().forEach((cell) => {
					if (columns.includes(cell.column)) {
						cells.push(component ? cell.getComponent() : cell);
					}
				});
			});
		}
		
		return cells;
	}
	
	getStructuredCells() {
		return this.getCells(true, true);
	}
	
	getRows() {
		return this._getTableRows().slice(this.top, this.bottom + 1);
	}
	
	getColumns() {
		return this._getTableColumns().slice(this.left, this.right + 1);
	}
	
	clearValues(){
		var cells = this.getCells();
		var clearValue = this.table.options.selectableRangeClearCellsValue;
		
		this.table.blockRedraw();
		
		cells.forEach((cell) => {
			cell.setValue(clearValue);
		});
		
		this.table.restoreRedraw();
		
	}
	
	getBounds(component){
		var cells = this.getCells(false, component),
		output = {
			start:null,
			end:null,
		};
		
		if(cells.length){
			output.start = cells[0];
			output.end = cells[cells.length - 1];
		}else {
			console.warn("No bounds defined on range");
		}
		
		return output;
	}
	
	getComponent() {
		if (!this.component) {
			this.component = new RangeComponent(this);
		}
		return this.component;
	}
	
	destroy(notify) {
		this.destroyed = true;
		
		this.element.remove();
		
		if(notify){
			this.rangeManager.rangeRemoved(this);
		}
		
		if(this.initialized){
			this.dispatchExternal("rangeRemoved", this.getComponent());
		}
	}
	
	destroyedGuard(func){
		if(this.destroyed){
			console.warn("You cannot call the "  + func + " function on a destroyed range");
		}
		
		return !this.destroyed;
	}
}

class SelectRange extends Module {
	constructor(table) {
		super(table);
		
		this.selecting = "cell";
		this.mousedown = false;
		this.ranges = [];
		this.overlay = null;
		this.rowHeader = null;
		this.layoutChangeTimeout = null;
		this.columnSelection = false;
		this.rowSelection = false;
		this.maxRanges = 0;
		this.activeRange = false;
		this.blockKeydown = false;
		
		this.keyDownEvent = this._handleKeyDown.bind(this);
		this.mouseUpEvent = this._handleMouseUp.bind(this);
		
		this.registerTableOption("selectableRange", false); //enable selectable range
		this.registerTableOption("selectableRangeColumns", false); //enable selectable range
		this.registerTableOption("selectableRangeRows", false); //enable selectable range
		this.registerTableOption("selectableRangeClearCells", false); //allow clearing of active range
		this.registerTableOption("selectableRangeClearCellsValue", undefined); //value for cleared active range

		this.registerTableFunction("getRangesData", this.getRangesData.bind(this));
		this.registerTableFunction("getRanges", this.getRanges.bind(this));
		this.registerTableFunction("addRange", this.addRangeFromComponent.bind(this));

		this.registerComponentFunction("cell", "getRanges", this.cellGetRanges.bind(this));
		this.registerComponentFunction("row", "getRanges", this.rowGetRanges.bind(this));
		this.registerComponentFunction("column", "getRanges", this.colGetRanges.bind(this));
	}
	
	///////////////////////////////////
	///////    Initialization   ///////
	///////////////////////////////////
	
	initialize() {
		if (this.options("selectableRange")) {		
			if(!this.options("selectableRows")){
				
				this.maxRanges = this.options("selectableRange");
				
				this.initializeTable();
				this.initializeWatchers();
			}else {
				console.warn("SelectRange functionality cannot be used in conjunction with row selection");
			}
		}
	}
	
	
	initializeTable() {		
		this.overlay = document.createElement("div");
		this.overlay.classList.add("tabulator-range-overlay");
		
		this.rangeContainer = document.createElement("div");
		this.rangeContainer.classList.add("tabulator-range-container");
		
		this.activeRangeCellElement = document.createElement("div");
		this.activeRangeCellElement.classList.add("tabulator-range-cell-active");
		
		this.overlay.appendChild(this.rangeContainer);
		this.overlay.appendChild(this.activeRangeCellElement);
		
		this.table.rowManager.element.addEventListener("keydown", this.keyDownEvent);
		
		this.resetRanges();
		
		this.table.rowManager.element.appendChild(this.overlay);
		this.table.columnManager.element.setAttribute("tabindex", 0);
		this.table.element.classList.add("tabulator-ranges");
	}
	
	initializeWatchers() {
		this.columnSelection = this.options("selectableRangeColumns");
		this.rowSelection = this.options("selectableRangeRows");
		
		this.subscribe("column-init", this.initializeColumn.bind(this));
		this.subscribe("column-mousedown", this.handleColumnMouseDown.bind(this));
		this.subscribe("column-mousemove", this.handleColumnMouseMove.bind(this));
		this.subscribe("column-resized", this.handleColumnResized.bind(this));
		this.subscribe("column-width", this.layoutChange.bind(this));
		this.subscribe("column-height", this.layoutChange.bind(this));
		this.subscribe("column-resized", this.layoutChange.bind(this));
		this.subscribe("columns-loaded", this.updateHeaderColumn.bind(this));

		this.subscribe("cell-height", this.layoutChange.bind(this));
		this.subscribe("cell-rendered", this.renderCell.bind(this));
		this.subscribe("cell-mousedown", this.handleCellMouseDown.bind(this));
		this.subscribe("cell-mousemove", this.handleCellMouseMove.bind(this));
		this.subscribe("cell-click", this.handleCellClick.bind(this));
		this.subscribe("cell-editing", this.handleEditingCell.bind(this));
		
		this.subscribe("page-changed", this.redraw.bind(this));

		this.subscribe("scroll-vertical", this.layoutChange.bind(this));
		this.subscribe("scroll-horizontal", this.layoutChange.bind(this));
		
		this.subscribe("data-destroy", this.tableDestroyed.bind(this));
		this.subscribe("data-processed", this.resetRanges.bind(this));
		
		this.subscribe("table-layout", this.layoutElement.bind(this));
		this.subscribe("table-redraw", this.redraw.bind(this));
		this.subscribe("table-destroy", this.tableDestroyed.bind(this));
		
		this.subscribe("edit-editor-clear", this.finishEditingCell.bind(this));
		this.subscribe("edit-blur", this.restoreFocus.bind(this));
		
		this.subscribe("keybinding-nav-prev", this.keyNavigate.bind(this, "left"));
		this.subscribe("keybinding-nav-next", this.keyNavigate.bind(this, "right"));
		this.subscribe("keybinding-nav-left", this.keyNavigate.bind(this, "left"));
		this.subscribe("keybinding-nav-right", this.keyNavigate.bind(this, "right"));
		this.subscribe("keybinding-nav-up", this.keyNavigate.bind(this, "up"));
		this.subscribe("keybinding-nav-down", this.keyNavigate.bind(this, "down"));
		this.subscribe("keybinding-nav-range", this.keyNavigateRange.bind(this));
	}
	
	
	initializeColumn(column) {
		if(this.columnSelection && column.definition.headerSort && this.options("headerSortClickElement") !== "icon"){
			console.warn("Using column headerSort with selectableRangeColumns option may result in unpredictable behavior. Consider using headerSortClickElement: 'icon'.");
		}
		
		if (column.modules.edit) ;
	}
	
	updateHeaderColumn(){
		if(this.rowSelection){
			this.rowHeader = this.table.columnManager.getVisibleColumnsByIndex()[0];
			
			if(this.rowHeader){
				this.rowHeader.definition.cssClass = this.rowHeader.definition.cssClass + " tabulator-range-row-header";
				
				if(this.rowHeader.definition.headerSort){
					console.warn("Using column headerSort with selectableRangeRows option may result in unpredictable behavior");
				}
				
				if(this.rowHeader.definition.editor){
					console.warn("Using column editor with selectableRangeRows option may result in unpredictable behavior");
				}
			}
		}
	}
	
	///////////////////////////////////
	///////   Table Functions   ///////
	///////////////////////////////////
	
	getRanges(){
		return this.ranges.map((range) => range.getComponent());
	}
	
	getRangesData() {
		return this.ranges.map((range) => range.getData());
	}
	
	addRangeFromComponent(start, end){
		start = start ? start._cell : null;
		end = end ? end._cell : null;
		
		return this.addRange(start, end);
	}
	
	///////////////////////////////////
	/////// Component Functions ///////
	///////////////////////////////////
	
	cellGetRanges(cell){
		var ranges = [];
		
		if (cell.column === this.rowHeader) {
			ranges = this.ranges.filter((range) => range.occupiesRow(cell.row));
		} else {
			ranges = this.ranges.filter((range) => range.occupies(cell));
		}
		
		return ranges.map((range) => range.getComponent());
	}
	
	rowGetRanges(row){
		var ranges = this.ranges.filter((range) => range.occupiesRow(row));
		
		return ranges.map((range) => range.getComponent());
	}
	
	colGetRanges(col){
		var ranges = this.ranges.filter((range) => range.occupiesColumn(col));
		
		return ranges.map((range) => range.getComponent());
	}
	
	///////////////////////////////////
	////////// Event Handlers /////////
	///////////////////////////////////
	
	_handleMouseUp(e){
		this.mousedown = false;
		document.removeEventListener("mouseup", this.mouseUpEvent);
	}
	
	_handleKeyDown(e) {
		if (!this.blockKeydown && (!this.table.modules.edit || (this.table.modules.edit && !this.table.modules.edit.currentCell))) {
			if (e.key === "Enter") {
				// is editing a cell?
				if (this.table.modules.edit && this.table.modules.edit.currentCell) {
					return;
				}

				this.table.modules.edit.editCell(this.getActiveCell());
				
				e.preventDefault();
			}

			if ((e.key === "Backspace" || e.key === "Delete") && this.options("selectableRangeClearCells")) {
				if(this.activeRange){
					this.activeRange.clearValues();
				}
			}
		}
	}
	
	initializeFocus(cell){
		var range;
		
		try{
			if (document.selection) { // IE
				range = document.body.createTextRange();
				range.moveToElementText(cell.getElement());
				range.select();
			} else if (window.getSelection) {
				range = document.createRange();
				range.selectNode(cell.getElement());
				window.getSelection().removeAllRanges();
				window.getSelection().addRange(range);
			}
		}catch(e){}
	}
	
	restoreFocus(element){
		this.table.rowManager.element.focus();
		
		return true;
	}
	
	///////////////////////////////////
	////// Column Functionality ///////
	///////////////////////////////////
	
	handleColumnResized(column) {
		var selected;
		
		if (this.selecting !== "column" && this.selecting !== "all") {
			return;
		}
		
		selected = this.ranges.some((range) => range.occupiesColumn(column));
		
		if (!selected) {
			return;
		}
		
		this.ranges.forEach((range) => {
			var selectedColumns = range.getColumns(true);
			
			selectedColumns.forEach((selectedColumn) => {
				if (selectedColumn !== column) {
					selectedColumn.setWidth(column.width);
				}
			});
		});
	}
	
	handleColumnMouseDown(event, column) {
		if (event.button === 2 && (this.selecting === "column" || this.selecting === "all") && this.activeRange.occupiesColumn(column)) {
			return;
		}
		
		this.mousedown = true;
		
		document.addEventListener("mouseup", this.mouseUpEvent);
		
		this.newSelection(event, column);
	}
	
	handleColumnMouseMove(e, column) {
		if (column === this.rowHeader || !this.mousedown || this.selecting === 'all') {
			return;
		}
		
		this.activeRange.setBounds(false, column, true);
	}
	
	///////////////////////////////////
	//////// Cell Functionality ///////
	///////////////////////////////////
	
	renderCell(cell) {
		var el = cell.getElement(),
		rangeIdx = this.ranges.findIndex((range) => range.occupies(cell));
		
		el.classList.toggle("tabulator-range-selected", rangeIdx !== -1);
		el.classList.toggle("tabulator-range-only-cell-selected", this.ranges.length === 1 && this.ranges[0].atTopLeft(cell) &&	this.ranges[0].atBottomRight(cell));
		
		el.dataset.range = rangeIdx;
	}
	
	handleCellMouseDown(event, cell) {
		if (event.button === 2 && (this.activeRange.occupies(cell) || ((this.selecting === "row" || this.selecting === "all") && this.activeRange.occupiesRow(cell.row)))) {
			return;
		}
		
		this.mousedown = true;
		
		document.addEventListener("mouseup", this.mouseUpEvent);
		
		this.newSelection(event, cell);
	}
	
	handleCellMouseMove(e, cell) {
		if (!this.mousedown || this.selecting === "all") {
			return;
		}
		
		this.activeRange.setBounds(false, cell, true);
	}
	
	handleCellClick(e, cell){
		this.initializeFocus(cell);
	}
	
	handleEditingCell(cell) {
		if(this.activeRange){
			this.activeRange.setBounds(cell);
		}
	}
	
	finishEditingCell() {
		this.blockKeydown = true;
		this.table.rowManager.element.focus();

		setTimeout(() => {
			this.blockKeydown = false;
		}, 10);
	}
	
	///////////////////////////////////
	///////     Navigation      ///////
	///////////////////////////////////
	
	keyNavigate(dir, e){
		if(this.navigate(false, false, dir)){
			e.preventDefault();
		}
	}
	
	keyNavigateRange(e, dir, jump, expand){
		if(this.navigate(jump, expand, dir)){
			e.preventDefault();
		}
	}
	
	navigate(jump, expand, dir) {
		var moved = false,
		range, rangeEdge, nextRow, nextCol, row, column;
		
		// Don't navigate while editing
		if (this.table.modules.edit && this.table.modules.edit.currentCell) {
			return false;
		}
		
		// If there are more than 1 range, use the active range and destroy the others
		if (this.ranges.length > 1) {
			this.ranges = this.ranges.filter((range) => {
				if (range === this.activeRange) {
					range.setEnd(range.start.row, range.start.col);
					return true;
				}
				range.destroy();
				return false;
			});
		}
		
		range = this.activeRange;
		
		rangeEdge = expand ? range.end : range.start;
		nextRow = rangeEdge.row;
		nextCol = rangeEdge.col;
		
		if(jump){
			switch(dir){
				case "left":
					nextCol = this.findJumpCellLeft(range.start.row, rangeEdge.col);
					break;
				case "right":
					nextCol = this.findJumpCellRight(range.start.row, rangeEdge.col);
					break;
				case "up":
					nextRow = this.findJumpCellUp(rangeEdge.row, range.start.col);
					break;
				case "down":
					nextRow = this.findJumpCellDown(rangeEdge.row, range.start.col);
					break;
			}
		}else {
			if(expand){
				if ((this.selecting === 'row' && (dir === 'left' || dir === 'right')) || (this.selecting === 'column' && (dir === 'up' || dir === 'down'))) {
					return;
				}
			}
			
			switch(dir){
				case "left":
					nextCol = Math.max(nextCol - 1, 0);
					break;
				case "right":
					nextCol = Math.min(nextCol + 1, this.getTableColumns().length - 1);
					break;
				case "up":
					nextRow = Math.max(nextRow - 1, 0);
					break;
				case "down":
					nextRow = Math.min(nextRow + 1, this.getTableRows().length - 1);
					break;
			}
		}
		
		moved = nextCol !== rangeEdge.col || nextRow !== rangeEdge.row;
		
		if(!expand){
			range.setStart(nextRow, nextCol);
		}
		
		range.setEnd(nextRow, nextCol);
		
		if(!expand){
			this.selecting = "cell";
		}
		
		if (moved) {
			row = this.getRowByRangePos(range.end.row);
			column = this.getColumnByRangePos(range.end.col);
			
			if ((dir === 'left' || dir === 'right') && column.getElement().parentNode === null) {
				column.getComponent().scrollTo(undefined, false);
			} else if ((dir === 'up' || dir === 'down') && row.getElement().parentNode === null) {
				row.getComponent().scrollTo(undefined, false);
			} else {
				// Use faster autoScroll when the elements are on the DOM
				this.autoScroll(range, row.getElement(), column.getElement());
			}
			
			this.layoutElement();
			
			return true;
		}
	}
	
	rangeRemoved(removed){
		this.ranges = this.ranges.filter((range) => range !== removed);
		
		if(this.activeRange === removed){
			if(this.ranges.length){
				this.activeRange = this.ranges[this.ranges.length - 1];
			}else {
				this.addRange();
			}
		}
		
		this.layoutElement();
	}
	
	findJumpCell(cells, reverse, emptyStart, emptySide){
		var nextCell;
		
		if(reverse){
			cells = cells.reverse();
		}
		
		for(let currentCell of cells){
			let currentValue = currentCell.getValue();
			
			if(emptyStart){
				nextCell = currentCell;
				if(currentValue){
					break;
				}
			}else {
				if(emptySide){
					nextCell = currentCell;
					
					if(currentValue){
						break;
					}
				}else {
					if(currentValue){
						nextCell = currentCell;
					}else {
						break;
					}
				}
			}
		}
		
		return nextCell;
	}
	
	findJumpCellLeft(rowPos, colPos){
		var row = this.getRowByRangePos(rowPos),
		cells = row.cells.filter((cell) => cell.column.visible),
		isStartingCellEmpty = !cells[colPos].getValue(),
		isLeftOfStartingCellEmpty = cells[colPos] ? !cells[colPos].getValue() : false,
		jumpCol = colPos,
		targetCells = this.rowHeader ? cells.slice(1, colPos) : cells.slice(0, colPos),
		nextCell = this.findJumpCell(targetCells, true, isStartingCellEmpty, isLeftOfStartingCellEmpty);
		
		if(nextCell){
			jumpCol = nextCell.column.getPosition() - 1;
		}
		
		return jumpCol;
	}
	
	findJumpCellRight(rowPos, colPos){
		var row = this.getRowByRangePos(rowPos),
		cells = row.cells.filter((cell) => cell.column.visible),
		isStartingCellEmpty = !cells[colPos].getValue(),
		isRightOfStartingCellEmpty = cells[colPos + 1] ? !cells[colPos + 1].getValue() : false,
		jumpCol = colPos,
		nextCell = this.findJumpCell(cells.slice(colPos + 1, cells.length), false, isStartingCellEmpty, isRightOfStartingCellEmpty);
		
		if(nextCell){
			jumpCol = nextCell.column.getPosition() - 1;
		}
		
		return jumpCol;
	}
	
	findJumpCellUp(rowPos, colPos) {
		var column = this.getColumnByRangePos(colPos),
		cells = column.cells.filter((cell) => this.table.rowManager.activeRows.includes(cell.row)),
		isStartingCellEmpty = !cells[rowPos].getValue(),
		isTopOfStartingCellEmpty = cells[rowPos - 1] ? !cells[rowPos - 1].getValue() : false,
		jumpRow = rowPos,
		nextCell = this.findJumpCell(cells.slice(0, jumpRow), true, isStartingCellEmpty, isTopOfStartingCellEmpty);
		
		if(nextCell){
			jumpRow = nextCell.row.position - 1;
		}
		
		return jumpRow;
	}
	
	findJumpCellDown(rowPos, colPos) {
		var column = this.getColumnByRangePos(colPos),
		cells = column.cells.filter((cell) => this.table.rowManager.activeRows.includes(cell.row)),
		isStartingCellEmpty = !cells[rowPos].getValue(),
		isBottomOfStartingCellEmpty = cells[rowPos + 1] ? !cells[rowPos + 1].getValue() : false,
		jumpRow = rowPos,
		nextCell = this.findJumpCell(cells.slice(jumpRow + 1, cells.length), false, isStartingCellEmpty, isBottomOfStartingCellEmpty);
		
		if(nextCell){
			jumpRow = nextCell.row.position - 1;
		}
		
		return jumpRow;
	}
	
	///////////////////////////////////
	///////      Selection      ///////
	///////////////////////////////////
	newSelection(event, element) {
		var range;
		
		if (element.type === "column") {
			if(!this.columnSelection){
				return;
			}
			
			if (element === this.rowHeader) {
				range = this.resetRanges();
				this.selecting = "all";
				
				var topLeftCell, bottomRightCell = this.getCell(-1, -1);

				if(this.rowHeader){
					topLeftCell = this.getCell(0, 1);
				}else {
					topLeftCell = this.getCell(0, 0);
				}
				
				range.setBounds(topLeftCell, bottomRightCell);		
				return;
			} else {
				this.selecting = "column";
			}
		} else if (element.column === this.rowHeader) {
			this.selecting = "row";
		} else {
			this.selecting = "cell";
		}
		
		if (event.shiftKey) {
			this.activeRange.setBounds(false, element);
		} else if (event.ctrlKey) {
			this.addRange().setBounds(element);
		} else {
			this.resetRanges().setBounds(element);
		}
	}
	
	autoScroll(range, row, column) {
		var tableHolder = this.table.rowManager.element,
		rowHeader, rect, view, withinHorizontalView, withinVerticalView;

		if (typeof row === 'undefined') {
			row = this.getRowByRangePos(range.end.row).getElement();
		}
		
		if (typeof column === 'undefined') {
			column = this.getColumnByRangePos(range.end.col).getElement();
		}

		if (this.rowHeader) {
			rowHeader = this.rowHeader.getElement();
		}
		
		rect = {
			left: column.offsetLeft,
			right: column.offsetLeft + column.offsetWidth,
			top: row.offsetTop,
			bottom: row.offsetTop + row.offsetHeight,
		};
		
		view = {
			left: tableHolder.scrollLeft,
			right: Math.ceil(tableHolder.scrollLeft + tableHolder.clientWidth),
			top: tableHolder.scrollTop,
			bottom:	tableHolder.scrollTop +	tableHolder.offsetHeight - this.table.rowManager.scrollbarWidth,
		};

		if (rowHeader) {
			view.left += rowHeader.offsetWidth;
		}
		
		withinHorizontalView = view.left < rect.left &&	rect.left < view.right && view.left < rect.right &&	rect.right < view.right;
		
		withinVerticalView = view.top < rect.top &&	rect.top < view.bottom && view.top < rect.bottom &&	rect.bottom < view.bottom;
		
		if (!withinHorizontalView) {
			if (rect.left < view.left) {
				tableHolder.scrollLeft = rect.left;
				if (rowHeader) {
					tableHolder.scrollLeft -= rowHeader.offsetWidth;
				}
			} else if (rect.right > view.right) {
				tableHolder.scrollLeft = rect.right - tableHolder.clientWidth;
			}
		}
		
		if (!withinVerticalView) {
			if (rect.top < view.top) {
				tableHolder.scrollTop = rect.top;
			} else if (rect.bottom > view.bottom) {
				tableHolder.scrollTop = rect.bottom - tableHolder.clientHeight;
			}
		}
	}
	
	
	///////////////////////////////////
	///////       Layout        ///////
	///////////////////////////////////
	
	layoutChange(){
		this.overlay.style.visibility = "hidden";
		clearTimeout(this.layoutChangeTimeout);
		this.layoutChangeTimeout = setTimeout(this.layoutRanges.bind(this), 200);
	}
	
	redraw(force) {
		if (force) {
			this.selecting = 'cell';
			this.resetRanges();
			this.layoutElement();
		}
	}
	
	layoutElement(visibleRows) {
		var rows;
		
		if (visibleRows) {
			rows = this.table.rowManager.getVisibleRows(true);
		} else {
			rows = this.table.rowManager.getRows();
		}
		
		rows.forEach((row) => {
			if (row.type === "row") {
				this.layoutRow(row);
				row.cells.forEach((cell) => this.renderCell(cell));
			}
		});
		
		this.getTableColumns().forEach((column) => {
			this.layoutColumn(column);
		});
		
		this.layoutRanges();
	}
	
	layoutRow(row) {
		var el = row.getElement(),
		selected = false,
		occupied = this.ranges.some((range) => range.occupiesRow(row));
		
		if (this.selecting === "row") {
			selected = occupied;
		} else if (this.selecting === "all") {
			selected = true;
		}
		
		el.classList.toggle("tabulator-range-selected", selected);
		el.classList.toggle("tabulator-range-highlight", occupied);
	}
	
	layoutColumn(column) {
		var el = column.getElement(),		
		selected = false,
		occupied = this.ranges.some((range) => range.occupiesColumn(column));
		
		if (this.selecting === "column") {
			selected = occupied;
		} else if (this.selecting === "all") {
			selected = true;
		}
		
		el.classList.toggle("tabulator-range-selected", selected);
		el.classList.toggle("tabulator-range-highlight", occupied);
	}
	
	layoutRanges() {
		var activeCell;
		
		if (!this.table.initialized) {
			return;
		}
		
		activeCell = this.getActiveCell();
		
		if (!activeCell) {
			return;
		}
		
		this.activeRangeCellElement.style.left = activeCell.row.getElement().offsetLeft + activeCell.getElement().offsetLeft + "px";
		this.activeRangeCellElement.style.top =	activeCell.row.getElement().offsetTop + "px";
		this.activeRangeCellElement.style.width = activeCell.getElement().offsetLeft + activeCell.getElement().offsetWidth - activeCell.getElement().offsetLeft + "px";
		this.activeRangeCellElement.style.height = activeCell.row.getElement().offsetTop + activeCell.row.getElement().offsetHeight - activeCell.row.getElement().offsetTop + "px";
		
		this.ranges.forEach((range) => range.layout());
		
		this.overlay.style.visibility = "visible";
	}
	
	
	///////////////////////////////////
	///////  Helper Functions   ///////
	///////////////////////////////////	
	
	getCell(rowIdx, colIdx) {
		var row;
		
		if (colIdx < 0) {
			colIdx = this.getTableColumns().length + colIdx;
			if (colIdx < 0) {
				return null;
			}
		}
		
		if (rowIdx < 0) {
			rowIdx = this.getTableRows().length + rowIdx;
		}
		
		row = this.table.rowManager.getRowFromPosition(rowIdx + 1);
		
		return row ? row.getCells(false, true).filter((cell) => cell.column.visible)[colIdx] : null;
	}
	
	
	getActiveCell() {
		return this.getCell(this.activeRange.start.row, this.activeRange.start.col);
	}
	
	getRowByRangePos(pos) {
		return this.getTableRows()[pos];
	}
	
	getColumnByRangePos(pos) {
		return this.getTableColumns()[pos];
	}
	
	getTableRows() {
		return this.table.rowManager.getDisplayRows();
	}
	
	getTableColumns() {
		return this.table.columnManager.getVisibleColumnsByIndex();
	}
	
	addRange(start, end) {
		var  range;
		
		if(this.maxRanges !== true && this.ranges.length >= this.maxRanges){
			this.ranges.shift().destroy();
		}
		
		range = new Range(this.table, this, start, end);
		
		this.activeRange = range;
		this.ranges.push(range);
		this.rangeContainer.appendChild(range.element);
		
		return range;
	}
	
	resetRanges() {
		var range, cell;
		
		this.ranges.forEach((range) => range.destroy());
		this.ranges = [];
		
		range = this.addRange();
		
		if(this.table.rowManager.activeRows.length){
			cell = this.table.rowManager.activeRows[0].cells[this.rowHeader ? 1 : 0];

			if(cell){
				range.setBounds(cell);
				this.initializeFocus(cell);
			}
		}
		
		return range;
	}
	
	tableDestroyed(){
		document.removeEventListener("mouseup", this.mouseUpEvent);
		this.table.rowManager.element.removeEventListener("keydown", this.keyDownEvent);
	}
	
	selectedRows(component) {
		return component ? this.activeRange.getRows().map((row) => row.getComponent()) : this.activeRange.getRows();
	}
	
	selectedColumns(component) {
		return component ? this.activeRange.getColumns().map((col) => col.getComponent()) : this.activeRange.getColumns();
	}
}

SelectRange.moduleName = "selectRange";

class Tooltip extends Module{
	
	constructor(table){
		super(table);
		
		this.tooltipSubscriber = null,
		this.headerSubscriber = null,
		
		this.timeout = null;
		this.popupInstance = null;
		
		this.registerTableOption("tooltipGenerationMode", undefined);  //deprecated
		this.registerTableOption("tooltipDelay", 300); 
		
		this.registerColumnOption("tooltip");
		this.registerColumnOption("headerTooltip");
	}
	
	initialize(){
		this.deprecatedOptionsCheck();
		
		this.subscribe("column-init", this.initializeColumn.bind(this));
	}
	
	deprecatedOptionsCheck(){
		this.deprecationCheckMsg("tooltipGenerationMode", "This option is no longer needed as tooltips are always generated on hover now");
	}	
	
	initializeColumn(column){
		if(column.definition.headerTooltip && !this.headerSubscriber){
			this.headerSubscriber = true;
			
			this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip"));
			this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"));
		}
		
		if(column.definition.tooltip && !this.tooltipSubscriber){
			this.tooltipSubscriber = true;
			
			this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip"));
			this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip"));
		}
	}
	
	mousemoveCheck(action, e, component){
		var tooltip = action === "tooltip" ? component.column.definition.tooltip : component.definition.headerTooltip;
		
		if(tooltip){
			this.clearPopup();
			this.timeout = setTimeout(this.loadTooltip.bind(this, e, component, tooltip), this.table.options.tooltipDelay);
		}
	}

	mouseoutCheck(action, e, component){
		if(!this.popupInstance){
			this.clearPopup();
		}
	}
	
	clearPopup(action, e, component){
		clearTimeout(this.timeout);
		this.timeout = null;
		
		if(this.popupInstance){
			this.popupInstance.hide();
		}
	}
	
	loadTooltip(e, component, tooltip){
		var contentsEl, renderedCallback, coords;

		function onRendered(callback){
			renderedCallback = callback;
		}
		
		if(typeof tooltip === "function"){
			tooltip = tooltip(e, component.getComponent(), onRendered);
		}
		
		if(tooltip instanceof HTMLElement){
			contentsEl = tooltip;
		}else {
			contentsEl = document.createElement("div");
			
			if(tooltip === true){
				if(component instanceof Cell){
					tooltip = component.value;
				}else {
					if(component.definition.field){
						this.langBind("columns|" + component.definition.field, (value) => {
							contentsEl.innerHTML = tooltip = value || component.definition.title;
						});
					}else {
						tooltip = component.definition.title;
					}
				}
			}
			
			contentsEl.innerHTML = tooltip;
		}
		
		if(tooltip || tooltip === 0 || tooltip === false){
			contentsEl.classList.add("tabulator-tooltip");

			contentsEl.addEventListener("mousemove", e => e.preventDefault());
			
			this.popupInstance = this.popup(contentsEl);
			
			if(typeof renderedCallback === "function"){
				this.popupInstance.renderCallback(renderedCallback);
			}

			coords = this.popupInstance.containerEventCoords(e);
			
			this.popupInstance.show(coords.x + 15, coords.y + 15).hideOnBlur(() => {
				this.dispatchExternal("TooltipClosed", component.getComponent());
				this.popupInstance = null;
			});
			
			this.dispatchExternal("TooltipOpened", component.getComponent());
		}
	}
}

Tooltip.moduleName = "tooltip";

var defaultValidators = {
	//is integer
	integer: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}

		value = Number(value);

		return !isNaN(value) && isFinite(value) && Math.floor(value) === value;
	},

	//is float
	float: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		
		value = Number(value);

		return !isNaN(value) && isFinite(value) && value % 1 !== 0;
	},

	//must be a number
	numeric: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return !isNaN(value);
	},

	//must be a string
	string: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return isNaN(value);
	},

	//must be alphanumeric
	alphanumeric: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}

		var reg = new RegExp(/^[a-z0-9]+$/i);

		return reg.test(value);
	},

	//maximum value
	max: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return parseFloat(value) <= parameters;
	},

	//minimum value
	min: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return parseFloat(value) >= parameters;
	},

	//starts with  value
	starts: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return String(value).toLowerCase().startsWith(String(parameters).toLowerCase());
	},

	//ends with  value
	ends: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return String(value).toLowerCase().endsWith(String(parameters).toLowerCase());
	},


	//minimum string length
	minLength: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return String(value).length >= parameters;
	},

	//maximum string length
	maxLength: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		return String(value).length <= parameters;
	},

	//in provided value list
	in: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}

		if(typeof parameters == "string"){
			parameters = parameters.split("|");
		}

		return parameters.indexOf(value) > -1;
	},

	//must match provided regex
	regex: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		var reg = new RegExp(parameters);

		return reg.test(value);
	},

	//value must be unique in this column
	unique: function(cell, value, parameters){
		if(value === "" || value === null || typeof value === "undefined"){
			return true;
		}
		var unique = true;

		var cellData = cell.getData();
		var column = cell.getColumn()._getSelf();

		this.table.rowManager.rows.forEach(function(row){
			var data = row.getData();

			if(data !== cellData){
				if(value == column.getFieldValue(data)){
					unique = false;
				}
			}
		});

		return unique;
	},

	//must have a value
	required:function(cell, value, parameters){
		return value !== "" && value !== null && typeof value !== "undefined";
	},
};

class Validate extends Module{
	
	constructor(table){
		super(table);
		
		this.invalidCells = [];
		
		this.registerTableOption("validationMode", "blocking");
		
		this.registerColumnOption("validator");
		
		this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this));
		this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this));
		this.registerTableFunction("validate", this.userValidate.bind(this));
		
		this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this));
		this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this));
		this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this));
		
		this.registerComponentFunction("column", "validate", this.columnValidate.bind(this));
		this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
	}
	
	
	initialize(){
		this.subscribe("cell-delete", this.clearValidation.bind(this));
		this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
		
		this.subscribe("edit-success", this.editValidate.bind(this));
		this.subscribe("edit-editor-clear", this.editorClear.bind(this));
		this.subscribe("edit-edited-clear", this.editedClear.bind(this));
	}
	
	///////////////////////////////////
	///////// Event Handling //////////
	///////////////////////////////////
	
	editValidate(cell, value, previousValue){
		var valid = this.table.options.validationMode !== "manual" ? this.validate(cell.column.modules.validate, cell, value) : true;
		
		// allow time for editor to make render changes then style cell
		if(valid !== true){
			setTimeout(() => {
				cell.getElement().classList.add("tabulator-validation-fail");
				this.dispatchExternal("validationFailed", cell.getComponent(), value, valid);
			});
		}
		
		return valid;
	}
	
	editorClear(cell, cancelled){
		if(cancelled){
			if(cell.column.modules.validate){
				this.cellValidate(cell);
			}
		}

		cell.getElement().classList.remove("tabulator-validation-fail");
	}
	
	editedClear(cell){
		if(cell.modules.validate){
			cell.modules.validate.invalid = false;
		}
	}
	
	///////////////////////////////////
	////////// Cell Functions /////////
	///////////////////////////////////
	
	cellIsValid(cell){
		return cell.modules.validate ? (cell.modules.validate.invalid || true) : true;
	}
	
	cellValidate(cell){
		return this.validate(cell.column.modules.validate, cell, cell.getValue());
	}
	
	///////////////////////////////////
	///////// Column Functions ////////
	///////////////////////////////////
	
	columnValidate(column){
		var invalid = [];
		
		column.cells.forEach((cell) => {
			if(this.cellValidate(cell) !== true){
				invalid.push(cell.getComponent());
			}
		});
		
		return invalid.length ? invalid : true;
	}
	
	///////////////////////////////////
	////////// Row Functions //////////
	///////////////////////////////////
	
	rowValidate(row){
		var invalid = [];
		
		row.cells.forEach((cell) => {
			if(this.cellValidate(cell) !== true){
				invalid.push(cell.getComponent());
			}
		});
		
		return invalid.length ? invalid : true;
	}
	
	///////////////////////////////////
	///////// Table Functions /////////
	///////////////////////////////////
	
	
	userClearCellValidation(cells){
		if(!cells){
			cells = this.getInvalidCells();
		}
		
		if(!Array.isArray(cells)){
			cells = [cells];
		}
		
		cells.forEach((cell) => {
			this.clearValidation(cell._getSelf());
		});
	}
	
	userValidate(cells){
		var output = [];
		
		//clear row data
		this.table.rowManager.rows.forEach((row) => {
			row = row.getComponent();
			
			var valid = row.validate();
			
			if(valid !== true){
				output = output.concat(valid);
			}
		});
		
		return output.length ? output : true;
	}
	
	///////////////////////////////////
	///////// Internal Logic //////////
	///////////////////////////////////
	
	initializeColumnCheck(column){
		if(typeof column.definition.validator !== "undefined"){
			this.initializeColumn(column);
		}
	}
	
	//validate
	initializeColumn(column){
		var self = this,
		config = [],
		validator;
		
		if(column.definition.validator){
			
			if(Array.isArray(column.definition.validator)){
				column.definition.validator.forEach((item) => {
					validator = self._extractValidator(item);
					
					if(validator){
						config.push(validator);
					}
				});
				
			}else {
				validator = this._extractValidator(column.definition.validator);
				
				if(validator){
					config.push(validator);
				}
			}
			
			column.modules.validate = config.length ? config : false;
		}
	}
	
	_extractValidator(value){
		var type, params, pos;
		
		switch(typeof value){
			case "string":
				pos = value.indexOf(':');
			
				if(pos > -1){
					type = value.substring(0,pos);
					params = value.substring(pos+1);
				}else {
					type = value;
				}
			
				return this._buildValidator(type, params);
			
			case "function":
				return this._buildValidator(value);
			
			case "object":
				return this._buildValidator(value.type, value.parameters);
		}
	}
	
	_buildValidator(type, params){
		
		var func = typeof type == "function" ? type : Validate.validators[type];
		
		if(!func){
			console.warn("Validator Setup Error - No matching validator found:", type);
			return false;
		}else {
			return {
				type:typeof type == "function" ? "function" : type,
				func:func,
				params:params,
			};
		}
	}
	
	validate(validators, cell, value){
		var self = this,
		failedValidators = [],
		invalidIndex = this.invalidCells.indexOf(cell);
		
		if(validators){
			validators.forEach((item) => {
				if(!item.func.call(self, cell.getComponent(), value, item.params)){
					failedValidators.push({
						type:item.type,
						parameters:item.params
					});
				}
			});
		}
		
		if(!cell.modules.validate){
			cell.modules.validate = {};
		}
		
		if(!failedValidators.length){
			cell.modules.validate.invalid = false;
			cell.getElement().classList.remove("tabulator-validation-fail");
			
			if(invalidIndex > -1){
				this.invalidCells.splice(invalidIndex, 1);
			}
		}else {
			cell.modules.validate.invalid = failedValidators;
			
			if(this.table.options.validationMode !== "manual"){
				cell.getElement().classList.add("tabulator-validation-fail");
			}
			
			if(invalidIndex == -1){
				this.invalidCells.push(cell);
			}
		}
		
		return failedValidators.length ? failedValidators : true;
	}
	
	getInvalidCells(){
		var output = [];
		
		this.invalidCells.forEach((cell) => {
			output.push(cell.getComponent());
		});
		
		return output;
	}
	
	clearValidation(cell){
		var invalidIndex;
		
		if(cell.modules.validate && cell.modules.validate.invalid){
			
			cell.getElement().classList.remove("tabulator-validation-fail");
			cell.modules.validate.invalid = false;
			
			invalidIndex = this.invalidCells.indexOf(cell);
			
			if(invalidIndex > -1){
				this.invalidCells.splice(invalidIndex, 1);
			}
		}
	}
}

Validate.moduleName = "validate";

//load defaults
Validate.validators = defaultValidators;

var modules = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AccessorModule: Accessor,
	AjaxModule: Ajax,
	ClipboardModule: Clipboard,
	ColumnCalcsModule: ColumnCalcs,
	DataTreeModule: DataTree,
	DownloadModule: Download,
	EditModule: Edit$1,
	ExportModule: Export,
	FilterModule: Filter,
	FormatModule: Format,
	FrozenColumnsModule: FrozenColumns,
	FrozenRowsModule: FrozenRows,
	GroupRowsModule: GroupRows,
	HistoryModule: History,
	HtmlTableImportModule: HtmlTableImport,
	ImportModule: Import,
	InteractionModule: Interaction,
	KeybindingsModule: Keybindings,
	MenuModule: Menu,
	MoveColumnsModule: MoveColumns,
	MoveRowsModule: MoveRows,
	MutatorModule: Mutator,
	PageModule: Page,
	PersistenceModule: Persistence,
	PopupModule: Popup$1,
	PrintModule: Print,
	ReactiveDataModule: ReactiveData,
	ResizeColumnsModule: ResizeColumns,
	ResizeRowsModule: ResizeRows,
	ResizeTableModule: ResizeTable,
	ResponsiveLayoutModule: ResponsiveLayout,
	SelectRowModule: SelectRow,
	SortModule: Sort,
	SelectRangeModule: SelectRange,
	TooltipModule: Tooltip,
	ValidateModule: Validate
});

var defaultOptions = {

	debugEventsExternal:false, //flag to console log events
	debugEventsInternal:false, //flag to console log events
	debugInvalidOptions:true, //allow toggling of invalid option warnings
	debugInvalidComponentFuncs:true, //allow toggling of invalid component warnings
	debugInitialization:true, //allow toggling of pre initialization function call warnings
	debugDeprecation:true, //allow toggling of deprecation warnings

	height:false, //height of tabulator
	minHeight:false, //minimum height of tabulator
	maxHeight:false, //maximum height of tabulator

	columnHeaderVertAlign:"top", //vertical alignment of column headers

	popupContainer:false,

	columns:[],//store for colum header info
	columnDefaults:{}, //store column default props

	data:false, //default starting data

	autoColumns:false, //build columns from data row structure
	autoColumnsDefinitions:false,

	nestedFieldSeparator:".", //separator for nested data

	footerElement:false, //hold footer element

	index:"id", //filed for row index

	textDirection:"auto",

	addRowPos:"bottom", //position to insert blank rows, top|bottom

	headerVisible:true, //hide header

	renderVertical:"virtual",
	renderHorizontal:"basic",
	renderVerticalBuffer:0, // set virtual DOM buffer size

	scrollToRowPosition:"top",
	scrollToRowIfVisible:true,

	scrollToColumnPosition:"left",
	scrollToColumnIfVisible:true,

	rowFormatter:false,
	rowFormatterPrint:null,
	rowFormatterClipboard:null,
	rowFormatterHtmlOutput:null,

	rowHeight:null,

	placeholder:false,

	dataLoader:true,
	dataLoaderLoading:false,
	dataLoaderError:false,
	dataLoaderErrorTimeout:3000,

	dataSendParams:{},

	dataReceiveParams:{},
};

class OptionsList {
	constructor(table, msgType, defaults = {}){
		this.table = table;
		this.msgType = msgType;
		this.registeredDefaults = Object.assign({}, defaults);
	}
	
	register(option, value){
		this.registeredDefaults[option] = value;
	}
	
	generate(defaultOptions, userOptions = {}){
		var output = Object.assign({}, this.registeredDefaults),
		warn = this.table.options.debugInvalidOptions || userOptions.debugInvalidOptions === true;
		
		Object.assign(output, defaultOptions);
		
		for (let key in userOptions){
			if(!output.hasOwnProperty(key)){
				if(warn){
					console.warn("Invalid " + this.msgType + " option:", key);
				}

				output[key] = userOptions.key;
			}
		}
	
		
		for (let key in output){
			if(key in userOptions){
				output[key] = userOptions[key];
			}else {
				if(Array.isArray(output[key])){
					output[key] = Object.assign([], output[key]);
				}else if(typeof output[key] === "object" && output[key] !== null){
					output[key] = Object.assign({}, output[key]);
				}else if (typeof output[key] === "undefined"){
					delete output[key];
				}
			}
		}
		
		return output;
	}
}

class Renderer extends CoreFeature{
	constructor(table){
		super(table);

		this.elementVertical = table.rowManager.element;
		this.elementHorizontal = table.columnManager.element;
		this.tableElement =  table.rowManager.tableElement;

		this.verticalFillMode = "fit"; // used by row manager to determine how to size the render area ("fit" - fits container to the contents, "fill" - fills the container without resizing it)
	}


	///////////////////////////////////
	/////// Internal Bindings /////////
	///////////////////////////////////

	initialize(){
		//initialize core functionality
	}

	clearRows(){
		//clear down existing rows layout
	}

	clearColumns(){
		//clear down existing columns layout
	}


	reinitializeColumnWidths(columns){
		//resize columns to fit data
	}


	renderRows(){
		//render rows from a clean slate
	}

	renderColumns(){
		//render columns from a clean slate
	}

	rerenderRows(callback){
		// rerender rows and keep position
		if(callback){
			callback();
		}
	}

	rerenderColumns(update, blockRedraw){
		//rerender columns
	}

	renderRowCells(row){
		//render the cells in a row
	}

	rerenderRowCells(row, force){
		//rerender the cells in a row
	}

	scrollColumns(left, dir){
		//handle horizontal scrolling
	}

	scrollRows(top, dir){
		//handle vertical scrolling
	}

	resize(){
		//container has resized, carry out any needed recalculations (DO NOT RERENDER IN THIS FUNCTION)
	}

	scrollToRow(row){
		//scroll to a specific row
	}

	scrollToRowNearestTop(row){
		//determine weather the row is nearest the top or bottom of the table, return true for top or false for bottom
	}

	visibleRows(includingBuffer){
		//return the visible rows
		return [];
	}

	///////////////////////////////////
	//////// Helper Functions /////////
	///////////////////////////////////

	rows(){
		return this.table.rowManager.getDisplayRows();
	}

	styleRow(row, index){
		var rowEl = row.getElement();

		if(index % 2){
			rowEl.classList.add("tabulator-row-even");
			rowEl.classList.remove("tabulator-row-odd");
		}else {
			rowEl.classList.add("tabulator-row-odd");
			rowEl.classList.remove("tabulator-row-even");
		}
	}

	///////////////////////////////////
	/////// External Triggers /////////
	/////// (DO NOT OVERRIDE) /////////
	///////////////////////////////////

	clear(){
		//clear down existing layout
		this.clearRows();
		this.clearColumns();
	}

	render(){
		//render from a clean slate
		this.renderRows();
		this.renderColumns();
	}

	rerender(callback){
		// rerender and keep position
		this.rerenderRows();
		this.rerenderColumns();
	}

	scrollToRowPosition(row, position, ifVisible){
		var rowIndex = this.rows().indexOf(row),
		rowEl = row.getElement(),
		offset = 0;

		return new Promise((resolve, reject) => {
			if(rowIndex > -1){

				if(typeof ifVisible === "undefined"){
					ifVisible = this.table.options.scrollToRowIfVisible;
				}

				//check row visibility
				if(!ifVisible){
					if(Helpers.elVisible(rowEl)){
						offset = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top;
						
						if(offset > 0 && offset < this.elementVertical.clientHeight - rowEl.offsetHeight){
							resolve();
							return false;
						}
					}
				}

				if(typeof position === "undefined"){
					position = this.table.options.scrollToRowPosition;
				}

				if(position === "nearest"){
					position = this.scrollToRowNearestTop(row) ? "top" : "bottom";
				}

				//scroll to row
				this.scrollToRow(row);

				//align to correct position
				switch(position){
					case "middle":
					case "center":

						if(this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight){
							this.elementVertical.scrollTop = this.elementVertical.scrollTop + (rowEl.offsetTop - this.elementVertical.scrollTop) - ((this.elementVertical.scrollHeight - rowEl.offsetTop) / 2);
						}else {
							this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.clientHeight / 2);
						}

						break;

					case "bottom":

						if(this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight){
							this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - rowEl.offsetTop) + rowEl.offsetHeight;
						}else {
							this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + rowEl.offsetHeight;
						}

						break;

					case "top":
						this.elementVertical.scrollTop = rowEl.offsetTop;					
						break;
				}

				resolve();

			}else {
				console.warn("Scroll Error - Row not visible");
				reject("Scroll Error - Row not visible");
			}
		});
	}
}

class BasicHorizontal extends Renderer{
	constructor(table){
		super(table);
	}
	
	renderRowCells(row, inFragment) {
		const rowFrag = document.createDocumentFragment();
		row.cells.forEach((cell) => {
			rowFrag.appendChild(cell.getElement());
		});
		row.element.appendChild(rowFrag);
		
		if(!inFragment){
			row.cells.forEach((cell) => {
				cell.cellRendered();
			});
		}
	}
	
	reinitializeColumnWidths(columns){
		columns.forEach(function(column){
			column.reinitializeWidth();
		});
	}
}

class VirtualDomHorizontal extends Renderer{
	constructor(table){
		super(table);
		
		this.leftCol = 0;
		this.rightCol = 0;
		this.scrollLeft = 0;
		
		this.vDomScrollPosLeft = 0;
		this.vDomScrollPosRight = 0;
		
		this.vDomPadLeft = 0;
		this.vDomPadRight = 0;
		
		this.fitDataColAvg = 0;
		
		this.windowBuffer = 200; //pixel margin to make column visible before it is shown on screen
		
		this.visibleRows = null;
		
		this.initialized = false;
		this.isFitData = false;
		
		this.columns = [];
	}
	
	initialize(){
		this.compatibilityCheck();
		this.layoutCheck();
		this.vertScrollListen();
	}
	
	compatibilityCheck(){		
		if(this.options("layout") == "fitDataTable"){
			console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode");
		}
		
		if(this.options("responsiveLayout")){
			console.warn("Horizontal Virtual DOM is not compatible with responsive columns");
		}
		
		if(this.options("rtl")){
			console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
		}
	}
	
	layoutCheck(){
		this.isFitData = this.options("layout").startsWith('fitData');
	}
	
	vertScrollListen(){
		this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this));
		this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
	}
	
	clearVisRowCache(){
		this.visibleRows = null;
	}
	
	//////////////////////////////////////
	///////// Public Functions ///////////
	//////////////////////////////////////
	
	renderColumns(row, force){
		this.dataChange();
	}
	
	
	scrollColumns(left, dir){
		if(this.scrollLeft != left){
			this.scrollLeft = left;
			
			this.scroll(left - (this.vDomScrollPosLeft + this.windowBuffer));
		}
	}
	
	calcWindowBuffer(){
		var buffer = this.elementVertical.clientWidth;
		
		this.table.columnManager.columnsByIndex.forEach((column) => {
			if(column.visible){
				var width = column.getWidth();
				
				if(width > buffer){
					buffer = width;
				}
			}
		});
		
		this.windowBuffer = buffer * 2;
	}
	
	rerenderColumns(update, blockRedraw){		
		var old = {
			cols:this.columns,
			leftCol:this.leftCol,
			rightCol:this.rightCol,
		},
		colPos = 0;
		
		if(update && !this.initialized){
			return;
		}
		
		this.clear();
		
		this.calcWindowBuffer();
		
		this.scrollLeft = this.elementVertical.scrollLeft;
		
		this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer;
		this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
		
		this.table.columnManager.columnsByIndex.forEach((column) => {
			var config = {},
			width;
			
			if(column.visible){
				if(!column.modules.frozen){			
					width = column.getWidth();

					config.leftPos = colPos;
					config.rightPos = colPos + width;
					
					config.width = width;
					
					if (this.isFitData) {
						config.fitDataCheck = column.modules.vdomHoz ? column.modules.vdomHoz.fitDataCheck : true;
					}
					
					if((colPos + width > this.vDomScrollPosLeft) && (colPos < this.vDomScrollPosRight)){
						//column is visible
						
						if(this.leftCol == -1){
							this.leftCol = this.columns.length;
							this.vDomPadLeft = colPos;
						}
						
						this.rightCol = this.columns.length;
					}else {
						// column is hidden
						if(this.leftCol !== -1){
							this.vDomPadRight += width;
						}
					}
					
					this.columns.push(column);
					
					column.modules.vdomHoz = config;
					
					colPos += width;
				}
			}
		});
		
		this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
		this.tableElement.style.paddingRight = this.vDomPadRight + "px";
		
		this.initialized = true;
		
		if(!blockRedraw){
			if(!update || this.reinitChanged(old)){
				this.reinitializeRows();
			}
		}
		
		this.elementVertical.scrollLeft = this.scrollLeft;
	}
	
	renderRowCells(row){
		if(this.initialized){
			this.initializeRow(row);
		}else {
			const rowFrag = document.createDocumentFragment();
			row.cells.forEach((cell) => {
				rowFrag.appendChild(cell.getElement());
			});
			row.element.appendChild(rowFrag);

			row.cells.forEach((cell) => {
				cell.cellRendered();
			});
		}
	}
	
	rerenderRowCells(row, force){
		this.reinitializeRow(row, force);
	}
	
	reinitializeColumnWidths(columns){
		for(let i = this.leftCol; i <= this.rightCol; i++){
			this.columns[i].reinitializeWidth();
		}
	}
	
	//////////////////////////////////////
	//////// Internal Rendering //////////
	//////////////////////////////////////
	
	deinitialize(){
		this.initialized = false;
	}
	
	clear(){
		this.columns = [];
		
		this.leftCol = -1;
		this.rightCol = 0;
		
		this.vDomScrollPosLeft = 0;
		this.vDomScrollPosRight = 0;
		this.vDomPadLeft = 0;
		this.vDomPadRight = 0;
	}
	
	dataChange(){
		var change = false,
		row, rowEl;
		
		if(this.isFitData){
			this.table.columnManager.columnsByIndex.forEach((column) => {
				if(!column.definition.width && column.visible){
					change = true;
				}
			});
			
			if(change && this.table.rowManager.getDisplayRows().length){
				this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
				
				row = this.chain("rows-sample", [1], [], () => {
					return this.table.rowManager.getDisplayRows();
				})[0];
				
				if(row){
					rowEl = row.getElement();
					
					row.generateCells();
					
					this.tableElement.appendChild(rowEl);
					
					for(let colEnd = 0; colEnd < row.cells.length; colEnd++){
						let cell = row.cells[colEnd];
						rowEl.appendChild(cell.getElement());
						
						cell.column.reinitializeWidth();
					}
					
					rowEl.parentNode.removeChild(rowEl);
					
					this.rerenderColumns(false, true);
				}
			}
		}else {
			if(this.options("layout") === "fitColumns"){
				this.layoutRefresh();
				this.rerenderColumns(false, true);
			}
		}
	}
	
	reinitChanged(old){
		var match = true;
		
		if(old.cols.length !== this.columns.length || old.leftCol !== this.leftCol || old.rightCol !== this.rightCol){
			return true;
		}
		
		old.cols.forEach((col, i) => {
			if(col !== this.columns[i]){
				match = false;
			}
		});
		
		return !match;
	}
	
	reinitializeRows(){
		var visibleRows = this.getVisibleRows(),
		otherRows = this.table.rowManager.getRows().filter(row => !visibleRows.includes(row));

		visibleRows.forEach((row) => {
			this.reinitializeRow(row, true);
		});

		otherRows.forEach((row) =>{
			row.deinitialize();
		});
	}
	
	getVisibleRows(){
		if (!this.visibleRows){
			this.visibleRows = this.table.rowManager.getVisibleRows();
		}
		
		return this.visibleRows;	
	}
	
	scroll(diff){
		this.vDomScrollPosLeft += diff;
		this.vDomScrollPosRight += diff;
		
		if(Math.abs(diff) > (this.windowBuffer / 2)){
			this.rerenderColumns();
		}else {
			if(diff > 0){
				//scroll right
				this.addColRight();
				this.removeColLeft();
			}else {
				//scroll left
				this.addColLeft();
				this.removeColRight();
			}
		}
	}
	
	colPositionAdjust (start, end, diff){
		for(let i = start; i < end; i++){
			let column = this.columns[i];
			
			column.modules.vdomHoz.leftPos += diff;
			column.modules.vdomHoz.rightPos += diff;
		}
	}
	
	addColRight(){
		var changes = false,
		working = true;
		
		while(working){

			let column = this.columns[this.rightCol + 1];
			
			if(column){
				if(column.modules.vdomHoz.leftPos <= this.vDomScrollPosRight){
					changes = true;
					
					this.getVisibleRows().forEach((row) => {
						if(row.type !== "group"){
							var cell = row.getCell(column);
							row.getElement().insertBefore(cell.getElement(), row.getCell(this.columns[this.rightCol]).getElement().nextSibling);
							cell.cellRendered();
						}
					});
					
					this.fitDataColActualWidthCheck(column);
					
					this.rightCol++; // Don't move this below the >= check below

					this.getVisibleRows().forEach((row) => {
						if(row.type !== "group"){
							row.modules.vdomHoz.rightCol = this.rightCol;
						}
					});
					
					if(this.rightCol >= (this.columns.length - 1)){
						this.vDomPadRight = 0;
					}else {
						this.vDomPadRight -= column.getWidth();
					}	
				}else {
					working = false;
				}
			}else {
				working = false;
			}
		}
		
		if(changes){
			this.tableElement.style.paddingRight = this.vDomPadRight + "px";
		}
	}
	
	addColLeft(){
		var changes = false,
		working = true;
		
		while(working){
			let column = this.columns[this.leftCol - 1];
			
			if(column){
				if(column.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft){
					changes = true;
					
					this.getVisibleRows().forEach((row) => {
						if(row.type !== "group"){
							var cell = row.getCell(column);
							row.getElement().insertBefore(cell.getElement(), row.getCell(this.columns[this.leftCol]).getElement());
							cell.cellRendered();
						}
					});
					
					this.leftCol--; // don't move this below the <= check below

					this.getVisibleRows().forEach((row) => {
						if(row.type !== "group"){
							row.modules.vdomHoz.leftCol = this.leftCol;
						}
					});
					
					if(this.leftCol <= 0){ // replicating logic in addColRight
						this.vDomPadLeft = 0;
					}else {
						this.vDomPadLeft -= column.getWidth();
					}
					
					let diff = this.fitDataColActualWidthCheck(column);
					
					if(diff){
						this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + diff;
						this.vDomPadRight -= diff;
					}
					
				}else {
					working = false;
				}
			}else {
				working = false;
			}
		}
		
		if(changes){
			this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
		}
	}
	
	removeColRight(){
		var changes = false,
		working = true;
		
		while(working){
			let column = this.columns[this.rightCol];
			
			if(column){
				if(column.modules.vdomHoz.leftPos > this.vDomScrollPosRight){
					changes = true;
					
					this.getVisibleRows().forEach((row) => {
						if(row.type !== "group"){
							var cell = row.getCell(column);
							
							try {
								row.getElement().removeChild(cell.getElement());
							} catch (ex) {
								console.warn("Could not removeColRight", ex.message);
							}
						}
					});
					
					this.vDomPadRight += column.getWidth();
					this.rightCol --;

					this.getVisibleRows().forEach((row) => {
						if(row.type !== "group"){
							row.modules.vdomHoz.rightCol = this.rightCol;
						}
					});
				}else {
					working = false;
				}
			}else {
				working = false;
			}
		}
		
		if(changes){
			this.tableElement.style.paddingRight = this.vDomPadRight + "px";
		}
	}
	
	removeColLeft(){
		var changes = false,
		working = true;

		while(working){
			let column = this.columns[this.leftCol];
			
			if(column){
				if(column.modules.vdomHoz.rightPos < this.vDomScrollPosLeft){
					changes = true;
					
					this.getVisibleRows().forEach((row) => {					
						if(row.type !== "group"){
							var cell = row.getCell(column);
							
							try {
								row.getElement().removeChild(cell.getElement());
							} catch (ex) {
								console.warn("Could not removeColLeft", ex.message);
							}
						}
					});
					
					this.vDomPadLeft += column.getWidth();
					this.leftCol ++;

					this.getVisibleRows().forEach((row) => {
						if(row.type !== "group"){
							row.modules.vdomHoz.leftCol = this.leftCol;
						}
					});
				}else {
					working = false;
				}
			}else {
				working = false;
			}
		}
		
		if(changes){
			this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
		}
	}
	
	fitDataColActualWidthCheck(column){
		var newWidth, widthDiff;
		
		if(column.modules.vdomHoz.fitDataCheck){
			column.reinitializeWidth();
			
			newWidth = column.getWidth();
			widthDiff = newWidth - column.modules.vdomHoz.width;
			
			if(widthDiff){
				column.modules.vdomHoz.rightPos += widthDiff;
				column.modules.vdomHoz.width = newWidth;
				this.colPositionAdjust(this.columns.indexOf(column) + 1, this.columns.length, widthDiff);
			}
			
			column.modules.vdomHoz.fitDataCheck = false;
		}
		
		return widthDiff;
	}
	
	initializeRow(row){
		if(row.type !== "group"){
			row.modules.vdomHoz = {
				leftCol:this.leftCol,
				rightCol:this.rightCol,
			};

			if(this.table.modules.frozenColumns){
				this.table.modules.frozenColumns.leftColumns.forEach((column) => {
					this.appendCell(row, column);
				});
			}

			for(let i = this.leftCol; i <= this.rightCol; i++){
				this.appendCell(row, this.columns[i]);
			}

			if(this.table.modules.frozenColumns){
				this.table.modules.frozenColumns.rightColumns.forEach((column) => {
					this.appendCell(row, column);
				});
			}
		}
	}
	
	appendCell(row, column){
		if(column && column.visible){
			let cell = row.getCell(column);
			
			row.getElement().appendChild(cell.getElement());
			cell.cellRendered();
		}
	}
	
	reinitializeRow(row, force){
		if(row.type !== "group"){
			if(force || !row.modules.vdomHoz || row.modules.vdomHoz.leftCol !== this.leftCol || row.modules.vdomHoz.rightCol !== this.rightCol){
				
				var rowEl = row.getElement();
				while(rowEl.firstChild) rowEl.removeChild(rowEl.firstChild);

				this.initializeRow(row);
			}
		}
	}
}

class ColumnManager extends CoreFeature {
	
	constructor (table){
		super(table);
		
		this.blockHozScrollEvent = false;
		this.headersElement = null;
		this.contentsElement = null;
		this.element = null ; //containing element
		this.columns = []; // column definition object
		this.columnsByIndex = []; //columns by index
		this.columnsByField = {}; //columns by field
		this.scrollLeft = 0;
		this.optionsList = new OptionsList(this.table, "column definition", defaultColumnOptions);
		
		this.redrawBlock = false; //prevent redraws to allow multiple data manipulations before continuing
		this.redrawBlockUpdate = null; //store latest redraw update only status
		
		this.renderer = null;
	}
	
	////////////// Setup Functions /////////////////
	
	initialize(){
		this.initializeRenderer();
		
		this.headersElement = this.createHeadersElement();
		this.contentsElement = this.createHeaderContentsElement();
		this.element = this.createHeaderElement();
		
		this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild);
		this.element.insertBefore(this.contentsElement, this.element.firstChild);

		this.initializeScrollWheelWatcher();
		
		this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
		this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
	}

	padVerticalScrollbar(width){
		if(this.table.rtl){
			this.headersElement.style.marginLeft = width + "px";
		}else {
			this.headersElement.style.marginRight = width + "px";
		}
	}
	
	initializeRenderer(){
		var renderClass;
		
		var renderers = {
			"virtual": VirtualDomHorizontal,
			"basic": BasicHorizontal,
		};
		
		if(typeof this.table.options.renderHorizontal === "string"){
			renderClass = renderers[this.table.options.renderHorizontal];
		}else {
			renderClass = this.table.options.renderHorizontal;
		}
		
		if(renderClass){
			this.renderer = new renderClass(this.table, this.element, this.tableElement);
			this.renderer.initialize();
		}else {
			console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
		}
	}
	
	
	createHeadersElement (){
		var el = document.createElement("div");
		
		el.classList.add("tabulator-headers");
		el.setAttribute("role", "row");
		
		return el;
	}

	createHeaderContentsElement (){
		var el = document.createElement("div");
		
		el.classList.add("tabulator-header-contents");
		el.setAttribute("role", "rowgroup");
		
		return el;
	}
	
	createHeaderElement (){
		var el = document.createElement("div");
		
		el.classList.add("tabulator-header");
		el.setAttribute("role", "rowgroup");
		
		if(!this.table.options.headerVisible){
			el.classList.add("tabulator-header-hidden");
		}
		
		return el;
	}
	
	//return containing element
	getElement(){
		return this.element;
	}

	//return containing contents element
	getContentsElement(){
		return this.contentsElement;
	}
	
	
	//return header containing element
	getHeadersElement(){
		return this.headersElement;
	}
	
	//scroll horizontally to match table body
	scrollHorizontal(left){
		this.contentsElement.scrollLeft = left;

		this.scrollLeft = left;
		
		this.renderer.scrollColumns(left);
	}

	initializeScrollWheelWatcher(){
		this.contentsElement.addEventListener("wheel", (e) => {
			var left;

			if(e.deltaX){
				left = this.contentsElement.scrollLeft + e.deltaX;

				this.table.rowManager.scrollHorizontal(left);
				this.table.columnManager.scrollHorizontal(left);
			}
		});
	}
	
	///////////// Column Setup Functions /////////////
	generateColumnsFromRowData(data){
		var cols = [],
		definitions = this.table.options.autoColumnsDefinitions,
		row, sorter;
		
		if(data && data.length){
			
			row = data[0];
			
			for(var key in row){
				let col = {
					field:key,
					title:key,
				};
				
				let value = row[key];
				
				switch(typeof value){
					case "undefined":
						sorter = "string";
						break;
					
					case "boolean":
						sorter = "boolean";
						break;
					
					case "object":
						if(Array.isArray(value)){
							sorter = "array";
						}else {
							sorter = "string";
						}
						break;
					
					default:
						if(!isNaN(value) && value !== ""){
							sorter = "number";
						}else {
							if(value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)){
								sorter = "alphanum";
							}else {
								sorter = "string";
							}
						}
						break;
				}
				
				col.sorter = sorter;
				
				cols.push(col);
			}
			
			if(definitions){
				
				switch(typeof definitions){
					case "function":
						this.table.options.columns = definitions.call(this.table, cols);
						break;
					
					case "object":
						if(Array.isArray(definitions)){
							cols.forEach((col) => {
								var match = definitions.find((def) => {
									return def.field === col.field;
								});
								
								if(match){
									Object.assign(col, match);
								}
							});
							
						}else {
							cols.forEach((col) => {
								if(definitions[col.field]){
									Object.assign(col, definitions[col.field]);
								}
							});
						}
						
						this.table.options.columns = cols;
						break;
				}
			}else {
				this.table.options.columns = cols;
			}
			
			this.setColumns(this.table.options.columns);
		}
	}
	
	setColumns(cols, row){
		while(this.headersElement.firstChild) this.headersElement.removeChild(this.headersElement.firstChild);
		
		this.columns = [];
		this.columnsByIndex = [];
		this.columnsByField = {};
		
		this.dispatch("columns-loading");
		
		cols.forEach((def, i) => {
			this._addColumn(def);
		});
		
		this._reIndexColumns();
		
		this.dispatch("columns-loaded");
		
		this.rerenderColumns(false, true);
		
		this.redraw(true);
	}
	
	_addColumn(definition, before, nextToColumn){
		var column = new Column(definition, this),
		colEl = column.getElement(),
		index = nextToColumn ? this.findColumnIndex(nextToColumn) : nextToColumn;
		
		if(nextToColumn && index > -1){
			var topColumn = nextToColumn.getTopColumn();
			var parentIndex = this.columns.indexOf(topColumn);
			var nextEl = topColumn.getElement();
			
			if(before){
				this.columns.splice(parentIndex, 0, column);
				nextEl.parentNode.insertBefore(colEl, nextEl);
			}else {
				this.columns.splice(parentIndex + 1, 0, column);
				nextEl.parentNode.insertBefore(colEl, nextEl.nextSibling);
			}
		}else {
			if(before){
				this.columns.unshift(column);
				this.headersElement.insertBefore(column.getElement(), this.headersElement.firstChild);
			}else {
				this.columns.push(column);
				this.headersElement.appendChild(column.getElement());
			}
		}
		
		column.columnRendered();
		
		return column;
	}
	
	registerColumnField(col){
		if(col.definition.field){
			this.columnsByField[col.definition.field] = col;
		}
	}
	
	registerColumnPosition(col){
		this.columnsByIndex.push(col);
	}
	
	_reIndexColumns(){
		this.columnsByIndex = [];
		
		this.columns.forEach(function(column){
			column.reRegisterPosition();
		});
	}
	
	//ensure column headers take up the correct amount of space in column groups
	verticalAlignHeaders(){
		var minHeight = 0;
		
		if(!this.redrawBlock){

			this.headersElement.style.height="";
			
			this.columns.forEach((column) => {
				column.clearVerticalAlign();
			});
			
			this.columns.forEach((column) => {
				var height = column.getHeight();
				
				if(height > minHeight){
					minHeight = height;
				}
			});

			this.headersElement.style.height = minHeight + "px";

			this.columns.forEach((column) => {
				column.verticalAlign(this.table.options.columnHeaderVertAlign, minHeight);
			});
			
			this.table.rowManager.adjustTableSize();
		}
	}
	
	//////////////// Column Details /////////////////
	findColumn(subject){
		var columns;

		if(typeof subject == "object"){
			
			if(subject instanceof Column){
				//subject is column element
				return subject;
			}else if(subject instanceof ColumnComponent){
				//subject is public column component
				return subject._getSelf() || false;
			}else if(typeof HTMLElement !== "undefined" && subject instanceof HTMLElement){

				columns = [];

				this.columns.forEach((column) => {
					columns.push(column);
					columns = columns.concat(column.getColumns(true));
				});

				//subject is a HTML element of the column header
				let match = columns.find((column) => {
					return column.element === subject;
				});
				
				return match || false;
			}
			
		}else {
			//subject should be treated as the field name of the column
			return this.columnsByField[subject] || false;
		}
		
		//catch all for any other type of input
		return false;
	}
	
	getColumnByField(field){
		return this.columnsByField[field];
	}
	
	getColumnsByFieldRoot(root){
		var matches = [];
		
		Object.keys(this.columnsByField).forEach((field) => {
			var fieldRoot = this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator)[0] : field;
			if(fieldRoot === root){
				matches.push(this.columnsByField[field]);
			}
		});
		
		return matches;
	}
	
	getColumnByIndex(index){
		return this.columnsByIndex[index];
	}
	
	getFirstVisibleColumn(){
		var index = this.columnsByIndex.findIndex((col) => {
			return col.visible;
		});
		
		return index > -1 ? this.columnsByIndex[index] : false;
	}

	getVisibleColumnsByIndex() {
		return this.columnsByIndex.filter((col) => col.visible);
	}
	
	getColumns(){
		return this.columns;
	}
	
	findColumnIndex(column){
		return this.columnsByIndex.findIndex((col) => {
			return column === col;
		});
	}
	
	//return all columns that are not groups
	getRealColumns(){
		return this.columnsByIndex;
	}
	
	//traverse across columns and call action
	traverse(callback){
		this.columnsByIndex.forEach((column,i) =>{
			callback(column, i);
		});
	}
	
	//get definitions of actual columns
	getDefinitions(active){
		var output = [];
		
		this.columnsByIndex.forEach((column) => {
			if(!active || (active && column.visible)){
				output.push(column.getDefinition());
			}
		});
		
		return output;
	}
	
	//get full nested definition tree
	getDefinitionTree(){
		var output = [];
		
		this.columns.forEach((column) => {
			output.push(column.getDefinition(true));
		});
		
		return output;
	}
	
	getComponents(structured){
		var output = [],
		columns = structured ? this.columns : this.columnsByIndex;
		
		columns.forEach((column) => {
			output.push(column.getComponent());
		});
		
		return output;
	}
	
	getWidth(){
		var width = 0;
		
		this.columnsByIndex.forEach((column) => {
			if(column.visible){
				width += column.getWidth();
			}
		});
		
		return width;
	}
	
	moveColumn(from, to, after){
		to.element.parentNode.insertBefore(from.element, to.element);
		
		if(after){
			to.element.parentNode.insertBefore(to.element, from.element);
		}
		
		this.moveColumnActual(from, to, after);

		this.verticalAlignHeaders();
		
		this.table.rowManager.reinitialize();
	}
	
	moveColumnActual(from, to, after){
		if(from.parent.isGroup){
			this._moveColumnInArray(from.parent.columns, from, to, after);
		}else {
			this._moveColumnInArray(this.columns, from, to, after);
		}
		
		this._moveColumnInArray(this.columnsByIndex, from, to, after, true);
		
		this.rerenderColumns(true);
		
		this.dispatch("column-moved", from, to, after);
		
		if(this.subscribedExternal("columnMoved")){
			this.dispatchExternal("columnMoved", from.getComponent(), this.table.columnManager.getComponents());
		}
	}
	
	_moveColumnInArray(columns, from, to, after, updateRows){
		var	fromIndex = columns.indexOf(from),
		toIndex, rows = [];
		
		if (fromIndex > -1) {
			
			columns.splice(fromIndex, 1);
			
			toIndex = columns.indexOf(to);
			
			if (toIndex > -1) {
				
				if(after){
					toIndex = toIndex+1;
				}
				
			}else {
				toIndex = fromIndex;
			}
			
			columns.splice(toIndex, 0, from);
			
			if(updateRows){
				
				rows = this.chain("column-moving-rows", [from, to, after], null, []) || [];
				
				rows = rows.concat(this.table.rowManager.rows);
				
				rows.forEach(function(row){
					if(row.cells.length){
						var cell = row.cells.splice(fromIndex, 1)[0];
						row.cells.splice(toIndex, 0, cell);
					}
				});
				
			}
		}
	}
	
	scrollToColumn(column, position, ifVisible){
		var left = 0,
		offset = column.getLeftOffset(),
		adjust = 0,
		colEl = column.getElement();
		
		
		return new Promise((resolve, reject) => {
			
			if(typeof position === "undefined"){
				position = this.table.options.scrollToColumnPosition;
			}
			
			if(typeof ifVisible === "undefined"){
				ifVisible = this.table.options.scrollToColumnIfVisible;
			}
			
			if(column.visible){
				
				//align to correct position
				switch(position){
					case "middle":
					case "center":
						adjust = -this.element.clientWidth / 2;
						break;
					
					case "right":
						adjust = colEl.clientWidth - this.headersElement.clientWidth;
						break;
				}
				
				//check column visibility
				if(!ifVisible){
					if(offset > 0 && offset + colEl.offsetWidth < this.element.clientWidth){
						return false;
					}
				}
				
				//calculate scroll position
				left = offset + adjust;
				
				left = Math.max(Math.min(left, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth),0);
				
				this.table.rowManager.scrollHorizontal(left);
				this.scrollHorizontal(left);
				
				resolve();
			}else {
				console.warn("Scroll Error - Column not visible");
				reject("Scroll Error - Column not visible");
			}
			
		});
	}
	
	//////////////// Cell Management /////////////////
	generateCells(row){
		var cells = [];
		
		this.columnsByIndex.forEach((column) => {
			cells.push(column.generateCell(row));
		});
		
		return cells;
	}
	
	//////////////// Column Management /////////////////
	getFlexBaseWidth(){
		var totalWidth = this.table.element.clientWidth, //table element width
		fixedWidth = 0;
		
		//adjust for vertical scrollbar if present
		if(this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight){
			totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
		}
		
		this.columnsByIndex.forEach(function(column){
			var width, minWidth, colWidth;
			
			if(column.visible){
				
				width = column.definition.width || 0;
				
				minWidth = parseInt(column.minWidth);
				
				if(typeof(width) == "string"){
					if(width.indexOf("%") > -1){
						colWidth = (totalWidth / 100) * parseInt(width) ;
					}else {
						colWidth = parseInt(width);
					}
				}else {
					colWidth = width;
				}
				
				fixedWidth += colWidth > minWidth ? colWidth : minWidth;
				
			}
		});
		
		return fixedWidth;
	}
	
	addColumn(definition, before, nextToColumn){
		return new Promise((resolve, reject) => {
			var column = this._addColumn(definition, before, nextToColumn);
			
			this._reIndexColumns();
			
			this.dispatch("column-add", definition, before, nextToColumn);
			
			if(this.layoutMode() != "fitColumns"){
				column.reinitializeWidth();
			}
			
			this.redraw(true);
			
			this.table.rowManager.reinitialize();
			
			this.rerenderColumns();
			
			resolve(column);
		});
	}
	
	//remove column from system
	deregisterColumn(column){
		var field = column.getField(),
		index;
		
		//remove from field list
		if(field){
			delete this.columnsByField[field];
		}
		
		//remove from index list
		index = this.columnsByIndex.indexOf(column);
		
		if(index > -1){
			this.columnsByIndex.splice(index, 1);
		}
		
		//remove from column list
		index = this.columns.indexOf(column);
		
		if(index > -1){
			this.columns.splice(index, 1);
		}
		
		this.verticalAlignHeaders();
		
		this.redraw();
	}
	
	rerenderColumns(update, silent){
		if(!this.redrawBlock){
			this.renderer.rerenderColumns(update, silent);
		}else {
			if(update === false || (update === true && this.redrawBlockUpdate === null)){
				this.redrawBlockUpdate = update;
			}
		}
	}
	
	blockRedraw(){
		this.redrawBlock = true;
		this.redrawBlockUpdate = null;
	}
	
	restoreRedraw(){
		this.redrawBlock = false;
		this.verticalAlignHeaders();
		this.renderer.rerenderColumns(this.redrawBlockUpdate);
		
	}
	
	//redraw columns
	redraw(force){
		if(Helpers.elVisible(this.element)){
			this.verticalAlignHeaders();
		}
		
		if(force){
			this.table.rowManager.resetScroll();
			this.table.rowManager.reinitialize();
		}
		
		if(!this.confirm("table-redrawing", force)){
			this.layoutRefresh(force);
		}
		
		this.dispatch("table-redraw", force);
		
		this.table.footerManager.redraw();
	}
}

class BasicVertical extends Renderer{
	constructor(table){
		super(table);
		
		this.verticalFillMode = "fill";
		
		this.scrollTop = 0;
		this.scrollLeft = 0;
		
		this.scrollTop = 0;
		this.scrollLeft = 0;
	}
	
	clearRows(){
		var element = this.tableElement;
		
		// element.children.detach();
		while(element.firstChild) element.removeChild(element.firstChild);
		
		element.scrollTop = 0;
		element.scrollLeft = 0;
		
		element.style.minWidth = "";
		element.style.minHeight = "";
		element.style.display = "";
		element.style.visibility = "";
	}
	
	renderRows() {
		var element = this.tableElement,
		onlyGroupHeaders = true,
		tableFrag = document.createDocumentFragment(),
		rows = this.rows();
		
		rows.forEach((row, index) => {
			this.styleRow(row, index);
			row.initialize(false, true);
			
			if (row.type !== "group") {
				onlyGroupHeaders = false;
			}
			
			tableFrag.appendChild(row.getElement());
		});
		
		element.appendChild(tableFrag);
		
		rows.forEach((row) => {
			row.rendered();
			
			if(!row.heightInitialized) {
				row.calcHeight(true);
			}
		});
		
		rows.forEach((row) => {
			if(!row.heightInitialized) {
				row.setCellHeight();
			}
		});
		
		if(onlyGroupHeaders){
			element.style.minWidth = this.table.columnManager.getWidth() + "px";
		}else {
			element.style.minWidth = "";
		}
	}
	
	
	rerenderRows(callback){	
		this.clearRows();
		
		if(callback){
			callback();
		}
		
		this.renderRows();

		if(!this.rows().length){
			this.table.rowManager.tableEmpty();
		}
	}
	
	scrollToRowNearestTop(row){
		var rowTop = Helpers.elOffset(row.getElement()).top;
		
		return !(Math.abs(this.elementVertical.scrollTop - rowTop) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - rowTop));
	}
	
	scrollToRow(row){
		var rowEl = row.getElement();
		
		this.elementVertical.scrollTop = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
	}
	
	visibleRows(includingBuffer){
		return this.rows();
	}
	
}

class VirtualDomVertical extends Renderer{
	constructor(table){
		super(table);

		this.verticalFillMode = "fill";

		this.scrollTop = 0;
		this.scrollLeft = 0;

		this.vDomRowHeight = 20; //approximation of row heights for padding

		this.vDomTop = 0; //hold position for first rendered row in the virtual DOM
		this.vDomBottom = 0; //hold position for last rendered row in the virtual DOM

		this.vDomScrollPosTop = 0; //last scroll position of the vDom top;
		this.vDomScrollPosBottom = 0; //last scroll position of the vDom bottom;

		this.vDomTopPad = 0; //hold value of padding for top of virtual DOM
		this.vDomBottomPad = 0; //hold value of padding for bottom of virtual DOM

		this.vDomMaxRenderChain = 90; //the maximum number of dom elements that can be rendered in 1 go

		this.vDomWindowBuffer = 0; //window row buffer before removing elements, to smooth scrolling

		this.vDomWindowMinTotalRows = 20; //minimum number of rows to be generated in virtual dom (prevent buffering issues on tables with tall rows)
		this.vDomWindowMinMarginRows = 5; //minimum number of rows to be generated in virtual dom margin

		this.vDomTopNewRows = []; //rows to normalize after appending to optimize render speed
		this.vDomBottomNewRows = []; //rows to normalize after appending to optimize render speed
	}

	//////////////////////////////////////
	///////// Public Functions ///////////
	//////////////////////////////////////

	clearRows(){
		var element = this.tableElement;

		// element.children.detach();
		while(element.firstChild) element.removeChild(element.firstChild);

		element.style.paddingTop = "";
		element.style.paddingBottom = "";
		element.style.minHeight = "";
		element.style.display = "";
		element.style.visibility = "";

		this.elementVertical.scrollTop = 0;
		this.elementVertical.scrollLeft = 0;

		this.scrollTop = 0;
		this.scrollLeft = 0;

		this.vDomTop = 0;
		this.vDomBottom = 0;
		this.vDomTopPad = 0;
		this.vDomBottomPad = 0;
		this.vDomScrollPosTop = 0;
		this.vDomScrollPosBottom = 0;
	}

	renderRows(){
		this._virtualRenderFill();
	}

	rerenderRows(callback){
		var scrollTop = this.elementVertical.scrollTop;
		var topRow = false;
		var topOffset = false;

		var left = this.table.rowManager.scrollLeft;

		var rows = this.rows();

		for(var i = this.vDomTop; i <= this.vDomBottom; i++){

			if(rows[i]){
				var diff = scrollTop - rows[i].getElement().offsetTop;

				if(topOffset === false || Math.abs(diff) < topOffset){
					topOffset = diff;
					topRow = i;
				}else {
					break;
				}
			}
		}

		rows.forEach((row) => {
			row.deinitializeHeight();
		});

		if(callback){
			callback();
		}

		if(this.rows().length){
			this._virtualRenderFill((topRow === false ? this.rows.length - 1 : topRow), true, topOffset || 0);
		}else {
			this.clear();
			this.table.rowManager.tableEmpty();
		}

		this.scrollColumns(left);
	}

	scrollColumns(left){
		this.table.rowManager.scrollHorizontal(left);
	}

	scrollRows(top, dir){
		var topDiff = top - this.vDomScrollPosTop;
		var bottomDiff = top - this.vDomScrollPosBottom;
		var margin = this.vDomWindowBuffer * 2;
		var rows = this.rows();

		this.scrollTop = top;

		if(-topDiff > margin || bottomDiff > margin){
			//if big scroll redraw table;
			var left = this.table.rowManager.scrollLeft;
			this._virtualRenderFill(Math.floor((this.elementVertical.scrollTop / this.elementVertical.scrollHeight) * rows.length));
			this.scrollColumns(left);
		}else {

			if(dir){
				//scrolling up
				if(topDiff < 0){
					this._addTopRow(rows, -topDiff);
				}

				if(bottomDiff < 0){
					//hide bottom row if needed
					if(this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer){
						this._removeBottomRow(rows, -bottomDiff);
					}else {
						this.vDomScrollPosBottom = this.scrollTop;
					}
				}
			}else {

				if(bottomDiff >= 0){
					this._addBottomRow(rows, bottomDiff);
				}

				//scrolling down
				if(topDiff >= 0){
					//hide top row if needed
					if(this.scrollTop > this.vDomWindowBuffer){
						this._removeTopRow(rows, topDiff);
					}else {
						this.vDomScrollPosTop = this.scrollTop;
					}
				}
			}
		}
	}

	resize(){
		this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
	}

	scrollToRowNearestTop(row){
		var rowIndex = this.rows().indexOf(row);

		return !(Math.abs(this.vDomTop - rowIndex) > Math.abs(this.vDomBottom - rowIndex));
	}

	scrollToRow(row){
		var index = this.rows().indexOf(row);

		if(index > -1){
			this._virtualRenderFill(index, true);
		}
	}

	visibleRows(includingBuffer){
		var topEdge = this.elementVertical.scrollTop,
		bottomEdge = this.elementVertical.clientHeight + topEdge,
		topFound = false,
		topRow = 0,
		bottomRow = 0,
		rows = this.rows();

		if(includingBuffer){
			topRow = this.vDomTop;
			bottomRow = this.vDomBottom;
		}else {
			for(var i = this.vDomTop; i <= this.vDomBottom; i++){
				if(rows[i]){
					if(!topFound){
						if((topEdge - rows[i].getElement().offsetTop) >= 0){
							topRow = i;
						}else {
							topFound = true;

							if(bottomEdge - rows[i].getElement().offsetTop >= 0){
								bottomRow = i;
							}else {
								break;
							}
						}
					}else {
						if(bottomEdge - rows[i].getElement().offsetTop >= 0){
							bottomRow = i;
						}else {
							break;
						}
					}
				}
			}
		}

		return rows.slice(topRow, bottomRow + 1);
	}

	//////////////////////////////////////
	//////// Internal Rendering //////////
	//////////////////////////////////////

	//full virtual render
	_virtualRenderFill(position, forceMove, offset) {
		var	element = this.tableElement,
		holder = this.elementVertical,
		topPad = 0,
		rowsHeight = 0,
		rowHeight = 0,
		heightOccupied = 0,
		topPadHeight = 0,
		i = 0,
		rows = this.rows(),
		rowsCount = rows.length,
		index = 0,
		row,
		rowFragment,
		renderedRows = [],
		totalRowsRendered = 0,
		rowsToRender = 0,
		fixedHeight = this.table.rowManager.fixedHeight,
		containerHeight = this.elementVertical.clientHeight, 
		avgRowHeight = this.table.options.rowHeight, 
		resized = true;

		position = position || 0;

		offset = offset || 0;

		if(!position){
			this.clear();
		}else {
			while(element.firstChild) element.removeChild(element.firstChild);

			//check if position is too close to bottom of table
			heightOccupied = (rowsCount - position + 1) * this.vDomRowHeight;

			if(heightOccupied < containerHeight){
				position -= Math.ceil((containerHeight - heightOccupied) / this.vDomRowHeight);
				if(position < 0){
					position = 0;
				}
			}

			//calculate initial pad
			topPad = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight),  this.vDomWindowMinMarginRows), position);
			position -= topPad;
		}

		if(rowsCount && Helpers.elVisible(this.elementVertical)){
			this.vDomTop = position;
			this.vDomBottom = position -1;

			if(fixedHeight || this.table.options.maxHeight) {
				if(avgRowHeight) {
					rowsToRender = (containerHeight / avgRowHeight) + (this.vDomWindowBuffer / avgRowHeight);
				}
				rowsToRender = Math.max(this.vDomWindowMinTotalRows, Math.ceil(rowsToRender));
			}
			else {
				rowsToRender = rowsCount;
			}

			while(((rowsToRender == rowsCount || rowsHeight <= containerHeight + this.vDomWindowBuffer) || totalRowsRendered < this.vDomWindowMinTotalRows) && this.vDomBottom < rowsCount -1) {
				renderedRows = [];
				rowFragment = document.createDocumentFragment();

				i = 0;

				while ((i < rowsToRender) && this.vDomBottom < rowsCount -1) {	
					index = this.vDomBottom + 1,
					row = rows[index];

					this.styleRow(row, index);

					row.initialize(false, true);
					if(!row.heightInitialized && !this.table.options.rowHeight){
						row.clearCellHeight();
					}

					rowFragment.appendChild(row.getElement());
					renderedRows.push(row);
					this.vDomBottom ++;
					i++;
				}

				if(!renderedRows.length){
					break;
				}

				element.appendChild(rowFragment);
				
				// NOTE: The next 3 loops are separate on purpose
				// This is to batch up the dom writes and reads which drastically improves performance 

				renderedRows.forEach((row) => {
					row.rendered();

					if(!row.heightInitialized) {
						row.calcHeight(true);
					}
				});

				renderedRows.forEach((row) => {
					if(!row.heightInitialized) {
						row.setCellHeight();
					}
				});

				renderedRows.forEach((row) => {
					rowHeight = row.getHeight();
					
					if(totalRowsRendered < topPad){
						topPadHeight += rowHeight;
					}else {
						rowsHeight += rowHeight;
					}

					if(rowHeight > this.vDomWindowBuffer){
						this.vDomWindowBuffer = rowHeight * 2;
					}
					totalRowsRendered++;
				});

				resized = this.table.rowManager.adjustTableSize();
				containerHeight = this.elementVertical.clientHeight;
				if(resized && (fixedHeight || this.table.options.maxHeight))
				{
					avgRowHeight = rowsHeight / totalRowsRendered;
					rowsToRender = Math.max(this.vDomWindowMinTotalRows, Math.ceil((containerHeight / avgRowHeight) + (this.vDomWindowBuffer / avgRowHeight)));
				}
			}

			if(!position){
				this.vDomTopPad = 0;
				//adjust row height to match average of rendered elements
				this.vDomRowHeight = Math.floor((rowsHeight + topPadHeight) / totalRowsRendered);
				this.vDomBottomPad = this.vDomRowHeight * (rowsCount - this.vDomBottom -1);

				this.vDomScrollHeight = topPadHeight + rowsHeight + this.vDomBottomPad - containerHeight;
			}else {
				this.vDomTopPad = !forceMove ? this.scrollTop - topPadHeight : (this.vDomRowHeight * this.vDomTop) + offset;
				this.vDomBottomPad = this.vDomBottom == rowsCount-1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - rowsHeight - topPadHeight, 0);
			}
			
			element.style.paddingTop = this.vDomTopPad+"px";
			element.style.paddingBottom = this.vDomBottomPad+"px";

			if(forceMove){
				this.scrollTop = this.vDomTopPad + (topPadHeight) + offset - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - containerHeight : 0);
			}

			this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - containerHeight);

			//adjust for horizontal scrollbar if present (and not at top of table)
			if(this.elementVertical.scrollWidth > this.elementVertical.clientWidth && forceMove){
				this.scrollTop += this.elementVertical.offsetHeight - containerHeight;
			}

			this.vDomScrollPosTop = this.scrollTop;
			this.vDomScrollPosBottom = this.scrollTop;

			holder.scrollTop = this.scrollTop;

			this.dispatch("render-virtual-fill");
		}
	}

	_addTopRow(rows, fillableSpace){
		var table = this.tableElement,
		addedRows = [],
		paddingAdjust = 0,
		index = this.vDomTop -1,
		i = 0,
		working = true;

		while(working){
			if(this.vDomTop){
				let row = rows[index],
				rowHeight, initialized;

				if(row && i < this.vDomMaxRenderChain){
					rowHeight = row.getHeight() || this.vDomRowHeight;
					initialized = row.initialized;

					if(fillableSpace >= rowHeight){

						this.styleRow(row, index);
						table.insertBefore(row.getElement(), table.firstChild);

						if(!row.initialized || !row.heightInitialized){
							addedRows.push(row);
						}

						row.initialize();

						if(!initialized){
							rowHeight = row.getElement().offsetHeight;

							if(rowHeight > this.vDomWindowBuffer){
								this.vDomWindowBuffer = rowHeight * 2;
							}
						}

						fillableSpace -= rowHeight;
						paddingAdjust += rowHeight;

						this.vDomTop--;
						index--;
						i++;

					}else {
						working = false;
					}

				}else {
					working = false;
				}

			}else {
				working = false;
			}
		}

		for (let row of addedRows){
			row.clearCellHeight();
		}

		this._quickNormalizeRowHeight(addedRows);

		if(paddingAdjust){
			this.vDomTopPad -= paddingAdjust;

			if(this.vDomTopPad < 0){
				this.vDomTopPad = index * this.vDomRowHeight;
			}

			if(index < 1){
				this.vDomTopPad = 0;
			}

			table.style.paddingTop = this.vDomTopPad + "px";
			this.vDomScrollPosTop -= paddingAdjust;
		}
	}

	_removeTopRow(rows, fillableSpace){
		var removableRows = [],
		paddingAdjust = 0,
		i = 0,
		working = true;

		while(working){
			let row = rows[this.vDomTop],
			rowHeight;

			if(row && i < this.vDomMaxRenderChain){
				rowHeight = row.getHeight() || this.vDomRowHeight;

				if(fillableSpace >= rowHeight){
					this.vDomTop++;

					fillableSpace -= rowHeight;
					paddingAdjust += rowHeight;

					removableRows.push(row);
					i++;
				}else {
					working = false;
				}
			}else {
				working = false;
			}
		}

		for (let row of removableRows){
			let rowEl = row.getElement();

			if(rowEl.parentNode){
				rowEl.parentNode.removeChild(rowEl);
			}
		}

		if(paddingAdjust){
			this.vDomTopPad += paddingAdjust;
			this.tableElement.style.paddingTop = this.vDomTopPad + "px";
			this.vDomScrollPosTop += this.vDomTop ? paddingAdjust : paddingAdjust + this.vDomWindowBuffer;
		}
	}

	_addBottomRow(rows, fillableSpace){
		var table = this.tableElement,
		addedRows = [],
		paddingAdjust = 0,
		index = this.vDomBottom + 1,
		i = 0,
		working = true;

		while(working){
			let row = rows[index],
			rowHeight, initialized;

			if(row && i < this.vDomMaxRenderChain){
				rowHeight = row.getHeight() || this.vDomRowHeight;
				initialized = row.initialized;

				if(fillableSpace >= rowHeight){

					this.styleRow(row, index);
					table.appendChild(row.getElement());

					if(!row.initialized || !row.heightInitialized){
						addedRows.push(row);
					}

					row.initialize();

					if(!initialized){
						rowHeight = row.getElement().offsetHeight;

						if(rowHeight > this.vDomWindowBuffer){
							this.vDomWindowBuffer = rowHeight * 2;
						}
					}

					fillableSpace -= rowHeight;
					paddingAdjust += rowHeight;

					this.vDomBottom++;
					index++;
					i++;
				}else {
					working = false;
				}
			}else {
				working = false;
			}
		}

		for (let row of addedRows){
			row.clearCellHeight();
		}

		this._quickNormalizeRowHeight(addedRows);

		if(paddingAdjust){
			this.vDomBottomPad -= paddingAdjust;

			if(this.vDomBottomPad < 0 || index == rows.length -1){
				this.vDomBottomPad = 0;
			}

			table.style.paddingBottom = this.vDomBottomPad + "px";
			this.vDomScrollPosBottom += paddingAdjust;
		}
	}

	_removeBottomRow(rows, fillableSpace){
		var removableRows = [],
		paddingAdjust = 0,
		i = 0,
		working = true;

		while(working){
			let row = rows[this.vDomBottom],
			rowHeight;

			if(row && i < this.vDomMaxRenderChain){
				rowHeight = row.getHeight() || this.vDomRowHeight;

				if(fillableSpace >= rowHeight){
					this.vDomBottom --;

					fillableSpace -= rowHeight;
					paddingAdjust += rowHeight;

					removableRows.push(row);
					i++;
				}else {
					working = false;
				}
			}else {
				working = false;
			}
		}

		for (let row of removableRows){
			let rowEl = row.getElement();

			if(rowEl.parentNode){
				rowEl.parentNode.removeChild(rowEl);
			}
		}

		if(paddingAdjust){
			this.vDomBottomPad += paddingAdjust;

			if(this.vDomBottomPad < 0){
				this.vDomBottomPad = 0;
			}

			this.tableElement.style.paddingBottom = this.vDomBottomPad + "px";
			this.vDomScrollPosBottom -= paddingAdjust;
		}
	}

	_quickNormalizeRowHeight(rows){
		for(let row of rows){
			row.calcHeight();
		}

		for(let row of rows){
			row.setCellHeight();
		}
	}
}

class RowManager extends CoreFeature{
	
	constructor(table){
		super(table);
		
		this.element = this.createHolderElement(); //containing element
		this.tableElement = this.createTableElement(); //table element
		this.heightFixer = this.createTableElement(); //table element
		this.placeholder = null; //placeholder element
		this.placeholderContents = null; //placeholder element
		
		this.firstRender = false; //handle first render
		this.renderMode = "virtual"; //current rendering mode
		this.fixedHeight = false; //current rendering mode
		
		this.rows = []; //hold row data objects
		this.activeRowsPipeline = []; //hold calculation of active rows
		this.activeRows = []; //rows currently available to on display in the table
		this.activeRowsCount = 0; //count of active rows
		
		this.displayRows = []; //rows currently on display in the table
		this.displayRowsCount = 0; //count of display rows
		
		this.scrollTop = 0;
		this.scrollLeft = 0;
		
		this.redrawBlock = false; //prevent redraws to allow multiple data manipulations before continuing
		this.redrawBlockRestoreConfig = false; //store latest redraw function calls for when redraw is needed
		this.redrawBlockRenderInPosition = false; //store latest redraw function calls for when redraw is needed
		
		this.dataPipeline = []; //hold data pipeline tasks
		this.displayPipeline = []; //hold data display pipeline tasks
		
		this.scrollbarWidth = 0;
		
		this.renderer = null;
	}
	
	//////////////// Setup Functions /////////////////
	
	createHolderElement (){
		var el = document.createElement("div");
		
		el.classList.add("tabulator-tableholder");
		el.setAttribute("tabindex", 0);
		// el.setAttribute("role", "rowgroup");
		
		return el;
	}
	
	createTableElement (){
		var el = document.createElement("div");
		
		el.classList.add("tabulator-table");
		el.setAttribute("role", "rowgroup");
		
		return el;
	}
	
	initializePlaceholder(){
		var placeholder = this.table.options.placeholder;
		
		if(typeof placeholder === "function"){
			placeholder = placeholder.call(this.table);
		}
		
		placeholder = this.chain("placeholder", [placeholder], placeholder, placeholder) || placeholder;
		
		//configure placeholder element
		if(placeholder){	
			let el = document.createElement("div");
			el.classList.add("tabulator-placeholder");
			
			if(typeof placeholder == "string"){
				let contents = document.createElement("div");
				contents.classList.add("tabulator-placeholder-contents");
				contents.innerHTML = placeholder;
				
				el.appendChild(contents);
				
				this.placeholderContents = contents;
				
			}else if(typeof HTMLElement !== "undefined" && placeholder instanceof HTMLElement){
				
				el.appendChild(placeholder);
				this.placeholderContents = placeholder;
			}else {
				console.warn("Invalid placeholder provided, must be string or HTML Element", placeholder);
				
				this.el = null;
			}
			
			this.placeholder = el;
		}
	}
	
	//return containing element
	getElement(){
		return this.element;
	}
	
	//return table element
	getTableElement(){
		return this.tableElement;
	}
	
	initialize(){
		this.initializePlaceholder();
		this.initializeRenderer();
		
		//initialize manager
		this.element.appendChild(this.tableElement);
		
		this.firstRender = true;
		
		//scroll header along with table body
		this.element.addEventListener("scroll", () => {
			var left = this.element.scrollLeft,
			leftDir = this.scrollLeft > left,
			top = this.element.scrollTop,
			topDir = this.scrollTop > top;
			
			//handle horizontal scrolling
			if(this.scrollLeft != left){
				this.scrollLeft = left;
				
				this.dispatch("scroll-horizontal", left, leftDir);
				this.dispatchExternal("scrollHorizontal", left, leftDir);
				
				this._positionPlaceholder();
			}
			
			//handle vertical scrolling
			if(this.scrollTop != top){
				this.scrollTop = top;
				
				this.renderer.scrollRows(top, topDir);
				
				this.dispatch("scroll-vertical", top, topDir);
				this.dispatchExternal("scrollVertical", top, topDir);
			}
		});
	}
	
	////////////////// Row Manipulation //////////////////
	findRow(subject){
		if(typeof subject == "object"){
			if(subject instanceof Row){
				//subject is row element
				return subject;
			}else if(subject instanceof RowComponent){
				//subject is public row component
				return subject._getSelf() || false;
			}else if(typeof HTMLElement !== "undefined" && subject instanceof HTMLElement){
				//subject is a HTML element of the row
				let match = this.rows.find((row) => {
					return row.getElement() === subject;
				});
				
				return match || false;
			}else if(subject === null){
				return false;
			}
		}else if(typeof subject == "undefined"){
			return false;
		}else {
			//subject should be treated as the index of the row
			let match = this.rows.find((row) => {
				return row.data[this.table.options.index] == subject;
			});
			
			return match || false;
		}
		
		//catch all for any other type of input
		return false;
	}
	
	getRowFromDataObject(data){
		var match = this.rows.find((row) => {
			return row.data === data;
		});
		
		return match || false;
	}
	
	getRowFromPosition(position){
		return this.getDisplayRows().find((row) => {
			return row.getPosition() === position && row.isDisplayed();
		});
	}
	
	scrollToRow(row, position, ifVisible){
		return this.renderer.scrollToRowPosition(row, position, ifVisible);
	}
	
	////////////////// Data Handling //////////////////
	setData(data, renderInPosition, columnsChanged){
		return new Promise((resolve, reject)=>{
			if(renderInPosition && this.getDisplayRows().length){
				if(this.table.options.pagination){
					this._setDataActual(data, true);
				}else {
					this.reRenderInPosition(() => {
						this._setDataActual(data);
					});
				}
			}else {
				if(this.table.options.autoColumns && columnsChanged && this.table.initialized){
					this.table.columnManager.generateColumnsFromRowData(data);
				}
				this.resetScroll();
				
				this._setDataActual(data);
			}
			
			resolve();
		});
	}
	
	_setDataActual(data, renderInPosition){
		this.dispatchExternal("dataProcessing", data);
		
		this._wipeElements();
		
		if(Array.isArray(data)){
			this.dispatch("data-processing", data);
			
			data.forEach((def, i) => {
				if(def && typeof def === "object"){
					var row = new Row(def, this);
					this.rows.push(row);
				}else {
					console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", def);
				}
			});
			
			this.refreshActiveData(false, false, renderInPosition);
			
			this.dispatch("data-processed", data);
			this.dispatchExternal("dataProcessed", data);
		}else {
			console.error("Data Loading Error - Unable to process data due to invalid data type \nExpecting: array \nReceived: ", typeof data, "\nData:     ", data);
		}
	}
	
	_wipeElements(){
		this.dispatch("rows-wipe");
		
		this.destroy();
		
		this.adjustTableSize();
		
		this.dispatch("rows-wiped");
	}
	
	destroy(){
		this.rows.forEach((row) => {
			row.wipe();
		});
		
		this.rows = [];
		this.activeRows = [];
		this.activeRowsPipeline = [];
		this.activeRowsCount = 0;
		this.displayRows = [];
		this.displayRowsCount = 0;
	}
	
	deleteRow(row, blockRedraw){
		var allIndex = this.rows.indexOf(row),
		activeIndex = this.activeRows.indexOf(row);
		
		if(activeIndex > -1){
			this.activeRows.splice(activeIndex, 1);
		}
		
		if(allIndex > -1){
			this.rows.splice(allIndex, 1);
		}
		
		this.setActiveRows(this.activeRows);
		
		this.displayRowIterator((rows) => {
			var displayIndex = rows.indexOf(row);
			
			if(displayIndex > -1){
				rows.splice(displayIndex, 1);
			}
		});
		
		if(!blockRedraw){
			this.reRenderInPosition();
		}
		
		this.regenerateRowPositions();
		
		this.dispatchExternal("rowDeleted", row.getComponent());
		
		if(!this.displayRowsCount){
			this.tableEmpty();
		}
		
		if(this.subscribedExternal("dataChanged")){
			this.dispatchExternal("dataChanged", this.getData());
		}
	}
	
	addRow(data, pos, index, blockRedraw){
		var row = this.addRowActual(data, pos, index, blockRedraw);
		return row;
	}
	
	//add multiple rows
	addRows(data, pos, index, refreshDisplayOnly){
		var rows = [];
		
		return new Promise((resolve, reject) => {
			pos = this.findAddRowPos(pos);
			
			if(!Array.isArray(data)){
				data = [data];
			}
			
			if((typeof index == "undefined" && pos) || (typeof index !== "undefined" && !pos)){
				data.reverse();
			}
			
			data.forEach((item, i) => {
				var row = this.addRow(item, pos, index, true);
				rows.push(row);
				this.dispatch("row-added", row, item, pos, index);
			});
			
			this.refreshActiveData(refreshDisplayOnly ? "displayPipeline" : false, false, true);
			
			this.regenerateRowPositions();
			
			if(this.displayRowsCount){
				this._clearPlaceholder();
			}
			
			resolve(rows);
		});
	}
	
	findAddRowPos(pos){
		if(typeof pos === "undefined"){
			pos = this.table.options.addRowPos;
		}
		
		if(pos === "pos"){
			pos = true;
		}
		
		if(pos === "bottom"){
			pos = false;
		}
		
		return pos;
	}
	
	addRowActual(data, pos, index, blockRedraw){
		var row = data instanceof Row ? data : new Row(data || {}, this),
		top = this.findAddRowPos(pos),
		allIndex = -1,
		activeIndex, chainResult;
		
		if(!index){
			chainResult = this.chain("row-adding-position", [row, top], null, {index, top});
			
			index = chainResult.index;
			top = chainResult.top;
		}
		
		if(typeof index !== "undefined"){
			index = this.findRow(index);
		}
		
		index = this.chain("row-adding-index", [row, index, top], null, index);
		
		if(index){
			allIndex = this.rows.indexOf(index);
		}
		
		if(index && allIndex > -1){
			activeIndex = this.activeRows.indexOf(index);
			
			this.displayRowIterator(function(rows){
				var displayIndex = rows.indexOf(index);
				
				if(displayIndex > -1){
					rows.splice((top ? displayIndex : displayIndex + 1), 0, row);
				}
			});
			
			if(activeIndex > -1){
				this.activeRows.splice((top ? activeIndex : activeIndex + 1), 0, row);
			}
			
			this.rows.splice((top ? allIndex : allIndex + 1), 0, row);
			
		}else {
			
			if(top){
				
				this.displayRowIterator(function(rows){
					rows.unshift(row);
				});
				
				this.activeRows.unshift(row);
				this.rows.unshift(row);
			}else {
				this.displayRowIterator(function(rows){
					rows.push(row);
				});
				
				this.activeRows.push(row);
				this.rows.push(row);
			}
		}
		
		this.setActiveRows(this.activeRows);
		
		this.dispatchExternal("rowAdded", row.getComponent());
		
		if(this.subscribedExternal("dataChanged")){
			this.dispatchExternal("dataChanged", this.table.rowManager.getData());
		}
		
		if(!blockRedraw){
			this.reRenderInPosition();
		}
		
		return row;
	}
	
	moveRow(from, to, after){
		this.dispatch("row-move", from, to, after);
		
		this.moveRowActual(from, to, after);
		
		this.regenerateRowPositions();
		
		this.dispatch("row-moved", from, to, after);
		this.dispatchExternal("rowMoved", from.getComponent());
	}
	
	moveRowActual(from, to, after){
		this.moveRowInArray(this.rows, from, to, after);
		this.moveRowInArray(this.activeRows, from, to, after);
		
		this.displayRowIterator((rows) => {
			this.moveRowInArray(rows, from, to, after);
		});
		
		this.dispatch("row-moving", from, to, after);
	}
	
	moveRowInArray(rows, from, to, after){
		var	fromIndex, toIndex, start, end;
		
		if(from !== to){
			
			fromIndex = rows.indexOf(from);
			
			if (fromIndex > -1) {
				
				rows.splice(fromIndex, 1);
				
				toIndex = rows.indexOf(to);
				
				if (toIndex > -1) {
					
					if(after){
						rows.splice(toIndex+1, 0, from);
					}else {
						rows.splice(toIndex, 0, from);
					}
					
				}else {
					rows.splice(fromIndex, 0, from);
				}
			}
			
			//restyle rows
			if(rows === this.getDisplayRows()){
				
				start = fromIndex < toIndex ? fromIndex : toIndex;
				end = toIndex > fromIndex ? toIndex : fromIndex +1;
				
				for(let i = start; i <= end; i++){
					if(rows[i]){
						this.styleRow(rows[i], i);
					}
				}
			}
		}
	}
	
	clearData(){
		this.setData([]);
	}
	
	getRowIndex(row){
		return this.findRowIndex(row, this.rows);
	}
	
	getDisplayRowIndex(row){
		var index = this.getDisplayRows().indexOf(row);
		return index > -1 ? index : false;
	}
	
	nextDisplayRow(row, rowOnly){
		var index = this.getDisplayRowIndex(row),
		nextRow = false;
		
		
		if(index !== false && index < this.displayRowsCount -1){
			nextRow = this.getDisplayRows()[index+1];
		}
		
		if(nextRow && (!(nextRow instanceof Row) || nextRow.type != "row")){
			return this.nextDisplayRow(nextRow, rowOnly);
		}
		
		return nextRow;
	}
	
	prevDisplayRow(row, rowOnly){
		var index = this.getDisplayRowIndex(row),
		prevRow = false;
		
		if(index){
			prevRow = this.getDisplayRows()[index-1];
		}
		
		if(rowOnly && prevRow && (!(prevRow instanceof Row) || prevRow.type != "row")){
			return this.prevDisplayRow(prevRow, rowOnly);
		}
		
		return prevRow;
	}
	
	findRowIndex(row, list){
		var rowIndex;
		
		row = this.findRow(row);
		
		if(row){
			rowIndex = list.indexOf(row);
			
			if(rowIndex > -1){
				return rowIndex;
			}
		}
		
		return false;
	}
	
	getData(active, transform){
		var output = [],
		rows = this.getRows(active);
		
		rows.forEach(function(row){
			if(row.type == "row"){
				output.push(row.getData(transform || "data"));
			}
		});
		
		return output;
	}
	
	getComponents(active){
		var	output = [],
		rows = this.getRows(active);
		
		rows.forEach(function(row){
			output.push(row.getComponent());
		});
		
		return output;
	}
	
	getDataCount(active){
		var rows = this.getRows(active);
		
		return rows.length;
	}
	
	scrollHorizontal(left){
		this.scrollLeft = left;
		this.element.scrollLeft = left;
		
		this.dispatch("scroll-horizontal", left);
	}
	
	registerDataPipelineHandler(handler, priority){
		if(typeof priority !== "undefined"){
			this.dataPipeline.push({handler, priority});
			this.dataPipeline.sort((a, b) => {
				return a.priority - b.priority;
			});
		}else {
			console.error("Data pipeline handlers must have a priority in order to be registered");
		}
	}
	
	registerDisplayPipelineHandler(handler, priority){
		if(typeof priority !== "undefined"){
			this.displayPipeline.push({handler, priority});
			this.displayPipeline.sort((a, b) => {
				return a.priority - b.priority;
			});
		}else {
			console.error("Display pipeline handlers must have a priority in order to be registered");
		}
	}
	
	//set active data set
	refreshActiveData(handler, skipStage, renderInPosition){
		var table = this.table,
		stage = "",
		index = 0,
		cascadeOrder = ["all", "dataPipeline", "display", "displayPipeline", "end"];
		
		if(!this.table.destroyed){
			if(typeof handler === "function"){
				index = this.dataPipeline.findIndex((item) => {
					return item.handler === handler;
				});
				
				if(index > -1){
					stage = "dataPipeline";
					
					if(skipStage){
						if(index == this.dataPipeline.length - 1){
							stage = "display";
						}else {
							index++;
						}
					}
				}else {
					index = this.displayPipeline.findIndex((item) => {
						return item.handler === handler;
					});
					
					if(index > -1){
						stage = "displayPipeline";
						
						if(skipStage){
							if(index == this.displayPipeline.length - 1){
								stage = "end";
							}else {
								index++;
							}
						}
					}else {
						console.error("Unable to refresh data, invalid handler provided", handler);
						return;
					}
				}
			}else {
				stage = handler || "all";
				index = 0;
			}
			
			if(this.redrawBlock){
				if(!this.redrawBlockRestoreConfig || (this.redrawBlockRestoreConfig && ((this.redrawBlockRestoreConfig.stage === stage && index < this.redrawBlockRestoreConfig.index) || (cascadeOrder.indexOf(stage) < cascadeOrder.indexOf(this.redrawBlockRestoreConfig.stage))))){
					this.redrawBlockRestoreConfig = {
						handler: handler,
						skipStage: skipStage,
						renderInPosition: renderInPosition,
						stage:stage,
						index:index,
					};
				}
				
				return;
			}else {
				if(Helpers.elVisible(this.element)){
					if(renderInPosition){
						this.reRenderInPosition(this.refreshPipelines.bind(this, handler, stage, index, renderInPosition));
					}else {
						this.refreshPipelines(handler, stage, index, renderInPosition);
						
						if(!handler){
							this.table.columnManager.renderer.renderColumns();
						}
						
						this.renderTable();
						
						if(table.options.layoutColumnsOnNewData){
							this.table.columnManager.redraw(true);
						}
					}
				}else {
					this.refreshPipelines(handler, stage, index, renderInPosition);
				}
				
				this.dispatch("data-refreshed");
			}
		}
	}
	
	refreshPipelines(handler, stage, index, renderInPosition){
		this.dispatch("data-refreshing");
		
		if(!handler || !this.activeRowsPipeline[0]){
			this.activeRowsPipeline[0] = this.rows.slice(0);
		}
		
		//cascade through data refresh stages
		switch(stage){
			case "all":
			//handle case where all data needs refreshing
			
			case "dataPipeline":
				for(let i = index; i < this.dataPipeline.length; i++){
					let result = this.dataPipeline[i].handler(this.activeRowsPipeline[i].slice(0));
				
					this.activeRowsPipeline[i + 1] = result || this.activeRowsPipeline[i].slice(0);
				}
			
				this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
			
			case "display":
				index = 0;
				this.resetDisplayRows();
			
			case "displayPipeline":
				for(let i = index; i < this.displayPipeline.length; i++){
					let result = this.displayPipeline[i].handler((i ? this.getDisplayRows(i - 1) : this.activeRows).slice(0), renderInPosition);
				
					this.setDisplayRows(result || this.getDisplayRows(i - 1).slice(0), i);
				}
			
			case "end":
			//case to handle scenario when trying to skip past end stage
				this.regenerateRowPositions();
		}
		
		if(this.getDisplayRows().length){
			this._clearPlaceholder();
		}
	}
	
	//regenerate row positions
	regenerateRowPositions(){
		var rows = this.getDisplayRows();
		var index = 1;
		
		rows.forEach((row) => {
			if (row.type === "row"){
				row.setPosition(index);
				index++;
			}
		});
	}
	
	setActiveRows(activeRows){
		this.activeRows = this.activeRows = Object.assign([], activeRows);
		this.activeRowsCount = this.activeRows.length;
	}
	
	//reset display rows array
	resetDisplayRows(){
		this.displayRows = [];
		
		this.displayRows.push(this.activeRows.slice(0));
		
		this.displayRowsCount = this.displayRows[0].length;
	}
	
	//set display row pipeline data
	setDisplayRows(displayRows, index){
		this.displayRows[index] = displayRows;
		
		if(index == this.displayRows.length -1){
			this.displayRowsCount = this.displayRows[this.displayRows.length -1].length;
		}
	}
	
	getDisplayRows(index){
		if(typeof index == "undefined"){
			return this.displayRows.length ? this.displayRows[this.displayRows.length -1] : [];
		}else {
			return this.displayRows[index] || [];
		}
	}
	
	getVisibleRows(chain, viewable){
		var rows =  Object.assign([], this.renderer.visibleRows(!viewable));
		
		if(chain){
			rows = this.chain("rows-visible", [viewable], rows, rows);
		}
		
		return rows;
	}
	
	//repeat action across display rows
	displayRowIterator(callback){
		this.activeRowsPipeline.forEach(callback);
		this.displayRows.forEach(callback);
		
		this.displayRowsCount = this.displayRows[this.displayRows.length -1].length;
	}
	
	//return only actual rows (not group headers etc)
	getRows(type){
		var rows = [];
		
		switch(type){
			case "active":
				rows = this.activeRows;
				break;
			
			case "display":
				rows = this.table.rowManager.getDisplayRows();
				break;
			
			case "visible":
				rows = this.getVisibleRows(false, true);
				break;
			
			default:
				rows = this.chain("rows-retrieve", type, null, this.rows) || this.rows;
		}
		
		return rows;
	}
	
	///////////////// Table Rendering /////////////////
	//trigger rerender of table in current position
	reRenderInPosition(callback){
		if(this.redrawBlock){
			if(callback){
				callback();
			}else {
				this.redrawBlockRenderInPosition = true;
			}
		}else {
			this.dispatchExternal("renderStarted");
			
			this.renderer.rerenderRows(callback);
			
			if(!this.fixedHeight){
				this.adjustTableSize();
			}
			
			this.scrollBarCheck();
			
			this.dispatchExternal("renderComplete");
		}
	}
	
	scrollBarCheck(){
		var scrollbarWidth = 0;
		
		//adjust for vertical scrollbar moving table when present
		if(this.element.scrollHeight > this.element.clientHeight){
			scrollbarWidth = this.element.offsetWidth - this.element.clientWidth;
		}
		
		if(scrollbarWidth !== this.scrollbarWidth){
			this.scrollbarWidth = scrollbarWidth;
			this.dispatch("scrollbar-vertical", scrollbarWidth);
		}
	}
	
	initializeRenderer(){
		var renderClass;
		
		var renderers = {
			"virtual": VirtualDomVertical,
			"basic": BasicVertical,
		};
		
		if(typeof this.table.options.renderVertical === "string"){
			renderClass = renderers[this.table.options.renderVertical];
		}else {
			renderClass = this.table.options.renderVertical;
		}
		
		if(renderClass){
			this.renderMode = this.table.options.renderVertical;
			
			this.renderer = new renderClass(this.table, this.element, this.tableElement);
			this.renderer.initialize();
			
			if((this.table.element.clientHeight || this.table.options.height) && !(this.table.options.minHeight && this.table.options.maxHeight)){
				this.fixedHeight = true;
			}else {
				this.fixedHeight = false;
			}
		}else {
			console.error("Unable to find matching renderer:", this.table.options.renderVertical);
		}
	}
	
	getRenderMode(){
		return this.renderMode;
	}
	
	renderTable(){
		this.dispatchExternal("renderStarted");
		
		this.element.scrollTop = 0;
		
		this._clearTable();
		
		if(this.displayRowsCount){
			this.renderer.renderRows();
			
			if(this.firstRender){
				this.firstRender = false;
				
				if(!this.fixedHeight){
					this.adjustTableSize();
				}
				
				this.layoutRefresh(true);
			}
		}else {
			this.renderEmptyScroll();
		}
		
		if(!this.fixedHeight){
			this.adjustTableSize();
		}
		
		this.dispatch("table-layout");
		
		if(!this.displayRowsCount){
			this._showPlaceholder();
		}
		
		this.scrollBarCheck();
		
		this.dispatchExternal("renderComplete");
	}
	
	//show scrollbars on empty table div
	renderEmptyScroll(){
		if(this.placeholder){
			this.tableElement.style.display = "none";
		}else {
			this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
			// this.tableElement.style.minHeight = "1px";
			// this.tableElement.style.visibility = "hidden";
		}
	}
	
	_clearTable(){	
		this._clearPlaceholder();
		
		this.scrollTop = 0;
		this.scrollLeft = 0;
		
		this.renderer.clearRows();
	}
	
	tableEmpty(){
		this.renderEmptyScroll();
		this._showPlaceholder();
	}

	checkPlaceholder(){
		if(this.displayRowsCount){
			this._clearPlaceholder();
		}else {
			this.tableEmpty();
		}
	}
	
	_showPlaceholder(){
		if(this.placeholder){
			if(this.placeholder && this.placeholder.parentNode){
				this.placeholder.parentNode.removeChild(this.placeholder);
			}
			
			this.initializePlaceholder();
			
			this.placeholder.setAttribute("tabulator-render-mode", this.renderMode);
			
			this.getElement().appendChild(this.placeholder);
			this._positionPlaceholder();

			this.adjustTableSize();
		}
	}
	
	_clearPlaceholder(){
		if(this.placeholder && this.placeholder.parentNode){
			this.placeholder.parentNode.removeChild(this.placeholder);
		}
		
		// clear empty table placeholder min
		this.tableElement.style.minWidth = "";
		this.tableElement.style.display = "";
	}
	
	_positionPlaceholder(){
		if(this.placeholder && this.placeholder.parentNode){
			this.placeholder.style.width = this.table.columnManager.getWidth() + "px";
			this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px";
			this.placeholderContents.style.marginLeft = this.scrollLeft + "px";
		}
	}
	
	styleRow(row, index){
		var rowEl = row.getElement();
		
		if(index % 2){
			rowEl.classList.add("tabulator-row-even");
			rowEl.classList.remove("tabulator-row-odd");
		}else {
			rowEl.classList.add("tabulator-row-odd");
			rowEl.classList.remove("tabulator-row-even");
		}
	}
	
	//normalize height of active rows
	normalizeHeight(){
		this.activeRows.forEach(function(row){
			row.normalizeHeight();
		});
	}
	
	//adjust the height of the table holder to fit in the Tabulator element
	adjustTableSize(){
		let initialHeight = this.element.clientHeight, minHeight;
		let resized = false;
		
		if(this.renderer.verticalFillMode === "fill"){
			let otherHeight =  Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
			
			if(this.fixedHeight){
				minHeight = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
				
				const height = "calc(100% - " + otherHeight + "px)";
				this.element.style.minHeight = minHeight || "calc(100% - " + otherHeight + "px)";
				this.element.style.height = height;
				this.element.style.maxHeight = height;
			} else {
				this.element.style.height = "";
				this.element.style.height =
				this.table.element.clientHeight - otherHeight + "px";
				this.element.scrollTop = this.scrollTop;
			}
			
			this.renderer.resize();
			
			//check if the table has changed size when dealing with variable height tables
			if(!this.fixedHeight && initialHeight != this.element.clientHeight){
				resized = true;
				if(this.subscribed("table-resize")){
					this.dispatch("table-resize");
				}else {
					this.redraw();
				}
			}
			
			this.scrollBarCheck();
		}
		
		this._positionPlaceholder();
		return resized;
	}
	
	//reinitialize all rows
	reinitialize(){
		this.rows.forEach(function(row){
			row.reinitialize(true);
		});
	}
	
	//prevent table from being redrawn
	blockRedraw (){
		this.redrawBlock = true;
		this.redrawBlockRestoreConfig = false;
	}
	
	//restore table redrawing
	restoreRedraw (){
		this.redrawBlock = false;
		
		if(this.redrawBlockRestoreConfig){
			this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition);
			
			this.redrawBlockRestoreConfig = false;
		}else {
			if(this.redrawBlockRenderInPosition){
				this.reRenderInPosition();
			}
		}
		
		this.redrawBlockRenderInPosition = false;
	}
	
	//redraw table
	redraw (force){
		this.adjustTableSize();
		this.table.tableWidth = this.table.element.clientWidth;
		
		if(!force){	
			this.reRenderInPosition();
			this.scrollHorizontal(this.scrollLeft);
		}else {
			this.renderTable();
		}
	}
	
	resetScroll(){
		this.element.scrollLeft = 0;
		this.element.scrollTop = 0;
		
		if(this.table.browser === "ie"){
			var event = document.createEvent("Event");
			event.initEvent("scroll", false, true);
			this.element.dispatchEvent(event);
		}else {
			this.element.dispatchEvent(new Event('scroll'));
		}
	}
}

class FooterManager extends CoreFeature{

	constructor(table){
		super(table);

		this.active = false;
		this.element = this.createElement(); //containing element
		this.containerElement = this.createContainerElement(); //containing element
		this.external = false;
	}

	initialize(){
		this.initializeElement();
	}

	createElement(){
		var el = document.createElement("div");

		el.classList.add("tabulator-footer");

		return el;
	}

	
	createContainerElement(){
		var el = document.createElement("div");

		el.classList.add("tabulator-footer-contents");

		this.element.appendChild(el);

		return el;
	}

	initializeElement(){
		if(this.table.options.footerElement){

			switch(typeof this.table.options.footerElement){
				case "string":
					if(this.table.options.footerElement[0] === "<"){
						this.containerElement.innerHTML = this.table.options.footerElement;
					}else {
						this.external = true;
						this.containerElement = document.querySelector(this.table.options.footerElement);
					}
					break;

				default:
					this.element = this.table.options.footerElement;
					break;
			}
		}
	}

	getElement(){
		return this.element;
	}

	append(element){
		this.activate();

		this.containerElement.appendChild(element);
		this.table.rowManager.adjustTableSize();
	}

	prepend(element){
		this.activate();

		this.element.insertBefore(element, this.element.firstChild);
		this.table.rowManager.adjustTableSize();
	}

	remove(element){
		element.parentNode.removeChild(element);
		this.deactivate();
	}

	deactivate(force){
		if(!this.element.firstChild || force){
			if(!this.external){
				this.element.parentNode.removeChild(this.element);
			}
			this.active = false;
		}
	}

	activate(){
		if(!this.active){
			this.active = true;
			if(!this.external){
				this.table.element.appendChild(this.getElement());
				this.table.element.style.display = '';
			}
		}
	}

	redraw(){
		this.dispatch("footer-redraw");
	}
}

class InteractionManager extends CoreFeature {
	
	constructor (table){
		super(table);
		
		this.el = null;
		
		this.abortClasses = ["tabulator-headers", "tabulator-table"];
		
		this.previousTargets = {};
		
		this.listeners = [
			"click",
			"dblclick",
			"contextmenu",
			"mouseenter",
			"mouseleave",
			"mouseover",
			"mouseout",
			"mousemove",
			"mouseup",
			"mousedown",
			"touchstart",
			"touchend",
		];
		
		this.componentMap = {
			"tabulator-cell":"cell",
			"tabulator-row":"row",
			"tabulator-group":"group",
			"tabulator-col":"column",
		};
		
		this.pseudoTrackers = {
			"row":{
				subscriber:null,
				target:null,
			},
			"cell":{
				subscriber:null,
				target:null,
			},
			"group":{
				subscriber:null,
				target:null,
			},
			"column":{
				subscriber:null,
				target:null,
			},
		};
		
		this.pseudoTracking = false;
	}
	
	initialize(){
		this.el = this.table.element;
		
		this.buildListenerMap();
		this.bindSubscriptionWatchers();
	}
	
	buildListenerMap(){
		var listenerMap = {};
		
		this.listeners.forEach((listener) => {
			listenerMap[listener] = {
				handler:null,
				components:[],
			};
		});
		
		this.listeners = listenerMap;
	}
	
	bindPseudoEvents(){
		Object.keys(this.pseudoTrackers).forEach((key) => {
			this.pseudoTrackers[key].subscriber = this.pseudoMouseEnter.bind(this, key);
			this.subscribe(key + "-mouseover", this.pseudoTrackers[key].subscriber);
		});
		
		this.pseudoTracking = true;
	}
	
	pseudoMouseEnter(key, e, target){
		if(this.pseudoTrackers[key].target !== target){
			
			if(this.pseudoTrackers[key].target){
				this.dispatch(key + "-mouseleave", e, this.pseudoTrackers[key].target);
			}
			
			this.pseudoMouseLeave(key, e);
			
			this.pseudoTrackers[key].target = target;
			
			this.dispatch(key + "-mouseenter", e, target);
		}
	}
	
	pseudoMouseLeave(key, e){
		var leaveList = Object.keys(this.pseudoTrackers),
		linkedKeys = {
			"row":["cell"],
			"cell":["row"],
		};
		
		leaveList = leaveList.filter((item) => {
			var links = linkedKeys[key];
			return item !== key && (!links || (links && !links.includes(item)));
		});
		
		
		leaveList.forEach((key) => {
			var target = this.pseudoTrackers[key].target;
			
			if(this.pseudoTrackers[key].target){
				this.dispatch(key + "-mouseleave", e, target);
				
				this.pseudoTrackers[key].target = null;
			}
		});
	}
	
	
	bindSubscriptionWatchers(){
		var listeners = Object.keys(this.listeners),
		components = Object.values(this.componentMap);
		
		for(let comp of components){
			for(let listener of listeners){
				let key = comp + "-" + listener;
				
				this.subscriptionChange(key, this.subscriptionChanged.bind(this, comp, listener));
			}
		}
		
		this.subscribe("table-destroy", this.clearWatchers.bind(this));
	}
	
	subscriptionChanged(component, key, added){
		var listener = this.listeners[key].components,
		index = listener.indexOf(component),
		changed = false;
		
		if(added){
			if(index === -1){
				listener.push(component);
				changed = true;
			}
		}else {
			if(!this.subscribed(component + "-" + key)){
				if(index > -1){
					listener.splice(index, 1);
					changed = true;
				}
			}
		}
		
		if((key === "mouseenter" || key === "mouseleave") && !this.pseudoTracking){
			this.bindPseudoEvents();
		}
		
		if(changed){
			this.updateEventListeners();
		}
	}
	
	updateEventListeners(){
		for(let key in this.listeners){
			let listener = this.listeners[key];
			
			if(listener.components.length){
				if(!listener.handler){
					listener.handler = this.track.bind(this, key);
					this.el.addEventListener(key, listener.handler);
					// this.el.addEventListener(key, listener.handler, {passive: true})
				}
			}else {
				if(listener.handler){
					this.el.removeEventListener(key, listener.handler);
					listener.handler = null;
				}
			}
		}
	}
	
	track(type, e){
		var path = (e.composedPath && e.composedPath()) || e.path;
		
		var targets = this.findTargets(path);
		targets = this.bindComponents(type, targets);
		
		this.triggerEvents(type, e, targets);
		
		if(this.pseudoTracking && (type == "mouseover" || type == "mouseleave") && !Object.keys(targets).length){
			this.pseudoMouseLeave("none", e);
		}
	}
	
	findTargets(path){
		var targets = {};
		
		let componentMap = Object.keys(this.componentMap);
		
		for (let el of path) {
			let classList = el.classList ? [...el.classList] : [];
			
			let abort = classList.filter((item) => {
				return this.abortClasses.includes(item);
			});
			
			if(abort.length){
				break;
			}
			
			let elTargets = classList.filter((item) => {
				return componentMap.includes(item);
			});
			
			for (let target of elTargets) {
				if(!targets[this.componentMap[target]]){
					targets[this.componentMap[target]] = el;
				}
			}
		}

		if(targets.group && targets.group === targets.row){
			delete targets.row;
		}

		return targets;
	}
	
	bindComponents(type, targets){
		//ensure row component is looked up before cell
		var keys = Object.keys(targets).reverse(),
		listener = this.listeners[type],
		matches = {},
		targetMatches = {};
		
		for(let key of keys){
			let component,
			target = targets[key],
			previousTarget = this.previousTargets[key];
			
			if(previousTarget && previousTarget.target === target){
				component = previousTarget.component;
			}else {
				switch(key){
					case "row":
					case "group":
						if(listener.components.includes("row") || listener.components.includes("cell") || listener.components.includes("group")){
							let rows = this.table.rowManager.getVisibleRows(true);
						
							component = rows.find((row) => {
								return row.getElement() === target;
							});
						
							if(targets["row"] && targets["row"].parentNode && targets["row"].parentNode.closest(".tabulator-row")){
								targets[key] = false;
							}
						}
						break;
					
					case "column":
						if(listener.components.includes("column")){
							component = this.table.columnManager.findColumn(target);
						}
						break;
					
					case "cell":
						if(listener.components.includes("cell")){
							if(matches["row"] instanceof Row){
								component = matches["row"].findCell(target);
							}else {	
								if(targets["row"]){
									console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?");
								}
							}
						}
						break;
				}
			}
			
			if(component){
				matches[key] = component;
				targetMatches[key] = {
					target:target,
					component:component,
				};
			}
		}
		
		this.previousTargets = targetMatches;
		
		return matches;
	}
	
	triggerEvents(type, e, targets){
		var listener = this.listeners[type];

		for(let key in targets){
			if(targets[key] && listener.components.includes(key)){
				this.dispatch(key + "-" + type, e, targets[key]);
			}
		}
	}
	
	clearWatchers(){
		for(let key in this.listeners){
			let listener = this.listeners[key];
			
			if(listener.handler){
				this.el.removeEventListener(key, listener.handler);
				listener.handler = null;
			}
		}
	}
}

class ComponentFunctionBinder{

	constructor(table){
		this.table = table;

		this.bindings = {};
	}

	bind(type, funcName, handler){
		if(!this.bindings[type]){
			this.bindings[type] = {};
		}

		if(this.bindings[type][funcName]){
			console.warn("Unable to bind component handler, a matching function name is already bound", type, funcName, handler);
		}else {
			this.bindings[type][funcName] = handler;
		}
	}

	handle(type, component, name){
		if(this.bindings[type] && this.bindings[type][name] && typeof this.bindings[type][name].bind === 'function'){
			return this.bindings[type][name].bind(null, component);
		}else {
			if(name !== "then" && typeof name === "string" && !name.startsWith("_")){
				if(this.table.options.debugInvalidComponentFuncs){
					console.error("The " + type + " component does not have a " + name + " function, have you checked that you have the correct Tabulator module installed?");
				}
			}
		}
	}
}

class DataLoader extends CoreFeature{
	constructor(table){
		super(table);
		
		this.requestOrder = 0; //prevent requests coming out of sequence if overridden by another load request
		this.loading = false;
	}
	
	initialize(){}
	
	load(data, params, config, replace, silent, columnsChanged){
		var requestNo = ++this.requestOrder;

		if(this.table.destroyed){
			return Promise.resolve();
		}
		
		this.dispatchExternal("dataLoading", data);
		
		//parse json data to array
		if (data && (data.indexOf("{") == 0 || data.indexOf("[") == 0)){
			data = JSON.parse(data);
		}
		
		if(this.confirm("data-loading", [data, params, config, silent])){
			this.loading = true;
			
			if(!silent){
				this.alertLoader();
			}
			
			//get params for request
			params = this.chain("data-params", [data, config, silent], params || {}, params || {});
			
			params = this.mapParams(params, this.table.options.dataSendParams);
			
			var result = this.chain("data-load", [data, params, config, silent], false, Promise.resolve([]));
			
			return result.then((response) => {
				if(!this.table.destroyed){
					if(!Array.isArray(response) && typeof response == "object"){
						response = this.mapParams(response, this.objectInvert(this.table.options.dataReceiveParams));
					}
					
					var rowData = this.chain("data-loaded", response, null, response);
					
					if(requestNo == this.requestOrder){
						this.clearAlert();
						
						if(rowData !== false){
							this.dispatchExternal("dataLoaded", rowData);
							this.table.rowManager.setData(rowData,  replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
						}
					}else {
						console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
					}
				}else {
					console.warn("Data Load Response Blocked - Table has been destroyed");
				}
			}).catch((error) => {
				console.error("Data Load Error: ", error);
				this.dispatchExternal("dataLoadError", error);
				
				if(!silent){
					this.alertError();
				}
				
				setTimeout(() => {
					this.clearAlert();
				}, this.table.options.dataLoaderErrorTimeout);
			})
				.finally(() => {
					this.loading = false;
				});
		}else {
			this.dispatchExternal("dataLoaded", data);
			
			if(!data){
				data = [];
			}
			
			this.table.rowManager.setData(data, replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
			return Promise.resolve();
		}
	}
	
	mapParams(params, map){
		var output = {};
		
		for(let key in params){
			output[map.hasOwnProperty(key) ? map[key] : key] = params[key];
		}
		
		return output;
	}
	
	objectInvert(obj){
		var output = {};
		
		for(let key in obj){
			output[obj[key]] = key;
		}
		
		return output;
	}
	
	blockActiveLoad(){
		this.requestOrder++;
	}
	
	alertLoader(){
		var shouldLoad = typeof this.table.options.dataLoader === "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
		
		if(shouldLoad){
			this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
		}
	}
	
	alertError(){
		this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
	}
	
	clearAlert(){
		this.table.alertManager.clear();
	}
}

class ExternalEventBus {

	constructor(table, optionsList, debug){
		this.table = table;
		this.events = {};
		this.optionsList = optionsList || {};
		this.subscriptionNotifiers = {};

		this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
		this.debug = debug;
	}

	subscriptionChange(key, callback){
		if(!this.subscriptionNotifiers[key]){
			this.subscriptionNotifiers[key] = [];
		}

		this.subscriptionNotifiers[key].push(callback);

		if(this.subscribed(key)){
			this._notifySubscriptionChange(key, true);
		}
	}

	subscribe(key, callback){
		if(!this.events[key]){
			this.events[key] = [];
		}

		this.events[key].push(callback);

		this._notifySubscriptionChange(key, true);
	}

	unsubscribe(key, callback){
		var index;

		if(this.events[key]){
			if(callback){
				index = this.events[key].findIndex((item) => {
					return item === callback;
				});

				if(index > -1){
					this.events[key].splice(index, 1);
				}else {
					console.warn("Cannot remove event, no matching event found:", key, callback);
					return;
				}
			}else {
				delete this.events[key];
			}
		}else {
			console.warn("Cannot remove event, no events set on:", key);
			return;
		}

		this._notifySubscriptionChange(key, false);
	}

	subscribed(key){
		return this.events[key] && this.events[key].length;
	}

	_notifySubscriptionChange(key, subscribed){
		var notifiers = this.subscriptionNotifiers[key];

		if(notifiers){
			notifiers.forEach((callback)=>{
				callback(subscribed);
			});
		}
	}

	_dispatch(){
		var args = Array.from(arguments),
		key = args.shift(),
		result;

		if(this.events[key]){
			this.events[key].forEach((callback, i) => {
				let callResult = callback.apply(this.table, args);

				if(!i){
					result = callResult;
				}
			});
		}

		return result;
	}

	_debugDispatch(){
		var args = Array.from(arguments),
		key = args[0];

		args[0] = "ExternalEvent:" + args[0];

		if(this.debug === true || this.debug.includes(key)){
			console.log(...args);
		}

		return this._dispatch(...arguments);
	}
}

class InternalEventBus {

	constructor(debug){
		this.events = {};
		this.subscriptionNotifiers = {};

		this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
		this.chain = debug ? this._debugChain.bind(this) : this._chain.bind(this);
		this.confirm = debug ? this._debugConfirm.bind(this) : this._confirm.bind(this);
		this.debug = debug;
	}

	subscriptionChange(key, callback){
		if(!this.subscriptionNotifiers[key]){
			this.subscriptionNotifiers[key] = [];
		}

		this.subscriptionNotifiers[key].push(callback);

		if(this.subscribed(key)){
			this._notifySubscriptionChange(key, true);
		}
	}

	subscribe(key, callback, priority = 10000){
		if(!this.events[key]){
			this.events[key] = [];
		}

		this.events[key].push({callback, priority});

		this.events[key].sort((a, b) => {
			return a.priority - b.priority;
		});

		this._notifySubscriptionChange(key, true);
	}

	unsubscribe(key, callback){
		var index;

		if(this.events[key]){
			if(callback){
				index = this.events[key].findIndex((item) => {
					return item.callback === callback;
				});

				if(index > -1){
					this.events[key].splice(index, 1);
				}else {
					console.warn("Cannot remove event, no matching event found:", key, callback);
					return;
				}
			}
		}else {
			console.warn("Cannot remove event, no events set on:", key);
			return;
		}

		this._notifySubscriptionChange(key, false);
	}

	subscribed(key){
		return this.events[key] && this.events[key].length;
	}

	_chain(key, args, initialValue, fallback){
		var value = initialValue;

		if(!Array.isArray(args)){
			args = [args];
		}

		if(this.subscribed(key)){
			this.events[key].forEach((subscriber, i) => {
				value = subscriber.callback.apply(this, args.concat([value]));
			});

			return value;
		}else {
			return typeof fallback === "function" ? fallback() : fallback;
		}
	}

	_confirm(key, args){
		var confirmed = false;

		if(!Array.isArray(args)){
			args = [args];
		}

		if(this.subscribed(key)){
			this.events[key].forEach((subscriber, i) => {
				if(subscriber.callback.apply(this, args)){
					confirmed = true;
				}
			});
		}

		return confirmed;
	}

	_notifySubscriptionChange(key, subscribed){
		var notifiers = this.subscriptionNotifiers[key];

		if(notifiers){
			notifiers.forEach((callback)=>{
				callback(subscribed);
			});
		}
	}

	_dispatch(){
		var args = Array.from(arguments),
		key = args.shift();

		if(this.events[key]){
			this.events[key].forEach((subscriber) => {
				subscriber.callback.apply(this, args);
			});
		}
	}

	_debugDispatch(){
		var args = Array.from(arguments),
		key = args[0];

		args[0] = "InternalEvent:" + key;

		if(this.debug === true || this.debug.includes(key)){
			console.log(...args);
		}

		return this._dispatch(...arguments);
	}

	_debugChain(){
		var args = Array.from(arguments),
		key = args[0];

		args[0] = "InternalEvent:" + key;

		if(this.debug === true || this.debug.includes(key)){
			console.log(...args);
		}

		return this._chain(...arguments);
	}

	_debugConfirm(){
		var args = Array.from(arguments),
		key = args[0];

		args[0] = "InternalEvent:" + key;

		if(this.debug === true || this.debug.includes(key)){
			console.log(...args);
		}

		return this._confirm(...arguments);
	}
}

class DeprecationAdvisor extends CoreFeature{
	
	constructor(table){
		super(table);
	}
	
	_warnUser(){
		if(this.options("debugDeprecation")){
			console.warn(...arguments);
		}
	}
	
	check(oldOption, newOption, convert){
		var msg = "";
		
		if(typeof this.options(oldOption) !== "undefined"){
			msg = "Deprecated Setup Option - Use of the %c" + oldOption + "%c option is now deprecated";
			
			if(newOption){
				msg = msg + ", Please use the %c" + newOption + "%c option instead";
				this._warnUser(msg, 'font-weight: bold;', 'font-weight: normal;', 'font-weight: bold;', 'font-weight: normal;');

				if(convert){
					this.table.options[newOption] = this.table.options[oldOption];
				}
			}else {
				this._warnUser(msg, 'font-weight: bold;', 'font-weight: normal;');
			}
			
			return false;
		}else {
			return true;
		}
	}
	
	checkMsg(oldOption, msg){
		if(typeof this.options(oldOption) !== "undefined"){
			this._warnUser("%cDeprecated Setup Option - Use of the %c" + oldOption + " %c option is now deprecated, " + msg, 'font-weight: normal;', 'font-weight: bold;', 'font-weight: normal;');
			
			return false;
		}else {
			return true;
		}
	}
	
	msg(msg){
		this._warnUser(msg);
	}
}

class TableRegistry {

	static register(table){
		TableRegistry.tables.push(table);
	}

	static deregister(table){
		var index = TableRegistry.tables.indexOf(table);

		if(index > -1){
			TableRegistry.tables.splice(index, 1);
		}
	}

	static lookupTable(query, silent){
		var results = [],
		matches, match;

		if(typeof query === "string"){
			matches = document.querySelectorAll(query);

			if(matches.length){
				for(var i = 0; i < matches.length; i++){
					match = TableRegistry.matchElement(matches[i]);

					if(match){
						results.push(match);
					}
				}
			}

		}else if((typeof HTMLElement !== "undefined" && query instanceof HTMLElement) || query instanceof Tabulator){
			match = TableRegistry.matchElement(query);

			if(match){
				results.push(match);
			}
		}else if(Array.isArray(query)){
			query.forEach(function(item){
				results = results.concat(TableRegistry.lookupTable(item));
			});
		}else {
			if(!silent){
				console.warn("Table Connection Error - Invalid Selector", query);
			}
		}

		return results;
	}

	static matchElement(element){
		return TableRegistry.tables.find(function(table){
			return element instanceof Tabulator ? table === element : table.element === element;
		});
	}
}

TableRegistry.tables = [];

//resize columns to fit data they contain
function fitData(columns, forced){
	if(forced){
		this.table.columnManager.renderer.reinitializeColumnWidths(columns);
	}
	
	if(this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)){
		this.table.modules.responsiveLayout.update();
	}
}

//resize columns to fit data they contain and stretch row to fill table, also used for fitDataTable
function fitDataGeneral(columns, forced){
	columns.forEach(function(column){
		column.reinitializeWidth();
	});

	if(this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)){
		this.table.modules.responsiveLayout.update();
	}
}

//resize columns to fit data the contain and stretch last column to fill table
function fitDataStretch(columns, forced){
	var colsWidth = 0,
	tableWidth = this.table.rowManager.element.clientWidth,
	gap = 0,
	lastCol = false;

	columns.forEach((column, i) => {
		if(!column.widthFixed){
			column.reinitializeWidth();
		}

		if(this.table.options.responsiveLayout ? column.modules.responsive.visible : column.visible){
			lastCol = column;
		}

		if(column.visible){
			colsWidth += column.getWidth();
		}
	});

	if(lastCol){
		gap = tableWidth - colsWidth + lastCol.getWidth();

		if(this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)){
			lastCol.setWidth(0);
			this.table.modules.responsiveLayout.update();
		}

		if(gap > 0){
			lastCol.setWidth(gap);
		}else {
			lastCol.reinitializeWidth();
		}
	}else {
		if(this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)){
			this.table.modules.responsiveLayout.update();
		}
	}
}

//resize columns to fit
function fitColumns(columns, forced){
	var totalWidth = this.table.rowManager.element.getBoundingClientRect().width; //table element width
	var fixedWidth = 0; //total width of columns with a defined width
	var flexWidth = 0; //total width available to flexible columns
	var flexGrowUnits = 0; //total number of widthGrow blocks across all columns
	var flexColWidth = 0; //desired width of flexible columns
	var flexColumns = []; //array of flexible width columns
	var fixedShrinkColumns = []; //array of fixed width columns that can shrink
	var flexShrinkUnits = 0; //total number of widthShrink blocks across all columns
	var overflowWidth = 0; //horizontal overflow width
	var gapFill = 0; //number of pixels to be added to final column to close and half pixel gaps

	function calcWidth(width){
		var colWidth;

		if(typeof(width) == "string"){
			if(width.indexOf("%") > -1){
				colWidth = (totalWidth / 100) * parseInt(width);
			}else {
				colWidth = parseInt(width);
			}
		}else {
			colWidth = width;
		}

		return colWidth;
	}

	//ensure columns resize to take up the correct amount of space
	function scaleColumns(columns, freeSpace, colWidth, shrinkCols){
		var oversizeCols = [],
		oversizeSpace = 0,
		remainingSpace = 0,
		nextColWidth = 0,
		remainingFlexGrowUnits = flexGrowUnits,
		gap = 0,
		changeUnits = 0,
		undersizeCols = [];

		function calcGrow(col){
			return (colWidth * (col.column.definition.widthGrow || 1));
		}

		function calcShrink(col){
			return  (calcWidth(col.width) - (colWidth * (col.column.definition.widthShrink || 0)));
		}

		columns.forEach(function(col, i){
			var width = shrinkCols ? calcShrink(col) : calcGrow(col);
			if(col.column.minWidth >= width){
				oversizeCols.push(col);
			}else {
				if(col.column.maxWidth && col.column.maxWidth < width){
					col.width = col.column.maxWidth;
					freeSpace -= col.column.maxWidth;

					remainingFlexGrowUnits -= shrinkCols ? (col.column.definition.widthShrink || 1) : (col.column.definition.widthGrow || 1);

					if(remainingFlexGrowUnits){
						colWidth = Math.floor(freeSpace/remainingFlexGrowUnits);
					}
				}else {
					undersizeCols.push(col);
					changeUnits += shrinkCols ? (col.column.definition.widthShrink || 1) : (col.column.definition.widthGrow || 1);
				}
			}
		});

		if(oversizeCols.length){
			oversizeCols.forEach(function(col){
				oversizeSpace += shrinkCols ?  col.width - col.column.minWidth : col.column.minWidth;
				col.width = col.column.minWidth;
			});

			remainingSpace = freeSpace - oversizeSpace;

			nextColWidth = changeUnits ? Math.floor(remainingSpace/changeUnits) : remainingSpace;

			gap = scaleColumns(undersizeCols, remainingSpace, nextColWidth, shrinkCols);
		}else {
			gap = changeUnits ? freeSpace - (Math.floor(freeSpace/changeUnits) * changeUnits) : freeSpace;

			undersizeCols.forEach(function(column){
				column.width = shrinkCols ? calcShrink(column) : calcGrow(column);
			});
		}

		return gap;
	}

	if(this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)){
		this.table.modules.responsiveLayout.update();
	}

	//adjust for vertical scrollbar if present
	if(this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight){
		totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
	}

	columns.forEach(function(column){
		var width, minWidth, colWidth;

		if(column.visible){

			width = column.definition.width;
			minWidth =  parseInt(column.minWidth);

			if(width){

				colWidth = calcWidth(width);

				fixedWidth += colWidth > minWidth ? colWidth : minWidth;

				if(column.definition.widthShrink){
					fixedShrinkColumns.push({
						column:column,
						width:colWidth > minWidth ? colWidth : minWidth
					});
					flexShrinkUnits += column.definition.widthShrink;
				}

			}else {
				flexColumns.push({
					column:column,
					width:0,
				});
				flexGrowUnits += column.definition.widthGrow || 1;
			}
		}
	});

	//calculate available space
	flexWidth = totalWidth - fixedWidth;

	//calculate correct column size
	flexColWidth = Math.floor(flexWidth / flexGrowUnits);

	//generate column widths
	gapFill = scaleColumns(flexColumns, flexWidth, flexColWidth, false);

	//increase width of last column to account for rounding errors
	if(flexColumns.length && gapFill > 0){
		flexColumns[flexColumns.length-1].width += gapFill;
	}

	//calculate space for columns to be shrunk into
	flexColumns.forEach(function(col){
		flexWidth -= col.width;
	});

	overflowWidth = Math.abs(gapFill) + flexWidth;

	//shrink oversize columns if there is no available space
	if(overflowWidth > 0 && flexShrinkUnits){
		gapFill = scaleColumns(fixedShrinkColumns, overflowWidth, Math.floor(overflowWidth / flexShrinkUnits), true);
	}

	//decrease width of last column to account for rounding errors
	if(gapFill && fixedShrinkColumns.length){
		fixedShrinkColumns[fixedShrinkColumns.length-1].width -= gapFill;
	}

	flexColumns.forEach(function(col){
		col.column.setWidth(col.width);
	});

	fixedShrinkColumns.forEach(function(col){
		col.column.setWidth(col.width);
	});
}

var defaultModes = {
	fitData:fitData,
	fitDataFill:fitDataGeneral,
	fitDataTable:fitDataGeneral,
	fitDataStretch:fitDataStretch,
	fitColumns:fitColumns ,
};

class Layout extends Module{

	constructor(table){
		super(table, "layout");

		this.mode = null;

		this.registerTableOption("layout", "fitData"); //layout type
		this.registerTableOption("layoutColumnsOnNewData", false); //update column widths on setData

		this.registerColumnOption("widthGrow");
		this.registerColumnOption("widthShrink");
	}

	//initialize layout system
	initialize(){
		var layout = this.table.options.layout;

		if(Layout.modes[layout]){
			this.mode = layout;
		}else {
			console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + layout);
			this.mode = 'fitData';
		}

		this.table.element.setAttribute("tabulator-layout", this.mode);
		this.subscribe("column-init", this.initializeColumn.bind(this));
	}

	initializeColumn(column){
		if(column.definition.widthGrow){
			column.definition.widthGrow = Number(column.definition.widthGrow);
		}
		if(column.definition.widthShrink){
			column.definition.widthShrink = Number(column.definition.widthShrink);
		}
	}

	getMode(){
		return this.mode;
	}

	//trigger table layout
	layout(dataChanged){
		this.dispatch("layout-refreshing");
		Layout.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, dataChanged);
		this.dispatch("layout-refreshed");
	}
}

Layout.moduleName = "layout";

//load defaults
Layout.modes = defaultModes;

var defaultLangs = {
	"default":{ //hold default locale text
		"groups":{
			"item":"item",
			"items":"items",
		},
		"columns":{
		},
		"data":{
			"loading":"Loading",
			"error":"Error",
		},
		"pagination":{
			"page_size":"Page Size",
			"page_title":"Show Page",
			"first":"First",
			"first_title":"First Page",
			"last":"Last",
			"last_title":"Last Page",
			"prev":"Prev",
			"prev_title":"Prev Page",
			"next":"Next",
			"next_title":"Next Page",
			"all":"All",
			"counter":{
				"showing": "Showing",
				"of": "of",
				"rows": "rows",
				"pages": "pages",
			}
		},
		"headerFilters":{
			"default":"filter column...",
			"columns":{}
		}
	},
};

class Localize extends Module{

	constructor(table){
		super(table);

		this.locale = "default"; //current locale
		this.lang = false; //current language
		this.bindings = {}; //update events to call when locale is changed
		this.langList = {};

		this.registerTableOption("locale", false); //current system language
		this.registerTableOption("langs", {});
	}

	initialize(){
		this.langList = Helpers.deepClone(Localize.langs);

		if(this.table.options.columnDefaults.headerFilterPlaceholder !== false){
			this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
		}

		for(let locale in this.table.options.langs){
			this.installLang(locale, this.table.options.langs[locale]);
		}

		this.setLocale(this.table.options.locale);

		this.registerTableFunction("setLocale", this.setLocale.bind(this));
		this.registerTableFunction("getLocale", this.getLocale.bind(this));
		this.registerTableFunction("getLang", this.getLang.bind(this));
	}

	//set header placeholder
	setHeaderFilterPlaceholder(placeholder){
		this.langList.default.headerFilters.default = placeholder;
	}

	//setup a lang description object
	installLang(locale, lang){
		if(this.langList[locale]){
			this._setLangProp(this.langList[locale], lang);
		}else {
			this.langList[locale] = lang;
		}
	}

	_setLangProp(lang, values){
		for(let key in values){
			if(lang[key] && typeof lang[key] == "object"){
				this._setLangProp(lang[key], values[key]);
			}else {
				lang[key] = values[key];
			}
		}
	}

	//set current locale
	setLocale(desiredLocale){
		desiredLocale = desiredLocale || "default";

		//fill in any matching language values
		function traverseLang(trans, path){
			for(var prop in trans){
				if(typeof trans[prop] == "object"){
					if(!path[prop]){
						path[prop] = {};
					}
					traverseLang(trans[prop], path[prop]);
				}else {
					path[prop] = trans[prop];
				}
			}
		}

		//determining correct locale to load
		if(desiredLocale === true && navigator.language){
			//get local from system
			desiredLocale = navigator.language.toLowerCase();
		}

		if(desiredLocale){
			//if locale is not set, check for matching top level locale else use default
			if(!this.langList[desiredLocale]){
				let prefix = desiredLocale.split("-")[0];

				if(this.langList[prefix]){
					console.warn("Localization Error - Exact matching locale not found, using closest match: ", desiredLocale, prefix);
					desiredLocale = prefix;
				}else {
					console.warn("Localization Error - Matching locale not found, using default: ", desiredLocale);
					desiredLocale = "default";
				}
			}
		}

		this.locale = desiredLocale;

		//load default lang template
		this.lang = Helpers.deepClone(this.langList.default || {});

		if(desiredLocale != "default"){
			traverseLang(this.langList[desiredLocale], this.lang);
		}

		this.dispatchExternal("localized", this.locale, this.lang);

		this._executeBindings();
	}

	//get current locale
	getLocale(locale){
		return this.locale;
	}

	//get lang object for given local or current if none provided
	getLang(locale){
		return locale ? this.langList[locale] : this.lang;
	}

	//get text for current locale
	getText(path, value){
		var fillPath = value ? path + "|" + value : path,
		pathArray = fillPath.split("|"),
		text = this._getLangElement(pathArray, this.locale);

		// if(text === false){
		// 	console.warn("Localization Error - Matching localized text not found for given path: ", path);
		// }

		return text || "";
	}

	//traverse langs object and find localized copy
	_getLangElement(path, locale){
		var root = this.lang;

		path.forEach(function(level){
			var rootPath;

			if(root){
				rootPath = root[level];

				if(typeof rootPath != "undefined"){
					root = rootPath;
				}else {
					root = false;
				}
			}
		});

		return root;
	}

	//set update binding
	bind(path, callback){
		if(!this.bindings[path]){
			this.bindings[path] = [];
		}

		this.bindings[path].push(callback);

		callback(this.getText(path), this.lang);
	}

	//iterate through bindings and trigger updates
	_executeBindings(){
		for(let path in this.bindings){
			this.bindings[path].forEach((binding) => {
				binding(this.getText(path), this.lang);
			});
		}
	}
}

Localize.moduleName = "localize";

//load defaults
Localize.langs = defaultLangs;

class Comms extends Module{

	constructor(table){
		super(table);
	}

	initialize(){
		this.registerTableFunction("tableComms", this.receive.bind(this));
	}

	getConnections(selectors){
		var connections = [],
		connection;

		connection = TableRegistry.lookupTable(selectors);

		connection.forEach((con) =>{
			if(this.table !== con){
				connections.push(con);
			}
		});

		return connections;
	}

	send(selectors, module, action, data){
		var connections = this.getConnections(selectors);

		connections.forEach((connection) => {
			connection.tableComms(this.table.element, module, action, data);
		});

		if(!connections.length && selectors){
			console.warn("Table Connection Error - No tables matching selector found", selectors);
		}
	}

	receive(table, module, action, data){
		if(this.table.modExists(module)){
			return this.table.modules[module].commsReceived(table, action, data);
		}else {
			console.warn("Inter-table Comms Error - no such module:", module);
		}
	}
}

Comms.moduleName = "comms";

var coreModules = /*#__PURE__*/Object.freeze({
	__proto__: null,
	LayoutModule: Layout,
	LocalizeModule: Localize,
	CommsModule: Comms
});

class ModuleBinder {
	
	constructor(tabulator, modules){
		this.bindStaticFunctionality(tabulator);
		this.bindModules(tabulator, coreModules, true);
		
		if(modules){
			this.bindModules(tabulator, modules);
		}
	}
	
	bindStaticFunctionality(tabulator){
		tabulator.moduleBindings = {};
		
		tabulator.extendModule = function(name, property, values){
			if(tabulator.moduleBindings[name]){
				var source = tabulator.moduleBindings[name][property];
				
				if(source){
					if(typeof values == "object"){
						for(let key in values){
							source[key] = values[key];
						}
					}else {
						console.warn("Module Error - Invalid value type, it must be an object");
					}
				}else {
					console.warn("Module Error - property does not exist:", property);
				}
			}else {
				console.warn("Module Error - module does not exist:", name);
			}
		};
		
		tabulator.registerModule = function(modules){
			if(!Array.isArray(modules)){
				modules = [modules];
			}
			
			modules.forEach((mod) => {
				tabulator.registerModuleBinding(mod);
			});
		};
		
		tabulator.registerModuleBinding = function(mod){
			tabulator.moduleBindings[mod.moduleName] = mod;
		};
		
		tabulator.findTable = function(query){
			var results = TableRegistry.lookupTable(query, true);
			return Array.isArray(results) && !results.length ? false : results;
		};
		
		//ensure that module are bound to instantiated function
		tabulator.prototype.bindModules = function(){
			var orderedStartMods = [],
			orderedEndMods = [],
			unOrderedMods = [];
			
			this.modules = {};
			
			for(var name in tabulator.moduleBindings){
				let mod = tabulator.moduleBindings[name];
				let module = new mod(this);
				
				this.modules[name] = module;
				
				if(mod.prototype.moduleCore){
					this.modulesCore.push(module);
				}else {
					if(mod.moduleInitOrder){
						if(mod.moduleInitOrder < 0){
							orderedStartMods.push(module);
						}else {
							orderedEndMods.push(module);
						}
						
					}else {
						unOrderedMods.push(module);
					}
				}
			}
			
			orderedStartMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
			orderedEndMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
			
			this.modulesRegular = orderedStartMods.concat(unOrderedMods.concat(orderedEndMods));
		};
	}
	
	bindModules(tabulator, modules, core){
		var mods = Object.values(modules);
		
		if(core){
			mods.forEach((mod) => {
				mod.prototype.moduleCore = true;
			});
		}
		
		tabulator.registerModule(mods);
	}
}

class Alert extends CoreFeature{
	constructor(table){
		super(table);
        
		this.element = this._createAlertElement();
		this.msgElement = this._createMsgElement();
		this.type = null;
        
		this.element.appendChild(this.msgElement);
	}
    
	_createAlertElement(){
		var el = document.createElement("div");
		el.classList.add("tabulator-alert");
		return el;
	}
    
	_createMsgElement(){
		var el = document.createElement("div");
		el.classList.add("tabulator-alert-msg");
		el.setAttribute("role", "alert");
		return el;
	}
    
	_typeClass(){
		return "tabulator-alert-state-" + this.type;
	}
    
	alert(content, type = "msg"){
		if(content){
			this.clear();

			this.dispatch("alert-show", type);
            
			this.type = type;
            
			while(this.msgElement.firstChild) this.msgElement.removeChild(this.msgElement.firstChild);
            
			this.msgElement.classList.add(this._typeClass());
            
			if(typeof content === "function"){
				content = content();
			}
            
			if(content instanceof HTMLElement){
				this.msgElement.appendChild(content);
			}else {
				this.msgElement.innerHTML = content;
			}
            
			this.table.element.appendChild(this.element);
		}
	}
    
	clear(){
		this.dispatch("alert-hide", this.type);

		if(this.element.parentNode){
			this.element.parentNode.removeChild(this.element);
		}
        
		this.msgElement.classList.remove(this._typeClass());
	}
}

class Tabulator {
	
	constructor(element, options){
		
		this.options = {};
		
		this.columnManager = null; // hold Column Manager
		this.rowManager = null; //hold Row Manager
		this.footerManager = null; //holder Footer Manager
		this.alertManager = null; //hold Alert Manager
		this.vdomHoz  = null; //holder horizontal virtual dom
		this.externalEvents = null; //handle external event messaging
		this.eventBus = null; //handle internal event messaging
		this.interactionMonitor = false; //track user interaction
		this.browser = ""; //hold current browser type
		this.browserSlow = false; //handle reduced functionality for slower browsers
		this.browserMobile = false; //check if running on mobile, prevent resize cancelling edit on keyboard appearance
		this.rtl = false; //check if the table is in RTL mode
		this.originalElement = null; //hold original table element if it has been replaced
		
		this.componentFunctionBinder = new ComponentFunctionBinder(this); //bind component functions
		this.dataLoader = false; //bind component functions
		
		this.modules = {}; //hold all modules bound to this table
		this.modulesCore = []; //hold core modules bound to this table (for initialization purposes)
		this.modulesRegular = []; //hold regular modules bound to this table (for initialization purposes)
		
		this.deprecationAdvisor = new DeprecationAdvisor(this);
		this.optionsList = new OptionsList(this, "table constructor");
		
		this.initialized = false;
		this.destroyed = false;
		
		if(this.initializeElement(element)){
			
			this.initializeCoreSystems(options);
			
			//delay table creation to allow event bindings immediately after the constructor
			setTimeout(() => {
				this._create();
			});
		}
		
		TableRegistry.register(this); //register table for inter-device communication
	}
	
	initializeElement(element){
		if(typeof HTMLElement !== "undefined" && element instanceof HTMLElement){
			this.element = element;
			return true;
		}else if(typeof element === "string"){
			this.element = document.querySelector(element);
			
			if(this.element){
				return true;
			}else {
				console.error("Tabulator Creation Error - no element found matching selector: ", element);
				return false;
			}
		}else {
			console.error("Tabulator Creation Error - Invalid element provided:", element);
			return false;
		}
	}
	
	initializeCoreSystems(options){
		this.columnManager = new ColumnManager(this);
		this.rowManager = new RowManager(this);
		this.footerManager = new FooterManager(this);
		this.dataLoader = new DataLoader(this);
		this.alertManager = new Alert(this);
		
		this.bindModules();
		
		this.options = this.optionsList.generate(Tabulator.defaultOptions, options);
		
		this._clearObjectPointers();
		
		this._mapDeprecatedFunctionality();
		
		this.externalEvents = new ExternalEventBus(this, this.options, this.options.debugEventsExternal);
		this.eventBus = new InternalEventBus(this.options.debugEventsInternal);
		
		this.interactionMonitor = new InteractionManager(this);
		
		this.dataLoader.initialize();
		// this.columnManager.initialize();
		// this.rowManager.initialize();
		this.footerManager.initialize();
	}
	
	//convert deprecated functionality to new functions
	_mapDeprecatedFunctionality(){
		//all previously deprecated functionality removed in the 5.0 release
	}
	
	_clearSelection(){
		
		this.element.classList.add("tabulator-block-select");
		
		if (window.getSelection) {
			if (window.getSelection().empty) {  // Chrome
				window.getSelection().empty();
			} else if (window.getSelection().removeAllRanges) {  // Firefox
				window.getSelection().removeAllRanges();
			}
		} else if (document.selection) {  // IE?
			document.selection.empty();
		}
		
		this.element.classList.remove("tabulator-block-select");
	}
	
	//create table
	_create(){
		this.externalEvents.dispatch("tableBuilding");
		this.eventBus.dispatch("table-building");
		
		this._rtlCheck();
		
		this._buildElement();
		
		this._initializeTable();
		
		this._loadInitialData();
		
		this.initialized = true;
		
		this.externalEvents.dispatch("tableBuilt");
	}
	
	_rtlCheck(){
		var style = window.getComputedStyle(this.element);
		
		switch(this.options.textDirection){
			case"auto":
				if(style.direction !== "rtl"){
					break;
				}
			
			case "rtl":
				this.element.classList.add("tabulator-rtl");
				this.rtl = true;
				break;
			
			case "ltr":
				this.element.classList.add("tabulator-ltr");
			
			default:
				this.rtl = false;
		}
	}
	
	//clear pointers to objects in default config object
	_clearObjectPointers(){
		this.options.columns = this.options.columns.slice(0);
		
		if(Array.isArray(this.options.data) && !this.options.reactiveData){
			this.options.data = this.options.data.slice(0);
		}
	}
	
	//build tabulator element
	_buildElement(){
		var element = this.element,
		options = this.options,
		newElement;
		
		if(element.tagName === "TABLE"){
			this.originalElement = this.element;
			newElement = document.createElement("div");
			
			//transfer attributes to new element
			var attributes = element.attributes;
			
			// loop through attributes and apply them on div
			for(var i in attributes){
				if(typeof attributes[i] == "object"){
					newElement.setAttribute(attributes[i].name, attributes[i].value);
				}
			}
			
			// replace table with div element
			element.parentNode.replaceChild(newElement, element);
			
			this.element = element = newElement;
		}
		
		element.classList.add("tabulator");
		element.setAttribute("role", "grid");
		
		//empty element
		while(element.firstChild) element.removeChild(element.firstChild);
		
		//set table height
		if(options.height){
			options.height = isNaN(options.height) ? options.height : options.height + "px";
			element.style.height = options.height;
		}
		
		//set table min height
		if(options.minHeight !== false){
			options.minHeight = isNaN(options.minHeight) ? options.minHeight : options.minHeight + "px";
			element.style.minHeight = options.minHeight;
		}
		
		//set table maxHeight
		if(options.maxHeight !== false){
			options.maxHeight = isNaN(options.maxHeight) ? options.maxHeight : options.maxHeight + "px";
			element.style.maxHeight = options.maxHeight;
		}
	}
	
	//initialize core systems and modules
	_initializeTable(){
		var element = this.element,
		options = this.options;
		
		this.interactionMonitor.initialize();
		
		this.columnManager.initialize();
		this.rowManager.initialize();
		
		this._detectBrowser();
		
		//initialize core modules
		this.modulesCore.forEach((mod) => {
			mod.initialize();
		});
		
		//build table elements
		element.appendChild(this.columnManager.getElement());
		element.appendChild(this.rowManager.getElement());
		
		if(options.footerElement){
			this.footerManager.activate();
		}
		
		if(options.autoColumns && options.data){
			
			this.columnManager.generateColumnsFromRowData(this.options.data);
		}
		
		//initialize regular modules
		this.modulesRegular.forEach((mod) => {
			mod.initialize();
		});
		
		this.columnManager.setColumns(options.columns);
		
		this.eventBus.dispatch("table-built");
	}
	
	_loadInitialData(){
		this.dataLoader.load(this.options.data);
		this.columnManager.verticalAlignHeaders();
	}
	
	//deconstructor
	destroy(){
		var element = this.element;
		
		this.destroyed = true;
		
		TableRegistry.deregister(this); //deregister table from inter-device communication
		
		this.eventBus.dispatch("table-destroy");
		
		//clear row data
		this.rowManager.destroy();
		
		//clear DOM
		while(element.firstChild) element.removeChild(element.firstChild);
		element.classList.remove("tabulator");

		this.externalEvents.dispatch("tableDestroyed");
	}
	
	_detectBrowser(){
		var ua = navigator.userAgent||navigator.vendor||window.opera;
		
		if(ua.indexOf("Trident") > -1){
			this.browser = "ie";
			this.browserSlow = true;
		}else if(ua.indexOf("Edge") > -1){
			this.browser = "edge";
			this.browserSlow = true;
		}else if(ua.indexOf("Firefox") > -1){
			this.browser = "firefox";
			this.browserSlow = false;
		}else if(ua.indexOf("Mac OS") > -1){
			this.browser = "safari";
			this.browserSlow = false;
		}else {
			this.browser = "other";
			this.browserSlow = false;
		}
		
		this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(ua)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(ua.slice(0,4));
	}
	
	initGuard(func, msg){
		var stack, line;
		
		if(this.options.debugInitialization && !this.initialized){
			if(!func){
				stack = new Error().stack.split("\n");
				
				line = stack[0] == "Error" ? stack[2] : stack[1];
				
				if(line[0] == " "){
					func = line.trim().split(" ")[1].split(".")[1];
				}else {
					func = line.trim().split("@")[0];
				}
			}
			
			console.warn("Table Not Initialized - Calling the " + func + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (msg ? " " + msg : ""));
		}
		
		return this.initialized;
	}
	
	////////////////// Data Handling //////////////////
	//block table redrawing
	blockRedraw(){
		this.initGuard();

		this.eventBus.dispatch("redraw-blocking");
		
		this.rowManager.blockRedraw();
		this.columnManager.blockRedraw();

		this.eventBus.dispatch("redraw-blocked");
	}
	
	//restore table redrawing
	restoreRedraw(){
		this.initGuard();

		this.eventBus.dispatch("redraw-restoring");

		this.rowManager.restoreRedraw();
		this.columnManager.restoreRedraw();

		this.eventBus.dispatch("redraw-restored");
	}
	
	//load data
	setData(data, params, config){
		this.initGuard(false, "To set initial data please use the 'data' property in the table constructor.");
		
		return this.dataLoader.load(data, params, config, false);
	}
	
	//clear data
	clearData(){
		this.initGuard();
		
		this.dataLoader.blockActiveLoad();
		this.rowManager.clearData();
	}
	
	//get table data array
	getData(active){
		return this.rowManager.getData(active);
	}
	
	//get table data array count
	getDataCount(active){
		return this.rowManager.getDataCount(active);
	}
	
	//replace data, keeping table in position with same sort
	replaceData(data, params, config){
		this.initGuard();
		
		return this.dataLoader.load(data, params, config, true, true);
	}
	
	//update table data
	updateData(data){
		var responses = 0;
		
		this.initGuard();
		
		return new Promise((resolve, reject) => {
			this.dataLoader.blockActiveLoad();
			
			if(typeof data === "string"){
				data = JSON.parse(data);
			}
			
			if(data && data.length > 0){
				data.forEach((item) => {
					var row = this.rowManager.findRow(item[this.options.index]);
					
					if(row){
						responses++;
						
						row.updateData(item)
							.then(()=>{
								responses--;
							
								if(!responses){
									resolve();
								}
							})
							.catch((e) => {
								reject("Update Error - Unable to update row", item, e);
							});
					}else {
						reject("Update Error - Unable to find row", item);
					}
				});
			}else {
				console.warn("Update Error - No data provided");
				reject("Update Error - No data provided");
			}
		});
	}
	
	addData(data, pos, index){
		this.initGuard();
		
		return new Promise((resolve, reject) => {
			this.dataLoader.blockActiveLoad();
			
			if(typeof data === "string"){
				data = JSON.parse(data);
			}
			
			if(data){
				this.rowManager.addRows(data, pos, index)
					.then((rows) => {
						var output = [];
					
						rows.forEach(function(row){
							output.push(row.getComponent());
						});
					
						resolve(output);
					});
			}else {
				console.warn("Update Error - No data provided");
				reject("Update Error - No data provided");
			}
		});
	}
	
	//update table data
	updateOrAddData(data){
		var rows = [],
		responses = 0;
		
		this.initGuard();
		
		return new Promise((resolve, reject) => {
			this.dataLoader.blockActiveLoad();
			
			if(typeof data === "string"){
				data = JSON.parse(data);
			}
			
			if(data && data.length > 0){
				data.forEach((item) => {
					var row = this.rowManager.findRow(item[this.options.index]);
					
					responses++;
					
					if(row){
						row.updateData(item)
							.then(()=>{
								responses--;
								rows.push(row.getComponent());
							
								if(!responses){
									resolve(rows);
								}
							});
					}else {
						this.rowManager.addRows(item)
							.then((newRows)=>{
								responses--;
								rows.push(newRows[0].getComponent());
							
								if(!responses){
									resolve(rows);
								}
							});
					}
				});
			}else {
				console.warn("Update Error - No data provided");
				reject("Update Error - No data provided");
			}
		});
	}
	
	//get row object
	getRow(index){
		var row = this.rowManager.findRow(index);
		
		if(row){
			return row.getComponent();
		}else {
			console.warn("Find Error - No matching row found:", index);
			return false;
		}
	}
	
	//get row object
	getRowFromPosition(position){
		var row = this.rowManager.getRowFromPosition(position);
		
		if(row){
			return row.getComponent();
		}else {
			console.warn("Find Error - No matching row found:", position);
			return false;
		}
	}
	
	//delete row from table
	deleteRow(index){
		var foundRows = [];
		
		this.initGuard();
		
		if(!Array.isArray(index)){
			index = [index];
		}
		
		//find matching rows
		for(let item of index){
			let row = this.rowManager.findRow(item, true);
			
			if(row){
				foundRows.push(row);
			}else {
				console.error("Delete Error - No matching row found:", item);
				return Promise.reject("Delete Error - No matching row found");
			}
		}
		
		//sort rows into correct order to ensure smooth delete from table
		foundRows.sort((a, b) => {
			return this.rowManager.rows.indexOf(a) > this.rowManager.rows.indexOf(b) ? 1 : -1;
		});
		
		//delete rows
		foundRows.forEach((row) =>{
			row.delete();
		});
		
		this.rowManager.reRenderInPosition();
		
		return Promise.resolve();
	}
	
	//add row to table
	addRow(data, pos, index){
		this.initGuard();
		
		if(typeof data === "string"){
			data = JSON.parse(data);
		}
		
		return this.rowManager.addRows(data, pos, index, true)
			.then((rows)=>{
				return rows[0].getComponent();
			});
	}
	
	//update a row if it exists otherwise create it
	updateOrAddRow(index, data){
		var row = this.rowManager.findRow(index);
		
		this.initGuard();
		
		if(typeof data === "string"){
			data = JSON.parse(data);
		}
		
		if(row){
			return row.updateData(data)
				.then(()=>{
					return row.getComponent();
				});
		}else {
			return this.rowManager.addRows(data)
				.then((rows)=>{
					return rows[0].getComponent();
				});
		}
	}
	
	//update row data
	updateRow(index, data){
		var row = this.rowManager.findRow(index);
		
		this.initGuard();
		
		if(typeof data === "string"){
			data = JSON.parse(data);
		}
		
		if(row){
			return row.updateData(data)
				.then(()=>{
					return Promise.resolve(row.getComponent());
				});
		}else {
			console.warn("Update Error - No matching row found:", index);
			return Promise.reject("Update Error - No matching row found");
		}
	}
	
	//scroll to row in DOM
	scrollToRow(index, position, ifVisible){
		var row = this.rowManager.findRow(index);
		
		if(row){
			return this.rowManager.scrollToRow(row, position, ifVisible);
		}else {
			console.warn("Scroll Error - No matching row found:", index);
			return Promise.reject("Scroll Error - No matching row found");
		}
	}
	
	moveRow(from, to, after){
		var fromRow = this.rowManager.findRow(from);
		
		this.initGuard();
		
		if(fromRow){
			fromRow.moveToRow(to, after);
		}else {
			console.warn("Move Error - No matching row found:", from);
		}
	}
	
	getRows(active){
		return this.rowManager.getComponents(active);	
	}
	
	//get position of row in table
	getRowPosition(index){
		var row = this.rowManager.findRow(index);
		
		if(row){
			return row.getPosition();
		}else {
			console.warn("Position Error - No matching row found:", index);
			return false;
		}
	}
	
	/////////////// Column Functions  ///////////////
	setColumns(definition){
		this.initGuard(false, "To set initial columns please use the 'columns' property in the table constructor");
		
		this.columnManager.setColumns(definition);
	}
	
	getColumns(structured){
		return this.columnManager.getComponents(structured);
	}
	
	getColumn(field){
		var column = this.columnManager.findColumn(field);
		
		if(column){
			return column.getComponent();
		}else {
			console.warn("Find Error - No matching column found:", field);
			return false;
		}
	}
	
	getColumnDefinitions(){
		return this.columnManager.getDefinitionTree();
	}
	
	showColumn(field){
		var column = this.columnManager.findColumn(field);
		
		this.initGuard();
		
		if(column){
			column.show();
		}else {
			console.warn("Column Show Error - No matching column found:", field);
			return false;
		}
	}
	
	hideColumn(field){
		var column = this.columnManager.findColumn(field); 
		
		this.initGuard();
		
		if(column){
			column.hide();
		}else {
			console.warn("Column Hide Error - No matching column found:", field);
			return false;
		}
	}
	
	toggleColumn(field){
		var column = this.columnManager.findColumn(field);
		
		this.initGuard();
		
		if(column){
			if(column.visible){
				column.hide();
			}else {
				column.show();
			}
		}else {
			console.warn("Column Visibility Toggle Error - No matching column found:", field);
			return false;
		}
	}
	
	addColumn(definition, before, field){
		var column = this.columnManager.findColumn(field);
		
		this.initGuard();
		
		return this.columnManager.addColumn(definition, before, column)
			.then((column) => {
				return column.getComponent();
			});
	}
	
	deleteColumn(field){
		var column = this.columnManager.findColumn(field);
		
		this.initGuard();
		
		if(column){
			return column.delete();
		}else {
			console.warn("Column Delete Error - No matching column found:", field);
			return Promise.reject();
		}
	}
	
	updateColumnDefinition(field, definition){
		var column = this.columnManager.findColumn(field);
		
		this.initGuard();
		
		if(column){
			return column.updateDefinition(definition);
		}else {
			console.warn("Column Update Error - No matching column found:", field);
			return Promise.reject();
		}
	}
	
	moveColumn(from, to, after){
		var fromColumn = this.columnManager.findColumn(from),
		toColumn = this.columnManager.findColumn(to);
		
		this.initGuard();
		
		if(fromColumn){
			if(toColumn){
				this.columnManager.moveColumn(fromColumn, toColumn, after);
			}else {
				console.warn("Move Error - No matching column found:", toColumn);
			}
		}else {
			console.warn("Move Error - No matching column found:", from);
		}
	}
	
	//scroll to column in DOM
	scrollToColumn(field, position, ifVisible){
		return new Promise((resolve, reject) => {
			var column = this.columnManager.findColumn(field);
			
			if(column){
				return this.columnManager.scrollToColumn(column, position, ifVisible);
			}else {
				console.warn("Scroll Error - No matching column found:", field);
				return Promise.reject("Scroll Error - No matching column found");
			}
		});
	}
	
	//////////// General Public Functions ////////////
	//redraw list without updating data
	redraw(force){
		this.initGuard();

		this.columnManager.redraw(force);
		this.rowManager.redraw(force);
	}
	
	setHeight(height){
		this.options.height = isNaN(height) ? height : height + "px";
		this.element.style.height = this.options.height;
		this.rowManager.initializeRenderer();
		this.rowManager.redraw(true);
	}
	
	//////////////////// Event Bus ///////////////////
	
	on(key, callback){
		this.externalEvents.subscribe(key, callback);
	}
	
	off(key, callback){
		this.externalEvents.unsubscribe(key, callback);
	}
	
	dispatchEvent(){
		var args = Array.from(arguments);
		args.shift();
		
		this.externalEvents.dispatch(...arguments);
	}

	//////////////////// Alerts ///////////////////

	alert(contents, type){
		this.initGuard();

		this.alertManager.alert(contents, type);
	}

	clearAlert(){
		this.initGuard();

		this.alertManager.clear();
	}
	
	////////////// Extension Management //////////////
	modExists(plugin, required){
		if(this.modules[plugin]){
			return true;
		}else {
			if(required){
				console.error("Tabulator Module Not Installed: " + plugin);
			}
			return false;
		}
	}
	
	module(key){
		var mod = this.modules[key];
		
		if(!mod){
			console.error("Tabulator module not installed: " + key);
		}
		
		return mod;
	}
}

//default setup options
Tabulator.defaultOptions = defaultOptions;

//bind modules and static functionality
new ModuleBinder(Tabulator);

//tabulator with all modules installed

class TabulatorFull extends Tabulator {}

//bind modules and static functionality
new ModuleBinder(TabulatorFull, modules);

class PseudoRow {

	constructor (type){
		this.type = type;
		this.element = this._createElement();
	}

	_createElement(){
		var el = document.createElement("div");
		el.classList.add("tabulator-row");
		return el;
	}

	getElement(){
		return this.element;
	}

	getComponent(){
		return false;
	}

	getData(){
		return {};
	}

	getHeight(){
		return this.element.outerHeight;
	}

	initialize(){}

	reinitialize(){}

	normalizeHeight(){}

	generateCells(){}

	reinitializeHeight(){}

	calcHeight(){}

	setCellHeight(){}

	clearCellHeight(){}

	rendered(){}
}


//# sourceMappingURL=tabulator_esm.js.map


/***/ }),

/***/ "./node_modules/wcslight/lib-esm/WCSLight.js":
/*!***************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/WCSLight.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WCSLight: () => (/* binding */ WCSLight)
/* harmony export */ });
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");
/* harmony import */ var _projections_MercatorProjection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./projections/MercatorProjection.js */ "./node_modules/wcslight/lib-esm/projections/MercatorProjection.js");
/* harmony import */ var _projections_HiPSProjection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projections/HiPSProjection.js */ "./node_modules/wcslight/lib-esm/projections/HiPSProjection.js");
/* harmony import */ var _projections_HEALPixProjection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./projections/HEALPixProjection.js */ "./node_modules/wcslight/lib-esm/projections/HEALPixProjection.js");
/* harmony import */ var _projections_GnomonicProjection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./projections/GnomonicProjection.js */ "./node_modules/wcslight/lib-esm/projections/GnomonicProjection.js");
/* harmony import */ var _model_FITS_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./model/FITS.js */ "./node_modules/wcslight/lib-esm/model/FITS.js");
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






class WCSLight {
    static cutout(center, radius, pxsize, inproj, outproj) {
        return __awaiter(this, void 0, void 0, function* () {
            const outRADecList = outproj.getImageRADecList(center, radius, pxsize);
            if (outRADecList.length == 0) {
                const res = {
                    fitsheader: null,
                    fitsdata: null,
                    inproj: inproj,
                    outproj: outproj,
                    fitsused: inproj.fitsUsed
                };
                return res;
            }
            const inputPixelsList = inproj.world2pix(outRADecList);
            try {
                const invalues = yield inproj.getPixValues(inputPixelsList);
                const fitsHeaderParams = inproj.getCommonFitsHeaderParams();
                if (invalues !== undefined) {
                    const fitsdata = outproj.setPxsValue(invalues, fitsHeaderParams);
                    const fitsheader = outproj.getFITSHeader();
                    const fits = new _model_FITS_js__WEBPACK_IMPORTED_MODULE_5__.FITS(fitsheader, fitsdata);
                    const res = {
                        fitsheader: fits.header,
                        fitsdata: fits.data,
                        inproj: inproj,
                        outproj: outproj,
                        fitsused: inproj.fitsUsed
                    };
                    return res;
                }
                else {
                    const nanFits = outproj.generateFITSWithNaN();
                    const res = {
                        fitsheader: nanFits.header,
                        fitsdata: nanFits.data,
                        inproj: inproj,
                        outproj: outproj,
                        fitsused: inproj.fitsUsed
                    };
                    return res;
                }
            }
            catch (err) {
                console.error("[WCSLight] ERROR: " + err);
                return null;
            }
        });
    }
    /**
     *
     * @param {*} fitsheader
     * @param {*} fitsdata
     * @returns {URL}
     */
    static generateFITS(fitsheader, fitsdata) {
        const blobUrl = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSParser.generateFITS(fitsheader, fitsdata);
        return blobUrl;
    }
    static changeProjection(filepath, outprojname) {
        // TODO
    }
    static getProjection(projectionName) {
        if (projectionName === "Mercator") {
            return new _projections_MercatorProjection_js__WEBPACK_IMPORTED_MODULE_1__.MercatorProjection();
        }
        else if (projectionName === "HiPS") {
            return new _projections_HiPSProjection_js__WEBPACK_IMPORTED_MODULE_2__.HiPSProjection();
        }
        else if (projectionName === "HEALPix") {
            return new _projections_HEALPixProjection_js__WEBPACK_IMPORTED_MODULE_3__.HEALPixProjection();
        }
        else if (projectionName === "Gnomonic") {
            return new _projections_GnomonicProjection_js__WEBPACK_IMPORTED_MODULE_4__.GnomonicProjection();
        }
        else {
            return null;
            // throw new ProjectionNotFound(projectionName);
        }
    }
    static getAvaillableProjections() {
        return ["Mercator", "HiPS", "HEALPix"];
    }
}
//# sourceMappingURL=WCSLight.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractProjection: () => (/* reexport safe */ _projections_AbstractProjection_js__WEBPACK_IMPORTED_MODULE_6__.AbstractProjection),
/* harmony export */   CoordsType: () => (/* reexport safe */ _model_CoordsType_js__WEBPACK_IMPORTED_MODULE_1__.CoordsType),
/* harmony export */   GnomonicProjection: () => (/* reexport safe */ _projections_GnomonicProjection_js__WEBPACK_IMPORTED_MODULE_7__.GnomonicProjection),
/* harmony export */   HEALPixProjection: () => (/* reexport safe */ _projections_HEALPixProjection_js__WEBPACK_IMPORTED_MODULE_8__.HEALPixProjection),
/* harmony export */   HiPSHelper: () => (/* reexport safe */ _projections_HiPSHelper_js__WEBPACK_IMPORTED_MODULE_9__.HiPSHelper),
/* harmony export */   HiPSProjection: () => (/* reexport safe */ _projections_HiPSProjection_js__WEBPACK_IMPORTED_MODULE_10__.HiPSProjection),
/* harmony export */   ImagePixel: () => (/* reexport safe */ _model_ImagePixel_js__WEBPACK_IMPORTED_MODULE_2__.ImagePixel),
/* harmony export */   MercatorProjection: () => (/* reexport safe */ _projections_MercatorProjection_js__WEBPACK_IMPORTED_MODULE_11__.MercatorProjection),
/* harmony export */   NumberType: () => (/* reexport safe */ _model_NumberType_js__WEBPACK_IMPORTED_MODULE_3__.NumberType),
/* harmony export */   Point: () => (/* reexport safe */ _model_Point_js__WEBPACK_IMPORTED_MODULE_4__.Point),
/* harmony export */   TestProj: () => (/* reexport safe */ _projections_TestProj_js__WEBPACK_IMPORTED_MODULE_12__.TestProj),
/* harmony export */   WCSLight: () => (/* reexport safe */ _WCSLight_js__WEBPACK_IMPORTED_MODULE_0__.WCSLight),
/* harmony export */   astroToSpherical: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.astroToSpherical),
/* harmony export */   cartesianToSpherical: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.cartesianToSpherical),
/* harmony export */   degToRad: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.degToRad),
/* harmony export */   fillAstro: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.fillAstro),
/* harmony export */   fillSpherical: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.fillSpherical),
/* harmony export */   radToDeg: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.radToDeg),
/* harmony export */   sphericalToAstro: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.sphericalToAstro),
/* harmony export */   sphericalToCartesian: () => (/* reexport safe */ _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.sphericalToCartesian)
/* harmony export */ });
/* harmony import */ var _WCSLight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WCSLight.js */ "./node_modules/wcslight/lib-esm/WCSLight.js");
/* harmony import */ var _model_CoordsType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/CoordsType.js */ "./node_modules/wcslight/lib-esm/model/CoordsType.js");
/* harmony import */ var _model_ImagePixel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/ImagePixel.js */ "./node_modules/wcslight/lib-esm/model/ImagePixel.js");
/* harmony import */ var _model_NumberType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/NumberType.js */ "./node_modules/wcslight/lib-esm/model/NumberType.js");
/* harmony import */ var _model_Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/Point.js */ "./node_modules/wcslight/lib-esm/model/Point.js");
/* harmony import */ var _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./model/Utils.js */ "./node_modules/wcslight/lib-esm/model/Utils.js");
/* harmony import */ var _projections_AbstractProjection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./projections/AbstractProjection.js */ "./node_modules/wcslight/lib-esm/projections/AbstractProjection.js");
/* harmony import */ var _projections_GnomonicProjection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./projections/GnomonicProjection.js */ "./node_modules/wcslight/lib-esm/projections/GnomonicProjection.js");
/* harmony import */ var _projections_HEALPixProjection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./projections/HEALPixProjection.js */ "./node_modules/wcslight/lib-esm/projections/HEALPixProjection.js");
/* harmony import */ var _projections_HiPSHelper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./projections/HiPSHelper.js */ "./node_modules/wcslight/lib-esm/projections/HiPSHelper.js");
/* harmony import */ var _projections_HiPSProjection_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./projections/HiPSProjection.js */ "./node_modules/wcslight/lib-esm/projections/HiPSProjection.js");
/* harmony import */ var _projections_MercatorProjection_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./projections/MercatorProjection.js */ "./node_modules/wcslight/lib-esm/projections/MercatorProjection.js");
/* harmony import */ var _projections_TestProj_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./projections/TestProj.js */ "./node_modules/wcslight/lib-esm/projections/TestProj.js");













//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/model/CoordsType.js":
/*!***********************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/model/CoordsType.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CoordsType: () => (/* binding */ CoordsType)
/* harmony export */ });
/**
 * @author Fabrizio Giordano (Fab77)
 * Enum for coordinate types.
 * @readonly
 * @enum {{name: string, hex: string}}
 */
var CoordsType;
(function (CoordsType) {
    CoordsType["CARTESIAN"] = "cartesian";
    CoordsType["SPHERICAL"] = "spherical";
    CoordsType["ASTRO"] = "astro";
})(CoordsType || (CoordsType = {}));
//# sourceMappingURL=CoordsType.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/model/FITS.js":
/*!*****************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/model/FITS.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FITS: () => (/* binding */ FITS)
/* harmony export */ });
class FITS {
    constructor(header, data) {
        this._header = header;
        this._data = data;
    }
    get header() {
        return this._header;
    }
    get data() {
        return this._data;
    }
}
//# sourceMappingURL=FITS.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/model/ImagePixel.js":
/*!***********************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/model/ImagePixel.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImagePixel: () => (/* binding */ ImagePixel)
/* harmony export */ });
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
class ImagePixel {
    constructor(i = null, j = null, tileno = null) {
        this._i = i;
        this._j = j;
        this._tileno = tileno;
    }
    geti() {
        return this._i;
    }
    getj() {
        return this._j;
    }
    get tileno() {
        return this._tileno;
    }
}
//# sourceMappingURL=ImagePixel.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/model/NumberType.js":
/*!***********************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/model/NumberType.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberType: () => (/* binding */ NumberType)
/* harmony export */ });
var NumberType;
(function (NumberType) {
    NumberType[NumberType["DEGREES"] = 0] = "DEGREES";
    NumberType[NumberType["RADIANS"] = 1] = "RADIANS";
    NumberType[NumberType["DECIMAL"] = 2] = "DECIMAL";
    NumberType[NumberType["HMS"] = 3] = "HMS";
    NumberType[NumberType["DMS"] = 4] = "DMS";
})(NumberType || (NumberType = {}));
//# sourceMappingURL=NumberType.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/model/Point.js":
/*!******************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/model/Point.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Point: () => (/* binding */ Point)
/* harmony export */ });
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ "./node_modules/wcslight/lib-esm/model/Utils.js");
/* harmony import */ var _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CoordsType.js */ "./node_modules/wcslight/lib-esm/model/CoordsType.js");
/**
 * @author Fabrizio Giordano (Fab77)
 */
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Point_astro, _Point_spherical, _Point_cartesian;


class Point {
    constructor(in_type, unit, ...coords) {
        _Point_astro.set(this, void 0);
        // #equatorial: EquatorialCoords;
        // #galactic: GalacticCoords;
        _Point_spherical.set(this, void 0);
        _Point_cartesian.set(this, void 0);
        if (in_type == _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__.CoordsType.CARTESIAN) {
            __classPrivateFieldGet(this, _Point_cartesian, "f").x = parseFloat(coords[0].toFixed(global.MAX_DECIMALS));
            __classPrivateFieldGet(this, _Point_cartesian, "f").y = parseFloat(coords[1].toFixed(global.MAX_DECIMALS));
            __classPrivateFieldGet(this, _Point_cartesian, "f").z = parseFloat(coords[2].toFixed(global.MAX_DECIMALS));
            __classPrivateFieldSet(this, _Point_spherical, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.cartesianToSpherical)(__classPrivateFieldGet(this, _Point_cartesian, "f")), "f");
            __classPrivateFieldSet(this, _Point_astro, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.sphericalToAstro)(__classPrivateFieldGet(this, _Point_spherical, "f")), "f");
        }
        else if (in_type == _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__.CoordsType.ASTRO) {
            __classPrivateFieldSet(this, _Point_astro, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.fillAstro)(coords[0], coords[1], unit), "f");
            __classPrivateFieldSet(this, _Point_spherical, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.astroToSpherical)(__classPrivateFieldGet(this, _Point_astro, "f")), "f");
            __classPrivateFieldSet(this, _Point_cartesian, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.sphericalToCartesian)(__classPrivateFieldGet(this, _Point_spherical, "f"), 1.0), "f"); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)
        }
        else if (in_type == _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__.CoordsType.SPHERICAL) {
            __classPrivateFieldSet(this, _Point_spherical, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.fillSpherical)(coords[0], coords[1], unit), "f");
            __classPrivateFieldSet(this, _Point_cartesian, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.sphericalToCartesian)(__classPrivateFieldGet(this, _Point_spherical, "f"), 1.0), "f"); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)
            __classPrivateFieldSet(this, _Point_astro, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.sphericalToAstro)(__classPrivateFieldGet(this, _Point_spherical, "f")), "f");
        }
        else {
            console.error("CoordsType " + in_type + " not recognised.");
        }
        if (__classPrivateFieldGet(this, _Point_spherical, "f").phiDeg > 360) {
            __classPrivateFieldGet(this, _Point_spherical, "f").phiDeg -= 360;
        }
        if (__classPrivateFieldGet(this, _Point_astro, "f").raDeg > 360) {
            __classPrivateFieldGet(this, _Point_astro, "f").raDeg -= 360;
        }
    }
    // constructor(in_options: ICoordsFormat, in_type: CoordsType){
    // 	if (in_type == CoordsType.CARTESIAN){
    // 		this.#cartesian.x = parseFloat((in_options as CartesianCoords).x.toFixed(global.MAX_DECIMALS));
    // 		this.#cartesian.y = parseFloat((in_options as CartesianCoords).y.toFixed(global.MAX_DECIMALS));
    // 		this.#cartesian.z = parseFloat((in_options as CartesianCoords).z.toFixed(global.MAX_DECIMALS));
    // 		this.#spherical = cartesianToSpherical(this.#cartesian);
    // 		this.#astro = sphericalToAstro(this.#spherical);
    // 	}else if (in_type == CoordsType.ASTRO){
    // 		if ((in_options as AstroCoords).raDeg && (in_options as AstroCoords).decDeg) {
    // 			this.#astro = radegDecdegToAstro((in_options as AstroCoords).raDeg,  (in_options as AstroCoords).decDeg );
    // 		} else if ((in_options as AstroCoords).raRad && (in_options as AstroCoords).decRad) {
    // 			this.#astro = raradDecradToAstro((in_options as AstroCoords).raRad,  (in_options as AstroCoords).decRad );
    // 		} else {
    // 			console.error("AstroCoords incomplete "+ in_options );
    // 			return null;
    // 		}
    // 		this.#spherical = astroToSpherical(this.#astro);
    // 		this.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)
    // 	}else if (in_type == CoordsType.SPHERICAL){
    // 		if ((in_options as SphericalCoords).phiDeg && (in_options as SphericalCoords).thetaDeg) {
    // 			this.#spherical = phidegThetadegToSpherical((in_options as SphericalCoords).phiDeg,  (in_options as SphericalCoords).thetaDeg );
    // 		} else if ((in_options as SphericalCoords).phiRad && (in_options as SphericalCoords).thetaRad) {
    // 			this.#spherical = phiradThetaradToSpherical((in_options as SphericalCoords).phiRad,  (in_options as SphericalCoords).thetaRad );
    // 		} else {
    // 			console.error("SphericalCoords incomplete "+ in_options );
    // 			return null;
    // 		}
    // 		this.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)
    // 		this.#astro = sphericalToAstro(this.#spherical);
    // 	}else{
    // 		console.error("CoordsType "+in_type+" not recognised.");
    // 	}
    // }
    get spherical() {
        return __classPrivateFieldGet(this, _Point_spherical, "f");
    }
    get astro() {
        return __classPrivateFieldGet(this, _Point_astro, "f");
    }
    get cartesian() {
        return __classPrivateFieldGet(this, _Point_cartesian, "f");
    }
}
_Point_astro = new WeakMap(), _Point_spherical = new WeakMap(), _Point_cartesian = new WeakMap();
//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/model/Utils.js":
/*!******************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/model/Utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   astroToSpherical: () => (/* binding */ astroToSpherical),
/* harmony export */   cartesianToSpherical: () => (/* binding */ cartesianToSpherical),
/* harmony export */   colorHex2RGB: () => (/* binding */ colorHex2RGB),
/* harmony export */   decDegToDMS: () => (/* binding */ decDegToDMS),
/* harmony export */   degToRad: () => (/* binding */ degToRad),
/* harmony export */   fillAstro: () => (/* binding */ fillAstro),
/* harmony export */   fillSpherical: () => (/* binding */ fillSpherical),
/* harmony export */   raDegToHMS: () => (/* binding */ raDegToHMS),
/* harmony export */   radToDeg: () => (/* binding */ radToDeg),
/* harmony export */   sphericalToAstro: () => (/* binding */ sphericalToAstro),
/* harmony export */   sphericalToCartesian: () => (/* binding */ sphericalToCartesian)
/* harmony export */ });
/* harmony import */ var _NumberType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NumberType.js */ "./node_modules/wcslight/lib-esm/model/NumberType.js");
/**
 * @author Fabrizio Giordano (Fab)
 */
// import vec3 from 'gl-matrix';

function Utils() {
}
function cartesianToSpherical(xyz) {
    let dotXYZ = dot(xyz, xyz);
    let r = Math.sqrt(dotXYZ);
    let thetaRad = Math.acos(xyz[2] / r);
    let thetaDeg = radToDeg(thetaRad);
    // NB: in atan(y/x) is written with params switched atan2(x, y)
    let phiRad = Math.atan2(xyz[1], xyz[0]);
    let phiDeg = radToDeg(phiRad);
    if (phiDeg < 0) {
        phiDeg += 360;
    }
    return {
        phiDeg: phiDeg,
        thetaDeg: thetaDeg,
        phiRad: phiRad,
        thetaRad: thetaRad
    };
}
;
function sphericalToAstro(phiTheta) {
    let raDeg;
    let decDeg;
    raDeg = phiTheta.phiDeg;
    if (raDeg < 0) {
        raDeg += 360;
    }
    decDeg = 90 - phiTheta.thetaDeg;
    return {
        "raDeg": raDeg,
        "decDeg": decDeg,
        "raRad": degToRad(raDeg),
        "decRad": degToRad(decDeg)
    };
}
function astroToSpherical(raDec) {
    let phiDeg;
    let thetaDeg;
    phiDeg = raDec.raDeg;
    if (phiDeg < 0) {
        phiDeg += 360;
    }
    thetaDeg = 90 - raDec.decDeg;
    return {
        "phiDeg": phiDeg,
        "thetaDeg": thetaDeg,
        "phiRad": degToRad(phiDeg),
        "thetaRad": degToRad(thetaDeg),
    };
}
function sphericalToCartesian(phiTheta, r) {
    r = (r == undefined) ? 1 : r;
    var x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);
    var y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);
    var z = r * Math.cos(phiTheta.thetaRad);
    return {
        "x": x,
        "y": y,
        "z": z
    };
}
;
function fillAstro(ra, dec, unit) {
    if (unit == _NumberType_js__WEBPACK_IMPORTED_MODULE_0__.NumberType.DEGREES) {
        return {
            "raDeg": ra,
            "decDeg": dec,
            "raRad": degToRad(ra),
            "decRad": degToRad(dec)
        };
    }
    else if (unit == _NumberType_js__WEBPACK_IMPORTED_MODULE_0__.NumberType.RADIANS) {
        return {
            "raRad": ra,
            "decRad": dec,
            "raDeg": radToDeg(ra),
            "decDeg": radToDeg(dec)
        };
    }
    else {
        console.error("Wrong operation. NumberType " + unit + " not supported");
    }
}
function fillSpherical(phi, theta, unit) {
    if (unit == _NumberType_js__WEBPACK_IMPORTED_MODULE_0__.NumberType.DEGREES) {
        return {
            "phiDeg": phi,
            "thetaDeg": theta,
            "phiRad": degToRad(phi),
            "thetaRad": degToRad(theta)
        };
    }
    else if (unit == _NumberType_js__WEBPACK_IMPORTED_MODULE_0__.NumberType.RADIANS) {
        return {
            "phiDeg": radToDeg(phi),
            "thetaDeg": radToDeg(theta),
            "phiRad": phi,
            "thetaRad": theta
        };
    }
    else {
        console.error("Wrong operation. NumberType " + unit + " not supported");
    }
}
function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
function colorHex2RGB(hexColor) {
    //	console.log(hexColor);
    var hex1 = hexColor.substring(1, 3);
    var hex2 = hexColor.substring(3, 5);
    var hex3 = hexColor.substring(5, 7);
    var dec1 = parseInt(hex1, 16);
    var dec2 = parseInt(hex2, 16);
    var dec3 = parseInt(hex3, 16);
    var rgb1 = (dec1 / 255).toFixed(2);
    var rgb2 = (dec2 / 255).toFixed(2);
    var rgb3 = (dec3 / 255).toFixed(2);
    return [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];
}
function degToRad(degrees) {
    return (degrees / 180) * Math.PI;
}
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}
function raDegToHMS(raDeg) {
    var h = Math.floor(raDeg / 15);
    var m = Math.floor((raDeg / 15 - h) * 60);
    var s = (raDeg / 15 - h - m / 60) * 3600;
    return {
        h: h,
        m: m,
        s: s
    };
}
function decDegToDMS(decDeg) {
    var sign = 1;
    if (decDeg < 0) {
        sign = -1;
    }
    var decDeg_abs = Math.abs(decDeg);
    var d = Math.trunc(decDeg_abs);
    var m = Math.trunc((decDeg_abs - d) * 60);
    var s = (decDeg_abs - d - m / 60) * 3600;
    d = d * sign;
    return {
        d: d,
        m: m,
        s: s
    };
}
function dms2DecDeg(decDMS) {
    var sign = Math.sign(decDMS.d);
    var deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s / 3600);
    return deg;
}
function hms2RaDeg(raHMS) {
    var sign = Math.sign(raHMS.h);
    var deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s / 3600)) * 15;
    return deg;
}
function worldToModel(xy, radius) {
    var x = xy[0];
    var y = xy[1];
    var z = Math.sqrt(radius * radius - xy[0] * xy[0] - xy[1] * xy[1]);
    return [x, y, z];
}
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/projections/AbstractProjection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/projections/AbstractProjection.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractProjection: () => (/* binding */ AbstractProjection)
/* harmony export */ });
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");
/* harmony import */ var _model_FITS_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/FITS.js */ "./node_modules/wcslight/lib-esm/model/FITS.js");


/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
class AbstractProjection {
    constructor(ctype1, ctype2, naxis1 = 0, naxis2 = 0, pxsize = 0) {
        this._ctype1 = ctype1;
        this._ctype2 = ctype2;
        this._naxis1 = naxis1;
        this._naxis2 = naxis2;
        this._pxsize = pxsize;
    }
    get naxis1() {
        return this._naxis1;
    }
    set naxis1(value) {
        this._naxis1 = value;
    }
    get naxis2() {
        return this._naxis2;
    }
    set naxis2(value) {
        this._naxis2 = value;
    }
    get pxsize() {
        return this._pxsize;
    }
    set pxsize(value) {
        this._pxsize = value;
    }
    get ctype1() {
        return this._ctype1;
    }
    set ctype1(value) {
        this._ctype1 = value;
    }
    get ctype2() {
        return this._ctype2;
    }
    set ctype2(value) {
        this._ctype2 = value;
    }
    // public abstract generateFITSWithNaN(): FITS;
    generateFITSWithNaN() {
        if (!this.naxis1 || !this.naxis2) {
            throw new Error("NAXIS1 and NAXIS2 must be initialized before generating FITS.");
        }
        let fitsheaders = [];
        let fitsheader = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeader();
        fitsheader.addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS1", this.naxis1));
        fitsheader.addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS2", this.naxis2));
        fitsheader.addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS", 2));
        fitsheader.addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BITPIX", "-64"));
        fitsheader.addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("SIMPLE", "T"));
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BSCALE", 1));
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BZERO", 0));
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CTYPE1", this.ctype1));
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CTYPE2", this.ctype2));
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CDELT1", this.pxsize)); // ??? Pixel spacing along axis 1 ???
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CDELT2", this.pxsize)); // ??? Pixel spacing along axis 2 ???
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRPIX1", this.naxis1 / 2)); // central/reference pixel i along naxis1
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRPIX2", this.naxis2 / 2)); // central/reference pixel j along naxis2
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRVAL1", NaN)); // central/reference pixel RA
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRVAL2", NaN)); // central/reference pixel Dec
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("ORIGIN", "'WCSLight v.0.x'"));
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("COMMENT", "'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'"));
        fitsheader.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("END"));
        fitsheaders.push(fitsheader);
        let bytesXelem = 8;
        // why not usign a simple arrays?
        let pv = new Map();
        pv.set(0, new Array(this.naxis2));
        pv.get(0);
        for (let r = 0; r < this.naxis2; r++) {
            pv.get(0)[r] = new Uint8Array(this.naxis1 * bytesXelem);
            pv.get(0)[r].fill(255);
        }
        const fitsNan = new _model_FITS_js__WEBPACK_IMPORTED_MODULE_1__.FITS(fitsheaders, pv);
        return fitsNan;
    }
    computeSquaredNaxes(d, ps) {
        // first approximation to be checked
        this._naxis1 = Math.ceil(d / ps);
        this._naxis2 = this._naxis1;
        this._pxsize = ps;
    }
}
//# sourceMappingURL=AbstractProjection.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/projections/GnomonicProjection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/projections/GnomonicProjection.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GnomonicProjection: () => (/* binding */ GnomonicProjection)
/* harmony export */ });
/* harmony import */ var _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractProjection.js */ "./node_modules/wcslight/lib-esm/projections/AbstractProjection.js");
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */





class GnomonicProjection extends _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_0__.AbstractProjection {
    constructor(infile) {
        super("'RA---TAN'", "'DEC--TAN'");
        if (infile) {
            this._inflie = infile;
        }
    }
    get fitsUsed() {
        throw new Error('Method not implemented.');
    }
    initFromFile(infile) {
        const _super = Object.create(null, {
            naxis1: { get: () => super.naxis1, set: v => super.naxis1 = v },
            naxis2: { get: () => super.naxis2, set: v => super.naxis2 = v }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let fp = new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSParser(infile);
            let promise = fp.loadFITS().then(fits => {
                // console.log(fits.header);
                this._pxvalues.set(0, fits.data);
                this._fitsheader[0] = fits.header;
                _super.naxis1 = fits.header.get("NAXIS1");
                _super.naxis2 = fits.header.get("NAXIS2");
                this._craDeg = fits.header.getItemListOf("CRVAL1")[0].value;
                this._cdecDeg = fits.header.getItemListOf("CRVAL2")[0].value;
                // TODO CDELT could not be present. In this is the case, 
                // there should be CDi_ja, but I am not handling them atm
                // [Ref. Representation of celestial coordinates in FITS - equation (1)]
                this._pxsize1 = this._fitsheader[0].getItemListOf("CDELT1")[0].value;
                this._pxsize2 = this._fitsheader[0].getItemListOf("CDELT2")[0].value;
                this._minra = this._craDeg - this._pxsize1 * _super.naxis1 / 2;
                if (this._minra < 0) {
                    this._minra += 360;
                }
                this._mindec = this._cdecDeg - this._pxsize2 * _super.naxis2 / 2;
                return fits;
            });
            yield promise;
            return promise;
        });
    }
    extractPhysicalValues(fits) {
        let bzero = fits.header.get("BZERO");
        let bscale = fits.header.get("BSCALE");
        let naxis1 = fits.header.get("NAXIS1");
        let naxis2 = fits.header.get("NAXIS2");
        let bitpix = fits.header.get("BITPIX");
        let bytesXelem = Math.abs(bitpix / 8);
        let blankBytes = jsfitsio__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.convertBlankToBytes(fits.header.get("BLANK"), bytesXelem); // TODO => ??????? Im not using it. it should be used!
        // let physicalvalues = new Array[naxis2][naxis1];
        let physicalvalues = new Array(naxis2);
        for (let n2 = 0; n2 < naxis2; n2++) {
            physicalvalues[n2] = new Array(naxis1);
            for (let n1 = 0; n1 < naxis1; n1++) {
                let pixval = jsfitsio__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);
                let physicalVal = bzero + bscale * pixval;
                physicalvalues[n2][n1] = physicalVal;
            }
        }
        return physicalvalues;
    }
    prepareFITSHeader(fitsHeaderParams) {
        this._fitsheader[0] = new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeader();
        this._fitsheader[0].addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("BITPIX", fitsHeaderParams.get("BITPIX")));
        this._fitsheader[0].addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("SIMPLE", fitsHeaderParams.get("SIMPLE")));
        if (fitsHeaderParams.get("BLANK") !== undefined) {
            this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("BLANK", fitsHeaderParams.get("BLANK")));
        }
        let bscale = 1.0;
        if (fitsHeaderParams.get("BSCALE") !== undefined) {
            bscale = fitsHeaderParams.get("BSCALE");
        }
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("BSCALE", bscale));
        let bzero = 0.0;
        if (fitsHeaderParams.get("BZERO") !== undefined) {
            bzero = fitsHeaderParams.get("BZERO");
        }
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("BZERO", bzero));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("NAXIS", 2));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("NAXIS1", super.naxis1));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("NAXIS2", super.naxis2));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CTYPE1", super.ctype1));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CTYPE2", super.ctype2));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CDELT1", super.pxsize)); // ??? Pixel spacing along axis 1 ???
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CDELT2", super.pxsize)); // ??? Pixel spacing along axis 2 ???
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CRPIX1", super.naxis1 / 2)); // central/reference pixel i along naxis1
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CRPIX2", super.naxis2 / 2)); // central/reference pixel j along naxis2
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CRVAL1", this._craDeg)); // central/reference pixel RA
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("CRVAL2", this._cdecDeg)); // central/reference pixel Dec
        let min = bzero + bscale * this._minphysicalval;
        let max = bzero + bscale * this._maxphysicalval;
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("DATAMIN", min)); // min data value
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("DATAMAX", max)); // max data value
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("ORIGIN", "WCSLight v.0.x"));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("COMMENT", "WCSLight v0.x developed by F.Giordano and Y.Ascasibar"));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem("END"));
        return this._fitsheader;
    }
    getFITSHeader() {
        return this._fitsheader;
    }
    getCommonFitsHeaderParams() {
        let header = new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeader();
        for (const [key, value] of this._fitsheader[0]) {
            // I could add a list of used NPIXs to be included in the comment of the output FITS
            if (["SIMPLE", "BITPIX", "BSCALE", "BZERO", "BLANK", "ORDER",].includes(key)) {
                // header.set(key, value);
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_1__.FITSHeaderItem(key, value));
            }
        }
        return header;
    }
    getPixValues(inputPixelsList) {
        const _super = Object.create(null, {
            naxis2: { get: () => super.naxis2 },
            naxis1: { get: () => super.naxis1 }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let promise = new Promise((resolve, reject) => {
                try {
                    let bytesXelem = Math.abs(this._fitsheader[0].get("BITPIX") / 8);
                    let blankBytes = jsfitsio__WEBPACK_IMPORTED_MODULE_1__.ParseUtils.convertBlankToBytes(this._fitsheader[0].get("BLANK"), bytesXelem);
                    let pixcount = inputPixelsList.length;
                    let values = new Uint8Array(pixcount * bytesXelem);
                    for (let p = 0; p < pixcount; p++) {
                        let imgpx = inputPixelsList[p];
                        // TODO check when input is undefined. atm it puts 0 bur it should be BLANK
                        // TODO why I am getting negative i and j? check world2pix!!!
                        if ((imgpx._j) < 0 || (imgpx._j) >= _super.naxis2 ||
                            (imgpx._i) < 0 || (imgpx._i) >= _super.naxis1) {
                            for (let b = 0; b < bytesXelem; b++) {
                                values[p * bytesXelem + b] = blankBytes[b];
                            }
                        }
                        else {
                            for (let b = 0; b < bytesXelem; b++) {
                                values[p * bytesXelem + b] = (this._pxvalues.get(0))[imgpx._j][(imgpx._i) * bytesXelem + b];
                            }
                        }
                    }
                    resolve(values);
                }
                catch (err) {
                    reject("[MercatorProjection] ERROR: " + err);
                }
            });
            return promise;
        });
    }
    setPxsValue(values, fitsHeaderParams) {
        // let bytesXelem = Math.abs(fitsHeaderParams.get("BITPIX") / 8);
        // let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get("BITPIX"));
        // let maxpixb = minpixb;
        // let bscale = (fitsHeaderParams.get("BSCALE") !== undefined) ? fitsHeaderParams.get("BSCALE") : 1.0;
        // let bzero = (fitsHeaderParams.get("BZERO") !== undefined) ? fitsHeaderParams.get("BZERO") : 0.0;
        // this._minphysicalval = bzero + bscale * minpixb;
        // this._maxphysicalval = bzero + bscale * maxpixb;
        // this._pxvalues = new Array(this._naxis2);
        // for (let r = 0; r < this._naxis2; r++) {
        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);
        // }
        // TODO ...
        return null;
    }
    getImageRADecList(center, radius, pxsize) {
        // let promise = new Promise((resolve, reject) => {
        //     this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]
        //     this._pxsize = pxsize;
        //     this._minra = center.ra - radius;
        //     if (this._minra < 0) {
        //         this._minra += 360;
        //     }
        //     this._mindec = center.dec - radius;
        //     let radeclist = [];
        //     let pra, pdec;
        // TODO ...
        /*
        basing on naxis1 and naxis2 call pix2world!!!
        */
        /*
        

        mindec = center.dec - radius;
        maxdec = center.dec + radius;
        below pixel size should  depend on the distance from the center
        let l =  0;
        let factor = 1;
        
        for (let d = mindec; d < maxdec; d+=pxsize) { <--ERROR the external loop must be over RA
            factor = 1 + 2**l;
            rapxsize = pxsize/factor;
            for (let r = 0; r < 360; r+=rapxsize) {
                radeclist.push(r, d);
            }
            l++;
        }
        */
        // let cidx = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;
        // this._cra = radeclist[cidx][0];
        // this._cdec = radeclist[cidx][1];
        // resolve(radeclist);
        // });
        // return promise;
        return null;
    }
    pix2world(i, j) {
        // TODO ...
        let x, y;
        let CDELT1 = this._fitsheader[0].getItemListOf("CDELT1")[0];
        let CDELT2 = this._fitsheader[0].getItemListOf("CDELT2")[0];
        let PC1_1 = this._fitsheader[0].getItemListOf("PC1_1")[0];
        let PC1_2 = this._fitsheader[0].getItemListOf("PC1_2")[0];
        let PC2_1 = this._fitsheader[0].getItemListOf("PC2_1")[0];
        let PC2_2 = this._fitsheader[0].getItemListOf("PC2_2")[0];
        let CD1_1 = this._fitsheader[0].getItemListOf("CD1_1")[0];
        let CD1_2 = this._fitsheader[0].getItemListOf("CD1_2")[0];
        let CD2_1 = this._fitsheader[0].getItemListOf("CD2_1")[0];
        let CD2_2 = this._fitsheader[0].getItemListOf("CD2_2")[0];
        let CRPIX1 = this._fitsheader[0].getItemListOf("CRPIX1")[0];
        let CRPIX2 = this._fitsheader[0].getItemListOf("CRPIX2")[0];
        if (CDELT1 !== undefined && CDELT2 !== undefined &&
            PC1_1 !== undefined && PC1_2 !== undefined &&
            PC2_1 !== undefined && PC2_2 !== undefined) { // if CDELTia and PCi_ja notation
            x = CDELT1 * (PC1_1 * (i - CRPIX1) + PC1_2 * (j - CRPIX2));
            y = CDELT2 * (PC2_1 * (i - CRPIX1) + PC2_2 * (j - CRPIX2));
        }
        else { // else CDi_ja notation
            x = CD1_1 * (i - CRPIX1) + CD1_2 * (j - CRPIX2);
            y = CD2_1 * (i - CRPIX1) + CD2_2 * (j - CRPIX2);
        }
        // let phi = math.arg(-y / x);
        // let R_theta = Math.sqrt(x * x + y * y);
        // let theta = Math.atan2(180 / (Math.PI * R_theta));
        // let ra, dec;
        // ra = phi;
        // dec = theta;
        // // TODO check if phi, theta match with ra, dec or they need to be (linearly) converted 
        // return [ra, dec];
        return null;
    }
    world2pix(radeclist) {
        let imgpxlist = [];
        let CDELT1 = (this._fitsheader[0].getItemListOf("CDELT1").length > 0) ? this._fitsheader[0].getItemListOf("CDELT1")[0] : undefined;
        let CDELT2 = (this._fitsheader[0].getItemListOf("CDELT2").length > 0) ? this._fitsheader[0].getItemListOf("CDELT2")[0] : undefined;
        let PC1_1 = (this._fitsheader[0].getItemListOf("PC1_1").length > 0) ? this._fitsheader[0].getItemListOf("PC1_1")[0] : undefined;
        let PC1_2 = (this._fitsheader[0].getItemListOf("PC1_2").length > 0) ? this._fitsheader[0].getItemListOf("PC1_2")[0] : undefined;
        let PC2_1 = (this._fitsheader[0].getItemListOf("PC2_1").length > 0) ? this._fitsheader[0].getItemListOf("PC2_1")[0] : undefined;
        let PC2_2 = (this._fitsheader[0].getItemListOf("PC2_2").length > 0) ? this._fitsheader[0].getItemListOf("PC2_2")[0] : undefined;
        let CD1_1 = (this._fitsheader[0].getItemListOf("CD1_1").length > 0) ? this._fitsheader[0].getItemListOf("CD1_1")[0] : undefined;
        let CD1_2 = (this._fitsheader[0].getItemListOf("CD1_2").length > 0) ? this._fitsheader[0].getItemListOf("CD1_2")[0] : undefined;
        let CD2_1 = (this._fitsheader[0].getItemListOf("CD2_1").length > 0) ? this._fitsheader[0].getItemListOf("CD2_1")[0] : undefined;
        let CD2_2 = (this._fitsheader[0].getItemListOf("CD2_2").length > 0) ? this._fitsheader[0].getItemListOf("CD2_2")[0] : undefined;
        let CRPIX1 = (this._fitsheader[0].getItemListOf("CRPIX1").length > 0) ? this._fitsheader[0].getItemListOf("CRPIX1")[0] : undefined;
        let CRPIX2 = (this._fitsheader[0].getItemListOf("CRPIX2").length > 0) ? this._fitsheader[0].getItemListOf("CRPIX2")[0] : undefined;
        radeclist.forEach(([ra, dec]) => {
            // TODO ...
            // let i, j;
            // // (linearly) convert ra, dec into phi, theta
            // let theta = dec;
            // let phi = ra;
            // let R_theta = (180 / Math.PI) * math.cot(theta);
            // let x = R_theta * Math.sin(phi);
            // let y = - R_theta * Math.cos(phi);
            // if (CDELT1 !== undefined && CDELT2 !== undefined &&
            //     PC1_1 !== undefined && PC1_2 !== undefined &&
            //     PC2_1 !== undefined && PC2_2 !== undefined
            // ) { // if CDELTia and PCi_ja notation
            //     j = y * CDELT1 * PC1_1 / (CDELT1 * CDELT2 * (PC1_1 * PC2_2 - PC2_1 * PC1_2)) + PC1_1 * CRPIX2 * (PC2_2 - PC2_1) / (PC1_1 * PC2_2 - PC2_1 * PC1_2);
            //     i = x / (CDELT1 * PC1_1) + CRPIX1 - j * PC1_2 / PC1_1 + CRPIX2 * PC1_2 / PC1_1;
            // } else { // else CDi_ja notation
            //     j = y * CD1_1 / (CD1_1 * CD2_2 - CD1_2 * CD2_1) + CRPIX2 * CD1_1 * (CD2_2 - CD2_1) / (CD1_1 * CD2_2 - CD1_2 * CD2_1);
            //     i = (x + CD1_1 * CRPIX1 - CD1_2 * j + CD1_2 * CRPIX2) / CD1_1;
            // }
            // imgpxlist.push(new ImagePixel(i, j));
        });
        return imgpxlist;
    }
}
//# sourceMappingURL=GnomonicProjection.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/projections/HEALPixProjection.js":
/*!************************************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/projections/HEALPixProjection.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEALPixProjection: () => (/* binding */ HEALPixProjection)
/* harmony export */ });
/* harmony import */ var _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractProjection.js */ "./node_modules/wcslight/lib-esm/projections/AbstractProjection.js");

class HEALPixProjection extends _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_0__.AbstractProjection {
    constructor() {
        super("'RA---HPX'", "'DEC--HPX'");
    }
    get fitsUsed() {
        throw new Error('Method not implemented.');
    }
    initFromFile(fitsfilepath, hipsURI, pxsize, order) {
        throw new Error('Method not implemented.');
    }
    prepareFITSHeader(fitsHeaderParams) {
        throw new Error('Method not implemented.');
    }
    getFITSHeader() {
        throw new Error('Method not implemented.');
    }
    getCommonFitsHeaderParams() {
        throw new Error('Method not implemented.');
    }
    extractPhysicalValues(fits) {
        throw new Error('Method not implemented.');
    }
    getPixValues(inputPixelsList) {
        throw new Error('Method not implemented.');
    }
    setPxsValue(values, fitsHeaderParams) {
        throw new Error('Method not implemented.');
    }
    getImageRADecList(center, radius, pxsize) {
        throw new Error('Method not implemented.');
    }
    pix2world(i, j) {
        throw new Error('Method not implemented.');
    }
    world2pix(radeclist) {
        throw new Error('Method not implemented.');
    }
}
//# sourceMappingURL=HEALPixProjection.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/projections/HiPSHelper.js":
/*!*****************************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/projections/HiPSHelper.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HiPSHelper: () => (/* binding */ HiPSHelper)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _model_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Utils.js */ "./node_modules/wcslight/lib-esm/model/Utils.js");
/* harmony import */ var _model_CoordsType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/CoordsType.js */ "./node_modules/wcslight/lib-esm/model/CoordsType.js");
/* harmony import */ var _model_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/Point.js */ "./node_modules/wcslight/lib-esm/model/Point.js");
/* harmony import */ var _model_NumberType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/NumberType.js */ "./node_modules/wcslight/lib-esm/model/NumberType.js");
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */


 // TODO change package



class HiPSHelper {
    /**
     * Table 1 - ref paper HEALPix  a Framework for High Resolution Discretization,
     * and Fast Analysis of Data Distributed on the Sphere
     * K. M. Gorski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.
     * Reinecke5, M. Bartelman9
     */
    /**
     *
     * @param {decimal degrees} pxsize
     * @returns {int} nside
     */
    static computeHiPSOrder(pxsize, pxXtile) {
        /**
         * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than
         * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\
         * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this
         * way:
         *
         * 	L(k) = L(0) / 2^k = 58.6 / 2^k
         *
         * Therefore, in the case of HiPS we need to take into account the extra resolution given by the
         * 512x512 (2^9) tiles. In this case the above becomes:
         *
         * 	L(k) = L(0) / (2^k * 2^9)
         *
         * Though, in order to compute the required order starting from the pxsize desired (in input) we
         * need to perform these steps:
         *
         * 	pxsize = L(k) = L(0) / (2^k * 2^9)
         * 	2^k = L(0) / (pxsize * 2^9)
         *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)
         * 	k = Log2 L(0) - Log2 (pxsize * 2^9)
         *
         */
        let k = Math.log2((HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);
        // let k = Math.log2(HiPSHelper.RES_ORDER_0 / (pxXtile * pxsize));
        k = Math.round(k);
        // let theta0px = HiPSHelper.RES_ORDER_0;
        // let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);
        // k = Match.round(k);
        // let nside = 2**k;
        // return {
        //     "nside" : nside,
        //     "norder" : k
        // };
        return k;
    }
    static computeHiPSOrder2(pxsize, pxXtile) {
        const k = Math.log2(Math.sqrt(Math.PI / 3) / (pxsize * pxXtile));
        const order = Math.round(k);
        console.warn(k);
        return order;
    }
    // based on "HiPS  Hierarchical Progressive Survey" IVOA recomandation (formula on table 5)
    static computeOrder(pxAngSizeDeg, pxTileWidth) {
        console.log(`Computing HiPS order having pixel angular size of ${pxAngSizeDeg} in degrees`);
        const deg2rad = Math.PI / 180;
        const pxAngSizeRad = pxAngSizeDeg * deg2rad;
        console.log(`pixel angular res in radians ${pxAngSizeRad}`);
        const computedOrder = 0.5 * Math.log2(Math.PI / (3 * pxAngSizeRad * pxAngSizeRad * pxTileWidth * pxTileWidth));
        console.log(`Order ${computedOrder}`);
        if (computedOrder < 0) {
            return 0;
        }
        return Math.floor(computedOrder);
    }
    // based on "HiPS  Hierarchical Progressive Survey" IVOA recomandation (formula on table 5)
    static computePxAngularSize(pxTileWidth, order) {
        const computedPxAngSizeRadiant = Math.sqrt(4 * Math.PI / (12 * Math.pow((pxTileWidth * (Math.pow(2, order))), 2)));
        console.log(`Computing Pixel size with tile of ${pxTileWidth} pixels and order ${order}`);
        const rad2deg = 180 / Math.PI;
        const deg = computedPxAngSizeRadiant * rad2deg;
        const arcmin = computedPxAngSizeRadiant * rad2deg * 60;
        const arcsec = computedPxAngSizeRadiant * rad2deg * 3600;
        console.log("Pixel size in radiant:" + computedPxAngSizeRadiant);
        console.log("Pixel size in degrees:" + deg);
        console.log("Pixel size in arcmin:" + arcmin);
        console.log("Pixel size in arcsec:" + arcsec);
        return {
            "rad": computedPxAngSizeRadiant,
            "deg": deg,
            "arcmin": arcmin,
            "arcsec": arcsec
        };
    }
    /**
     * Reference: HiPS  Hierarchical Progressive Survey page 11
     * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]
     * @param {*} order
     */
    static computePxSize(order, pxXtile) {
        // TODO CHECK IT
        // let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);
        let pxsize = 1 / (pxXtile * Math.pow(2, order)) * Math.sqrt(Math.PI / 3);
        return pxsize;
    }
    // /**
    //  * 
    //  * @param {Object {ra, dec}} point  decimal degrees
    //  * @returns {Object {phi_rad, theta_rad}} in radians
    //  */
    // static convert2PhiTheta (point: Point) {
    // 	let phitheta_rad = {};
    // 	let phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);
    // 	phitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);
    //     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);
    // 	return phitheta_rad;
    // }
    // static astroDegToSphericalRad(raDeg: number, decDeg: number) {
    // 	let phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);
    // 	let phiThetaRad = {
    // 		phi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),
    // 		theta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)
    // 	}
    // 	return phiThetaRad;
    // }
    // static degToRad(degrees: number): number {
    // 	return (degrees / 180 ) * Math.PI ;
    // }
    // static radToDeg(rad: number): number {
    // 	return (rad / Math.PI ) * 180 ;
    // }
    // static astroDegToSpherical(raDeg: number, decDeg: number): Point{
    // 	let phiDeg: number;
    // 	let thetaDeg: number;
    // 	phiDeg = raDeg;
    // 	if (phiDeg < 0){
    // 		phiDeg += 360;
    // 	}
    // 	thetaDeg = 90 - decDeg;
    // 	return {
    // 		phi: phiDeg,
    // 		theta: thetaDeg
    // 	};
    // }
    /**
     *
     * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians
     * @param {decimal} r Radius of the circle in radians
     * @returns
     */
    static computeBbox(point, r) {
        let bbox = [];
        bbox.push(new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));
        bbox.push(new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad + r));
        bbox.push(new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(null, false, point.spherical.thetaRad + r, point.spherical.phiRad + r));
        bbox.push(new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));
        return bbox;
    }
    static setupByTile(tileno, hp) {
        let xyGridProj = {
            "min_y": NaN,
            "max_y": NaN,
            "min_x": NaN,
            "max_x": NaN,
            "gridPointsDeg": []
        };
        let cornersVec3 = hp.getBoundariesWithStep(tileno, 1);
        let pointings = [];
        for (let i = 0; i < cornersVec3.length; i++) {
            pointings[i] = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(cornersVec3[i]);
            if (i >= 1) {
                let a = pointings[i - 1].phi;
                let b = pointings[i].phi;
                // case when RA is just crossing the origin (e.g. 357deg - 3deg)
                if (Math.abs(a - b) > Math.PI) {
                    if (pointings[i - 1].phi < pointings[i].phi) {
                        pointings[i - 1].phi += 2 * Math.PI;
                    }
                    else {
                        pointings[i].phi += 2 * Math.PI;
                    }
                }
            }
        }
        for (let j = 0; j < pointings.length; j++) {
            let coThetaRad = pointings[j].theta;
            // HEALPix works with colatitude (0 North Pole, 180 South Pole)
            // converting the colatitude in latitude (dec)
            let decRad = Math.PI / 2 - coThetaRad;
            let raRad = pointings[j].phi;
            // projection on healpix grid
            let p = new _model_Point_js__WEBPACK_IMPORTED_MODULE_3__.Point(_model_CoordsType_js__WEBPACK_IMPORTED_MODULE_2__.CoordsType.ASTRO, _model_NumberType_js__WEBPACK_IMPORTED_MODULE_4__.NumberType.RADIANS, raRad, decRad);
            let xyDeg = HiPSHelper.world2intermediate(p.astro);
            xyGridProj.gridPointsDeg[j * 2] = xyDeg[0];
            xyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];
            if (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {
                xyGridProj.max_y = xyDeg[1];
            }
            if (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {
                xyGridProj.min_y = xyDeg[1];
            }
            if (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {
                xyGridProj.max_x = xyDeg[0];
            }
            if (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {
                xyGridProj.min_x = xyDeg[0];
            }
        }
        return xyGridProj;
    }
    static world2intermediate(ac) {
        let x_grid;
        let y_grid;
        if (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts
            x_grid = ac.raDeg;
            y_grid = healpixjs__WEBPACK_IMPORTED_MODULE_0__.Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;
        }
        else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones
            let raDeg = ac.raDeg;
            let w = 0; // omega
            if (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0
                w = 1;
            }
            let sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(healpixjs__WEBPACK_IMPORTED_MODULE_0__.Hploc.sin(ac.decRad))));
            let phi_c = -180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);
            x_grid = phi_c + (raDeg - phi_c) * sigma;
            y_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);
            if (ac.decRad < 0) {
                y_grid *= -1;
            }
        }
        return [x_grid, y_grid];
    }
    // static world2intermediate(sc: SphericalCoords): [number, number] {
    //     let x_grid: number;
    // 	let y_grid: number;
    // 	if ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts
    // 		x_grid = sc.phiDeg;
    // 		y_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;
    // 	} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones
    // 		let phiDeg = sc.phiDeg;
    // 		let w = 0; // omega
    // 		if (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0
    // 			w = 1;
    // 		}
    // 		let sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );
    // 		let phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );
    // 		x_grid = phi_c + (phiDeg - phi_c) * sigma;
    // 		y_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);
    // 		if (sc.thetaRad < 0) {
    // 			y_grid *= -1;
    // 		}
    // 	}
    // 	return [x_grid, y_grid];
    // }
    static intermediate2pix(x, y, xyGridProj, pxXtile) {
        let xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);
        let yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);
        let i_norm;
        let j_norm;
        if ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {
            i_norm = (x + 360 - xyGridProj.min_x) / xInterval;
        }
        else {
            i_norm = (x - xyGridProj.min_x) / xInterval;
        }
        j_norm = (y - xyGridProj.min_y) / yInterval;
        let i = 0.5 - (i_norm - j_norm);
        let j = (i_norm + j_norm) - 0.5;
        // TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);
        pxXtile;
        // i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);
        // j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);
        // return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];
        i = Math.floor(i * pxXtile);
        j = Math.floor(j * pxXtile);
        return [i, pxXtile - j - 1];
    }
    static pix2intermediate(i, j, xyGridProj, naxis1, naxis2) {
        /**
           * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image
         * (i_norm,w_pixel) = (1,1) is the upper right corner
         * dimamond in figure 1 from "Mapping on the HEalpix grid" paper
         * (0,0) leftmost corner
         * (1,0) upper corner
         * (0,1) lowest corner
         * (1,1) rightmost corner
         * Thanks YAGO! :p
         */
        // let cnaxis1 = HiPSHelper.pxXtile;
        // let cnaxis2 = HiPSHelper.pxXtile;
        let cnaxis1 = naxis1;
        let cnaxis2 = naxis2;
        if (naxis1) {
            cnaxis1 = naxis1;
        }
        if (naxis2) {
            cnaxis2 = naxis2;
        }
        let i_norm = (i + 0.5) / cnaxis1;
        let j_norm = (j + 0.5) / cnaxis2;
        let xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;
        let yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;
        let yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;
        // bi-linear interpolation
        let x = xyGridProj.max_x - xInterval * (i_norm + j_norm);
        let y = yMean - yInterval * (j_norm - i_norm);
        return [x, y];
    }
    static intermediate2world(x, y) {
        let phiDeg;
        let thetaDeg;
        let Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;
        if (Math.abs(y) <= Yx) { // equatorial belts
            phiDeg = x;
            thetaDeg = (0,_model_Utils_js__WEBPACK_IMPORTED_MODULE_1__.radToDeg)(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));
        }
        else if (Math.abs(y) > Yx) { // polar regions
            let sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;
            let thetaRad = healpixjs__WEBPACK_IMPORTED_MODULE_0__.Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);
            let w = 0; // omega
            if (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0
                w = 1;
            }
            let x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);
            phiDeg = x_c + (x - x_c) / sigma;
            thetaDeg = (0,_model_Utils_js__WEBPACK_IMPORTED_MODULE_1__.radToDeg)(thetaRad);
            if (y <= 0) {
                thetaDeg *= -1;
            }
        }
        // return [phiDeg, thetaDeg];
        // TODO CHECK THIS!
        // let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);
        let p = new _model_Point_js__WEBPACK_IMPORTED_MODULE_3__.Point(_model_CoordsType_js__WEBPACK_IMPORTED_MODULE_2__.CoordsType.ASTRO, _model_NumberType_js__WEBPACK_IMPORTED_MODULE_4__.NumberType.DEGREES, phiDeg, thetaDeg);
        return p;
    }
}
// static pxXtile: number = 512; // TODO in some cases it is different
HiPSHelper.DEFAULT_Naxis1_2 = 512;
// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;
HiPSHelper.RES_ORDER_0 = 58.6;
HiPSHelper.H = 4;
HiPSHelper.K = 3;
HiPSHelper.THETAX = healpixjs__WEBPACK_IMPORTED_MODULE_0__.Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);
//# sourceMappingURL=HiPSHelper.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/projections/HiPSProjection.js":
/*!*********************************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/projections/HiPSProjection.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HiPSProjection: () => (/* binding */ HiPSProjection)
/* harmony export */ });
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractProjection.js */ "./node_modules/wcslight/lib-esm/projections/AbstractProjection.js");
/* harmony import */ var _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HiPSHelper.js */ "./node_modules/wcslight/lib-esm/projections/HiPSHelper.js");
/* harmony import */ var _model_ImagePixel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/ImagePixel.js */ "./node_modules/wcslight/lib-esm/model/ImagePixel.js");
/* harmony import */ var _model_Utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../model/Utils.js */ "./node_modules/wcslight/lib-esm/model/Utils.js");
/* harmony import */ var _model_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../model/Point.js */ "./node_modules/wcslight/lib-esm/model/Point.js");
/* harmony import */ var _model_CoordsType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../model/CoordsType.js */ "./node_modules/wcslight/lib-esm/model/CoordsType.js");
/* harmony import */ var _model_NumberType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../model/NumberType.js */ "./node_modules/wcslight/lib-esm/model/NumberType.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */













class HiPSProjection extends _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_2__.AbstractProjection {
    /**
     *
     * * ex with single local file:
     * let hp = new HiPSProjection('/mylocaldir/myfile.fits', null, null, null);
     * hp.initFromFile()
     *
     * * ex with single remote file:
     * let hp = new HiPSProjection('http://<hips-server>/Norder7/DirN/NpixXYZ.fits', null, null, null);
     * hp.initFromFile()
     *
     * * ex with HiPS server base local dir:
     * let hp = new HiPSProjection(null, <hips-local-root-dir>, pxsize, order);
     * hp.initFromBaseHiPSDir()
     *
     * * ex with HiPS server base URL:
     * let hp = new HiPSProjection(null, 'http://<hips-server>/<hips-root-dir>', pxsize, order);
     * hp.initFromBaseHiPSDir()
     *
     */
    //  constructor(fitsfilepath?: string, hipsBaseURI?: string, pxsize?: number, order?: number) {
    constructor() {
        super("'RA---HPX'", "'DEC--HPX'");
        // _naxis1!: number;
        // _naxis2!: number;
        this._isGalactic = false;
        this._fitsUsed = [];
        this._wcsname = "HPX"; // TODO check WCS standard
        // this._ctype1 = "RA---HPX";
        // this._ctype2 = "DEC--HPX";
        this._pxvalues = new Map();
        this._fitsheaderlist = new Array();
        this._radeclist = new Array();
    }
    parsePropertiesFile(baseUrl) {
        const _super = Object.create(null, {
            naxis1: { get: () => super.naxis1, set: v => super.naxis1 = v },
            naxis2: { get: () => super.naxis2, set: v => super.naxis2 = v }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const fp = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSParser(null);
            const promise = fp.getFile(baseUrl + "/properties").then((propFile) => {
                let prop;
                if (propFile instanceof ArrayBuffer) {
                    const textDecoder = new TextDecoder("iso-8859-1");
                    prop = textDecoder.decode(new Uint8Array(propFile));
                }
                else {
                    prop = propFile.toString('utf8');
                }
                /**
                    HiPS  Hierarchical Progressive Survey
                    Version 1.0
                    IVOA Proposed Recommendation
                    3rd April 2017
                    https://www.ivoa.net/documents/HiPS/20170403/PR-HIPS-1.0-20170403.pdf
                 */
                const txtArr = prop.split('\n');
                this._HIPS_TILE_WIDTH = 512;
                for (let line of txtArr) {
                    if (!line.includes("=")) {
                        continue;
                    }
                    const tokens = line.split("=");
                    if (tokens[1] === undefined) {
                        continue;
                    }
                    const key = tokens[0].trim();
                    const val = tokens[1].trim();
                    if (key == "hips_order") {
                        this._HIPS_MAX_ORDER = parseInt(val);
                        console.log("hips_order " + this._HIPS_MAX_ORDER);
                    }
                    else if (key == "hips_tile_width") {
                        this._HIPS_TILE_WIDTH = parseInt(val);
                        _super.naxis1 = this._HIPS_TILE_WIDTH;
                        _super.naxis2 = this._HIPS_TILE_WIDTH;
                        console.log("hips_tile_width " + this._HIPS_TILE_WIDTH);
                    }
                    else if (key == "hips_frame" && val == "galactic") {
                        this._isGalactic = true;
                    }
                }
                return propFile;
            });
            yield promise;
            return promise;
        });
    }
    initFromFile(fitsfilepath) {
        const _super = Object.create(null, {
            naxis1: { get: () => super.naxis1, set: v => super.naxis1 = v },
            naxis2: { get: () => super.naxis2, set: v => super.naxis2 = v }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let fp = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSParser(fitsfilepath);
            let promise = fp.loadFITS().then(fits => {
                this._pxvalues.set(0, fits.data);
                this._fitsheaderlist[0] = fits.header;
                let order = fits.header.get("ORDER");
                this.init(order);
                _super.naxis1 = fits.header.get("NAXIS1");
                _super.naxis2 = fits.header.get("NAXIS2");
                this._HIPS_TILE_WIDTH = _super.naxis1;
                this._pixno = fits.header.get("NPIX");
                this._xyGridProj = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.setupByTile(this._pixno, this._hp);
                return fits;
            });
            yield promise;
            return promise;
        });
    }
    initFromHiPSLocationAndPxSize(baseUrl, pxsize) {
        const _super = Object.create(null, {
            pxsize: { get: () => super.pxsize, set: v => super.pxsize = v }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this._hipsBaseURI = baseUrl;
            _super.pxsize = pxsize;
            if (this._HIPS_TILE_WIDTH === undefined) {
                yield this.parsePropertiesFile(baseUrl);
            }
            // let order = HiPSHelper.computeHiPSOrder(pxsize, this._HIPS_TILE_WIDTH);
            // let order2 = HiPSHelper.computeHiPSOrder2(pxsize, this._HIPS_TILE_WIDTH);
            let order = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.computeOrder(pxsize, this._HIPS_TILE_WIDTH);
            if (order > this._HIPS_MAX_ORDER) {
                order = this._HIPS_MAX_ORDER;
            }
            this.init(order);
        });
    }
    initFromHiPSLocationAndOrder(baseUrl, order) {
        const _super = Object.create(null, {
            pxsize: { get: () => super.pxsize, set: v => super.pxsize = v }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this._hipsBaseURI = baseUrl;
            if (this._HIPS_TILE_WIDTH === undefined) {
                yield this.parsePropertiesFile(baseUrl);
            }
            if (order > this._HIPS_MAX_ORDER) {
                order = this._HIPS_MAX_ORDER;
            }
            _super.pxsize = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.computePxSize(order, this._HIPS_TILE_WIDTH);
            this.init(order);
        });
    }
    init(order) {
        this._norder = order;
        this._nside = Math.pow(2, order);
        this._hp = new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Healpix(this._nside);
    }
    prepareFITSHeader(fitsHeaderParams) {
        for (let header of this._fitsheaderlist) {
            header.addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BITPIX", fitsHeaderParams.get("BITPIX")));
            header.addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("SIMPLE", fitsHeaderParams.get("SIMPLE")));
            if (fitsHeaderParams.get("BLANK") !== undefined) {
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BLANK", fitsHeaderParams.get("BLANK")));
            }
            let bscale = 1.0;
            if (fitsHeaderParams.get("BSCALE") !== undefined) {
                bscale = fitsHeaderParams.get("BSCALE");
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BSCALE", bscale));
            }
            let bzero = 0.0;
            if (fitsHeaderParams.get("BZERO") !== undefined) {
                bzero = fitsHeaderParams.get("BZERO");
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BZERO", bzero));
            }
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS", 2));
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS1", _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.DEFAULT_Naxis1_2));
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS2", _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.DEFAULT_Naxis1_2));
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("ORDER", this._norder));
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CTYPE1", super.ctype1));
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CTYPE2", super.ctype2));
            // header.addItem(new FITSHeaderItem("CRPIX1", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel i along naxis1
            // header.addItem(new FITSHeaderItem("CRPIX2", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel j along naxis2
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("ORIGIN", "WCSLight v.0.x"));
            header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("COMMENT", "WCSLight v0.x developed by F.Giordano and Y.Ascasibar"));
        }
        return this._fitsheaderlist;
    }
    getFITSHeader() {
        return this._fitsheaderlist;
    }
    getCommonFitsHeaderParams() {
        return this._fh_common;
    }
    extractPhysicalValues(fits) {
        let bzero = fits.header.get("BZERO");
        let bscale = fits.header.get("BSCALE");
        let naxis1 = fits.header.get("NAXIS1");
        let naxis2 = fits.header.get("NAXIS2");
        let bitpix = fits.header.get("BITPIX");
        let bytesXelem = Math.abs(bitpix / 8);
        let blankBytes = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.convertBlankToBytes(fits.header.get("BLANK"), bytesXelem); // TODO => ??????? Im not using it. it should be used!
        // let physicalvalues = new Array[naxis2][naxis1];
        let physicalvalues = new Array(naxis2);
        for (let n2 = 0; n2 < naxis2; n2++) {
            physicalvalues[n2] = new Array(naxis1);
            for (let n1 = 0; n1 < naxis1; n1++) {
                let pixval = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);
                let physicalVal = bzero + bscale * pixval;
                physicalvalues[n2][n1] = physicalVal;
            }
        }
        return physicalvalues;
    }
    getFITSFiles(inputPixelsList, destPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const fitsFilesGenerated = new Map();
            let promises = [];
            let tilesset = new Set();
            inputPixelsList.forEach((imgpx) => {
                tilesset.add(imgpx.tileno);
            });
            for (let hipstileno of tilesset) {
                let tileno = hipstileno;
                let dir = Math.floor(tileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 
                let fitsurl = this._hipsBaseURI + "/Norder" + this._norder + "/Dir" + dir + "/Npix" + tileno + ".fits";
                let fp = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSParser(fitsurl);
                promises.push(fp.loadFITS().then((fits) => {
                    if (fits !== null) {
                        let pixno = (fits.header.get("NPIX") !== undefined) ? fits.header.get("NPIX") : tileno;
                        // FITSParser.writeFITS(fits.header, fits.data, destPath+"/Npix"+pixno+".fits");
                        // fitsFilesGenerated.set(destPath+"/Npix"+pixno+".fits",FITSParser.generateFITS(fits.header, fits.data) );
                        fitsFilesGenerated.set(destPath + "/Npix" + pixno + ".fits", fits);
                    }
                }));
            }
            yield Promise.all(promises);
            return fitsFilesGenerated;
        });
    }
    get fitsUsed() {
        return this._fitsUsed;
    }
    getPixValues(inputPixelsList) {
        return __awaiter(this, void 0, void 0, function* () {
            let tilesset = new Set();
            inputPixelsList.forEach((imgpx) => {
                tilesset.add(imgpx.tileno);
            });
            let pixcount = inputPixelsList.length;
            let values = undefined;
            let fitsheaderlist = [];
            let promises = [];
            let self = this;
            for (let hipstileno of tilesset) {
                let dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 
                let fitsurl = this._hipsBaseURI + "/Norder" + this._norder + "/Dir" + dir + "/Npix" + hipstileno + ".fits";
                console.log(`Identified source file ${fitsurl}`);
                let fp = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSParser(fitsurl);
                promises.push(fp.loadFITS().then((fits) => {
                    if (fits === null) {
                        fitsheaderlist.push(undefined);
                    }
                    else {
                        self._fitsUsed.push(fitsurl);
                        let bytesXelem = Math.abs(fits.header.get("BITPIX") / 8);
                        let blankBytes = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.convertBlankToBytes(fits.header.get("BLANK"), bytesXelem); // => ???????
                        if (values === undefined) {
                            values = new Uint8Array(pixcount * bytesXelem);
                        }
                        // console.log(fitsurl + " loaded");
                        fitsheaderlist.push(fits.header);
                        for (let p = 0; p < pixcount; p++) {
                            let imgpx = inputPixelsList[p];
                            if (imgpx.tileno === hipstileno) {
                                // if (imgpx._j < HiPSHelper.DEFAULT_Naxis1_2 && imgpx._i < HiPSHelper.DEFAULT_Naxis1_2) {
                                if (imgpx._j < fits.header.get("NAXIS1") && imgpx._i < fits.header.get("NAXIS2")) {
                                    for (let b = 0; b < bytesXelem; b++) {
                                        values[p * bytesXelem + b] = fits.data[imgpx._j][imgpx._i * bytesXelem + b];
                                    }
                                }
                            }
                        }
                    }
                }));
            }
            yield Promise.all(promises);
            if (fitsheaderlist !== undefined) {
                this.prepareCommonHeader(fitsheaderlist);
            }
            return values;
        });
    }
    prepareCommonHeader(fitsheaderlist) {
        if (fitsheaderlist === undefined) {
            return;
        }
        if (!this._fh_common) {
            this._fh_common = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeader();
        }
        for (let i = 0; i < fitsheaderlist.length; i++) {
            let header = fitsheaderlist[i];
            if (header !== undefined) {
                for (let item of header.getItemList()) {
                    if (["SIMPLE", "BITPIX", "BSCALE", "BZERO", "BLANK", "ORDER"].includes(item.key)) {
                        if (!this._fh_common.getItemListOf(item.key)[0]) {
                            this._fh_common.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem(item.key, item.value));
                        }
                        else if (this._fh_common.getItemListOf(item.key)[0].value !== item.value) { // this should not happen 
                            throw new Error("Error parsing headers. " + item.key + " was " + this._fh_common.getItemListOf(item.key)[0] + " and now is " + item.value);
                        }
                    }
                }
            }
        }
    }
    // // TODO MOVE THIS IN AN UTILITY FILE
    // pixel2Physical(value, bzero, bscale) {
    // 	let pval = bzero + bscale * value;
    // 	return pval;
    // }
    setPxsValue(values, fitsHeaderParams) {
        // let vidx = 0; // <------ ERROR!!!!! pixel are not organized by tile!!!
        // let pxXTile = HiPSHelper.DEFAULT_Naxis1_2 * HiPSHelper.DEFAULT_Naxis1_2;
        let bytesXelem = Math.abs(fitsHeaderParams.get("BITPIX") / 8);
        let bscale = (fitsHeaderParams.get("BSCALE") !== undefined) ? fitsHeaderParams.get("BSCALE") : 1.0;
        let bzero = (fitsHeaderParams.get("BZERO") !== undefined) ? fitsHeaderParams.get("BZERO") : 0.0;
        if (bytesXelem === undefined || bscale === undefined || bzero === undefined) {
            throw new Error("BITPIX, BSCALE or BZERO are undefined");
        }
        // let minmaxmap = new Array();
        let minmaxmap = new Map();
        let nodata = new Map();
        this._tileslist.forEach((tileno) => {
            // this._pxvalues.set(tileno, new Array(HiPSHelper.DEFAULT_Naxis1_2));  // <- bidimensional
            // for (let row = 0; row < HiPSHelper.DEFAULT_Naxis1_2; row++) {
            this._pxvalues.set(tileno, new Array(this._HIPS_TILE_WIDTH)); // <- bidimensional
            for (let row = 0; row < this._HIPS_TILE_WIDTH; row++) {
                if (this._pxvalues.has(tileno)) {
                    let p = this._pxvalues.get(tileno);
                    if (p !== undefined) {
                        // p[row] = new Uint8Array(HiPSHelper.DEFAULT_Naxis1_2 * bytesXelem);
                        p[row] = new Uint8Array(this._HIPS_TILE_WIDTH * bytesXelem);
                    }
                }
            }
            minmaxmap.set("" + tileno + "", new Array(2));
            nodata.set("" + tileno + "", true);
        });
        let ra;
        let dec;
        let col;
        let row;
        for (let rdidx = 0; rdidx < this._radeclist.length; rdidx++) {
            [ra, dec] = this._radeclist[rdidx];
            let ac = (0,_model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.fillAstro)(ra, dec, _model_NumberType_js__WEBPACK_IMPORTED_MODULE_8__.NumberType.DEGREES);
            let sc = (0,_model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.astroToSpherical)(ac);
            let ptg = new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Pointing(null, false, sc.thetaRad, sc.phiRad);
            let pixtileno = this._hp.ang2pix(ptg);
            let xyGridProj = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.setupByTile(pixtileno, this._hp);
            // let rarad = degToRad(ra);
            // let decrad = degToRad(dec);
            // TODO CHECK THIS POINT before it was with ra and dec in radians
            let xy = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.world2intermediate(ac);
            if (this._HIPS_TILE_WIDTH === undefined) {
                throw new Error("this._HIPS_TILE_WIDTH undefined");
            }
            let ij = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.intermediate2pix(xy[0], xy[1], xyGridProj, this._HIPS_TILE_WIDTH);
            col = ij[0];
            row = ij[1];
            for (let b = 0; b < bytesXelem; b++) {
                let byte = values[rdidx * bytesXelem + b];
                // this._pxvalues.get(pixtileno)[row][col * bytesXelem + b] = byte	// <- bidimensional
                if (this._pxvalues.has(pixtileno)) {
                    let p = this._pxvalues.get(pixtileno);
                    if (p !== undefined) {
                        p[row][col * bytesXelem + b] = byte; // <- bidimensional
                    }
                }
                if (nodata.get("" + pixtileno + "")) {
                    if (byte != 0) {
                        nodata.set("" + pixtileno + "", false);
                    }
                }
            }
            let min = minmaxmap.get("" + pixtileno + "")[0];
            let max = minmaxmap.get("" + pixtileno + "")[1];
            if (this._pxvalues.has(pixtileno)) {
                let p = this._pxvalues.get(pixtileno);
                if (p !== undefined) {
                    let valpixb = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.extractPixelValue(0, p[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), fitsHeaderParams.get("BITPIX"));
                    let valphysical = bzero + bscale * valpixb;
                    if (valphysical < min || isNaN(min)) {
                        minmaxmap.get("" + pixtileno + "")[0] = valphysical;
                    }
                    else if (valphysical > max || isNaN(max)) {
                        minmaxmap.get("" + pixtileno + "")[1] = valphysical;
                    }
                }
            }
        }
        // Object.keys(this._pxvalues.keys()).forEach((tileno) => {
        const fhKeys = Array.from(this._pxvalues.keys());
        fhKeys.forEach((tileno) => {
            if (nodata.get("" + tileno + "") == false) { // there are data
                // tileno = parseInt(tileno);
                let header = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeader();
                header.set("NPIX", tileno);
                // TODO CONVERT minval and maxval to physical values!
                // header.addItem(new FITSHeaderItem("DATAMIN", minmaxmap["" + tileno + ""][0]));
                // header.addItem(new FITSHeaderItem("DATAMAX", minmaxmap["" + tileno + ""][1]));
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("DATAMIN", minmaxmap.get("" + tileno + "")[0]));
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("DATAMAX", minmaxmap.get("" + tileno + "")[1]));
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NPIX", tileno));
                let vec3 = this._hp.pix2vec(tileno);
                let ptg = new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Pointing(vec3);
                let crval1 = (0,_model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.radToDeg)(ptg.phi);
                let crval2 = 90 - (0,_model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.radToDeg)(ptg.theta);
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRVAL1", crval1));
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRVAL2", crval2));
                this._fitsheaderlist.push(header);
            }
            else { // no data
                // this._pxvalues.delete(parseInt(tileno));
                this._pxvalues.delete(tileno);
                // delete this._pxvalues["" + tileno + ""];
            }
        });
        this.prepareFITSHeader(fitsHeaderParams);
        return this._pxvalues;
    }
    getImageRADecList(center, radiusDeg) {
        let ptg = new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Pointing(null, false, center.spherical.thetaRad, center.spherical.phiRad);
        let radius_rad = (0,_model_Utils_js__WEBPACK_IMPORTED_MODULE_5__.degToRad)(radiusDeg);
        // with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16
        let rangeset = this._hp.queryDiscInclusive(ptg, radius_rad, 4); // <= check it 
        this._tileslist = [];
        for (let p = 0; p < rangeset.r.length; p++) {
            if (!this._tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {
                this._tileslist.push(rangeset.r[p]);
            }
        }
        let cpix = this._hp.ang2pix(ptg);
        if (!this._tileslist.includes(cpix)) {
            this._tileslist.push(cpix);
        }
        let minra = center.astro.raDeg - radiusDeg;
        let maxra = center.astro.raDeg + radiusDeg;
        let mindec = center.astro.decDeg - radiusDeg;
        let maxdec = center.astro.decDeg + radiusDeg;
        this._tileslist.forEach((tileno) => {
            this._xyGridProj = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.setupByTile(tileno, this._hp);
            // for (let j = 0; j < HiPSHelper.DEFAULT_Naxis1_2; j++) {
            // 	for (let i = 0; i < HiPSHelper.DEFAULT_Naxis1_2; i++) {
            for (let j = 0; j < this._HIPS_TILE_WIDTH; j++) {
                for (let i = 0; i < this._HIPS_TILE_WIDTH; i++) {
                    let p = this.pix2world(i, j);
                    if (p.astro.raDeg < minra || p.astro.raDeg > maxra ||
                        p.astro.decDeg < mindec || p.astro.decDeg > maxdec) {
                        continue;
                    }
                    this._radeclist.push([p.astro.raDeg, p.astro.decDeg]);
                }
            }
        });
        return this._radeclist;
    }
    pix2world(i, j) {
        let xy = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.pix2intermediate(i, j, this._xyGridProj, super.naxis1, super.naxis2);
        // TODO CHECK BELOW before it was only which is supposed to be wrong since intermediate2world returns SphericalCoords, not AstroCoords
        /**
        let raDecDeg = HiPSHelper.intermediate2world(xy[0], xy[1]);
        if (raDecDeg[0] > 360){
            raDecDeg[0] -= 360;
        }
        return raDecDeg;
        */
        let p = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.intermediate2world(xy[0], xy[1]);
        // if (p.spherical.phiDeg > 360){
        // 	sc.phiDeg -= 360;
        // }
        return p;
    }
    // conversion taken from https://astrophysicsandpython.com/2022/03/15/html-js-equatorial-to-galactic-coordinates/
    convertToGalactic(radeclist) {
        let finalradeclist = [];
        const deg2rad = Math.PI / 180;
        const rad2deg = 180 / Math.PI;
        const l_NCP = deg2rad * 122.930;
        const d_NGP = deg2rad * 27.1284;
        const a_NGP = deg2rad * 192.8595;
        radeclist.forEach(([ra, dec]) => {
            const ra_rad = deg2rad * ra;
            const dec_rad = deg2rad * dec;
            // sin(b)
            const sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) +
                Math.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);
            const b = Math.asin(sin_b);
            const b_deg = b * rad2deg;
            // l_NCP - l
            const lNCP_minus_l = Math.atan((Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /
                (Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)));
            const l = l_NCP - lNCP_minus_l;
            const l_deg = l * rad2deg;
            finalradeclist.push([l_deg, b_deg]);
        });
        return finalradeclist;
    }
    world2pix(radeclist) {
        // let imgpxlist = new ImagePixel[radeclist.length];
        let imgpxlist = [];
        let tileno;
        let prevTileno = undefined;
        // let k = 0;
        /*
            if HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b)
        */
        if (this._isGalactic) {
            radeclist = this.convertToGalactic(radeclist);
        }
        radeclist.forEach(([ra, dec]) => {
            const p = new _model_Point_js__WEBPACK_IMPORTED_MODULE_6__.Point(_model_CoordsType_js__WEBPACK_IMPORTED_MODULE_7__.CoordsType.ASTRO, _model_NumberType_js__WEBPACK_IMPORTED_MODULE_8__.NumberType.DEGREES, ra, dec);
            // let phiTheta_rad = HiPSHelper.astroDegToSphericalRad(ra, dec);
            const ptg = new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Pointing(null, false, p.spherical.thetaRad, p.spherical.phiRad);
            tileno = this._hp.ang2pix(ptg);
            if (prevTileno !== tileno || prevTileno === undefined) {
                this._xyGridProj = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.setupByTile(tileno, this._hp);
                prevTileno = tileno;
            }
            // let rarad =  HiPSHelper.degToRad(ra);
            // let decrad = HiPSHelper.degToRad(dec);
            const xy = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.world2intermediate(p.astro);
            if (this._HIPS_TILE_WIDTH === undefined) {
                throw new Error("this._HIPS_TILE_WIDTH undefined");
            }
            const ij = _HiPSHelper_js__WEBPACK_IMPORTED_MODULE_3__.HiPSHelper.intermediate2pix(xy[0], xy[1], this._xyGridProj, this._HIPS_TILE_WIDTH);
            imgpxlist.push(new _model_ImagePixel_js__WEBPACK_IMPORTED_MODULE_4__.ImagePixel(ij[0], ij[1], tileno));
        });
        return imgpxlist;
    }
}
//# sourceMappingURL=HiPSProjection.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/projections/MercatorProjection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/projections/MercatorProjection.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MercatorProjection: () => (/* binding */ MercatorProjection)
/* harmony export */ });
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");
/* harmony import */ var _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractProjection.js */ "./node_modules/wcslight/lib-esm/projections/AbstractProjection.js");
/* harmony import */ var _model_ImagePixel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/ImagePixel.js */ "./node_modules/wcslight/lib-esm/model/ImagePixel.js");
/* harmony import */ var _model_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/Point.js */ "./node_modules/wcslight/lib-esm/model/Point.js");
/* harmony import */ var _model_CoordsType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/CoordsType.js */ "./node_modules/wcslight/lib-esm/model/CoordsType.js");
/* harmony import */ var _model_NumberType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../model/NumberType.js */ "./node_modules/wcslight/lib-esm/model/NumberType.js");
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! process */ "?f615");
/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 *
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







class MercatorProjection extends _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_1__.AbstractProjection {
    constructor() {
        super("'RA---CAR'", "'DEC--CAR'");
        this._wcsname = "MER"; // TODO check WCS standard and create ENUM
        this._pxvalues = new Map();
        this._fitsheader = new Array();
    }
    initFromFile(infile) {
        const _super = Object.create(null, {
            naxis1: { get: () => super.naxis1, set: v => super.naxis1 = v },
            naxis2: { get: () => super.naxis2, set: v => super.naxis2 = v },
            pxsize: { get: () => super.pxsize, set: v => super.pxsize = v }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let fp = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSParser(infile);
            this._infile = infile;
            this._fitsUsed.push(infile);
            let promise = fp.loadFITS().then(fits => {
                // console.log(fits.header);
                this._pxvalues.set(0, fits.data);
                this._fitsheader[0] = fits.header;
                _super.naxis1 = fits.header.get("NAXIS1");
                _super.naxis2 = fits.header.get("NAXIS2");
                // this._naxis1 = fits.header.get("NAXIS1");
                // this._naxis2 = fits.header.get("NAXIS2");
                this._craDeg = fits.header.getItemListOf("CRVAL1")[0].value;
                this._cdecDeg = fits.header.getItemListOf("CRVAL2")[0].value;
                // TODO CDELT could not be present. In this is the case, 
                // there should be CDi_ja, but I am not handling them atm
                // [Ref. Representation of celestial coordinates in FITS - equation (1)]
                // this._pxsize1 = this._fitsheader[0].getItemListOf("CDELT1")[0].value as number;
                // this._pxsize2 = this._fitsheader[0].getItemListOf("CDELT2")[0].value as number;
                const pxsize1 = this._fitsheader[0].getItemListOf("CDELT1")[0].value;
                const pxsize2 = this._fitsheader[0].getItemListOf("CDELT2")[0].value;
                if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {
                    throw new Error("pxsize1 is not equal to pxsize2");
                    exit;
                }
                _super.pxsize = pxsize1;
                // this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;
                this._minra = this._craDeg - _super.pxsize * _super.naxis1 / 2;
                if (this._minra < 0) {
                    this._minra += 360;
                }
                // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;
                this._mindec = this._cdecDeg - _super.pxsize * _super.naxis2 / 2;
                return fits;
            });
            yield promise;
            return promise;
        });
    }
    extractPhysicalValues(fits) {
        let bzero = fits.header.get("BZERO");
        let bscale = fits.header.get("BSCALE");
        let naxis1 = fits.header.get("NAXIS1");
        let naxis2 = fits.header.get("NAXIS2");
        let bitpix = fits.header.get("BITPIX");
        let bytesXelem = Math.abs(bitpix / 8);
        let blankBytes = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.convertBlankToBytes(fits.header.get("BLANK"), bytesXelem); // TODO => ??????? Im not using it. it should be used!
        // let physicalvalues = new Array[naxis2][naxis1];
        let physicalvalues = new Array(naxis2);
        for (let n2 = 0; n2 < naxis2; n2++) {
            physicalvalues[n2] = new Array(naxis1);
            for (let n1 = 0; n1 < naxis1; n1++) {
                let pixval = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);
                let physicalVal = bzero + bscale * pixval;
                physicalvalues[n2][n1] = physicalVal;
            }
        }
        return physicalvalues;
    }
    prepareFITSHeader(fitsHeaderParams) {
        this._fitsheader[0] = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeader();
        this._fitsheader[0].addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS1", super.naxis1));
        this._fitsheader[0].addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS2", super.naxis2));
        this._fitsheader[0].addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("NAXIS", 2));
        this._fitsheader[0].addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BITPIX", fitsHeaderParams.get("BITPIX")));
        this._fitsheader[0].addItemAtTheBeginning(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("SIMPLE", fitsHeaderParams.get("SIMPLE")));
        if (fitsHeaderParams.get("BLANK") !== undefined) {
            this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BLANK", fitsHeaderParams.get("BLANK")));
        }
        let bscale = 1.0;
        if (fitsHeaderParams.get("BSCALE") !== undefined) {
            bscale = fitsHeaderParams.get("BSCALE");
        }
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BSCALE", bscale));
        let bzero = 0.0;
        if (fitsHeaderParams.get("BZERO") !== undefined) {
            bzero = fitsHeaderParams.get("BZERO");
        }
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("BZERO", bzero));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CTYPE1", super.ctype1));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CTYPE2", super.ctype2));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CDELT1", super.pxsize)); // ??? Pixel spacing along axis 1 ???
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CDELT2", super.pxsize)); // ??? Pixel spacing along axis 2 ???
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRPIX1", super.naxis1 / 2)); // central/reference pixel i along naxis1
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRPIX2", super.naxis2 / 2)); // central/reference pixel j along naxis2
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRVAL1", this._craDeg)); // central/reference pixel RA
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("CRVAL2", this._cdecDeg)); // central/reference pixel Dec
        let min = bzero + bscale * this._minphysicalval;
        let max = bzero + bscale * this._maxphysicalval;
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("DATAMIN", min)); // min data value
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("DATAMAX", max)); // max data value
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("ORIGIN", "'WCSLight v.0.x'"));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("COMMENT", "'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'"));
        this._fitsheader[0].addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("END"));
        return this._fitsheader;
    }
    getFITSHeader() {
        return this._fitsheader;
    }
    getCommonFitsHeaderParams() {
        let header = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeader();
        for (const [key, value] of this._fitsheader[0]) {
            // I could add a list of used NPIXs to be included in the comment of the output FITS
            if (["SIMPLE", "BITPIX", "BSCALE", "BZERO", "BLANK", "ORDER",].includes(key)) {
                header.addItem(new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem(key, value));
            }
        }
        return header;
    }
    get fitsUsed() {
        return this._fitsUsed;
    }
    getPixValues(inputPixelsList) {
        const _super = Object.create(null, {
            naxis2: { get: () => super.naxis2 },
            naxis1: { get: () => super.naxis1 }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let promise = new Promise((resolve, reject) => {
                try {
                    let bytesXelem = Math.abs(this._fitsheader[0].get("BITPIX") / 8);
                    let blankBytes = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.convertBlankToBytes(this._fitsheader[0].get("BLANK"), bytesXelem);
                    let pixcount = inputPixelsList.length;
                    let values = new Uint8Array(pixcount * bytesXelem);
                    for (let p = 0; p < pixcount; p++) {
                        let imgpx = inputPixelsList[p];
                        // TODO check when input is undefined. atm it puts 0 bur it should be BLANK
                        // TODO why I am getting negative i and j? check world2pix!!!
                        if ((imgpx._j) < 0 || (imgpx._j) >= _super.naxis2 ||
                            (imgpx._i) < 0 || (imgpx._i) >= _super.naxis1) {
                            for (let b = 0; b < bytesXelem; b++) {
                                values[p * bytesXelem + b] = blankBytes[b];
                            }
                        }
                        else {
                            let pv = this._pxvalues.get(0);
                            if (pv !== undefined) {
                                for (let b = 0; b < bytesXelem; b++) {
                                    values[p * bytesXelem + b] = pv[imgpx._j][(imgpx._i) * bytesXelem + b];
                                }
                            }
                        }
                    }
                    resolve(values);
                }
                catch (err) {
                    reject("[MercatorProjection] ERROR: " + err);
                }
            });
            return promise;
        });
    }
    setPxsValue(values, fitsHeaderParams) {
        let bytesXelem = Math.abs(fitsHeaderParams.get("BITPIX") / 8);
        let minpixb = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get("BITPIX"));
        let maxpixb = minpixb;
        let bscale = (fitsHeaderParams.get("BSCALE") !== undefined) ? fitsHeaderParams.get("BSCALE") : 1.0;
        let bzero = (fitsHeaderParams.get("BZERO") !== undefined) ? fitsHeaderParams.get("BZERO") : 0.0;
        this._minphysicalval = bzero + bscale * minpixb;
        this._maxphysicalval = bzero + bscale * maxpixb;
        // this._pxvalues = new Array(this._naxis2);
        // for (let r = 0; r < this._naxis2; r++) {
        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);
        // }
        // this._pxvalues.set(0, new Uint8Array[this._naxis2][this._naxis1 * bytesXelem]);
        this._pxvalues.set(0, new Array(super.naxis2));
        let pv = this._pxvalues.get(0);
        if (pv !== undefined) {
            for (let r = 0; r < super.naxis2; r++) {
                pv[r] = new Uint8Array(super.naxis1 * bytesXelem);
            }
            let r;
            let c;
            let b;
            for (let p = 0; (p * bytesXelem) < values.length; p++) {
                // console.log("processing "+p + " of "+ (values.length / bytesXelem));
                try {
                    r = Math.floor(p / super.naxis1);
                    c = (p - r * super.naxis1) * bytesXelem;
                    for (b = 0; b < bytesXelem; b++) {
                        pv[r][c + b] = values[p * bytesXelem + b];
                    }
                    let valpixb = jsfitsio__WEBPACK_IMPORTED_MODULE_0__.ParseUtils.extractPixelValue(0, values.slice(p * bytesXelem, (p * bytesXelem) + bytesXelem), fitsHeaderParams.get("BITPIX"));
                    let valphysical = bzero + bscale * valpixb;
                    if (valphysical < this._minphysicalval || isNaN(this._minphysicalval)) {
                        this._minphysicalval = valphysical;
                    }
                    else if (valphysical > this._maxphysicalval || isNaN(this._maxphysicalval)) {
                        this._maxphysicalval = valphysical;
                    }
                }
                catch (err) {
                    console.log(err);
                    console.log("p " + p);
                    console.log("r %, c %, b %" + r, c, b);
                    console.log("this._pxvalues[r][c + b] " + pv[r][c + b]);
                    console.log("values[p * bytesXelem + b] " + values[p * bytesXelem + b]);
                }
            }
        }
        this.prepareFITSHeader(fitsHeaderParams);
        return this._pxvalues;
    }
    getImageRADecList(center, radius, pxsize) {
        super.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]
        super.pxsize = pxsize;
        this._minra = center.astro.raDeg - radius;
        if (this._minra < 0) {
            this._minra += 360;
        }
        this._mindec = center.astro.decDeg - radius;
        let radeclist = new Array();
        for (let d = 0; d < super.naxis2; d++) {
            for (let r = 0; r < super.naxis1; r++) {
                radeclist.push([this._minra + (r * super.pxsize), this._mindec + (d * super.pxsize)]);
            }
        }
        let cidx = (super.naxis2 / 2) * super.naxis1 + super.naxis1 / 2;
        if (super.naxis1 % 2 != 0) {
            cidx = Math.floor(radeclist.length / 2);
        }
        // let cidx2 = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;
        // let cidx = Math.ceil(radeclist.length / 2);
        // let cidx = Math.floor(radeclist.length / 2);
        this._craDeg = radeclist[cidx][0];
        this._cdecDeg = radeclist[cidx][1];
        return radeclist;
    }
    /** TODO !!! check and handle RA passing through 360-0 */
    pix2world(i, j) {
        let ra;
        let dec;
        // ra = i * this._stepra + this._minra;
        // dec = j * this._stepdec + this._mindec;
        ra = i * super.pxsize + this._minra;
        dec = j * super.pxsize + this._mindec;
        let p = new _model_Point_js__WEBPACK_IMPORTED_MODULE_3__.Point(_model_CoordsType_js__WEBPACK_IMPORTED_MODULE_4__.CoordsType.ASTRO, _model_NumberType_js__WEBPACK_IMPORTED_MODULE_5__.NumberType.DEGREES, ra, dec);
        return p;
        // return [ra, dec];
    }
    world2pix(radeclist) {
        let imgpxlist = [];
        for (let radecItem of radeclist) {
            let ra = radecItem[0];
            let dec = radecItem[1];
            // let i = Math.floor((ra - this._minra) / this._pxsize1);
            // let j = Math.floor((dec - this._mindec) / this._pxsize2);
            let i = Math.floor((ra - this._minra) / super.pxsize);
            let j = Math.floor((dec - this._mindec) / super.pxsize);
            imgpxlist.push(new _model_ImagePixel_js__WEBPACK_IMPORTED_MODULE_2__.ImagePixel(i, j));
        }
        return imgpxlist;
    }
}
//# sourceMappingURL=MercatorProjection.js.map

/***/ }),

/***/ "./node_modules/wcslight/lib-esm/projections/TestProj.js":
/*!***************************************************************!*\
  !*** ./node_modules/wcslight/lib-esm/projections/TestProj.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TestProj: () => (/* binding */ TestProj)
/* harmony export */ });
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");
/* harmony import */ var _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractProjection.js */ "./node_modules/wcslight/lib-esm/projections/AbstractProjection.js");
// import { FITSParser } from 'fitsparser/FITSParser-node';
// import { FITSHeader } from 'fitsparser/model/FITSHeader';
// import { FITSHeaderItem } from 'fitsparser/model/FITSHeaderItem';
// import { FITSParsed } from 'fitsparser/model/FITSParsed';




class TestProj extends _AbstractProjection_js__WEBPACK_IMPORTED_MODULE_1__.AbstractProjection {
    constructor() {
        super("RA---MER", "DEC--MER");
        this._wcsname = "MER"; // TODO check WCS standard and create ENUM
        this._pxvalues = new Map();
        const fh = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeader();
        const fp = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSParser("./notexistent/");
        const fhi = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSHeaderItem("mykey", "myvalue", "mycomment");
    }
    get fitsUsed() {
        throw new Error('Method not implemented.');
    }
    initFromFile(fitsfilepath, hipsURI, pxsize, order) {
        throw new Error('Method not implemented.');
    }
    prepareFITSHeader(fitsHeaderParams) {
        throw new Error('Method not implemented.');
    }
    getFITSHeader() {
        throw new Error('Method not implemented.');
    }
    getCommonFitsHeaderParams() {
        throw new Error('Method not implemented.');
    }
    extractPhysicalValues(fits) {
        throw new Error('Method not implemented.');
    }
    getPixValues(inputPixelsList) {
        throw new Error('Method not implemented.');
    }
    computeSquaredNaxes(d, ps) {
        throw new Error('Method not implemented.');
    }
    setPxsValue(values, fitsHeaderParams) {
        throw new Error('Method not implemented.');
    }
    getImageRADecList(center, radius, pxsize) {
        throw new Error('Method not implemented.');
    }
    pix2world(i, j) {
        throw new Error('Method not implemented.');
    }
    world2pix(radeclist) {
        throw new Error('Method not implemented.');
    }
}
//# sourceMappingURL=TestProj.js.map

/***/ }),

/***/ "./src/css/controlpanelcontainer.css":
/*!*******************************************!*\
  !*** ./src/css/controlpanelcontainer.css ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_controlpanelcontainer_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./controlpanelcontainer.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/controlpanelcontainer.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_controlpanelcontainer_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_controlpanelcontainer_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_controlpanelcontainer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_controlpanelcontainer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/css/style.css":
/*!***************************!*\
  !*** ./src/css/style.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/js/Constants.js":
/*!*****************************!*\
  !*** ./src/js/Constants.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMaxDecimals4AstroCoords: () => (/* binding */ getMaxDecimals4AstroCoords),
/* harmony export */   getMaxDecimals4PixelValue: () => (/* binding */ getMaxDecimals4PixelValue)
/* harmony export */ });

function Costants () {

}

function getMaxDecimals4AstroCoords () {
    return 4;
  };
function getMaxDecimals4PixelValue () {
    return 8;
  };

/***/ }),

/***/ "./src/js/FVApi.js":
/*!*************************!*\
  !*** ./src/js/FVApi.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FVApi: () => (/* binding */ FVApi)
/* harmony export */ });
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Global.js */ "./src/js/Global.js");
/* harmony import */ var wcslight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wcslight */ "./node_modules/wcslight/lib-esm/index.js");
/**
 * @author Fabrizio Giordano (Fab77)
 */



class FVApi{

	constructor(){
		
		if (_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].debug){
			console.log("[FVApi::FVApi]");
		}
		console.log("[FVApi::FVApi]");
		this.runWCS();
		
	}

	testText(){
		return "Hola";
	}
	
	runWCS(){
		let hipsBaseUri = "http://skies.esac.esa.int/NVSS/";
		
		let radius_arc_sec = 87.3;
		let pxsize_arc_sec = 1.5;
		let radius_deg = radius_arc_sec / 3600;
		let pxsize_deg = pxsize_arc_sec / 3600;
		let radeg = 0.055417;
		let decdeg = 33.134167;
		
		let center = new wcslight__WEBPACK_IMPORTED_MODULE_1__.Point(wcslight__WEBPACK_IMPORTED_MODULE_1__.CoordsType.ASTRO, wcslight__WEBPACK_IMPORTED_MODULE_1__.NumberType.DEGREES, radeg, decdeg);
		let inproj = new wcslight__WEBPACK_IMPORTED_MODULE_1__.HiPSProjection();
		
		inproj.parsePropertiesFile(hipsBaseUri).then(async propFile => {

			inproj.initFromHiPSLocationAndPxSize(hipsBaseUri, pxsize_arc_sec)
			let outproj = new wcslight__WEBPACK_IMPORTED_MODULE_1__.MercatorProjection();
			
			wcslight__WEBPACK_IMPORTED_MODULE_1__.WCSLight.cutout(center, radius_arc_sec, pxsize_arc_sec, inproj, outproj).then((result) => {
				if (result.fitsused.length > 0){
					console.log(result);
					// res.download(file);
				} else {
					console.error("no data found");
				}
				
			})
			
		});
	}

}



/***/ }),

/***/ "./src/js/FVApp.js":
/*!*************************!*\
  !*** ./src/js/FVApp.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FVApp: () => (/* binding */ FVApp)
/* harmony export */ });
/* harmony import */ var _FVView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FVView.js */ "./src/js/FVView.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Global.js */ "./src/js/Global.js");
/* harmony import */ var _MainPresenter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainPresenter.js */ "./src/js/MainPresenter.js");
/**
 * @author Fabrizio Giordano (Fab77)
 */




class FVApp{

	constructor(){
		
		if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].debug){
			console.log("[FVApp::FVApp]");
		}
		this.init();
		this.initListeners();
	}


	/**
	 * used for debug pourpose in the browser console. 
	 * e.g. fabviewer.FVApp.prototype.getGlobalSettings()._showConvexPolygons = true
	 * @returns  
	 */
	getGlobalSettings() {
		return _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"];
	}

	
	init(){
		if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].debug){
			console.log("[FVApp::init]");
		}
		let canvas = document.getElementById("fabviewer_canvas");
		
		try {
			if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].debug){
				console.log("[FVApp::init]canvas");
				console.log(canvas);
			}
			
			this.gl = canvas.getContext("webgl2", {
				alpha: false
			});
			
			let params = new URLSearchParams(location.search);
			if (params.get('debug') != null){
				console.warn("WebGL DEBUG MODE ON");
				this.gl = WebGLDebugUtils.makeDebugContext(this.gl);	
			}
			
			this.gl.viewportWidth = canvas.width;
			this.gl.viewportHeight = canvas.height;
			
			this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
			
		} catch (e) {
			console.log("Error instansiating WebGL context");
		}
		if (!this.gl) {
			alert("Could not initialise WebGL, sorry :-(");
		}
		
		this.view = new _FVView_js__WEBPACK_IMPORTED_MODULE_0__["default"](canvas, _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].insideSphere);
		
		_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl = this.gl;
		
		this.presenter = new _MainPresenter_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.view, this.gl);
		
		this.fabVReqID = '';
		
		
	};
	
	initListeners(){
		
		let resizeCanvas = () => {
			if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].debug){
				console.log("[MainPresenter::addEventListeners->resizeCanvas]");
			}
		   	this.view.resize(this.gl);
		   	this.presenter.draw();
		}
		
		function handleContextLost(event){
			console.log("[handleContextLost]");
			event.preventDefault();
			cancelRequestAnimFrame(this.fabVReqID);
		}

		let handleContextRestored = (event) => {
			console.log("[handleContextRestored]");
			let canvas = document.getElementById("fabviewer_canvas");
			this.gl.viewportWidth = canvas.width;
			this.gl.viewportHeight = canvas.height;
			this.gl.clearColorrgbrgb(0.86, 0.86, 0.86, 1.0);
			
			this.gl.enable(this.gl.DEPTH_TEST);
			
			this.fabVReqID = requestAnimFrame(this.tick, canvas);
		}
		
		
		window.addEventListener('resize', resizeCanvas);
		this.view.canvas.addEventListener('webglcontextlost', handleContextLost, false);
		this.view.canvas.addEventListener('webglcontextrestored', handleContextRestored, false);
		resizeCanvas();
	};
	
	run(){
		if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].debug){
			console.log("[FVApp::run]");
		}
		this.tick();
	};
	
	tick() {
		
		this.drawScene();
		if(_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].debug){
			// Only do this at DEBUG since every getError call takes 5-10ms
			let error = this.gl.getError();
			if (error != this.gl.NO_ERROR && error != this.gl.CONTEXT_LOST_WEBGL) {
				console.log("GL error: "+error);
			}
		}

		this.fabVReqID = requestAnimationFrame(()=>this.tick());
		
	}

	
	drawScene(){
		this.presenter.draw();
	};
	
	
}

/***/ }),

/***/ "./src/js/FVView.js":
/*!**************************!*\
  !*** ./src/js/FVView.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Global.js */ "./src/js/Global.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/**
 * @author Fabrizio Giordano (Fab)
 */




class FVView {

	// TODO define here the CONSTANT with DOM names used

	constructor(in_canvas) {
		if (_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].debug) {
			console.log("[FVView::FVView]");
		}
		this._messagesMap = new Map();
		setInterval( () => { this.showMessageInQueue() }, 500)
		this.init(in_canvas);
	}

	init(in_canvas) {
		if (_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].debug) {
			console.log("[FVView::init]");
		}
		this.canvas = in_canvas;

		this.container = jquery__WEBPACK_IMPORTED_MODULE_1__("#fabvcontainer")
		this.container.width(window.innerWidth)
		this.container.height(window.innerHeight)
		
		this.widthToHeight = 4 / 3;
	};

	addMessageToMessageQueue(msgId, message){
		this._messagesMap.set(msgId, message)
	}

	removeMessageToMessageQueue(msgId){
		this._messagesMap.delete(msgId)
	}

	showMessageInQueue(){
		jquery__WEBPACK_IMPORTED_MODULE_1__("#message").hide()
		jquery__WEBPACK_IMPORTED_MODULE_1__("#message").empty();
		if (this._messagesMap.size > 0){
			
			for (const [msgId, message] of this._messagesMap) {
				jquery__WEBPACK_IMPORTED_MODULE_1__("#message").append(`<p><span id='${msgId}'>${message}</span><p>`)
			}
			jquery__WEBPACK_IMPORTED_MODULE_1__("#message").show()
		}
	}

	fillVersion(version){
		jquery__WEBPACK_IMPORTED_MODULE_1__("#version").append(version)
	}

	get metadataPanelButton(){
		return jquery__WEBPACK_IMPORTED_MODULE_1__("#metadata_button");
	}

	get dataPanelDomId() {
		return 'datapanel';
	}

	addHipsButtonHandler(handler) {
		jquery__WEBPACK_IMPORTED_MODULE_1__("#hips_button").on("click", handler);
	}

	appendChild2(html) {
		jquery__WEBPACK_IMPORTED_MODULE_1__("#controlpanel2container").append(html);

	};

	append2Body(html) {
		jquery__WEBPACK_IMPORTED_MODULE_1__("body").append(html);

	};

	append2FabvContainer(html) {

		this.container.append(html);
	};

	append2DataPanel(html){
		jquery__WEBPACK_IMPORTED_MODULE_1__("#datapanel").append(html);
	}

	resize(in_gl) {
		const newWidth = window.innerWidth - 3;
		const newHeight = window.innerHeight - 3;

		this.container.width(newWidth)
		this.container.height(newHeight)

		this.canvas.width = newWidth;
		this.canvas.height = newHeight;
		in_gl.viewportWidth = this.canvas.width;
		in_gl.viewportHeight = this.canvas.height;

	};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FVView);

/***/ }),

/***/ "./src/js/Global.js":
/*!**************************!*\
  !*** ./src/js/Global.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _events_InsideSphereSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/InsideSphereSelectionChangedEvent.js */ "./src/js/events/InsideSphereSelectionChangedEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _model_hipsnew_HiPS_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/hipsnew/HiPS.js */ "./src/js/model/hipsnew/HiPS.js");
/* harmony import */ var _config_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config.json */ "./src/js/config.json");
/* harmony import */ var _repos_HiPSNodeRepo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./repos/HiPSNodeRepo.js */ "./src/js/repos/HiPSNodeRepo.js");












class Global {

	_pMatrix;	// projection matrix (perspective)
	_mvMatrix;	// TODO model view matrix ? needed?
	_model;		// selected object
	_camera;		// the camera object
	_gl;			// GL context
	_rayPicker;	// TODO probably useless here ince all methods are static
	_hipsStack;
	_baseUrl;
	_selectionnside;
	_healpix4footprints;
	_showConvexPolygons; // used in FPCatalogue to drawing convex polygons together with the original footprints (for debug)
	_defaultHips;
	_blendMode
	HIPS_REF_ORDER;

	constructor() {

		this.HIPS_REF_ORDER = 6;
		this._TAPProviders = _config_json__WEBPACK_IMPORTED_MODULE_4__.tapProviders
		this._HiPSNodes = _config_json__WEBPACK_IMPORTED_MODULE_4__.hipsNodes
		this._useCORSProxy = _config_json__WEBPACK_IMPORTED_MODULE_4__.useCORSProxy
		this._corsProxyUrl=_config_json__WEBPACK_IMPORTED_MODULE_4__.corsProxyUrl
		this._maxDecimals= _config_json__WEBPACK_IMPORTED_MODULE_4__.maxDecimals
		this._defaultHipsUrl = _config_json__WEBPACK_IMPORTED_MODULE_4__.defaultHipsUrl
		this._debug = _config_json__WEBPACK_IMPORTED_MODULE_4__.debug;
		this._insideSphere = _config_json__WEBPACK_IMPORTED_MODULE_4__.insideView;
		this._version = _config_json__WEBPACK_IMPORTED_MODULE_4__.version

		this._pMatrix = null;
		this._mvMatrix = null;
		this._model = null;
		this._camera = null;
		this._gl = null;
		this._rayPicker = null;
		this._healpix = [];
		this._order = 3;
		
		this._selectionnside = 32;
		this._baseUrl = "http://skyint.esac.esa.int/esasky-tap/";
		this._healpix4footprints = false;
		this._showConvexPolygons = false; // used in FPCatalogue to drawing convex polygons together with the original footprints (for debug)
		this._showPointsInPolygons = false;
		this._defaultHips = null;
		this._blendMode = false;
	
	}

	get version(){
		return this._version
	}

	set corsProxyUrl(url) {
		this._corsProxyUrl = url;
	}

	get corsProxyUrl() {
		return this._corsProxyUrl;
	}
	get useCORSProxy(){
		return this._useCORSProxy;
	}

	set useCORSProxy(enabled){
		this._useCORSProxy = enabled;
	}

	get debug() {
		return this._debug;
	}

	getTAPProviders() {
		return this._TAPProviders;
	}

	setSelectedHiPS(hips) {
		this._selectedHiPS = hips;
	}

	getSelectedHiPS() {
		return this._selectedHiPS;
	}

	getHealpix(order) {
		if (this._healpix[order] == undefined) {
			this._healpix[order] = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Healpix(Math.pow(2, order));
		}
		return this._healpix[order];
	}

	get MAX_DECIMALS() {
		return this._maxDecimals;
	}

	get pMatrix() {
		return this._pMatrix;
	}
	// IS IT USED?!?
	get mvMatrix() {
		return this._mvMatrix;
	}

	get model() {
		return this._model;
	}

	get camera() {
		return this._camera;
	}

	get gl() {
		return this._gl;
	}

	get rayPicker() {
		return this._rayPicker;
	}

	set pMatrix(in_pMatrix) {
		this._pMatrix = in_pMatrix;
	}
	// TODO
	set mvMatrix(in_mvMatrix) {
		this._mvMatrix = in_mvMatrix;
	}

	set model(in_model) {
		this._model = in_model;
	}

	set camera(in_camera) {
		this._camera = in_camera;
	}

	set gl(in_gl) {
		this._gl = in_gl;
	}
	// TODO
	set rayPicker(in_rayPicker) {
		this._rayPicker = in_rayPicker;
	}


	set order(in_order) {
		this._order = in_order;
	}

	get order() {
		return this._order;
	}

	set insideSphere(in_insideSphere) {
		this._insideSphere = in_insideSphere;
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_InsideSphereSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"](in_insideSphere));
	}

	get insideSphere() {
		return this._insideSphere;
	}

	get baseUrl() {
		return this._baseUrl;
	}

	get nsideForSelection() {
		return this._selectionnside;
	}

	get healpix4footprints() {
		return this._healpix4footprints;
	}

	get showConvexPolygons() {
		return this._showConvexPolygons;
	}

	get showPointsInPolygons() {
		return this._showPointsInPolygons;
	}



	get defaultHips() {

		if (this._defaultHips == null) {
			const self = this
			this._defaultHips = (0,_repos_HiPSNodeRepo_js__WEBPACK_IMPORTED_MODULE_5__.addHiPS)("https://skies.esac.esa.int/DSSColor/").then((descriptor) => {
				self._defaultHips = new _model_hipsnew_HiPS_js__WEBPACK_IMPORTED_MODULE_3__["default"](1, [0.0, 0.0, 0.0], 0, 0, descriptor.surveyName, self._defaultHipsUrl, "jpg", descriptor.maxOrder, false, descriptor);
				self._defaultHips.refreshModel(180);
				self._selectedHiPS = self._defaultHips;	
				return this._defaultHips;
			});

			

		}
		return this._defaultHips;
	}

	get blendMode() {
		return this._blendMode;
	}

	set hipsFoV(fov) {
		this._hipsFoV = fov;
	}

	get hipsFoV() {
		return this._hipsFoV;
	}

	getConfig_cameraFovDeg(){
		return _config_json__WEBPACK_IMPORTED_MODULE_4__.camera.fovDeg;
	}
	
	getConfig_nearPlane(){
		return _config_json__WEBPACK_IMPORTED_MODULE_4__.camera.nearPlane;
	}

	getConfig_cameraFarPlane(){
		return _config_json__WEBPACK_IMPORTED_MODULE_4__.camera.farPlane;
	}

}

var global = new Global();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (global);

/***/ }),

/***/ "./src/js/MainPresenter.js":
/*!*********************************!*\
  !*** ./src/js/MainPresenter.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var _model_Camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/Camera.js */ "./src/js/model/Camera.js");
/* harmony import */ var _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/RayPickingUtils.js */ "./src/js/utils/RayPickingUtils.js");
/* harmony import */ var _modules_controlpanel_ControlPanelPresenter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/controlpanel/ControlPanelPresenter.js */ "./src/js/modules/controlpanel/ControlPanelPresenter.js");
/* harmony import */ var _presenter_CoordinatesPanelPresenter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./presenter/CoordinatesPanelPresenter.js */ "./src/js/presenter/CoordinatesPanelPresenter.js");
/* harmony import */ var _presenter_FoVPresenter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./presenter/FoVPresenter.js */ "./src/js/presenter/FoVPresenter.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Global.js */ "./src/js/Global.js");
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/Session.js */ "./src/js/utils/Session.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var _utils_MouseHelper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/MouseHelper.js */ "./src/js/utils/MouseHelper.js");
/* harmony import */ var _events_InsideSphereSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./events/InsideSphereSelectionChangedEvent.js */ "./src/js/events/InsideSphereSelectionChangedEvent.js");
/* harmony import */ var _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./events/OpenPanelEvent.js */ "./src/js/events/OpenPanelEvent.js");
/* harmony import */ var _modules_controlpanel_gotopanel_events_GoToEvent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/controlpanel/gotopanel/events/GoToEvent.js */ "./src/js/modules/controlpanel/gotopanel/events/GoToEvent.js");
/* harmony import */ var _model_grids_HealpixGrid_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./model/grids/HealpixGrid.js */ "./src/js/model/grids/HealpixGrid.js");
/* harmony import */ var _model_grids_EquatorialGrid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./model/grids/EquatorialGrid.js */ "./src/js/model/grids/EquatorialGrid.js");
/* harmony import */ var _events_ShowCoordsGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./events/ShowCoordsGridSelectionChangedEvent.js */ "./src/js/events/ShowCoordsGridSelectionChangedEvent.js");
/* harmony import */ var _events_ShowHealpixGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./events/ShowHealpixGridSelectionChangedEvent.js */ "./src/js/events/ShowHealpixGridSelectionChangedEvent.js");
/* harmony import */ var _modules_debug_DebugPresenter_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/debug/DebugPresenter.js */ "./src/js/modules/debug/DebugPresenter.js");
/* harmony import */ var _model_hipsnew_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./model/hipsnew/VisibleTilesManager.js */ "./src/js/model/hipsnew/VisibleTilesManager.js");
/* harmony import */ var _events_CORSTAPReposEvent_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./events/CORSTAPReposEvent.js */ "./src/js/events/CORSTAPReposEvent.js");
/* harmony import */ var _modules_datapanel_DataPanelPresenter_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/datapanel/DataPanelPresenter.js */ "./src/js/modules/datapanel/DataPanelPresenter.js");
/* harmony import */ var _events_AddMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./events/AddMessageToMsgBoxEvent.js */ "./src/js/events/AddMessageToMsgBoxEvent.js");
/* harmony import */ var _events_RemoveMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./events/RemoveMessageToMsgBoxEvent.js */ "./src/js/events/RemoveMessageToMsgBoxEvent.js");

/**
 * @author Fabrizio Giordano (Fab)
 */






































class MainPresenter {

	constructor(in_view, in_gl) {
		this.in_gl = in_gl;

		this.mouseHelper = new _utils_MouseHelper_js__WEBPACK_IMPORTED_MODULE_10__["default"]();

		this.init(in_view);
		this.registerForEvents();



	}

	init(in_view) {
		
		if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].debug) {
			console.log("[MainPresenter::init]");
		}
		this.view = in_view;

		if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].insideSphere) {
			this.camera = new _model_Camera_js__WEBPACK_IMPORTED_MODULE_1__["default"]([0.0, 0.0, -0.005], _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].insideSphere);
		} else {
			this.camera = new _model_Camera_js__WEBPACK_IMPORTED_MODULE_1__["default"]([0.0, 0.0, 3.0], _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].insideSphere);
		}
		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].camera = this.camera;
		let raypicker = new _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"](); // <-- check if it can be converted to singleton instead of putting it into global
		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].rayPicker = raypicker;

		this.aspectRatio;
		this.fovDeg = _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getConfig_cameraFovDeg();
		this.nearPlane = _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getConfig_nearPlane();
		this.farPlane = _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getConfig_cameraFarPlane();

		this.mouseDown = false;
		this.lastMouseX = null;
		this.lastMouseY = null;
		this.inertiaX = 0.0;
		this.inertiaY = 0.0;
		this.zoomInertia = 0.0;

		


		this.nearestVisibleObjectIdx = 0;

		this.pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_24__.create();
		this.firstRun = true;


		this.aspectRatio = this.view.canvas.width / this.view.canvas.height;
		this.pMatrix = this.computePerspectiveMatrix();
		if (this.firstRun) {
			const initialFoV = 180.;
			const position = [0.0, 0.0, 0.0];
			const initialPhiRad = 0.;
			const initialThetaRad = 0.;
			if (this.hpGrid == undefined) {
				this.hpGrid = new _model_grids_HealpixGrid_js__WEBPACK_IMPORTED_MODULE_14__["default"](1, position, initialPhiRad, initialThetaRad, initialFoV);
				_model_hipsnew_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_19__.newVisibleTilesManager.init(this.hpGrid); // <- here I need pmatrix for the raypicking
			}
			this.currentFoV = initialFoV;

			this.refreshFoV(this.pMatrix);
			setInterval(() => this.refreshFoV(), 100, this.pMatrix);
			// setInterval(() => this.refreshFoV(), 100);
			this.initPresenter();
			this.addEventListeners();
			this.view.addHipsButtonHandler(() => {
				this.hipsListPresenter.toggle();
			});
			this.view.fillVersion(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].version)
			_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultHips;
			this.firstRun = false;
		}

	};

	

	computePerspectiveMatrix() {
		this.aspectRatio = this.view.canvas.width / this.view.canvas.height;

		let farPlane;
		if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].insideSphere) {
			farPlane = 1.1 // far plane set to the radius (it could be more precise if needed)
		} else {



			let distCamera = - this.camera.getCameraMatrix()[14];
			let r = 1; // Need this to be the radius of the HiPS sphere. Can we get that somewhere?
			/**
			 * far plane dynamic computation
			 * O: origin of 3d space = center of sphere
			 * C: camera position
			 * r: radius of the sphere
			 * T: tangent point to the sphere from C
			 * F: far plane distance from camera
			 * beta: angle COT
			 * 
			 * 1. Pitagora:
			 * cateto2 = Math.sqrt(ipotenusa^2 - cateto1^2) 
			 * CT = Math.sqrt(CO^2 - r^2)
			 * 2. beta = atg(CT/r)
			 * 3. CF = CT Math.sin(beta)
			 * farplane = CF
			*/
			let c2 = Math.sqrt(distCamera ** 2 - r ** 2);
			let beta = Math.atan2(c2, r);
			let cf = c2 * Math.sin(beta);
			farPlane = cf;
		}
		let pMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_24__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_24__.perspective(pMatrix, this.fovDeg * Math.PI / 180.0, this.aspectRatio, this.nearPlane, farPlane);
		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].pMatrix = this.pMatrix; // TODO try to remove global.pMatrix
		return pMatrix;

	}

	registerForEvents() {
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _events_ShowHealpixGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_17__["default"].name);
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _events_ShowCoordsGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_16__["default"].name);

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _events_InsideSphereSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_11__["default"].name);

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_12__["default"].name);

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _modules_controlpanel_gotopanel_events_GoToEvent_js__WEBPACK_IMPORTED_MODULE_13__["default"].name);

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _events_CORSTAPReposEvent_js__WEBPACK_IMPORTED_MODULE_20__["default"].name);

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _events_AddMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_22__["default"].name)

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_8__["default"].registerForEvent(this, _events_RemoveMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_23__["default"].name)

	}

	notify(in_event) {


		switch (in_event.constructor) {

			case _events_ShowCoordsGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_16__["default"]:
				this._showGrid = in_event._shouldShowGrid
				break;

			case _events_ShowHealpixGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_17__["default"]:
				this._showHPXGrid = in_event._shouldShowGrid
				break;

			case _events_InsideSphereSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_11__["default"]:
				// this.refreshViewAndModel(false, in_event.insideSphere);
				// visibleTilesManager.refreshModel(this.refreshFov(global.insideSphere).minFoV);
				break;

			case _modules_controlpanel_gotopanel_events_GoToEvent_js__WEBPACK_IMPORTED_MODULE_13__["default"]:

				let ra = in_event.raDeg;
				let dec = in_event.decDeg;
				this.camera.goTo(ra, dec);
				break;

			case _events_CORSTAPReposEvent_js__WEBPACK_IMPORTED_MODULE_20__["default"]:
				this.controlPanelPresenter.refreshRepos();
				break;
			case _events_AddMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_22__["default"]:
				this.view.addMessageToMessageQueue(in_event.msgId, in_event.message)
				break;
			case _events_RemoveMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_23__["default"]:
				this.view.removeMessageToMessageQueue(in_event.msgId)
				break;
		}

	}

	initPresenter() {

		this.controlPanelPresenter = new _modules_controlpanel_ControlPanelPresenter_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.view);

		this.fovPresenter = new _presenter_FoVPresenter_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
		this.view.append2FabvContainer(this.fovPresenter.view.getHtml());

		this.coordinatesPanelPresenter = new _presenter_CoordinatesPanelPresenter_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
		this.view.append2FabvContainer(this.coordinatesPanelPresenter.view.getHtml());

		this._debugPresenter = null;


		this.dataPanelPresenter = new _modules_datapanel_DataPanelPresenter_js__WEBPACK_IMPORTED_MODULE_21__["default"](this.view.dataPanelDomId);
		this.view.append2DataPanel(this.dataPanelPresenter.view.getHtml())
		this.dataPanelPresenter.toggleView()
	};

	initDebugPresenter() {
		this._debugPresenter = new _modules_debug_DebugPresenter_js__WEBPACK_IMPORTED_MODULE_18__["default"]();
		this.view.append2FabvContainer(this._debugPresenter.view.html);
	}



	addEventListeners() {
		if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].debug) {
			console.log("[MainPresenter::addEventListeners]");
		}

		let self = this;
		this.view.metadataPanelButton.click(function () {
			self.dataPanelPresenter.toggleView();
		});

		let handleMouseDown = (event) => {
			this.view.canvas.setPointerCapture(event.pointerId);
			this.mouseDown = true;

			this.lastMouseX = event.pageX;
			this.lastMouseY = event.pageY;

			this.dataPanelPresenter.refresh(_utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.hoveredFootprints, _utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.hoveredSources)
			_utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.clearHoveredFootprints()
			event.preventDefault();
			return false;
		}

		let handleMouseUp = (event) => {
			this.view.canvas.releasePointerCapture(event.pointerId);
			this.mouseDown = false;
			document.getElementsByTagName("body")[0].style.cursor = "auto";
			this.lastMouseX = event.clientX;
			this.lastMouseY = event.clientY;


			// let intersectionWithModel = RayPickingUtils.getIntersectionPointWithModel(this.lastMouseX, this.lastMouseY, this.controlPanelPresenter.hipsListPresenter.getVisibleModels());
			let intersectionWithModel = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersectionPointWithModel(this.lastMouseX, this.lastMouseY, _utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.activeHiPS);

			if (intersectionWithModel.intersectionPoint.intersectionPoint === undefined) {
				return;
			}
			if (intersectionWithModel.intersectionPoint.intersectionPoint.length > 0) {

				let phiThetaDeg = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.cartesianToSpherical)(intersectionWithModel.intersectionPoint.intersectionPoint);
				//TODO to be reviewed. cartesianToSpherical seems to convert already Dec into [-90, 90]
				let raDecDeg = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.sphericalToAstroDeg)(phiThetaDeg.phi, phiThetaDeg.theta);
				let raHMS = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.raDegToHMS)(raDecDeg.ra);
				let decDMS = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.decDegToDMS)(raDecDeg.dec);
				this.controlPanelPresenter.setSphericalCoordinates(phiThetaDeg);
				this.coordinatesPanelPresenter.update(raDecDeg, raHMS, decDMS, phiThetaDeg.phi, phiThetaDeg.theta);

			}
			this.nearestVisibleObjectIdx = intersectionWithModel.idx;

		}


		let handleMouseMove = (event) => {
			let newX = event.clientX;
			let newY = event.clientY;

			if (this.mouseDown) {

				document.getElementsByTagName("body")[0].style.cursor = "grab";

				let deltaX = (newX - this.lastMouseX) * Math.PI / this.view.canvas.width;
				let deltaY = (newY - this.lastMouseY) * Math.PI / this.view.canvas.width;

				this.inertiaX += 0.1 * deltaX;
				this.inertiaY += 0.1 * deltaY;


			} else {

				// TODO 
				/**
				 * algo for source picking
				 * do raypicking against the HiPS sphere each draw cycle with mouse coords converted into model coords
				 * pass these coords to the fragment shader (catalogue fragment shader)
				 * In the fragment shader, compute if the segment from mouse coords and source point is less than the point radius (gl_PointSize)
				 * 
				 */
				// TODO THIS LOGIC should be moved into MouseHelper class
				let mousePicker = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersectionPointWithSingleModel(newX, newY);
				let mousePoint = mousePicker.intersectionPoint;
				let mouseObjectPicked = mousePicker.pickedObject;
				if (mousePoint !== undefined) {

					if (mousePoint.length > 0) {

						this.mouseHelper.update(mousePoint);
						this.controlPanelPresenter.setSphericalCoordinates(this.mouseHelper.phiThetaDeg);
						this.coordinatesPanelPresenter.update(this.mouseHelper.raDecDeg, this.mouseHelper.raHMS, this.mouseHelper.decDMS, this.mouseHelper.phiThetaDeg.phi, this.mouseHelper.phiThetaDeg.theta);

					} else {
						this.mouseHelper.clear();
						let phiThetaDeg = this.getPhiThetaDeg()
						let raDecDeg = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.sphericalToAstroDeg)(phiThetaDeg.phi, phiThetaDeg.theta)
						let raHMS = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.raDegToHMS)(raDecDeg.ra);
						let decDMS = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.decDegToDMS)(raDecDeg.dec);
						this.controlPanelPresenter.setSphericalCoordinates(phiThetaDeg);
						this.coordinatesPanelPresenter.update(raDecDeg, raHMS, decDMS, phiThetaDeg.phi, phiThetaDeg.theta);

					}

				}
			}

			this.lastMouseX = newX;
			this.lastMouseY = newY;
			event.preventDefault();
		}


		this.zoomIn = false;
		this.zoomOut = false;
		this.Xrot = 0;
		this.Yrot = 0;
		this.XYrot = [0, 0];
		this.keyPressed = false;


		let handleKeyUp = (event) => {
			this.keyPressed = false;
			this.zoomIn = false;
			this.zoomOut = false;
			this.Xrot = 0;
			this.Yrot = 0;
			this.XYrot = [0, 0];
			this.keyPressed = false;
		}

		let handleKeyPress = (event) => {

			let code = event.keyCode;

			let move = gl_matrix__WEBPACK_IMPORTED_MODULE_25__.clone([0, 0, 0]);
			let rotStep = 0.01;
			let pan = false;
			switch (code) {
				case 38:// arrowUp
					this.zoomInertia -= 0.0001;
					break;
				case 40:// arrowDown
					this.zoomInertia += 0.0001;
					break;
				case 87:// W
					this.Xrot = -1;
					break;
				case 88:// X
					this.Xrot = 1;
					break;
				case 68:// A
					this.Yrot = 1;
					break;
				case 65:// D
					this.Yrot = -1;
					break;
				case 81:// Q
					this.XYrot = [-rotStep, -rotStep];
					break;
				case 69:// E
					this.XYrot = [rotStep, -rotStep];
					break;
				case 90:// Z
					this.XYrot = [-rotStep, rotStep];
					break;
				case 67:// C
					this.XYrot = [rotStep, rotStep];
					break;
			}
			this.keyPressed = true;

		}

		let handleMouseWheel = (event) => {

			if (event.deltaY < 0) {
				// Zoom in
				this.zoomInertia -= 0.001;
			} else {
				// Zoom out
				this.zoomInertia += 0.001;
			}


		}

		// window.addEventListener('keydown', handleKeyPress);
		// window.addEventListener('keyup', handleKeyUp);

		this.view.canvas.onpointerdown = handleMouseDown;
		this.view.canvas.onpointerup = handleMouseUp;
		this.view.canvas.onpointermove = handleMouseMove;
		this.view.canvas.onwheel = handleMouseWheel;

	};

	getModelCenter() {


		let rect = this.view.canvas.getBoundingClientRect();


		let centralCanvasX = (rect.left + this.view.canvas.width) / 2;
		let centralCanvasY = (rect.top + this.view.canvas.height) / 2;

		let intersectionWithModel = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersectionPointWithModel(centralCanvasX, centralCanvasY, this.getVisibleModels());
		if (intersectionWithModel.intersectionPoint.intersectionPoint === undefined) {
			return;
		}
		if (intersectionWithModel.intersectionPoint.intersectionPoint.length > 0) {

			let phiThetaDeg = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.cartesianToSpherical)(intersectionWithModel.intersectionPoint.intersectionPoint);
			let raDecDeg = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.sphericalToAstroDeg)(phiThetaDeg.phi, phiThetaDeg.theta);
			let raHMS = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.raDegToHMS)(raDecDeg.ra);
			let decDMS = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.decDegToDMS)(raDecDeg.dec);
		} 
		return this.nearestVisibleObjectIdx;
	}


	getPhiThetaDeg(inside) {
		let maxX = _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.canvas.width;
		let maxY = _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.canvas.height;

		let point = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersectionPointWithSingleModel(maxX / 2, maxY / 2).intersectionPoint;
		inside = inside !== undefined ? inside : _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].insideSphere;
		return (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_9__.cartesianToSpherical)(point, !inside);
	}


	refreshFoV(pMatrix) {
		this.fovObj = this.hpGrid.refreshFoV(false, pMatrix);
		this.currentFoV = this.hpGrid.getMinFoV();
		if (this.fovPresenter) {
			this.fovPresenter.updateFoV(this.fovObj);
		}

	}

	draw() {

		this.aspectRatio = this.view.canvas.width / this.view.canvas.height;
		this.pMatrix = this.computePerspectiveMatrix();
		if (this.fovObj === undefined) {
			return;
		}

		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.getExtension('OES_element_index_uint');


		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.clear(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.COLOR_BUFFER_BIT | _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.DEPTH_BUFFER_BIT);

		let cameraRotated = false;
		let THETA, PHI;

		if (this.keyPressed) {
			if (this.Yrot != 0) {
				this.camera.rotateY(this.Yrot);
			} else if (this.Xrot != 0) {
				this.camera.rotateX(this.Xrot);
			} else if (this.XYrot[0] != 0 && this.XYrot[1] != 0) {    // ????? it would never enter here!!!!
				this.camera.rotate(this.XYrot[0], this.XYrot[1]);
			}
		}

		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.viewport(0, 0, _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.viewportWidth, _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.viewportHeight);
		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.clear(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.COLOR_BUFFER_BIT | _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.DEPTH_BUFFER_BIT);

		this.pMatrix = this.computePerspectiveMatrix();

		if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSelectedHiPS() !== undefined) {


			if (this.fovObj.minFoV > 0.1 || this.zoomInertia > 0) {
				if (Math.abs(this.zoomInertia) > 0.0001) {
					this.camera.zoom(this.zoomInertia);
					this.zoomInertia *= 0.95;
				}
			}
			if (this.mouseDown || Math.abs(this.inertiaX) > 0.02 || Math.abs(this.inertiaY) > 0.02) {
				cameraRotated = true;
				THETA = this.inertiaY;
				PHI = this.inertiaX;
				this.inertiaX *= 0.95;
				this.inertiaY *= 0.95;
				this.camera.rotate(PHI, THETA);
			} else {
				this.inertiaY = 0;
				this.inertiaX = 0;
			}


			//TODO REFRESH ControlPanelPresenter model only if the panel is open
			this.controlPanelPresenter.refreshModel();

			let activeHips = _utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.activeHiPS;

			// TODO review this. It sould be taken from HiPSGrid
			let j2000ModelMatrix = _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSelectedHiPS().getModelMatrix();
			let galacticModel = undefined;
			activeHips.forEach(hips => {
				if (hips.isGalacticHips) {
					galacticModel = hips.getModelMatrix();
				} else {
					j2000ModelMatrix = hips.getModelMatrix();
				}
			});

			if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].debug) {
				if (this._debugPresenter == null) {
					this.initDebugPresenter();
				}
				if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSelectedHiPS()._tileBuffer._tiles && _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSelectedHiPS()._tileBuffer._tilesCache) {
					this._debugPresenter.refresh(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSelectedHiPS()._tileBuffer._tiles, _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].getSelectedHiPS()._tileBuffer._tilesCache);
				}
			}

			_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.disable(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.DEPTH_TEST);
			_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.enable(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.BLEND);
			_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.enable(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.CULL_FACE);
			if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].insideSphere) {
				_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.cullFace(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.BACK);
			} else {
				_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.cullFace(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.FRONT);
			}

			if (_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].blendMode) {
				_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.blendFunc(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.SRC_ALPHA, _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.ONE);
			} else {
				_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.blendFunc(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.SRC_ALPHA, _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.ONE_MINUS_SRC_ALPHA);
			}

			_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.blendFunc(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.SRC_ALPHA, _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.ONE_MINUS_SRC_ALPHA);

			// DRAW HiPS
			_utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.activeHiPS.forEach(hips => {
				hips.draw(this.pMatrix, this.camera.getCameraMatrix(), cameraRotated);
			});

			// GRID
			let showHPXGrid = false;
			if (this._showHPXGrid) {
				jquery__WEBPACK_IMPORTED_MODULE_0__("#gridhpx").show();
				showHPXGrid = true;

			} else {
				jquery__WEBPACK_IMPORTED_MODULE_0__("#gridhpx").hide();
			}

			if (this.hpGrid !== undefined) {
				this.hpGrid.draw(j2000ModelMatrix, cameraRotated, showHPXGrid, this.pMatrix);
			}


			if (this._showGrid) {
				jquery__WEBPACK_IMPORTED_MODULE_0__("#gridcoords").show();
				if (this.eqGrid == undefined && this.fovObj !== undefined) {
					this.eqGrid = new _model_grids_EquatorialGrid_js__WEBPACK_IMPORTED_MODULE_15__["default"](1.0, this.fovObj.minFoV);
				}
				if (this.eqGrid !== undefined) {
					this.eqGrid.draw(j2000ModelMatrix, this.fovObj.minFoV);
				}

			} else {
				jquery__WEBPACK_IMPORTED_MODULE_0__("#gridcoords").hide();
			}





			_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.enable(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.DEPTH_TEST);
			_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.disable(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].gl.CULL_FACE);



			// CATALOGUES
			for (let cat of _utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.activeCatSets) {
				if (cat.ready) {
					cat.draw(j2000ModelMatrix, this.mouseHelper);
				}
			}

			// FOOTPRINTS
			for (let fset of _utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.activeFSets) {
				if (fset.ready) {
					fset.draw(j2000ModelMatrix, this.mouseHelper);
				}

			}


		}




		//		this.xyzRefSystemObj.draw(this.pMatrix, this.camera.getCameraMatrix());
	};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MainPresenter);

/***/ }),

/***/ "./src/js/config.json":
/*!****************************!*\
  !*** ./src/js/config.json ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"tapProviders":["https://archive.eso.org/tap_cat/","https://archive.eso.org/tap_obs/","https://sky.esa.int/esasky-tap/tap/","https://ws.cadc-ccda.hia-iha.nrc-cnrc.gc.ca/argus"],"hipsNodes":["https://skies.esac.esa.int/","https://alasky.cds.unistra.fr/hipslist"],"corsProxyUrl":"http://localhost:4000/","useCORSProxy":true,"maxDecimals":15,"defaultHipsUrl":"//skies.esac.esa.int/DSSColor","version":"Astrobrowser v1.0.0","debug":false,"insideView":false,"camera":{"fovDeg":34,"nearPlane":0.00001,"farPlane":2.5}}');

/***/ }),

/***/ "./src/js/events/AddMessageToMsgBoxEvent.js":
/*!**************************************************!*\
  !*** ./src/js/events/AddMessageToMsgBoxEvent.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class AddMessageToMsgBoxEvent{
	
	_message;
	_msgId;
	static name = "AddMessageToMsgBoxEvent";
	
	constructor(msgId, message){
		this._message = message
		this._msgId = msgId
	}
	
	get name(){
		return AddMessageToMsgBoxEvent.name;
	}

	get message(){
		return this._message
	}

	get msgId(){
		return this._msgId
	}
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddMessageToMsgBoxEvent);

/***/ }),

/***/ "./src/js/events/CORSTAPReposEvent.js":
/*!********************************************!*\
  !*** ./src/js/events/CORSTAPReposEvent.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class CORSTAPReposEvent{
	
	static name = "CORSTAPReposEvent";
	
	constructor(){}
	
	get name(){
		return CORSTAPReposEvent.name;
	}
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CORSTAPReposEvent);

/***/ }),

/***/ "./src/js/events/EventBus.js":
/*!***********************************!*\
  !*** ./src/js/events/EventBus.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class EventBus{
	
	eventsMap;
	
	constructor(){
		
		this.eventsMap = [];
		
	}
	
	registerForEvent(in_class, in_event_name){
		// console.log(in_event_name);
		if (this.eventsMap[in_event_name] == undefined){
			// console.log("undefined");
			this.eventsMap[in_event_name] = [];
		}
		if (!this.eventsMap[in_event_name].includes(in_class)){
			this.eventsMap[in_event_name].push(in_class);	
		}
		// console.log(in_class+"registered for event "+in_event_name);
//		console.log("Classes registered: "+this.#eventsMap[in_event_name]);
		this.printEventBusStatus();
	}
	
	printEventBusStatus(){
		
		for ( var eventName in this.eventsMap){
			
			for (var i = 0; i < this.eventsMap[eventName].length; i++){
				// console.log(eventName+"->"+this.eventsMap[eventName][i].name);
			}

		}
	}

	fireEvent(in_event){
		
		// console.log(JSON.stringify(in_event));
		let eventName = in_event.name;
		// console.log("FIRE EVENT "+eventName);
		
		this.printEventBusStatus();
		
		if (this.eventsMap[eventName] !== undefined){
			
			for (var i = 0; i < this.eventsMap[eventName].length; i++){
				
				let claz = this.eventsMap[eventName][i];
				// console.log("NOTIFY "+claz.name);
				claz.notify(in_event);
				
			}
			
		} else {
			// console.log("No classes registered for the event "+in_event.name);
		}
		
		
	}

	
}

var eventBus = new EventBus();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (eventBus);

/***/ }),

/***/ "./src/js/events/HiPSSelectedEvent.js":
/*!********************************************!*\
  !*** ./src/js/events/HiPSSelectedEvent.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class HiPSSelectedEvent{
	
	_hips;
	static name = "HiPSSelectedEvent";
	
	constructor(hips){
		this._hips = hips;
	}
	
	get name(){
		return HiPSSelectedEvent.name;
	}
	
	get hips(){
		return this._hips;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HiPSSelectedEvent);

/***/ }),

/***/ "./src/js/events/InsideSphereSelectionChangedEvent.js":
/*!************************************************************!*\
  !*** ./src/js/events/InsideSphereSelectionChangedEvent.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class InsideSphereSelectionChangedEvent{
	
	_insideSphere;
	static name = "InsideSphereSelectionChangedEvent";
	
	constructor(in_insideSphere){
		this._insideSphere = in_insideSphere;
	}
	
	get name(){
		return InsideSphereSelectionChangedEvent.name;
	}
	
	get insideSphere(){
		return this._insideSphere;
	}

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InsideSphereSelectionChangedEvent);

/***/ }),

/***/ "./src/js/events/OpenDataExplorerPanelEvent.js":
/*!*****************************************************!*\
  !*** ./src/js/events/OpenDataExplorerPanelEvent.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class OpenDataExplorerPanelEvent{
	
	_craDeg;
	_cdecDeg;
	_radiusDeg;
	_pxSize;
	_projectionName;
	_hipsURL;
	static name = "OpenDataExplorerPanelEvent";
	
	constructor(centralRA, centralDec, pxSize, radius, projectionName, hipsURL){
		this._craDeg = centralRA;
		this._cdecDeg = centralDec;
		this._pxSize = pxSize;
		this._radiusDeg = radius;
		this._projectionName = projectionName;
		this._hipsURL = hipsURL;
	}
	
	get craDeg() {
		return this._craDeg;
	}

	get cdecDeg() {
		return this._cdecDeg;
	}
	
	get radiusDeg() {
		return this._radiusDeg;
	}
	
	get projectionName() {
		return this._projectionName;
	}

	get pxSize() {
		return this._pxSize;
	}

	get hipsURL() {
		return this._hipsURL;
	}
	
	get name(){
		return OpenDataExplorerPanelEvent.name;
	}
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OpenDataExplorerPanelEvent);

/***/ }),

/***/ "./src/js/events/OpenPanelEvent.js":
/*!*****************************************!*\
  !*** ./src/js/events/OpenPanelEvent.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class OpenPanelEvent{
	
	_panelName;
	// _view;
	static name = "OpenPanelEvent";
	
	// constructor(panelName, view){
	constructor(panelName){
		this._panelName = panelName;
		// this._view = view;
	}
	
	get name(){
		return OpenPanelEvent.name;
	}

	// get view() {
	// 	return this._view;
	// }
	
	get panelName(){
		return this._panelName;
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OpenPanelEvent);

/***/ }),

/***/ "./src/js/events/RemoveMessageToMsgBoxEvent.js":
/*!*****************************************************!*\
  !*** ./src/js/events/RemoveMessageToMsgBoxEvent.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class RemoveMessageToMsgBoxEvent{
	
	_msgId;
	static name = "RemoveMessageToMsgBoxEvent";
	
	constructor(msgId){
		this._msgId = msgId
	}
	
	get name(){
		return RemoveMessageToMsgBoxEvent.name;
	}

	get msgId(){
		return this._msgId
	}
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RemoveMessageToMsgBoxEvent);

/***/ }),

/***/ "./src/js/events/ShowCoordsGridSelectionChangedEvent.js":
/*!**************************************************************!*\
  !*** ./src/js/events/ShowCoordsGridSelectionChangedEvent.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class ShowCoordsGridSelectionChangedEvent{
	
	_shouldShowGrid;
	static name = "ShowCoordsGridSelectionChangedEvent";
	
	constructor(in_shouldShowGrid){
		this._shouldShowGrid = in_shouldShowGrid;
	}
	
	get name(){
		return ShowCoordsGridSelectionChangedEvent.name;
	}
	
	get shouldShowGrid(){
		return this._shouldShowGrid;
	}

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShowCoordsGridSelectionChangedEvent);

/***/ }),

/***/ "./src/js/events/ShowHealpixGridSelectionChangedEvent.js":
/*!***************************************************************!*\
  !*** ./src/js/events/ShowHealpixGridSelectionChangedEvent.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class ShowHealpixGridSelectionChangedEvent{
	
	_shouldShowGrid;
	static name = "ShowHealpixGridSelectionChangedEvent";
	
	constructor(in_shouldShowGrid){
		this._shouldShowGrid = in_shouldShowGrid;
	}
	
	get name(){
		return ShowHealpixGridSelectionChangedEvent.name;
	}
	
	get shouldShowGrid(){
		return this._shouldShowGrid;
	}

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShowHealpixGridSelectionChangedEvent);

/***/ }),

/***/ "./src/js/model/AbstractSkyEntity.js":
/*!*******************************************!*\
  !*** ./src/js/model/AbstractSkyEntity.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _FoV_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FoV.js */ "./src/js/model/FoV.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");
/**
 * @author Fabrizio Giordano (Fab)
 * @param in_radius - number
 * @param in_gl - GL context
 * @param in_position - array of double e.g. [0.0, 0.0, 0.0]
 */





class AbstractSkyEntity{
	
	constructor(in_radius, in_position, in_xRad, in_yRad, in_name, isGalacticHips){
		let in_gl = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl;
		// 
		/**
		 * TODO !!!!!!! MOVE FOVOBJ IN A EXTERNAL OBJECT WITH STATIC METHODS 
		 * probably HealpiGrid is a good place and use it for model matrix as well
		 * in general. 
		 * To avoid displaying lines, add boolean property in HealpixGrid.draw 
		 * 
		 */
		this.fovObj = new _FoV_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);
		this.refreshMe = false;
		this.fovX_deg = 180;
		this.fovY_deg = 180;
		this.prevFoV = this.fovX_deg;
		this.name = in_name;
		this.center = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.clone(in_position);
		this.radius = in_radius;
		this.isGalacticHips = isGalacticHips !== undefined ? isGalacticHips : false;
		
		// GL related
		this.vertexTextureCoordBuffer = in_gl.createBuffer();
		this.vertexPositionBuffer = in_gl.createBuffer();
		this.vertexIndexBuffer = in_gl.createBuffer();
		this.shaderProgram = in_gl.createProgram();
		
		// Matrices related
		this.T = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		
		this.R = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		
		this.modelMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		
		this.inverseModelMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		
		this.galacticMatrixInverted = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.set(this.galacticMatrixInverted, 
			-0.054875582456588745, -0.8734370470046997,-0.48383501172065735, 0,
			0.49410945177078247, -0.4448296129703522, 0.7469822764396667, -0,
			-0.8676661849021912, -0.19807636737823486, 0.4559837877750397, 0,
			0, 0, 0, 1);

		// Initial position
		this.translate(this.center);
		this.rotate(in_xRad, in_yRad);
	}
	
	setIsGalacticFrame(isGalacticHips){
		this.isGalacticHips = isGalacticHips;
		this.refreshModelMatrix();
	}
	
	
	translate(in_translation){
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.translate(this.T, this.T, this.center);
		this.refreshModelMatrix();
	}
	
	rotate(rad1, rad2){

	    gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, rad2, [0, 0, 1]);
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, rad1, [1, 0, 0]);
	    
		this.refreshModelMatrix();

	}

	rotateFromZero(rad1, rad2){
		
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.identity(this.R);
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, rad1, [1, 0, 0]);
	    gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, rad2, [0, 0, 1]);
	    this.refreshModelMatrix();

	}

	refreshModelMatrix(){
		var R_inverse = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(R_inverse, this.R);
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply(this.modelMatrix, this.T, R_inverse);
		if(!_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].insideSphere){
			this.modelMatrix[1] = - this.modelMatrix[1];
			this.modelMatrix[5] = - this.modelMatrix[5];
			this.modelMatrix[9] = - this.modelMatrix[9];
			this.modelMatrix[13] = - this.modelMatrix[13];
		}

		if(this.isGalacticHips){
			gl_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply(this.modelMatrix, this.modelMatrix, this.galacticMatrixInverted);
		}
	}
	
	getModelMatrixInverse(){
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.identity(this.inverseModelMatrix);
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(this.inverseModelMatrix, this.modelMatrix);
		return this.inverseModelMatrix;
	}
	
	
	getModelMatrix(){
		return this.modelMatrix;
	}
	
	setMatricesUniform (projectionMatrix, cameraMatrix){
		
		in_gl.uniformMatrix4fv(this.shaderProgram.mMatrixUniform, false, this.modelMatrix);
		in_gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, projectionMatrix);
		in_gl.uniformMatrix4fv(this.shaderProgram.vMatrixUniform, false, cameraMatrix);
		
	}

	initShaderOld (){
		// Abstract
	}
	
	initBuffers(){
		// Abstract
	}
	
	initTextures (){
		// Abstract
	}
	
	draw (){
		// Abstract
	}
	
	drawAndSetMatrixUniform (projectionMatrix, cameraMatrix){
		this.draw();
		this.setMatricesUniform(projectionMatrix, cameraMatrix);
	}
	
	refreshFoV(insideSphere, pMatrix){
//		refreshFoV(in_pMatrix, in_camera, in_raypicker){
		
		var fovObj = this.fovObj.getFoV(insideSphere, pMatrix);
//		var fovObj = this.fovObj.getFoV(in_pMatrix, in_camera, in_raypicker);
		return fovObj;
		
	}
	
	
	refreshModel (in_fov, in_pan, in_camera){
		// Abstract
		// console.log("[AbstractSkyEntity::refreshModel]");
	}
	
	
	
	getMinFoV (){
		return this.fovObj.minFoV;
	}
	
	// Method overwritten by children having hierarchical geometry (e.g. HiPS)
	setGeometryNeedsToBeRefreshed (){
		this.refreshGeometryOnFoVChanged = false;
	};
	
	
	rotateX (m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv1 = m[1], mv5 = m[5], mv9 = m[9];

        m[1] = m[1]*c-m[2]*s;
        m[5] = m[5]*c-m[6]*s;
        m[9] = m[9]*c-m[10]*s;

        m[2] = m[2]*c+mv1*s;
        m[6] = m[6]*c+mv5*s;
        m[10] = m[10]*c+mv9*s;
        
        return m;
        
     }

     rotateY (m, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var mv0 = m[0], mv4 = m[4], mv8 = m[8];

        m[0] = c*m[0]+s*m[2];
        m[4] = c*m[4]+s*m[6];
        m[8] = c*m[8]+s*m[10];

        m[2] = c*m[2]-s*mv0;
        m[6] = c*m[6]-s*mv4;
        m[10] = c*m[10]-s*mv8;
        
        return m;
	 }
	
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AbstractSkyEntity);

/***/ }),

/***/ "./src/js/model/Camera.js":
/*!********************************!*\
  !*** ./src/js/model/Camera.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Utils.js */ "./src/js/utils/Utils.js");
/**
 * @author Fabrizio Giordano (Fab)
 */





class Camera{
	constructor(in_position, in_sphere){
		this.init(in_position, in_sphere);
	}
	
	init(in_position, in_sphere){
		this.insideSphere = in_sphere;
		this.cam_pos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.clone(in_position); // initial camera position
		this.cam_speed = 1.0;
		
		this.vMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create(); // view matrix
		this.T = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create(); // translation matrix
		this.R = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create(); // rotation matrix
		

		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.translate(this.T, this.T, 
			[this.cam_pos[0],
			this.cam_pos[1],
			this.cam_pos[2]]);
	

//		var T_inverse = mat4.create();
//		mat4.invert(T_inverse, this.T);

		this.FoV = this.previousFoV = 180.0;
//		var R_inverse = mat4.create();
//		mat4.invert(R_inverse, this.R);
//		mat4.multiply(this.vMatrix, T_inverse, R_inverse);
//		
		 
		this.move = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.clone([0, 0, 0]);
		
		
		

		
		
		//		COMMENTED 4 TEST
//		this.refreshViewMatrix();

		
		let raDeg = 0;
		let decDeg = 0;
		
		this.goTo(raDeg, decDeg);
		
//		let ptDeg = astroDegToSpherical(raDeg, decDeg);
//		/* 
//		 * angle on from z (on the xz plane). from 0 to 180 deg
//		 * theta 0 deg => z up
//		 * theta 180 deg => z down
//		 */
////		this.theta = degToRad(ptDeg.theta);
//		this.theta = -degToRad(decDeg);
//		/* 
//		 * angle on from x (on the xy plane). from 0 to 360 deg
//		 * phi 0 or 360 deg => x backward (out of the screen)
//		 * theta 180 deg => x forward 
//		 */
////		this.phi = degToRad(ptDeg.phi);
//		this.phi = degToRad(raDeg);
//
//		this.phi = 0;
//		this.theta = 0;
//		
//		
//		// model initial phi = 0 theta 90
//		// wanted model phi 10 theta 45
//		let cameraMatrix = mat4.create();
//		
//		cameraMatrix = mat4.rotate(cameraMatrix, cameraMatrix, this.phi, [0, 1, 0]);
//		cameraMatrix = mat4.rotate(cameraMatrix, cameraMatrix, this.theta, [1, 0, 0]);
//		
////		this.R = cameraMatrix;
//		this.R = mat4.clone(cameraMatrix);
//		cameraMatrix = mat4.translate(cameraMatrix, cameraMatrix, 
//				[in_position[0],
//				in_position[1],
//				in_position[2]]);
////		this.T = [cameraMatrix];		
//		
//		let cameraPos = [
//		      cameraMatrix[12],
//		      cameraMatrix[13],
//		      cameraMatrix[14],
//		    ];
//		
//		let focusPoint = [0.0, 0.0, 0.0];
//		
//		let cameraUp = vec3.clone([0.0, 1.0, 0.0]);
//		
//		cameraMatrix = mat4.targetTo(cameraMatrix, cameraPos, focusPoint, cameraUp); 
//		
//		let viewMatrix = mat4.create();
//		viewMatrix = mat4.invert(viewMatrix, cameraMatrix);
//		this.vMatrix = viewMatrix;
//		
//		console.log(this.getCameraAngle());
		
		
	};

	
	goTo(raDeg, decDeg){
		console.log(`global.insideSphere: ${_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].insideSphere}`)
		// if(!global.insideSphere){
			raDeg = 360 - raDeg;
		// }
		this.goToPhiTheta((0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__.astroDegToSpherical)(raDeg, decDeg));
	};

	goToPhiTheta(ptDeg){
		let xyz = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__.sphericalToCartesian)(ptDeg.phi, ptDeg.theta, this.cam_pos[2]);

		let cameraMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		
		cameraMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.translate(cameraMatrix, cameraMatrix, xyz);
		
		let focusPoint = [0.0, 0.0, 0.0];
		
		
		let cameraUp = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.clone([0.0, 1.0, 0.0]);
		let cameraPos = [
			cameraMatrix[12],
			cameraMatrix[13],
			cameraMatrix[14],
	    ];
		
		cameraMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.targetTo(cameraMatrix, cameraPos, focusPoint, cameraUp); 
		
		this.R = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.clone(cameraMatrix);
		this.R[12] = 0;
		this.R[13] = 0;
		this.R[14] = 0;
		
		
		let viewMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		if(this.cam_pos[2] != 0){
			gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(viewMatrix, cameraMatrix);
		}
		this.vMatrix = viewMatrix;
		
	};

	setInsideSphere(inside){
		if(inside != this.insideSphere){
			this.insideSphere = inside;
			// this.rotateYRadian(Math.PI);
			if(this.insideSphere){
				if(this.cam_pos[2] <= 2 ){
					this.cam_pos[2] = -2 + this.cam_pos[2];
				} else {
					this.cam_pos[2] = -0.005;
				}
			} else{
				this.cam_pos[2] = 2.0 + this.cam_pos[2];
			}
			gl_matrix__WEBPACK_IMPORTED_MODULE_3__.translate(this.T, gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create(), this.cam_pos);
			
			this.refreshViewMatrix();
		}
	}
	
	zoom(inertia){
		this.move = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.clone([0, 0, 0]);
		this.move[2] += this.cam_speed * inertia;

		if(this.insideSphere){
			if(this.cam_pos[2] + this.move[2] >= -0.005 && inertia > 0){
				this.cam_pos[2] = -0.005;
				inertia = 0;
			} else if(this.cam_pos[2] + this.move[2] <= -0.9885 && inertia < 0){
				this.cam_pos[2] = -0.9885;
				inertia = 0;
			} else {
				this.cam_pos[2] += this.move[2];
			}
		} else {
			if(this.cam_pos[2] < 1.005){
				this.move[2] *= this.cam_pos[2] / 100;
			} else if(this.cam_pos[2] < 1.05){
				this.move[2] *= this.cam_pos[2] / 20;
			} else if(this.cam_pos[2] < 1.3){
				this.move[2] *= this.cam_pos[2] / 3;
			}
			if(this.cam_pos[2] + this.move[2] <= 1.000001 && inertia < 0){
				this.cam_pos[2] = 1.000001;
			} else {
				this.cam_pos[2] += this.move[2];
			}
			this.cam_pos[2] += this.move[2];

		}
		
		
		var identity = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.translate(this.T, identity, this.cam_pos);
				
		this.refreshViewMatrix();
	}
	
	
	
	rotateZ(sign){
		let factorRad = sign * 0.01;
		this.phi += factorRad;
		
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, factorRad, [0, 0, 1]);
		

//		console.log("[Camera2::rotateY] END ---------- ");
		
		this.refreshViewMatrix();
		
	};
	
	rotateY(sign){
		let factorRad = sign * 0.01;
		this.phi += factorRad;
		
		var identity = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, factorRad, [0, 1, 0]);

//		console.log("[Camera2::rotateY] END ---------- ");
		
		this.refreshViewMatrix();
		
	};

	rotateXRadian(radian){
		// this.phi += radian;
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, radian, [1, 0, 0]);
		this.refreshViewMatrix();
	};
	rotateYRadian(radian){
		this.phi += radian;
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, radian, [0, 1, 0]);
		this.refreshViewMatrix();
	};
	rotateZRadian(radian){
		// this.phi += radian;
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, radian, [0, 0, 1]);
		this.refreshViewMatrix();
	};
	
	rotateX(sign){
//		factorRad = sign * 0.01;
		
		
		let factorRad = sign * 0.01;
		
		this.theta += factorRad;
//		console.log("THETA "+this.theta);
		var identity = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, factorRad, [1, 0, 0]);
		
	    
//		console.log("[Camera2::rotateY] END ---------- ");
		
//		mat4.inverse(this.R, this.vMatrix);
		this.refreshViewMatrix();
		
	};

	
//	rotate(phi, theta){
//		
//		let target = vec3.clone([0.0, 0.0, 0.0]);
//		let cameraPos = this.getCameraPosition ();
//		cameraPos = vec3.rotateY(cameraPos, cameraPos, target, -phi);
//		cameraPos = vec3.rotateX(cameraPos, cameraPos, target, -theta);
//		
//		
//		
//		let cameraRight = vec3.create();
//		let cameraUp = vec3.clone([0.0, 1.0, 0.0]);
//		cameraRight = vec3.cross(cameraRight, cameraPos, cameraUp);
//		cameraRight = vec3.normalize(cameraRight,cameraRight);
//		
//		cameraUp = vec3.cross(cameraUp, cameraRight, cameraPos);
//		cameraUp = vec3.normalize(cameraUp, cameraUp);
//		
//		let cameraMatrix = mat4.create();
//		cameraMatrix = mat4.targetTo(cameraMatrix, cameraPos, target, cameraUp);
//		
//		let viewMatrix = mat4.create();
//		viewMatrix = mat4.invert(viewMatrix, cameraMatrix);
//		this.vMatrix = viewMatrix;
//
//	};


	rotate(phi, theta){
		var totRot = Math.sqrt(phi*phi + theta*theta);
		if(totRot == 0) {return;}

		const pos = this.getCameraPosition();
		const dist2Center = Math.sqrt(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.dot(pos, pos));
		const usedRot = totRot * (dist2Center - 1) / 3.0;

		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.rotate(this.R, this.R, -(usedRot), [theta/totRot, phi/totRot, 0]);
		
		// console.log("totRotation "+ totRot);
	    // console.log("Camera rotation matrix "+ this.R);
	    this.refreshViewMatrix();
	    
	};

	refreshViewMatrix(){
		
		var T_inverse = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		var R_inverse = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(T_inverse, this.T);
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(R_inverse, this.R);
		
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply(this.vMatrix, T_inverse, R_inverse);

	};
	
	
	refreshFoV(currentFoV){
		
		this.previousFoV = this.FoV;
		this.FoV = currentFoV;
		
	};

	getCameraMatrix(){
		
		return this.vMatrix;
	};
	
	getCameraPosition (){
		// to be initiated into the init 
		var vMatrix_inverse = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_3__.invert(vMatrix_inverse, this.vMatrix);
		return [vMatrix_inverse[12], vMatrix_inverse[13], vMatrix_inverse[14]];
	};
		
	getCameraAngle(){
		
		let ptDeg = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__.cartesianToSpherical)(this.getCameraPosition ());
		console.log("[Camera3::getCameraAngle] "+ptDeg);
		return ptDeg;
		
	};
	

	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Camera);

/***/ }),

/***/ "./src/js/model/FoV.js":
/*!*****************************!*\
  !*** ./src/js/model/FoV.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/RayPickingUtils.js */ "./src/js/utils/RayPickingUtils.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */






/** TODO
 * THIS CLASS SHOULD BE A SINGLETON AND USED ONLY WITH THE FIRST ACTIVE HIPS 
*/
class FoV{
	
	_minFoV;
	
	constructor(in_model){
		this.fovXDeg = 180;
		this.fovYDeg = 180;
		this.prevMinFoV = 180;
		if (in_model == null){
			in_model = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultHips;
		}
		this.model = in_model;
		this._minFoV = 180;
	}
	
	getFoV(insideSphere, pMatrix){
		var gl = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl;

		
		this.prevMinFoV = this._minFoV;
		
		// horizontal FoV 
		this.fovXDeg = this.computeAngle(0, gl.canvas.height / 2, insideSphere, pMatrix);
		// vertical FoV 
		this.fovYDeg = this.computeAngle(gl.canvas.width / 2, 0, insideSphere, pMatrix);

		// if (this.fovXDeg <= 1.0) {
		// 	this.fovXDeg = 1.0;
		// }
		// if (this.fovYDeg <= 1.0) {
		// 	this.fovYDeg = 1.0;
		// }

		this._minFoV = this.minFoV;
		
		return this;
	}
	

	computeAngle(canvasX, canvasY, insideSphere, pMatrix){
		
		var camera = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].camera;
		
		var rayWorld = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_0__["default"].getRayFromMouse(canvasX, canvasY, pMatrix);
		
		var intersectionDistance = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_0__["default"].raySphere(camera.getCameraPosition(), rayWorld, this.model);
		
		if (intersectionDistance > 0){
			var intersectionPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
			gl_matrix__WEBPACK_IMPORTED_MODULE_3__.scale(intersectionPoint, rayWorld, intersectionDistance);
			gl_matrix__WEBPACK_IMPORTED_MODULE_3__.add(intersectionPoint, camera.getCameraPosition(), intersectionPoint);
			
			var center = this.model.center;
			
			var intersectionPoint_center_vector = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
			gl_matrix__WEBPACK_IMPORTED_MODULE_3__.subtract(intersectionPoint_center_vector, intersectionPoint, center);
			
			
			// 20250507: SOLVED? error found!!!!! when the camera is rotated, the following vector should be rotated as well
			// because the z-axis of the world doesn't coincide with the z-axis of the camera anymore 
			var b = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.clone( [this.model.center[0], this.model.center[1], this.model.center[2] + this.model.radius] );
			
			var vMatrixInverse = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.create();
			gl_matrix__WEBPACK_IMPORTED_MODULE_4__.invert(vMatrixInverse, camera.getCameraMatrix());
			
			//gl-matrix 0.x
			// mat4.multiplyVec3(vMatrixInverse, b, b);
			
			//gl-matrix 3.x
			// we apply here any possible rotation since in the view matrix since the 
			// z axis could not match with the z axis in the world space.
			this.mat4multiplyVec3(vMatrixInverse, b, b);
			
			
			
			var b_center_vector = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
			gl_matrix__WEBPACK_IMPORTED_MODULE_3__.subtract(b_center_vector, b, center);
			
			var scal_prod = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();
			scal_prod = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.dot(intersectionPoint_center_vector, b_center_vector);
			var intersectionPoint_center_vector_norm = Math.sqrt(
					intersectionPoint_center_vector[0]*intersectionPoint_center_vector[0] + 
					intersectionPoint_center_vector[1]*intersectionPoint_center_vector[1] + 
					intersectionPoint_center_vector[2]*intersectionPoint_center_vector[2]);
			var b_center_vector_norm = Math.sqrt(
					b_center_vector[0]*b_center_vector[0] + 
					b_center_vector[1]*b_center_vector[1] + 
					b_center_vector[2]*b_center_vector[2]);
			var cos_angle = scal_prod / (intersectionPoint_center_vector_norm * b_center_vector_norm);
			var angle_rad = Math.acos(cos_angle);
			var angle_deg = 2 * (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__.radToDeg)(angle_rad);
			
		}else{
			angle_deg = 180;
		}
		insideSphere = insideSphere ? insideSphere : _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].insideSphere;
		if(insideSphere){
			return 360 - angle_deg;
		} else {
			return angle_deg;
		}
	}
	
	get minFoV(){
		this._minFoV = (this.fovYDeg <= this.fovXDeg) ? this.fovYDeg : this.fovXDeg;
		return this._minFoV;
	}

	mat4multiplyVec3 = function(a, b, c) {
		c || (c = b);
		var d = b[0],
			e = b[1];
		b = b[2];
		c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];
		c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];
		c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];
		return c
	};
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FoV);

//function FoV(in_gl, in_canvas, in_model){
//	
//	var currentObj = this;
//	
//	this.init = function(){
//		currentObj.fovXDeg = 180;
//		currentObj.fovYDeg = 180;
//		currentObj.minFoV = 180;
//	};
//	
//	
//	
//
//	this.getFoV = function (in_pMatrix, in_camera){
//
//		function computeAngle(canvasX, canvasY, in_pMatrix, in_camera){
//			 
//			var rayWorld = RayPickingUtils.getRayFromMouse(canvasX, canvasY, in_pMatrix, in_camera.getCameraMatrix(), in_canvas);
//			
//			var intersectionDistance = RayPickingUtils.raySphere(in_camera.getCameraPosition(), rayWorld, in_model);
//			
//			if (intersectionDistance > 0){
//				var intersectionPoint = vec3.create();
//				vec3.scale(rayWorld, intersectionDistance, intersectionPoint);
//				vec3.add(in_camera.getCameraPosition(), intersectionPoint, intersectionPoint);
//				
//				var center = in_model.center;
//				
//				var intersectionPoint_center_vector = vec3.create();
//				vec3.subtract(intersectionPoint, center, intersectionPoint_center_vector);
//				
//				
//				// error found!!!!! when the camera is rotated, the following vector should be rotated as well
//				// because the z-axis of the world doesn't coincide with the z-axis of the camera anymore 
//				var b = vec3.create( [in_model.center[0], in_model.center[1], in_model.center[2] + in_model.radius] );
//				
//				var vMatrixInverse = mat4.create();
//				mat4.inverse(in_camera.getCameraMatrix(), vMatrixInverse);
//				
//				mat4.multiplyVec3(vMatrixInverse, b, b);
//				
//				
//				
//				var b_center_vector = vec3.create();
//				vec3.subtract(b, center, b_center_vector);
//				
//				var scal_prod = vec3.create();
//				scal_prod = vec3.dot(intersectionPoint_center_vector, b_center_vector);
//				var intersectionPoint_center_vector_norm = Math.sqrt(
//						intersectionPoint_center_vector[0]*intersectionPoint_center_vector[0] + 
//						intersectionPoint_center_vector[1]*intersectionPoint_center_vector[1] + 
//						intersectionPoint_center_vector[2]*intersectionPoint_center_vector[2]);
//				var b_center_vector_norm = Math.sqrt(
//						b_center_vector[0]*b_center_vector[0] + 
//						b_center_vector[1]*b_center_vector[1] + 
//						b_center_vector[2]*b_center_vector[2]);
//				var cos_angle = scal_prod / (intersectionPoint_center_vector_norm * b_center_vector_norm);
//				var angle_rad = Math.acos(cos_angle);
//				var angle_deg = 2 * radToDeg(angle_rad);
//				
//			}else{
//				angle_deg = 180;
//			}
//			return angle_deg;
//		}
//		
//		currentObj.prevMinFoV = currentObj.minFoV;
//		
//		// horizontal FoV 
//		currentObj.fovXDeg = computeAngle(0, in_canvas.height / 2, in_pMatrix, in_camera);
//		// vertical FoV 
//		currentObj.fovYDeg = computeAngle(in_canvas.width / 2, 0, in_pMatrix, in_camera);
//
//		currentObj.minFoV = currentObj.getMinFoV();
//		
//		return currentObj;
//
//	};
//	
//	this.getMinFoV = function(){
//		currentObj.minFoV = (currentObj.fovYDeg <= currentObj.fovXDeg) ? currentObj.fovYDeg : currentObj.fovXDeg;
//		return currentObj.minFoV;
//	};
//	
//	this.init();
//	
//	
//}


/***/ }),

/***/ "./src/js/model/HiPSDescriptor.js":
/*!****************************************!*\
  !*** ./src/js/model/HiPSDescriptor.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class HiPSDescriptor {
	
	_mission;
	_surveyName;
	_url;
	_maxOrder;
	_imgFormat;
	_hipsFrame;
	_emMin;
	_emMax;
	
	constructor(hipsproperties, hipsurl){
		
		// 

		// console.log(hipslist_JSON);
		this._minOrder = 3;
		this._imgformats = [];
		this._datarange = {min: undefined, max: undefined};
		this._maxOrder = undefined;
		this._tilewidth = undefined;
		this._hipsFrame = undefined;
		this._hipsName = undefined;
		this._hipsurl = hipsurl;
		this._emMin = undefined;
		this._emMax = undefined;

		const allLines = hipsproperties.split(/\r\n|\n/);
		allLines.forEach((line) => {
			if (line.startsWith("hips_tile_format") || line.startsWith("format")) {
				let formatlist = this.getValue(line.replace(/jpeg/ig, "jpg"));
				this._imgformats = formatlist.split(" ");
			} else if (line.startsWith("hips_data_range")) {
				let dr = this.getValue(line);
				this._datarange.min = parseFloat(dr.split(" ")[0].trim());
				this._datarange.max = parseFloat(dr.split(" ")[1].trim());
			} else if (line.startsWith("hips_tile_width")) {
				this._tilewidth = this.getValue(line);
			} else if (line.startsWith("hips_order_min")) {
				this._minOrder = parseInt(this.getValue(line));
			} else if (line.startsWith("hips_order") || line.startsWith("maxOrder")) {
				this._maxOrder = parseInt(this.getValue(line));
			} else if (line.startsWith("hips_frame") || line.startsWith("frame")) {
				this._hipsFrame = this.getValue(line);
			} else if (line.startsWith("obs_collection") || line.startsWith("label")) {
				this._hipsName = this.getValue(line);
			} else if (line.startsWith("em_min")) {
				this._emMin = this.getValue(line);
			} else if (line.startsWith("em_max")) {
				this._emMax = this.getValue(line);
			} 

			
		
		});

		if (this._hipsFrame === undefined) {
			console.warn("[HiPSDescriptor] this._hipsFrame is not defined in the properties file of "+this._hipsurl+". Setting it to equatorial for convenience");
			this._hipsFrame = "equatorial";
		}
		this._isGalctic = (this._hipsFrame.toLowerCase().includes("gal")) ? true : false;

		if (this._maxOrder === undefined || this._imgformats.length == 0) {
			throw new Error("[HiPSDescriptor] this._maxOrder: "+ this._maxOrder+" this._imgFormat.length: "+this._imgformats.length);
		}


		// this._mission = hipslist_JSON.mission;
		// this._surveyName = hipslist_JSON.surveyName;
		// let urlFromJson = hipslist_JSON.surveyRootUrl;
		// if(!urlFromJson.endsWith('/')){
		// 	urlFromJson += "/";
		// }
		// urlFromJson = urlFromJson.replace('cdn.skies', 'skies');

		// this._url = urlFromJson;
		// this._maxOrder = hipslist_JSON.maximumNorder;
		// this._imgFormat = hipslist_JSON.imgFormat;
		// this._hipsFrame = hipslist_JSON.hipsFrame;

	}

	getValue(line) {
		return line.split("=")[1].trim();
	}

	// get mission(){
	// 	return this._mission;
	// }
	
	get surveyName(){
		// return this._surveyName;
		return this._hipsName;
	}
	
	get url(){
		// return this._url;
		return this._hipsurl
	}
	
	get maxOrder(){
		return this._maxOrder;
	}

	get minOrder(){
		return this._minOrder;
	}
	
	get imgFormats(){
		return this._imgformats;
	}
	
	get hipsFrame(){
		return this._hipsFrame;
	}

	get isGalactic() {
		return this._isGalctic;
	}
	
	get emMin() {
		return this._emMin
	}

	get emMax() {
		return this._emMax
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HiPSDescriptor);


/***/ }),

/***/ "./src/js/model/SystemEntity.js":
/*!**************************************!*\
  !*** ./src/js/model/SystemEntity.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @author Fabrizio Giordano (Fab)
 */


class SystemEntity{
    constructor(){
        this.fps = 0;
        this.avgfps = 0;
    }
    getFps(){
        return this.fps;
    }

    getAvgFps(){
        return this.avgfps;
    }
    
    setFps(_fps){
        this.fps = _fps.toFixed(1);
    }

    setAvgFps(_avgfps){
        this.avgfps = _avgfps.toFixed(1);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SystemEntity);

/***/ }),

/***/ "./src/js/model/grids/EquatorialGrid.js":
/*!**********************************************!*\
  !*** ./src/js/model/grids/EquatorialGrid.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _hipsnew_FoVHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hipsnew/FoVHelper.js */ "./src/js/model/hipsnew/FoVHelper.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var _shaders_GridShaderManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shaders/GridShaderManager.js */ "./src/js/shaders/GridShaderManager.js");
/* harmony import */ var _utils_Point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/Point.js */ "./src/js/utils/Point.js");
/* harmony import */ var _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/CoordsType.js */ "./src/js/utils/CoordsType.js");
/* harmony import */ var _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/FoVUtils.js */ "./src/js/utils/FoVUtils.js");
/* harmony import */ var _FoV_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../FoV.js */ "./src/js/model/FoV.js");
/* harmony import */ var _GridTextHelper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GridTextHelper.js */ "./src/js/model/grids/GridTextHelper.js");












// import AbstractGrid from './AbstractGrid.js';


// class EquatorialGrid extends AbstractGrid {
    class EquatorialGrid {

	static ELEM_SIZE;
	static BYTES_X_ELEM;

    /**
     * 
     * @param {double} radius 
     * @param {double} fov
     */
    constructor(radius, fov) {

		// super(radius, fov);

		EquatorialGrid.ELEM_SIZE = 3;
		EquatorialGrid.BYTES_X_ELEM = new Float32Array().BYTES_PER_ELEMENT;

		this._viewmatrix = undefined;

		
		this._shaderProgram = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createProgram();
		this.initShaders();
		
        this._attribLocations = {};
		this._nPrimitiveFlags = 0;
		this._totPoints = 0;
		
		
        this._phiVertexPositionBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createBuffer();
        // this._indexBuffer = global.gl.createBuffer();
		this._thetaVertexPositionBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createBuffer();
		// this._indexBuffer = global.gl.createBuffer();
		
		this._attribLocations = {
				position: 0,
				selected: 1,
				pointSize: 2,
				color: [0.0, 1.0, 0.0, 1.0]
		};

        this._fov = fov;
        this._phiArray = [];
		this._thetaArray = [];
		
		this.initBuffers(fov);
        // this.initHtml();
	}

	initShaders() {

		let fragmentShaderStr = _shaders_GridShaderManager_js__WEBPACK_IMPORTED_MODULE_3__["default"].healpixGridFS();
		this.fragmentShader = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FRAGMENT_SHADER);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.shaderSource(this.fragmentShader, fragmentShaderStr);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.compileShader(this.fragmentShader);
		if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderParameter(this.fragmentShader, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.COMPILE_STATUS)) {
			alert(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderInfoLog(this.fragmentShader));
			return null;
		}

		let vertexShaderStr = _shaders_GridShaderManager_js__WEBPACK_IMPORTED_MODULE_3__["default"].healpixGridVS();
		this.vertexShader = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.VERTEX_SHADER);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.shaderSource(this.vertexShader, vertexShaderStr);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.compileShader(this.vertexShader);
		if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderParameter(this.vertexShader, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.COMPILE_STATUS)) {
			alert(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderInfoLog(this.vertexShader));
			return null;
		}

		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.attachShader(this._shaderProgram, this.vertexShader);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.attachShader(this._shaderProgram, this.fragmentShader);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.linkProgram(this._shaderProgram);

		if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getProgramParameter(this._shaderProgram, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.useProgram(this._shaderProgram);

	}

	initBuffers (fov) {

        
        let x, y, z;
        let phiVertexPosition, thetaVertexPosition;
		let thetaRad, phiRad;
		let R = 1.0;

        // let phiStep = 10;
		// let thetaStep = 10;
		let steps = _hipsnew_FoVHelper_js__WEBPACK_IMPORTED_MODULE_1__.fovHelper.getRADegSteps(fov);
        let phiStep = steps.raStep;
		let thetaStep = steps.decStep;

        this._phiStep  = phiStep;
        this._phiStepRad  = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__.degToRad)(phiStep);
        this._ra4Labels = new Map();

        this._thetaStep  = thetaStep;
        this._thetaStepRad  = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__.degToRad)(thetaStep);
        this._dec4Labels = new Map();

        this._phiArray = [];
		this._thetaArray = [];

        // phi section (for RA lines)
        for (let theta = thetaStep; theta < 180; theta += thetaStep){
			
			phiVertexPosition = new Float32Array(360/phiStep * 3);
			
			thetaRad = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__.degToRad)(theta);

			for (let phi = 0; phi <360; phi += phiStep){

				phiRad = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__.degToRad)(phi);
				
				x = R * Math.sin(thetaRad) * Math.cos(phiRad);
				y = R * Math.sin(thetaRad) * Math.sin(phiRad);
				z = R * Math.cos(thetaRad);
				
                let phiDphiStep = Math.floor(phi/phiStep);
				phiVertexPosition[ 3 * phiDphiStep] = x; 
				phiVertexPosition[ 3 * phiDphiStep + 1] = y;
				phiVertexPosition[ 3 * phiDphiStep + 2] = z;
				
                if (!this._dec4Labels.has(phi)) {
                    this._dec4Labels.set(phi, []);
                }
                this._dec4Labels.get(phi).push([x, y, z]);
			}
			
			this._phiArray.push(phiVertexPosition);

		}
		
		for (var phi = 0; phi <360; phi += phiStep){
						
			thetaVertexPosition = new Float32Array(360/thetaStep * 3);
			
			phiRad = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__.degToRad)(phi);
			
			for (var theta = 0; theta <360; theta += thetaStep){
				
				thetaRad = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__.degToRad)(theta);
				
				x = R * Math.sin(thetaRad) * Math.cos(phiRad);
				y = R * Math.sin(thetaRad) * Math.sin(phiRad);
				z = R * Math.cos(thetaRad);
				
				let thetaDthetaStep = Math.floor(theta/thetaStep);
				thetaVertexPosition[ 3 * thetaDthetaStep] = x; 
				thetaVertexPosition[ 3 * thetaDthetaStep + 1] = y;
				thetaVertexPosition[ 3 * thetaDthetaStep + 2] = z;
	
                if (!this._ra4Labels.has(90 - theta)) {
                    this._ra4Labels.set(90 - theta, []);
                }
                this._ra4Labels.get(90 - theta).push([x, y, z]);
			}
			
			this._thetaArray.push(thetaVertexPosition);
			
		}

		// console.log("Buffer initialized");
		
	}

    /**
     * 
     * @param {FoV} fovObj 
     */
	refresh(fov) {

        if (this._fov !== fov){
            
            this._fov = fov;
            this.initBuffers(this._fov);
            
        }
		
	}


    vectorDistance(p1, p2) {
        let r = Math.sqrt( (p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2 );
        return r;
    }
	

	enableShader(mMatrix){

		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.useProgram(this._shaderProgram);
		this._shaderProgram.catUniformMVMatrixLoc = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, "uMVMatrix");
		this._shaderProgram.catUniformProjMatrixLoc = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, "uPMatrix");
		this._attribLocations.position  = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getAttribLocation(this._shaderProgram, 'aCatPosition');
		
		let mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
		mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.multiply(mvMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].camera.getCameraMatrix(), mMatrix);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.uniformMatrix4fv(this._shaderProgram.catUniformMVMatrixLoc, false, mvMatrix);
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.uniformMatrix4fv(this._shaderProgram.catUniformProjMatrixLoc, false, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].pMatrix);

	}


    /**
	 * @param mMatrix:
	 *            model matrix the current catalogue is associated to (e.g. HiPS
	 *            matrix)
	 */
    
    draw(mMatrix, fovObj){
				
		if (this._thetaArray.length == 0) {
			return;
		}
        this.refresh(fovObj);

        this.enableShader(mMatrix);
    
        // TODO change to drawElements with GL_PRIMITIVE
        for (var i = 0; i < this._phiArray.length; i++){
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.ARRAY_BUFFER, this._phiVertexPositionBuffer);
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.ARRAY_BUFFER, this._phiArray[i], _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.STATIC_DRAW);
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.vertexAttribPointer(this._attribLocations.position, 3, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FLOAT, false, 0, 0);
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.enableVertexAttribArray(this._attribLocations.position);

            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.drawArrays(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.LINE_LOOP, 0, 360/this._phiStep);
		}

        // TODO change to drawElements with GL_PRIMITIVE
        for (var j = 0; j < this._thetaArray.length; j++){
		
			_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.ARRAY_BUFFER, this._thetaVertexPositionBuffer);
			_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.ARRAY_BUFFER, this._thetaArray[j], _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.STATIC_DRAW);
			_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.vertexAttribPointer(this._attribLocations.position, 3, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FLOAT, false, 0, 0);
			_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.enableVertexAttribArray(this._attribLocations.position);

			_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.drawArrays(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.LINE_LOOP, 0, 360/this._thetaStep);
			
		}


        let center = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_6__["default"].getCenterJ2000(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.canvas);
        let mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
        mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.multiply(mvMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].camera.getCameraMatrix(), mMatrix);
        let mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
        mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.multiply(mvpMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].pMatrix, mvMatrix);


        

        for (const [radegkey, points] of this._dec4Labels.entries()) {
            if (Math.abs(radegkey - center._raDeg) <= this._phiStep ) {
                
                for (let p = 0; p < points.length; p++) {
                
                    let phiPoint = [points[p][0], points[p][1], points[p][2], 1]; // ref point for the label
                    let point = new _utils_Point_js__WEBPACK_IMPORTED_MODULE_4__["default"]({"x": points[p][0], "y": points[p][1], "z": points[p][2]}, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CARTESIAN);
                
                    
                    
                    // position the div
                    let decDeg = point._decDeg;
                    if (Math.abs(decDeg - center._decDeg) < 60 ) {
                        // https://webglfundamentals.org/webgl/lessons/webgl-text-html.html
                        let clipspace = gl_matrix__WEBPACK_IMPORTED_MODULE_10__.create();
                        gl_matrix__WEBPACK_IMPORTED_MODULE_10__.transformMat4(clipspace, phiPoint, mvpMatrix);

                        // divide X and Y by W just like the GPU does.
                        clipspace[0] /= clipspace[3];
                        clipspace[1] /= clipspace[3];

                        // convert from clipspace to pixels
                        let pixelX = (clipspace[0] *  0.5 + 0.5) * _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.canvas.width;
                        let pixelY = (clipspace[1] * -0.5 + 0.5) * _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.canvas.height;
                        _GridTextHelper_js__WEBPACK_IMPORTED_MODULE_8__.gridTextHelper.addEqDivSet(decDeg.toFixed(2), pixelX, pixelY, 'dec');
                    }
                    
                        
                }

            }

        }
        
        for (const [decdegkey, points] of this._ra4Labels.entries()) {
            if (Math.abs(decdegkey - center._decDeg) <= this._thetaStep ) {
                
                for (let p = 0; p < points.length; p++) {
                
                    let phiPoint = [points[p][0], points[p][1], points[p][2], 1]; // ref point for the label
                    let point = new _utils_Point_js__WEBPACK_IMPORTED_MODULE_4__["default"]({"x": points[p][0], "y": points[p][1], "z": points[p][2]}, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CARTESIAN);
                
                    let d = this.vectorDistance(point, center);
                    
                    // // position the div
                    let raDeg = point._raDeg;

                    if (d < (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_2__.degToRad)(50)) {
                        // https://webglfundamentals.org/webgl/lessons/webgl-text-html.html
                        let clipspace = gl_matrix__WEBPACK_IMPORTED_MODULE_10__.create();
                        gl_matrix__WEBPACK_IMPORTED_MODULE_10__.transformMat4(clipspace, phiPoint, mvpMatrix);

                        // divide X and Y by W just like the GPU does.
                        clipspace[0] /= clipspace[3];
                        clipspace[1] /= clipspace[3];

                        // convert from clipspace to pixels
                        let pixelX = (clipspace[0] *  0.5 + 0.5) * _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.canvas.width;
                        let pixelY = (clipspace[1] * -0.5 + 0.5) * _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.canvas.height;
                        
                        _GridTextHelper_js__WEBPACK_IMPORTED_MODULE_8__.gridTextHelper.addEqDivSet(raDeg.toFixed(2), pixelX, pixelY, 'ra');
                    }
                        
                }

            }

        }
        
        _GridTextHelper_js__WEBPACK_IMPORTED_MODULE_8__.gridTextHelper.resetDivSets();
        


		

		// var ext = global.gl.getExtension('OES_element_index_uint');
		// global.gl.drawElements (global.gl.LINE_LOOP, this._vertexCataloguePosition.length / 3 + this._nPrimitiveFlags, global.gl.UNSIGNED_INT, 0);
		
		
		_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.ELEMENT_ARRAY_BUFFER, null);
		
		
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EquatorialGrid);

/***/ }),

/***/ "./src/js/model/grids/GridTextHelper.js":
/*!**********************************************!*\
  !*** ./src/js/model/grids/GridTextHelper.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gridTextHelper: () => (/* binding */ gridTextHelper)
/* harmony export */ });
/**
 * @author Fabrizio Giordano (Fab)
 * @param in_radius - number
 * @param in_gl - GL context
 * @param in_position - array of double e.g. [0.0, 0.0, 0.0]
 */


class GridTextHelper {


    _divEqContainerElement;
    _divHPXContainerElement;
    _divSets;
    _divSetNdx;

    constructor() {
        this._divEqContainerElement = document.querySelector("#gridcoords");
        this._divHPXContainerElement = document.querySelector("#gridhpx");
        this._divSetNdx = 0;
        this._divSets = [];
    }

    initHtml() {
        // this._divContainerElement = document.querySelector("#gridcoords");
        // this._divSetNdx = 0;
        // this._divSets = [];

    }

    resetDivSets() {
        // mark the remaining divs to not be displayed
        for (; this._divSetNdx < this._divSets.length; ++this._divSetNdx) {
            this._divSets[this._divSetNdx].style.display = "none";
        }
        this._divSetNdx = 0;
    }


    /**
     * 
     * @param {*} msg 
     * @param {*} x 
     * @param {*} y 
     */
    addHPXDivSet(msg, x, y) {
        // get the next div
        let divSet = this._divSets[this._divSetNdx++];

        // If it doesn't exist make a new one
        if (!divSet) {
            divSet = {};
            divSet.div = document.createElement("div");
            divSet.textNode = document.createTextNode("");
            divSet.style = divSet.div.style;

            
            divSet.div.className = "floating-div-ra";
            

            // add the text node to the div
            divSet.div.appendChild(divSet.textNode);

            // add the div to the container
            if (!this._divHPXContainerElement) {
                this._divHPXContainerElement = document.querySelector("#gridhpx");
            }
            this._divHPXContainerElement.appendChild(divSet.div);


            // Add it to the set
            this._divSets.push(divSet);
        }

        // make it display
        divSet.style.display = "block";
        
        divSet.style.left = Math.floor(x + 25) + "px";
        divSet.style.top = Math.floor(y) + "px";
        

        divSet.textNode.nodeValue = msg;
    }
    /**
     * 
     * @param {*} msg 
     * @param {*} x 
     * @param {*} y 
     * @param {String} type : ra or dec
     */
    addEqDivSet(msg, x, y, type) {
        // get the next div
        let divSet = this._divSets[this._divSetNdx++];

        // If it doesn't exist make a new one
        if (!divSet) {
            divSet = {};
            divSet.div = document.createElement("div");
            divSet.textNode = document.createTextNode("");
            divSet.style = divSet.div.style;

            if (type == 'ra') {
                divSet.div.className = "floating-div-ra";
            } else {
                divSet.div.className = "floating-div-dec";
            }


            // add the text node to the div
            divSet.div.appendChild(divSet.textNode);

            // add the div to the container
            if (!this._divEqContainerElement) {
                this._divEqContainerElement = document.querySelector("#gridcoords");
            }
            this._divEqContainerElement.appendChild(divSet.div);

            // Add it to the set
            this._divSets.push(divSet);
        }

        // make it display
        divSet.style.display = "block";
        if (type == 'ra') {
            divSet.style.left = Math.floor(x + 25) + "px";
            divSet.style.top = Math.floor(y) + "px";
        } else {
            divSet.style.left = Math.floor(x) + "px";
            divSet.style.top = Math.floor(y + 25) + "px";
        }


        divSet.textNode.nodeValue = msg;
    }

}


const gridTextHelper = new GridTextHelper();

/***/ }),

/***/ "./src/js/model/grids/HealpixGrid.js":
/*!*******************************************!*\
  !*** ./src/js/model/grids/HealpixGrid.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony import */ var _AbstractSkyEntity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AbstractSkyEntity.js */ "./src/js/model/AbstractSkyEntity.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _hipsnew_FoVHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hipsnew/FoVHelper.js */ "./src/js/model/hipsnew/FoVHelper.js");
/* harmony import */ var _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/FoVUtils.js */ "./src/js/utils/FoVUtils.js");
/* harmony import */ var _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/CoordsType.js */ "./src/js/utils/CoordsType.js");
/* harmony import */ var _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/RayPickingUtils.js */ "./src/js/utils/RayPickingUtils.js");
/* harmony import */ var _utils_Point_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils/Point.js */ "./src/js/utils/Point.js");
/* harmony import */ var _shaders_GridShaderManager_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../shaders/GridShaderManager.js */ "./src/js/shaders/GridShaderManager.js");
/* harmony import */ var _utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils/GeomUtils.js */ "./src/js/utils/GeomUtils.js");
/* harmony import */ var _GridTextHelper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./GridTextHelper.js */ "./src/js/model/grids/GridTextHelper.js");
/* harmony import */ var _hipsnew_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../hipsnew/VisibleTilesManager.js */ "./src/js/model/hipsnew/VisibleTilesManager.js");
















// import { visibleTilesManager } from './VisibleTilesManager.js';




class HealpixGrid extends _AbstractSkyEntity_js__WEBPACK_IMPORTED_MODULE_1__["default"]{

	static ELEM_SIZE;
	static BYTES_X_ELEM;
	_refreshingBuffers;

    constructor(radius, position, xrad, yrad, fov) {

		super(radius, position, xrad, yrad, "healpix-grid", false);

		HealpixGrid.ELEM_SIZE = 3;
		HealpixGrid.BYTES_X_ELEM = new Float32Array().BYTES_PER_ELEMENT;

		this._viewmatrix = undefined;

		
		this._shaderProgram = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createProgram();
		this.initShaders();
		// this._tileBuffer = new GridTilesBuffer(this._descriptor, this._format, this.shaderProgram, this.samplerIdx, this);
		// let fov = 180; // <== TODO this must be a constructor parameter

		let order = _hipsnew_FoVHelper_js__WEBPACK_IMPORTED_MODULE_3__.fovHelper.getHiPSNorder(fov);
		this._visibleorder = order;
		this._oldorder = order;

		// if (order > this._maxorder) {
		// 	order = this._maxorder
		// }

		// this._visiblePixels = this.computeVisiblePixels(order);


		this._attribLocations = {};
		this._nPrimitiveFlags = 0;
		this._totPoints = 0;
		
		this._refreshingBuffers = false
		
		this._vertexCataloguePositionBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
		this._indexBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
		
		this._vertexCataloguePosition = [];
		
		this._oldMouseCoords = null;
		
		this._attribLocations = {
				position: 0,
				selected: 1,
				pointSize: 2,
				color: [0.0, 1.0, 0.0, 1.0]
		};

		// this.initBuffers();
		// this.updateTiles(pixelByOrder.pixels, pixelByOrder.order);

	}



	initShaders() {

		let fragmentShaderStr = _shaders_GridShaderManager_js__WEBPACK_IMPORTED_MODULE_8__["default"].healpixGridFS();
		this.fragmentShader = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FRAGMENT_SHADER);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.shaderSource(this.fragmentShader, fragmentShaderStr);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.compileShader(this.fragmentShader);
		if (!_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getShaderParameter(this.fragmentShader, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.COMPILE_STATUS)) {
			alert(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getShaderInfoLog(this.fragmentShader));
			return null;
		}

		let vertexShaderStr = _shaders_GridShaderManager_js__WEBPACK_IMPORTED_MODULE_8__["default"].healpixGridVS();
		this.vertexShader = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.VERTEX_SHADER);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.shaderSource(this.vertexShader, vertexShaderStr);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.compileShader(this.vertexShader);
		if (!_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getShaderParameter(this.vertexShader, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.COMPILE_STATUS)) {
			alert(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getShaderInfoLog(this.vertexShader));
			return null;
		}

		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.attachShader(this._shaderProgram, this.vertexShader);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.attachShader(this._shaderProgram, this.fragmentShader);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.linkProgram(this._shaderProgram);

		if (!_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getProgramParameter(this._shaderProgram, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.useProgram(this._shaderProgram);

	}

	initBuffersBK () {
		this._nPrimitiveFlags = 0;
		this._refreshingBuffers = true;
		let pixels = this._visiblePixels.pixels;
		let order = this._visiblePixels.order;
		// let healpix = new Healpix(Math.pow(2, order));

		let positionIndex = 0;
		let vIdx = 0;
		let R = 1.0;
		
		let MAX_UNSIGNED_SHORT = 0xFFFFFFFF;

		
		/**
		 * https://stackoverflow.com/questions/33442043/projecting-an-arc-through-two-points-about-a-sphere
		float d;
		Vector3 P0, P1;

		float r = norm(P0);
		float angle = d / r;
		Vector3 axis = crossProduct(P0, P1);
		Matrix3 rotationMatrix = RotationMatrix(angle, axis);
		Vector3 endPoint = rotationMatrix * P0;
		*/


		// TODO remove common points between pixels
		let d = 0.1;
		let angle;
		let nSegs = 12;
		this._pointsXseg = nSegs - 1;
		let pointsXpix = this._pointsXseg * 4;

		this._indexes = new Uint32Array( (3 * 4 * pointsXpix + 1) * pixels.length );
		this._vertexCataloguePosition = new Float32Array( 3 * 4 * pointsXpix * pixels.length);
		
		for (let p = 0; p < pixels.length; p++) {
			let vecs = this._healpix.getBoundaries(pixels[p]);

			for (let v = 0; v < vecs.length; v++) {

				let p0 = vecs[v];
				let v0 = gl_matrix__WEBPACK_IMPORTED_MODULE_12__.fromValues(p0.x, p0.y, p0.z);
				let p1, v1;

				if (v == vecs.length - 1) {
					p1 = vecs[0];
					v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_12__.fromValues(p1.x, p1.y, p1.z);	
				} else {
					p1 = vecs[v+1];
					v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_12__.fromValues(p1.x, p1.y, p1.z);
				}

				let cross = gl_matrix__WEBPACK_IMPORTED_MODULE_12__.create();
				gl_matrix__WEBPACK_IMPORTED_MODULE_12__.cross(cross, v0, v1);
				
				let normcross_tmp = gl_matrix__WEBPACK_IMPORTED_MODULE_12__.create();
				gl_matrix__WEBPACK_IMPORTED_MODULE_12__.normalize(normcross_tmp, cross);
				let normcross = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Vec3(normcross_tmp[0], normcross_tmp[1], normcross_tmp[2]);

				let rot = gl_matrix__WEBPACK_IMPORTED_MODULE_13__.create();
				


				let distP0P1 = Math.sqrt( (p0.x-p1.x)**2 + (p0.y-p1.y)**2 + (p0.z-p1.z)**2 );
				

				
				let step = distP0P1/nSegs;

				this._vertexCataloguePosition[positionIndex] = R * p0.x;
				this._vertexCataloguePosition[positionIndex+1] = R * p0.y;
				this._vertexCataloguePosition[positionIndex+2] = R * p0.z;
				
				this._indexes[vIdx] = Math.floor(positionIndex/3);

				vIdx += 1;
				positionIndex += 3;

				for (let s = nSegs - 1; s > 0; s--){
				// for (let s = 1; s < nSegs; s++){
					angle = (s*step)/this.radius;
					rot[0] = Math.cos(angle) + normcross.x**2 * (1 - Math.cos(angle));
					rot[1] = normcross.x * normcross.y * (1 - Math.cos(angle)) - normcross.z * Math.sin(angle);
					rot[2] = normcross.x * normcross.z * (1 - Math.cos(angle)) + normcross.y * Math.sin(angle);

					rot[3] = normcross.x * normcross.y * (1 - Math.cos(angle)) + normcross.z * Math.sin(angle);
					rot[4] = Math.cos(angle) + normcross.y**2 * (1 - Math.cos(angle));
					rot[5] = normcross.y * normcross.z * (1 - Math.cos(angle)) - normcross.x * Math.sin(angle);

					rot[6] = normcross.x * normcross.z * (1 - Math.cos(angle)) - normcross.y * Math.sin(angle);
					rot[7] = normcross.y * normcross.z * (1 - Math.cos(angle)) + normcross.x * Math.sin(angle);
					rot[8] = Math.cos(angle) + normcross.z**2 * (1 - Math.cos(angle));
					
					let endPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_12__.create();
					gl_matrix__WEBPACK_IMPORTED_MODULE_12__.transformMat3(endPoint, v1, rot);

					this._vertexCataloguePosition[positionIndex] = R * endPoint[0];
					this._vertexCataloguePosition[positionIndex+1] = R * endPoint[1];
					this._vertexCataloguePosition[positionIndex+2] = R * endPoint[2];

					this._indexes[vIdx] = Math.floor(positionIndex/3);
				
					vIdx += 1;
					positionIndex += 3;
				}

				this._vertexCataloguePosition[positionIndex] = R * p1.x;
				this._vertexCataloguePosition[positionIndex+1] = R * p1.y;
				this._vertexCataloguePosition[positionIndex+2] = R * p1.z;

				this._indexes[vIdx] = Math.floor(positionIndex/3);

				vIdx += 1;
				positionIndex += 3;

			}

			this._indexes[vIdx] = MAX_UNSIGNED_SHORT;
			this._nPrimitiveFlags += 1;
			vIdx += 1;

		}
			

		// this._indexes = new Uint32Array( 5*pixels.length );
		// this._vertexCataloguePosition = new Float32Array( 3 * 4 * pixels.length);
		
		// for (let p = 0; p < pixels.length; p++) {
		// 	let vecs = healpix.getBoundaries(pixels[p]);

		// 	for (let v = 0; v < vecs.length; v++) {

		// 		this._vertexCataloguePosition[positionIndex] = R * vecs[v].x;
		// 		this._vertexCataloguePosition[positionIndex+1] = R * vecs[v].y;
		// 		this._vertexCataloguePosition[positionIndex+2] = R * vecs[v].z;
								
		// 		this._indexes[vIdx] = Math.floor(positionIndex/3);
				
		// 		vIdx += 1;
		// 		positionIndex += 3;

		// 	}
		// 	this._indexes[vIdx] = MAX_UNSIGNED_SHORT;
		// 	this._nPrimitiveFlags += 1;
		// 	vIdx += 1;

		// }

		this._refreshingBuffers = false;
		
	}

	initBuffers (pixels, order) {
		this._nPrimitiveFlags = 0;
		this._refreshingBuffers = true;
		// let pixels = this._visiblePixels.pixels;
		// let order = this._visiblePixels.order;

		// let healpix = new Healpix(Math.pow(2, order));
		let healpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(order);

		let positionIndex = 0;
		let vIdx = 0;
		let R = 1.0;
		
		let MAX_UNSIGNED_SHORT = 0xFFFFFFFF;

		
		/**
		 * https://stackoverflow.com/questions/33442043/projecting-an-arc-through-two-points-about-a-sphere
		float d;
		Vector3 P0, P1;

		float r = norm(P0);
		float angle = d / r;
		Vector3 axis = crossProduct(P0, P1);
		Matrix3 rotationMatrix = RotationMatrix(angle, axis);
		Vector3 endPoint = rotationMatrix * P0;
		*/


		// TODO remove common points between pixels
		this._indexes = new Uint32Array( 17*pixels.length );
		this._vertexCataloguePosition = new Float32Array( 3 * 16 * pixels.length);
		
		// let subhpx = new Healpix(Math.pow(2, order+1));
		// let subsubhpx = new Healpix(Math.pow(2, order+2));
		let subhpx = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(order+1);
		let subsubhpx = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(order+2);
		

		for (let p = 0; p < pixels.length; p++) {
			let vecs = healpix.getBoundaries(pixels[p]);

			let cpix0 = pixels[p] << 2;
			let cpix1 = cpix0 + 1;
			let cpix2 = cpix0 + 2;
			let cpix3 = cpix0 + 3;
			let cp0vecs = subhpx.getBoundaries(cpix0);
			// let cp1vecs = subhpx.getBoundaries(cpix1);
			// let cp2vecs = subhpx.getBoundaries(cpix2);
			let cp3vecs = subhpx.getBoundaries(cpix3);

		
			// v0(3/0)
			this._vertexCataloguePosition[positionIndex] = R * vecs[0].x;
			this._vertexCataloguePosition[positionIndex+1] = R * vecs[0].y;
			this._vertexCataloguePosition[positionIndex+2] = R * vecs[0].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			
			// v1(15/2)
			let subcpix3 = cpix3 << 2;
			let subcpix3_3 = subcpix3 + 3;
			let tmp  = subsubhpx.getBoundaries(subcpix3_3);
			this._vertexCataloguePosition[positionIndex] = R * tmp[1].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[1].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[1].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			
			// v1(3/1)
			this._vertexCataloguePosition[positionIndex] = R * cp3vecs[1].x;
			this._vertexCataloguePosition[positionIndex+1] = R * cp3vecs[1].y;
			this._vertexCataloguePosition[positionIndex+2] = R * cp3vecs[1].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;


			// v0(2/2)
			let subcpix2 = cpix2 << 2;
			let subcpix2_2 = subcpix2 + 2;
			tmp  = subsubhpx.getBoundaries(subcpix2_2);
			this._vertexCataloguePosition[positionIndex] = R * tmp[0].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[0].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[0].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			// v1(0/0)
			this._vertexCataloguePosition[positionIndex] = R * vecs[1].x;
			this._vertexCataloguePosition[positionIndex+1] = R * vecs[1].y;
			this._vertexCataloguePosition[positionIndex+2] = R * vecs[1].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;


			// v2(2/2)
			this._vertexCataloguePosition[positionIndex] = R * tmp[2].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[2].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[2].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			// v1(0/1)
			this._vertexCataloguePosition[positionIndex] = R * cp0vecs[1].x;
			this._vertexCataloguePosition[positionIndex+1] = R * cp0vecs[1].y;
			this._vertexCataloguePosition[positionIndex+2] = R * cp0vecs[1].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			// v1(0/2)
			let subcpix0 = cpix0 << 2;
			let subcpix0_2 = subcpix0;
			tmp  = subsubhpx.getBoundaries(subcpix0_2);
			this._vertexCataloguePosition[positionIndex] = R * tmp[1].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[1].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[1].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			// v2(0/0)
			this._vertexCataloguePosition[positionIndex] = R * vecs[2].x;
			this._vertexCataloguePosition[positionIndex+1] = R * vecs[2].y;
			this._vertexCataloguePosition[positionIndex+2] = R * vecs[2].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			// v3(0/2)
			this._vertexCataloguePosition[positionIndex] = R * tmp[3].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[3].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[3].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;


			// v3(0/1)
			this._vertexCataloguePosition[positionIndex] = R * cp0vecs[3].x;
			this._vertexCataloguePosition[positionIndex+1] = R * cp0vecs[3].y;
			this._vertexCataloguePosition[positionIndex+2] = R * cp0vecs[3].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;


			// v2(5/2)
			let subcpix1 = cpix1 << 2;
			let subcpix1_1 = subcpix1 + 1; 
			tmp  = subsubhpx.getBoundaries(subcpix1_1);
			this._vertexCataloguePosition[positionIndex] = R * tmp[2].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[2].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[2].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			// v3(0/0)
			this._vertexCataloguePosition[positionIndex] = R * vecs[3].x;
			this._vertexCataloguePosition[positionIndex+1] = R * vecs[3].y;
			this._vertexCataloguePosition[positionIndex+2] = R * vecs[3].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;

			// v0(5/2)
			this._vertexCataloguePosition[positionIndex] = R * tmp[0].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[0].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[0].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;


			// v3(3/1)
			this._vertexCataloguePosition[positionIndex] = R * cp3vecs[3].x;
			this._vertexCataloguePosition[positionIndex+1] = R * cp3vecs[3].y;
			this._vertexCataloguePosition[positionIndex+2] = R * cp3vecs[3].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;


			tmp  = subsubhpx.getBoundaries(subcpix3_3);
			this._vertexCataloguePosition[positionIndex] = R * tmp[3].x;
			this._vertexCataloguePosition[positionIndex+1] = R * tmp[3].y;
			this._vertexCataloguePosition[positionIndex+2] = R * tmp[3].z;				
			this._indexes[vIdx] = Math.floor(positionIndex/3);
			vIdx += 1;
			positionIndex += 3;



			this._indexes[vIdx] = MAX_UNSIGNED_SHORT;
			this._nPrimitiveFlags += 1;
			vIdx += 1;

		}

		this._refreshingBuffers = false;
		
	}

	// TODO this is in common with HiPS4.js. to be moved elsewhere
	computeVisiblePixels(order, fov) {

		// this._healpix = new Healpix(Math.pow(2, order));
		this._healpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(order);
		let pixels = [];
		
		if (order == 0) {
			let npix = this._healpix.getNPix();
			pixels = [npix];
			pixels.splice(0, npix);
			for (let i = 0; i < npix; i++) {
				pixels.push(i);
			}
		} else {



			let maxX = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.canvas.width;
			let maxY = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.canvas.height;

			let xy = [];
			let neighbours = [];
			let intersectionWithModel;
			let intersectionPoint = null;
			let currP, currPixNo;

			// TODO probably it would be better to use query_disc_inclusive from HEALPix 
			// against a polygon. Check my FHIPSWebGL2 project (BufferManager.js -> updateVisiblePixels)
			// intersectionWithModel = RayPickingUtils.getIntersectionPointWithSingleModel(maxX/2, maxY/2, this);
			// let vec3 = new Vec3(intersectionWithModel.intersectionPoint[0], intersectionWithModel.intersectionPoint[1], intersectionWithModel.intersectionPoint[2]);
			// let ptg = new Pointing(vec3);
			// let pxs = geomhealpix.queryDiscInclusive(ptg, fov * Math.PI/180, 4);
			// for (let p =0; p < pxs.r.length; p++) {
			//     if (pixels.indexOf(pxs.r[p]) == -1){
			//         if(pxs.r[p] >= 0){
			//             pixels.push(pxs.r[p]);	
			//         }
			//     }
			// }

			var i = 0;
			for (i = 0; i <= maxX; i += maxX / 10) {
				var j = 0;
				for (j = 0; j <= maxY; j += maxY / 10) {

					intersectionWithModel = {
						"intersectionPoint": null,
						"pickedObject": null
					};

					xy = [i, j];


					intersectionWithModel = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_6__["default"].getIntersectionPointWithSingleModel(xy[0], xy[1], this);
					intersectionPoint = intersectionWithModel.intersectionPoint;

					if (intersectionPoint.length > 0) {
						currP = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Vec3(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2]));


						
						currPixNo = this._healpix.ang2pix(currP);
						if (currPixNo >= 0) {
							neighbours = this._healpix.neighbours(currPixNo);
							if (pixels.indexOf(currPixNo) == -1) {
								pixels.push(currPixNo);
							}
							var k = 0;
							for (k = 0; k < neighbours.length; k++) {
								if (pixels.indexOf(neighbours[k]) == -1) {
									if (neighbours[k] >= 0) {
										pixels.push(neighbours[k]);
									}
								}
							}
						}
					}
				}
			}
		}


		return {
			"pixels": pixels,
			"order": order
		};

	}

	updateTiles(pixels, order) {
		let tiles = this._tileBuffer.updateTiles(pixels, order);
		return tiles;
	}


	refresh(pMatrix) {

		this._oldorder = this._visibleorder;

		this.refreshFoV(false, pMatrix);

		let fov = this.getMinFoV();

		// UPDATING GLOBAL FoV USED BY VISIBLETILEMANAGER. Move it into a method in GLOBAL
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].hipsFoV = fov;
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].order = _hipsnew_FoVHelper_js__WEBPACK_IMPORTED_MODULE_3__.fovHelper.getHiPSNorder(fov);
		
		this._visibleorder = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].order;
		// if (this._visibleorder > this._maxorder) {
		// 	this._visibleorder = this._maxorder
		// }
		// if (this._oldorder != this._visibleorder || cameraRotated) {
			
		// 	this._visiblePixels = this.computeVisiblePixels(this._visibleorder);
		// 	this.initBuffers();
			
		// }

	}

	

	enableShader(in_mMatrix){

		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.useProgram(this._shaderProgram);
		this._shaderProgram.catUniformMVMatrixLoc = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getUniformLocation(this._shaderProgram, "uMVMatrix");
		this._shaderProgram.catUniformProjMatrixLoc = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getUniformLocation(this._shaderProgram, "uPMatrix");
		this._attribLocations.position  = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.getAttribLocation(this._shaderProgram, 'aCatPosition');
		let mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.create();
		mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.multiply(mvMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].camera.getCameraMatrix(), in_mMatrix);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniformMatrix4fv(this._shaderProgram.catUniformMVMatrixLoc, false, mvMatrix);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniformMatrix4fv(this._shaderProgram.catUniformProjMatrixLoc, false, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].pMatrix);

		
		
	}
	

	 draw(mMatrix, cameraRotated, showHPXGrid, pMatrix) {
				
		// if (this._vertexCataloguePosition == undefined || this._vertexCataloguePosition.length == 0) {
		// 	return;
		// }
		// if (this._refreshingBuffers || this._vertexCataloguePosition == undefined || this._vertexCataloguePosition.length == 0) {
		// 	return;
		// }
		
		this.refresh(pMatrix);
		if (!showHPXGrid){
			return;
		}
		const visibleTiles = _hipsnew_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_11__.newVisibleTilesManager.visibleTilesByOrder;
		let pixels = visibleTiles.pixels;
		let order = visibleTiles.order;
		this.initBuffers(pixels, order);

		this.enableShader(mMatrix);
		
		// TODO move this out of the draw method <- ?
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this._vertexCataloguePositionBuffer);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this._vertexCataloguePosition, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);
		
		// setting footprint position
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.vertexAttribPointer(this._attribLocations.position, HealpixGrid.ELEM_SIZE, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FLOAT, false, HealpixGrid.BYTES_X_ELEM * HealpixGrid.ELEM_SIZE, 0);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.enableVertexAttribArray(this._attribLocations.position);
		
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this._indexes, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);
		
		// var ext = global.gl.getExtension('OES_element_index_uint'); // <-- moved into FVPresenter.draw
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.drawElements (_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINE_LOOP, this._vertexCataloguePosition.length / 3 + this._nPrimitiveFlags, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNSIGNED_INT, 0);
		// global.gl.drawElements (global.gl.POINT, this._vertexCataloguePosition.length / 3 + 1, global.gl.UNSIGNED_SHORT, 0);
		
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, null);
		_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, null);
		
        let mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.create();
        mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.multiply(mvMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].camera.getCameraMatrix(), mMatrix);
        let mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.create();
        mvpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_14__.multiply(mvpMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].pMatrix, mvMatrix);

		let center = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_4__["default"].getCenterJ2000(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.canvas);

		
		// let pixels = this._visiblePixels.pixels;
		// let order = this._visiblePixels.order;
		let fovMin = ((this.getMinFoV() * (Math.PI/180.0) ) / 2 );

		for (let p = 0; p < pixels.length; p++) {
			let pixCenter = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].order).pix2vec(pixels[p]);

			let point = new _utils_Point_js__WEBPACK_IMPORTED_MODULE_7__["default"]({"x": pixCenter.x, "y": pixCenter.y, "z": pixCenter.z}, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CARTESIAN);

			let distance = _utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_9__["default"].orthodromicDistance(center, point);
			if (distance < fovMin){
				let vertex = [pixCenter.x, pixCenter.y, pixCenter.z, 1];
				let clipspace = gl_matrix__WEBPACK_IMPORTED_MODULE_15__.create();
				gl_matrix__WEBPACK_IMPORTED_MODULE_15__.transformMat4(clipspace, vertex, mvpMatrix);
	
				// divide X and Y by W just like the GPU does.
				clipspace[0] /= clipspace[3];
				clipspace[1] /= clipspace[3];
	
				// convert from clipspace to pixels
				let pixelX = (clipspace[0] *  0.5 + 0.5) * _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.canvas.width;
				let pixelY = (clipspace[1] * -0.5 + 0.5) * _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.canvas.height;
	
				
				_GridTextHelper_js__WEBPACK_IMPORTED_MODULE_10__.gridTextHelper.addHPXDivSet(this._visibleorder+"/"+pixels[p], pixelX, pixelY);
			}


			
		}
		


		_GridTextHelper_js__WEBPACK_IMPORTED_MODULE_10__.gridTextHelper.resetDivSets();
		
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HealpixGrid);

/***/ }),

/***/ "./src/js/model/hipsnew/AllSky7.js":
/*!*****************************************!*\
  !*** ./src/js/model/hipsnew/AllSky7.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shaders/HiPSShaderProgram.js */ "./src/js/shaders/HiPSShaderProgram.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _TileBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileBuffer.js */ "./src/js/model/hipsnew/TileBuffer.js");
/* harmony import */ var canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! canvas */ "./node_modules/canvas/browser.js");
/* harmony import */ var _AllSkyTile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AllSkyTile.js */ "./src/js/model/hipsnew/AllSkyTile.js");





// import { Xyf } from 'healpixjs';

const { createCanvas } = canvas__WEBPACK_IMPORTED_MODULE_3__;


class AllSky {

	constructor(hips) {

		this._ready = false;
		this._hips = hips;

		this._format = hips.format;
		this._baseurl = hips.baseURL;
		this._maxorder = hips.maxOrder;
		this._minorder = hips.minOrder;
		this._isGalacticHips = hips.isGalacticHips;

		// this._order = order;
		// this._hipsRefOrder = global.HIPS_REF_ORDER; // used for geometry and texture mapping
		this._hipsTextureOrder = 3; // AllSky is a map of order 3 tiles

		this.opacity = 1.00;

		this._hipsShaderIndex = 0;
		this._pixels = [];

		this._texture = undefined;

		this.initImage();

	}

	initImage() {

		this._image = new Image();

		this._texurl = this._baseurl + "/Norder3/Allsky." + this._format;

		this._image.onload = () => {
			this.imageLoaded();

		};
		this._image.onerror = () => {
			console.error("File not found? {}", this._texurl)
		};

		this._image.setAttribute('crossorigin', 'anonymous');
		this._image.src = this._texurl;

	}

	imageLoaded() {

		this.texturesArray = this.splitImage()
		
		this.allSkyTiles = new Array(768)

		for (let p=0; p<768; p++){
			let tile = new _AllSkyTile_js__WEBPACK_IMPORTED_MODULE_4__["default"](p, 3, this._hips, this.texturesArray[p])
			this.allSkyTiles[p] = tile
			
		}
		this._textureLoaded = true
		this._ready = true

	}

	splitImage() {
		let textures = []
		
		const imgW = this._image.width;
		const imgH = this._image.height;
		let c = createCanvas(imgW, imgH)
		const ctx = c.getContext("2d")
		// ctx.createImageData(c.width, c.height);
		ctx.drawImage(this._image, 0, 0, imgW, imgH);
		
		const tileCountX = 27
		const tileCountY = 29
		
		const tilePxSize = this._image.width / tileCountX
		
		let tileno=0
		for (let row=0; row < tileCountY; row++) {
			for (let col=0; col < tileCountX; col++) {
				
				// const imgData = ctx.getImageData(col * 64 , row * 64, 64, 64).data
				// textures.push(new ImageData(imgData, 64, 64))
				const imgData = ctx.getImageData(col * tilePxSize , row * tilePxSize, tilePxSize, tilePxSize).data
				textures.push(new ImageData(imgData, tilePxSize, tilePxSize))
				tileno++
				if (tileno == 768) break
			}
		}
		
		// textures.forEach( t => {
		// 	const ctx2 = c.getContext("2d")
		// 	ctx2.putImageData(t, 0, 0);
		// 	const image = new Image();
		// 	image.src = c.toDataURL();
		// 	// console.log(image.src)
		// })


		return textures
	}

	



	draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx) {
		if (!this._ready) {
			return false;
		}
		let allSkyTiles2Skip = []
		if (visibleOrder >= this._hipsTextureOrder) {
			allSkyTiles2Skip = this.drawChildren(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx)
		} 
		// else {
			_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__.hipsShaderProgram.enableShaders(pMatrix, vMatrix, mMatrix, colorMapIdx);
			// TODO check if the enable below can be moved into hipsShaderProgram.enableShaders
			_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.enableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__.hipsShaderProgram.locations.vertexPositionAttribute);
			_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.enableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__.hipsShaderProgram.locations.textureCoordAttribute);
			for (let t = 0; t < 768; t++) {
				if (!allSkyTiles2Skip.includes(t)) {
					this.allSkyTiles[t].draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx)
				}
					
			}
			_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.disableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__.hipsShaderProgram.locations.vertexPositionAttribute);
        	_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.disableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__.hipsShaderProgram.locations.textureCoordAttribute);
		// }

		
	}


	drawChildren(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx) {

		let childrenOrder = this._hipsTextureOrder;
		if (!visibleTilesMap.has(childrenOrder)) {
			return;
		}
		
		let visibleTiles = visibleTilesMap.get(childrenOrder);
		let allSkyTiles2Skip = []
		for (let t = 0; t < visibleTiles.length; t++) {
			let childTile = undefined
			if (this._isGalacticHips) {
				childTile = _TileBuffer_js__WEBPACK_IMPORTED_MODULE_2__.newTileBuffer.getGalTile(visibleTiles[t], childrenOrder, this._hips);
			} else {
				childTile = _TileBuffer_js__WEBPACK_IMPORTED_MODULE_2__.newTileBuffer.getTile(visibleTiles[t], childrenOrder, this._hips);
			}

			childTile.draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx);
			if (childTile._ready) {
				allSkyTiles2Skip.push(visibleTiles[t])
			}
		}
		return allSkyTiles2Skip;
	}

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AllSky);

/***/ }),

/***/ "./src/js/model/hipsnew/AllSkyTile.js":
/*!********************************************!*\
  !*** ./src/js/model/hipsnew/AllSkyTile.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var wcslight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wcslight */ "./node_modules/wcslight/lib-esm/index.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shaders/HiPSShaderProgram.js */ "./src/js/shaders/HiPSShaderProgram.js");
/* harmony import */ var _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileBuffer.js */ "./src/js/model/hipsnew/TileBuffer.js");
/* harmony import */ var _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VisibleTilesManager.js */ "./src/js/model/hipsnew/VisibleTilesManager.js");
/* harmony import */ var _FoVHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FoVHelper.js */ "./src/js/model/hipsnew/FoVHelper.js");
/* harmony import */ var _HPXGeometryCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./HPXGeometryCache.js */ "./src/js/model/hipsnew/HPXGeometryCache.js");










class AllSkyTile {

    _hips;
    _tilebuffer;
    _tileno;
    _baseurl;
    _order;

    // constructor(tileno, descriptor, format, order, shaderprogram, tilebuffer, hips, samplerIdx) {
    constructor(tileno, order, hips, image) {

        this._ready = false;
        this._abort = false;

        this._hips = hips;
        this._tileno = tileno;

        this._format = hips.format;
        this._baseurl = hips.baseURL;
        this._maxorder = hips.maxOrder;
        this._minorder = hips.minOrder;
        this._isGalacticHips = hips.isGalacticHips;

        this._order = order;

        this.opacity = 1.00;

        this._hipsShaderIndex = 0; // <== used for multi hips 
        this._pixels = [];

        this._texture = undefined;

        this._cacheTime0 = undefined;

        this._inView = true;

        // setTimeout(() => {
        //     this.amIStillInFoV()
        // }, 1000);
        // this._amIStillInFoV_requsetID = setInterval( () => { this.amIStillInFoV() }, 5000);

        // this.initImage();
        this._image = image
        this.imageLoaded()
    }

    // destroyIntervals(){
    //     clearInterval(this._amIStillInFoV_requsetID);
    // }

    get cacheTime0() {
        return this._cacheTime0
    }

    resetCacheTime0(){
        this._cacheTime0 = undefined
    }

    setCacheTime0(){
        this._cacheTime0 = new Date().getTime()
    }

    // initImage() {

    //     this._image = new Image();
    //     this._downloading = true;
    //     this._imageLoaded = false;

    //     let dirnumber = Math.floor(this._tileno / 10000) * 10000;
    //     this._texurl = this._baseurl + "/Norder";
    //     this._texurl += this._order + "/Dir" + dirnumber + "/Npix" + this._tileno + "." + this._format;

    //     this._image.onload = () => {
    //         this.imageLoaded();

    //     };
    //     this._image.onerror = () => {
    //         console.error("File not found? {}", this._texurl)
    //         this._ready = false;
    //         this._abort = true;
    //     };

    //     this._image.setAttribute('crossorigin', 'anonymous');
    //     this._image.src = this._texurl;
    //     // this.loadImage();

    // }

    imageLoaded() {
        this._imageLoaded = true;
        this._downloading = false;
        
        this.textureLoaded();
        this.initModelBuffer();

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texImage2D(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, 0, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.RGBA, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.RGBA, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNSIGNED_BYTE, this._image);
        // global.gl.generateMipmap(global.gl.TEXTURE_2D);
        this._textureLoaded = true;

        if (this._textureLoaded) {
            this._ready = true;
        }

    }



    textureLoaded() {

        _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.enableProgram();

        this._texture = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createTexture();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.pixelStorei(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNPACK_FLIP_Y_WEBGL, true);
        // global.gl.pixelStorei(global.gl.UNPACK_FLIP_Y_WEBGL, false);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);

        // from WW
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_WRAP_S, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.CLAMP_TO_EDGE);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_WRAP_T, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.CLAMP_TO_EDGE);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_S, global.gl.CLAMP_TO_BORDER);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_T, global.gl.CLAMP_TO_BORDER);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_S, global.gl.CLAMP);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_T, global.gl.CLAMP);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_MIN_FILTER, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINEAR);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_MAG_FILTER, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINEAR);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_MIN_FILTER, global.gl.GL_LINEAR_MIPMAP_LINEAR);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_MAG_FILTER, global.gl.GL_LINEAR);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniform1i(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.shaderProgram.samplerUniform, this._hipsShaderIndex);

        if (!_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.isTexture(this._texture)) {
            console.log("error in texture");
        }

    }

    initModelBuffer() {

        this.vertexPosition = [];
        this.vertexPositionBuffer = [];
        this.vertexIndices = [];
        this.vertexIndexBuffer = [];

        const reforder = 4;

        const orighealpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(this._order)
        const origxyf = orighealpix.nest2xyf(this._tileno);

        const orderjump = reforder - this._order;

        const dxmin = origxyf.ix << orderjump;
        const dxmax = (origxyf.ix << orderjump) + (1 << orderjump);
        const dymin = origxyf.iy << orderjump;
        const dymax = (origxyf.iy << orderjump) + (1 << orderjump);

        const healpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(reforder)

        this._pixels = [];
        this.setupPositionAndTexture4Quadrant2(dxmin, dxmin + (dxmax - dxmin) / 2, dymin, dymin + (dymax - dymin) / 2, 0, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant2(dxmin + (dxmax - dxmin) / 2, dxmax, dymin, dymin + (dymax - dymin) / 2, 1, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant2(dxmin, dxmin + (dxmax - dxmin) / 2, dymin + (dymax - dymin) / 2, dymax, 2, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant2(dxmin + (dxmax - dxmin) / 2, dxmax, dymin + (dymax - dymin) / 2, dymax, 3, healpix, orderjump, origxyf);

        let pixelsXQuadrant = this.vertexPosition[0].length / 20;
        this.vertexIndices = this.computeVertexIndices(pixelsXQuadrant);
        this.vertexIndexBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndices, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);

    }

    computeVertexIndices(pixelsXQuadrant) {
        let vertexIndices = new Uint16Array(6 * pixelsXQuadrant);
        let baseFaceIndex = 0;
        for (let j = 0; j < pixelsXQuadrant; j++) {

            vertexIndices[6 * j] = baseFaceIndex;
            vertexIndices[6 * j + 1] = baseFaceIndex + 1;
            vertexIndices[6 * j + 2] = baseFaceIndex + 2;

            vertexIndices[6 * j + 3] = baseFaceIndex + 2;
            vertexIndices[6 * j + 4] = baseFaceIndex + 3;
            vertexIndices[6 * j + 5] = baseFaceIndex;

            baseFaceIndex = baseFaceIndex + 4;

        }
        return vertexIndices;
    }

    setupPositionAndTexture4Quadrant2(dxmin, dxmax, dymin, dymax, qidx, healpix, orderjump, origxyf) {

        let facesVec3Array = new Array();
        this.vertexPosition[qidx] = new Float32Array(20 * (dxmax - dxmin) * (dymax - dymin));

        let step = 1 / (1 << orderjump);
        let uindex = 0;
        let vindex = 0;
        let p = 0;

        for (let dx = dxmin; dx < dxmax; dx++) {
            for (let dy = dymin; dy < dymax; dy++) {
                
                facesVec3Array = healpix.getPointsForXyfNoStep(dx, dy, origxyf.face);
                uindex = dy - (origxyf.iy << orderjump);
                vindex = dx - (origxyf.ix << orderjump);

                this.vertexPosition[qidx][20 * p] = facesVec3Array[0].x;
                this.vertexPosition[qidx][20 * p + 1] = facesVec3Array[0].y;
                this.vertexPosition[qidx][20 * p + 2] = facesVec3Array[0].z;
                this.vertexPosition[qidx][20 * p + 3] = step + (step * uindex);
                this.vertexPosition[qidx][20 * p + 4] = 1 - (step + step * vindex);

                this.vertexPosition[qidx][20 * p + 5] = facesVec3Array[1].x;
                this.vertexPosition[qidx][20 * p + 6] = facesVec3Array[1].y;
                this.vertexPosition[qidx][20 * p + 7] = facesVec3Array[1].z;
                this.vertexPosition[qidx][20 * p + 8] = step + (step * uindex);
                this.vertexPosition[qidx][20 * p + 9] = 1 - (step * vindex);

                this.vertexPosition[qidx][20 * p + 10] = facesVec3Array[2].x;
                this.vertexPosition[qidx][20 * p + 11] = facesVec3Array[2].y;
                this.vertexPosition[qidx][20 * p + 12] = facesVec3Array[2].z;
                this.vertexPosition[qidx][20 * p + 13] = step * uindex;
                this.vertexPosition[qidx][20 * p + 14] = 1 - (step * vindex);

                this.vertexPosition[qidx][20 * p + 15] = facesVec3Array[3].x;
                this.vertexPosition[qidx][20 * p + 16] = facesVec3Array[3].y;
                this.vertexPosition[qidx][20 * p + 17] = facesVec3Array[3].z;
                this.vertexPosition[qidx][20 * p + 18] = step * uindex;
                this.vertexPosition[qidx][20 * p + 19] = 1 - (step + step * vindex);
                p++;
            }
        }

        this.vertexPositionBuffer[qidx] = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPositionBuffer[qidx]);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPosition[qidx], _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);

    }


    get inView(){
        return this._inView;
    }
    

    draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx) {

        if (!this._ready || this._abort) {
            return;
        }

        let quadrantsToDraw = new Set([0, 1, 2, 3]);
        
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniform1f(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureAlpha, this.opacity);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        let elemno = this.vertexIndices.length;

        quadrantsToDraw.forEach((qidx) => {
            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPositionBuffer[qidx]);

            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.vertexAttribPointer(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.vertexPositionAttribute, 3, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FLOAT, false, 5 * 4, 0);
            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.vertexAttribPointer(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureCoordAttribute, 2, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FLOAT, false, 5 * 4, 3 * 4);

            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.drawElements(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TRIANGLES, elemno, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNSIGNED_SHORT, 0);
        });

        
    }




}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AllSkyTile);

/***/ }),

/***/ "./src/js/model/hipsnew/AncestorTile.js":
/*!**********************************************!*\
  !*** ./src/js/model/hipsnew/AncestorTile.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var wcslight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wcslight */ "./node_modules/wcslight/lib-esm/index.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shaders/HiPSShaderProgram.js */ "./src/js/shaders/HiPSShaderProgram.js");
/* harmony import */ var _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileBuffer.js */ "./src/js/model/hipsnew/TileBuffer.js");
/* harmony import */ var _FoVHelper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FoVHelper.js */ "./src/js/model/hipsnew/FoVHelper.js");








class AncestorTile {

    _hips;
    _tileno;
    _baseurl;
    _order;

    constructor(tileno, order, hips) {

        this._ready = false;
        this._hips = hips;
        this._tileno = tileno;

        this._format = hips.format;
        this._baseurl = hips.baseURL;
        this._maxorder = hips.maxOrder;
        this._minorder = hips.minOrder;

        this._isGalacticHips = hips.isGalacticHips;

        this._order = order;

        this.opacity = 1.00;

        this._hipsShaderIndex = 0;
        this._pixels = [];

        this._texture = undefined;

        this.initImage();
    }

    destroyIntervals(){
        clearInterval(this._amIStillInFoV_requsetID);
    }

    initImage() {

        this._image = new Image();

        let dirnumber = Math.floor(this._tileno / 10000) * 10000;
        this._texurl = this._baseurl + "/Norder";
        this._texurl += this._order + "/Dir" + dirnumber + "/Npix" + this._tileno + "." + this._format;

        this._image.onload = () => {
            this.imageLoaded();

        };
        this._image.onerror = () => {
            console.error("File not found? {}", this._texurl)
        };

        this._image.setAttribute('crossorigin', 'anonymous');
        this._image.src = this._texurl;

    }

    imageLoaded() {

        this.textureLoaded();
        this.initModelBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texImage2D(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, 0, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.RGBA, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.RGBA, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNSIGNED_BYTE, this._image);
        this._textureLoaded = true;
        this._ready = true;

    }



    textureLoaded() {

        _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.enableProgram();

        this._texture = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createTexture();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.pixelStorei(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNPACK_FLIP_Y_WEBGL, true);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);

        // from WW
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_WRAP_S, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.CLAMP_TO_EDGE);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_WRAP_T, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.CLAMP_TO_EDGE);
        
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_S, global.gl.CLAMP_TO_BORDER);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_T, global.gl.CLAMP_TO_BORDER);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_MIN_FILTER, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINEAR);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_MAG_FILTER, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINEAR);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniform1i(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.shaderProgram.samplerUniform, this._hipsShaderIndex);

        if (!_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.isTexture(this._texture)) {
            console.log("error in texture");
        }

    }

    initModelBuffer() {

        this.vertexPosition = [];
        this.vertexPositionBuffer = [];
        this.vertexIndices = [];
        this.vertexIndexBuffer = [];

        let reforder = _FoVHelper_js__WEBPACK_IMPORTED_MODULE_5__.fovHelper.getRefOrder(this._order);

        let orighealpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(this._order)
        // let orighealpix = new Healpix(2 ** this._order);
        let origxyf = orighealpix.nest2xyf(this._tileno);

        let orderjump = reforder - this._order;

        // let dxmin = origxyf.ix * Math.pow(2, orderjump);
        // let dxmax = (origxyf.ix * Math.pow(2, orderjump)) + Math.pow(2, orderjump);
        // let dymin = origxyf.iy * Math.pow(2, orderjump);
        // let dymax = (origxyf.iy * Math.pow(2, orderjump)) + Math.pow(2, orderjump);

        let dxmin = origxyf.ix << orderjump;
        let dxmax = (origxyf.ix << orderjump) + (1 << orderjump);
        let dymin = origxyf.iy << orderjump;
        let dymax = (origxyf.iy << orderjump) + (1 << orderjump);

        let healpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(reforder)
        // let healpix = new Healpix(2 ** reforder);

        this._pixels = [];
        // this.setupPositionAndTexture4Quadrant2(dxmin, dxmax / 2, dymin, dymax / 2, 0, healpix, orderjump, origxyf);
        // this.setupPositionAndTexture4Quadrant2(dxmax / 2, dxmax, dymin, dymax / 2, 1, healpix, orderjump, origxyf);
        // this.setupPositionAndTexture4Quadrant2(dxmin, dxmax / 2, dymax / 2, dymax, 2, healpix, orderjump, origxyf);
        // this.setupPositionAndTexture4Quadrant2(dxmax / 2, dxmax, dymax / 2, dymax, 3, healpix, orderjump, origxyf);

        this.setupPositionAndTexture4Quadrant(dxmin, dxmax / 2, dymin, dymax / 2, 0, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant(dxmax / 2, dxmax, dymin, dymax / 2, 1, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant(dxmin, dxmax / 2, dymax / 2, dymax, 2, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant(dxmax / 2, dxmax, dymax / 2, dymax, 3, healpix, orderjump, origxyf);

        // let pixelsXQuadrant = this._pixels.length / 4;
        let pixelsXQuadrant = this.vertexPosition[0].length / 20;
        this.vertexIndices = this.computeVertexIndices(pixelsXQuadrant);
        this.vertexIndexBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndices, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);

        // global.gl.activeTexture(global.gl.TEXTURE0 + this._hipsShaderIndex);
        // global.gl.bindTexture(global.gl.TEXTURE_2D, this._texture);
        // global.gl.texImage2D(global.gl.TEXTURE_2D, 0, global.gl.RGBA, global.gl.RGBA, global.gl.UNSIGNED_BYTE, this._image);
        // this._textureLoaded = true;

    }



    computeVertexIndices(pixelsXQuadrant) {
        let vertexIndices = new Uint16Array(6 * pixelsXQuadrant);
        let baseFaceIndex = 0;
        for (let j = 0; j < pixelsXQuadrant; j++) {

            vertexIndices[6 * j] = baseFaceIndex;
            vertexIndices[6 * j + 1] = baseFaceIndex + 1;
            vertexIndices[6 * j + 2] = baseFaceIndex + 2;

            vertexIndices[6 * j + 3] = baseFaceIndex + 2;
            vertexIndices[6 * j + 4] = baseFaceIndex + 3;
            vertexIndices[6 * j + 5] = baseFaceIndex;

            baseFaceIndex = baseFaceIndex + 4;

        }
        return vertexIndices;
    }

    setupPositionAndTexture4Quadrant2(dxmin, dxmax, dymin, dymax, qidx, healpix, orderjump, origxyf) {

        let facesVec3Array = new Array();
        this.vertexPosition[qidx] = new Float32Array(20 * (dxmax - dxmin) * (dymax - dymin));

        let step = 1 / (1 << orderjump);
        let uindex = 0;
        let vindex = 0;
        let p = 0;

        for (let dx = dxmin; dx < dxmax; dx++) {
            for (let dy = dymin; dy < dymax; dy++) {
                // let ipix3 = healpix.xyf2nest(dx, dy, origxyf.face);
                // this._pixels.push(ipix3);
                // facesVec3Array = healpix.getBoundaries(ipix3)

                facesVec3Array = healpix.getPointsForXyfNoStep(dx, dy, origxyf.face);
                // let xyf = healpix.nest2xyf(ipix3);
                // uindex = xyf.iy - origxyf.iy * Math.pow(2, orderjump);
                // vindex = xyf.ix - origxyf.ix * Math.pow(2, orderjump);
                uindex = dy - (origxyf.iy << orderjump);
                vindex = dx - (origxyf.ix << orderjump);

                // uindex = xyf.iy - (origxyf.iy << orderjump);
                // vindex = xyf.ix - (origxyf.ix << orderjump);

                this.vertexPosition[qidx][20 * p] = facesVec3Array[0].x;
                this.vertexPosition[qidx][20 * p + 1] = facesVec3Array[0].y;
                this.vertexPosition[qidx][20 * p + 2] = facesVec3Array[0].z;
                this.vertexPosition[qidx][20 * p + 3] = step + (step * uindex);
                this.vertexPosition[qidx][20 * p + 4] = 1 - (step + step * vindex);

                this.vertexPosition[qidx][20 * p + 5] = facesVec3Array[1].x;
                this.vertexPosition[qidx][20 * p + 6] = facesVec3Array[1].y;
                this.vertexPosition[qidx][20 * p + 7] = facesVec3Array[1].z;
                this.vertexPosition[qidx][20 * p + 8] = step + (step * uindex);
                this.vertexPosition[qidx][20 * p + 9] = 1 - (step * vindex);

                this.vertexPosition[qidx][20 * p + 10] = facesVec3Array[2].x;
                this.vertexPosition[qidx][20 * p + 11] = facesVec3Array[2].y;
                this.vertexPosition[qidx][20 * p + 12] = facesVec3Array[2].z;
                this.vertexPosition[qidx][20 * p + 13] = step * uindex;
                this.vertexPosition[qidx][20 * p + 14] = 1 - (step * vindex);

                this.vertexPosition[qidx][20 * p + 15] = facesVec3Array[3].x;
                this.vertexPosition[qidx][20 * p + 16] = facesVec3Array[3].y;
                this.vertexPosition[qidx][20 * p + 17] = facesVec3Array[3].z;
                this.vertexPosition[qidx][20 * p + 18] = step * uindex;
                this.vertexPosition[qidx][20 * p + 19] = 1 - (step + step * vindex);
                p++;
            }
        }

        this.vertexPositionBuffer[qidx] = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPositionBuffer[qidx]);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPosition[qidx], _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);

    }


    setupPositionAndTexture4Quadrant(dxmin, dxmax, dymin, dymax, qidx, healpix, orderjump, origxyf) {

        let facesVec3Array = new Array();
        this.vertexPosition[qidx] = new Float32Array(20 * (dxmax - dxmin) * (dymax - dymin));

        let step = 1 / (1 << orderjump);
        let uindex = 0;
        let vindex = 0;
        let p = 0;

        for (let dx = dxmin; dx < dxmax; dx++) {
            for (let dy = dymin; dy < dymax; dy++) {
                let ipix3 = healpix.xyf2nest(dx, dy, origxyf.face);
                this._pixels.push(ipix3);

                facesVec3Array = healpix.getBoundaries(ipix3);
                // let xyf = healpix.nest2xyf(ipix3);
                // uindex = xyf.iy - origxyf.iy * Math.pow(2, orderjump);
                // vindex = xyf.ix - origxyf.ix * Math.pow(2, orderjump);
                uindex = dy - (origxyf.iy << orderjump);
                vindex = dx - (origxyf.ix << orderjump);

                // uindex = xyf.iy - (origxyf.iy << orderjump);
                // vindex = xyf.ix - (origxyf.ix << orderjump);

                this.vertexPosition[qidx][20 * p] = facesVec3Array[0].x;
                this.vertexPosition[qidx][20 * p + 1] = facesVec3Array[0].y;
                this.vertexPosition[qidx][20 * p + 2] = facesVec3Array[0].z;
                this.vertexPosition[qidx][20 * p + 3] = step + (step * uindex);
                this.vertexPosition[qidx][20 * p + 4] = 1 - (step + step * vindex);

                this.vertexPosition[qidx][20 * p + 5] = facesVec3Array[1].x;
                this.vertexPosition[qidx][20 * p + 6] = facesVec3Array[1].y;
                this.vertexPosition[qidx][20 * p + 7] = facesVec3Array[1].z;
                this.vertexPosition[qidx][20 * p + 8] = step + (step * uindex);
                this.vertexPosition[qidx][20 * p + 9] = 1 - (step * vindex);

                this.vertexPosition[qidx][20 * p + 10] = facesVec3Array[2].x;
                this.vertexPosition[qidx][20 * p + 11] = facesVec3Array[2].y;
                this.vertexPosition[qidx][20 * p + 12] = facesVec3Array[2].z;
                this.vertexPosition[qidx][20 * p + 13] = step * uindex;
                this.vertexPosition[qidx][20 * p + 14] = 1 - (step * vindex);

                this.vertexPosition[qidx][20 * p + 15] = facesVec3Array[3].x;
                this.vertexPosition[qidx][20 * p + 16] = facesVec3Array[3].y;
                this.vertexPosition[qidx][20 * p + 17] = facesVec3Array[3].z;
                this.vertexPosition[qidx][20 * p + 18] = step * uindex;
                this.vertexPosition[qidx][20 * p + 19] = 1 - (step + step * vindex);
                p++;
            }
        }

        this.vertexPositionBuffer[qidx] = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPositionBuffer[qidx]);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPosition[qidx], _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);

    }

    loadImage() {

        let _self = this;
        if (this._format == 'fits') {
            let hp = new wcslight__WEBPACK_IMPORTED_MODULE_1__.HiPSProjection();
            hp.initFromFile(_self._texurl).then((res) => {
                if (res !== undefined && res.data !== undefined) {
                    let canvas2d = new Canvas2D(res.data, res.header, res.outproj);
                    _self._image.src = canvas2d.getBrowseImage();

                }

            }).catch(function (err) {
                console.log("[Tile.js] FITS " + err);
            });
        } else {
            this._image.src = this._texurl;
        }

    }


    draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx) {

        if (!this._ready) {
            return false;
        }

        let quadrantsToDraw = new Set([0, 1, 2, 3]);
        if (visibleOrder > this._order) {
            quadrantsToDraw = this.drawChildren(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx);
        }

        _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.enableShaders(pMatrix, vMatrix, mMatrix, colorMapIdx);
        // TODO check if the enable below can be moved into hipsShaderProgram.enableShaders
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.enableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.vertexPositionAttribute);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.enableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureCoordAttribute);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniform1f(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureAlpha, this.opacity);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        let elemno = this.vertexIndices.length;

        quadrantsToDraw.forEach((qidx) => {
            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPositionBuffer[qidx]);

            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.vertexAttribPointer(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.vertexPositionAttribute, 3, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FLOAT, false, 5 * 4, 0);
            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.vertexAttribPointer(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureCoordAttribute, 2, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FLOAT, false, 5 * 4, 3 * 4);

            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.drawElements(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TRIANGLES, elemno, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNSIGNED_SHORT, 0);
        });


        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.disableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.vertexPositionAttribute);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.disableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureCoordAttribute);
        
    }


    drawChildren(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx) {

        let quadrantsToDraw = new Set([0, 1, 2, 3]);
        let childrenOrder = this._order + 1;
        if (!visibleTilesMap.has(childrenOrder)) {
            return;
        }
        for (let c = 0; c < 4; c++) {
            let childTileNo = (this._tileno << 2) + c;
            if (visibleTilesMap.get(childrenOrder).includes(childTileNo)) {
                let childTile = undefined
                if (this._isGalacticHips){
                    childTile = _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.getGalTile(childTileNo, childrenOrder, this._hips);
                } else {
                    childTile = _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.getTile(childTileNo, childrenOrder, this._hips);
                }
                childTile.draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx);
                if (childTile._ready) {
                    quadrantsToDraw.delete(childTile._tileno - (this._tileno << 2));
                }

            }
        }
        return quadrantsToDraw;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AncestorTile);

/***/ }),

/***/ "./src/js/model/hipsnew/ColorMap.js":
/*!******************************************!*\
  !*** ./src/js/model/hipsnew/ColorMap.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorMap: () => (/* binding */ colorMap)
/* harmony export */ });
/**
 * @author Fabrizio Giordano (Fab77)
 * Enum for coordinate types.
 * @readonly
 * @enum {{name: string, hex: string}}
 */
class ColorMap {
    PLANCK = {

        // "r": new Float32Array([0.00000,0.769231,1.53846,2.30769,3.07692,3.84615,4.61538,5.38462,6.15385,6.92308,7.69231,8.46154,9.23077,10.0000,11.5385,13.0769,14.6154,16.1538,17.6923,19.2308,20.7692,22.3077,23.8462,25.3846,26.9231,28.4615,30.0000,33.8462,37.6923,41.5385,45.3846,49.2308,53.0769,56.9231,60.7692,64.6154,68.4615,72.3077,76.1538,80.0000,88.5385,97.0769,105.615,114.154,122.692,131.231,139.769,148.308,156.846,165.385,173.923,182.462,191.000,193.846,196.692,199.538,202.385,205.231,208.077,210.923,213.769,216.615,219.462,222.308,225.154,228.000,229.182,230.364,231.545,232.727,233.909,235.091,236.273,237.455,238.636,239.818,241.000,241.000,241.364,241.727,242.091,242.455,242.818,243.182,243.545,243.909,244.273,244.636,245.000,245.231,245.462,245.692,245.923,246.154,246.385,246.615,246.846,247.077,247.308,247.538,247.769,248.000,248.146,248.292,248.438,248.585,248.731,248.877,249.023,249.169,249.315,249.462,249.608,249.754,249.900,249.312,248.723,248.135,247.546,246.958,246.369,245.781,245.192,244.604,244.015,243.427,242.838,242.250,239.308,236.365,233.423,230.481,227.538,224.596,221.654,218.712,215.769,212.827,209.885,206.942,204.000,201.000,198.000,195.000,192.000,189.000,186.000,183.000,180.000,177.000,174.000,171.000,168.000,165.000,161.077,157.154,153.231,149.308,145.385,141.462,137.538,133.615,129.692,125.769,121.846,117.923,114.000,115.038,116.077,117.115,118.154,119.192,120.231,121.269,122.308,123.346,124.385,125.423,126.462,127.500,131.423,135.346,139.269,143.192,147.115,151.038,154.962,158.885,162.808,166.731,170.654,174.577,178.500,180.462,182.423,184.385,186.346,188.308,190.269,192.231,194.192,196.154,198.115,200.077,202.038,204.000,205.962,207.923,209.885,211.846,213.808,215.769,217.731,219.692,221.654,223.615,225.577,227.538,229.500,230.481,231.462,232.442,233.423,234.404,235.385,236.365,237.346,238.327,239.308,240.288,241.269,242.250,242.642,243.035,243.427,243.819,244.212,244.604,244.996,245.388,245.781,246.173,246.565,246.958,247.350,247.814,248.277,248.741,249.205,249.668,250.132,250.595,251.059,251.523,251.986,252.450]),
        // "g": new Float32Array([0.00000,1.53846,3.07692,4.61538,6.15385,7.69231,9.23077,10.7692,12.3077,13.8462,15.3846,16.9231,18.4615,20.0000,32.6154,45.2308,57.8462,70.4615,83.0769,95.6923,108.308,120.923,133.538,146.154,158.769,171.385,184.000,187.923,191.846,195.769,199.692,203.615,207.538,211.462,215.385,219.308,223.231,227.154,231.077,235.000,235.308,235.615,235.923,236.231,236.538,236.846,237.154,237.462,237.769,238.077,238.385,238.692,239.000,239.077,239.154,239.231,239.308,239.385,239.462,239.538,239.615,239.692,239.769,239.846,239.923,240.000,240.091,240.182,240.273,240.364,240.455,240.545,240.636,240.727,240.818,240.909,241.000,241.000,240.909,240.818,240.727,240.636,240.545,240.455,240.364,240.273,240.182,240.091,240.000,239.615,239.231,238.846,238.462,238.077,237.692,237.308,236.923,236.538,236.154,235.769,235.385,235.000,232.615,230.231,227.846,225.462,223.077,220.692,218.308,215.923,213.538,211.154,208.769,206.385,204.000,200.077,196.154,192.231,188.308,184.385,180.462,176.538,172.615,168.692,164.769,160.846,156.923,153.000,147.115,141.231,135.346,129.462,123.577,117.692,111.808,105.923,100.038,94.1538,88.2692,82.3846,76.5000,73.0769,69.6538,66.2308,62.8077,59.3846,55.9615,52.5385,49.1154,45.6923,42.2692,38.8462,35.4231,32.0000,29.5385,27.0769,24.6154,22.1538,19.6923,17.2308,14.7692,12.3077,9.84615,7.38462,4.92308,2.46154,0.00000,9.80769,19.6154,29.4231,39.2308,49.0385,58.8462,68.6538,78.4615,88.2692,98.0769,107.885,117.692,127.500,131.423,135.346,139.269,143.192,147.115,151.038,154.962,158.885,162.808,166.731,170.654,174.577,178.500,180.462,182.423,184.385,186.346,188.308,190.269,192.231,194.192,196.154,198.115,200.077,202.038,204.000,205.962,207.923,209.885,211.846,213.808,215.769,217.731,219.692,221.654,223.615,225.577,227.538,229.500,230.481,231.462,232.442,233.423,234.404,235.385,236.365,237.346,238.327,239.308,240.288,241.269,242.250,242.642,243.035,243.427,243.819,244.212,244.604,244.996,245.388,245.781,246.173,246.565,246.958,247.350,247.814,248.277,248.741,249.205,249.668,250.132,250.595,251.059,251.523,251.986,252.450]),
        // "b": new Float32Array([255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,255.000,254.615,254.231,253.846,253.462,253.077,252.692,252.308,251.923,251.538,251.154,250.769,250.385,250.000,249.615,249.231,248.846,248.462,248.077,247.692,247.308,246.923,246.538,246.154,245.769,245.385,245.000,242.000,239.000,236.000,233.000,230.000,227.000,224.000,221.000,218.000,215.000,212.000,212.000,208.636,205.273,201.909,198.545,195.182,191.818,188.455,185.091,181.727,178.364,175.000,171.538,168.077,164.615,161.154,157.692,154.231,150.769,147.308,143.846,140.385,136.923,133.462,130.000,122.942,115.885,108.827,101.769,94.7115,87.6539,80.5962,73.5385,66.4808,59.4231,52.3654,45.3077,38.2500,36.2885,34.3269,32.3654,30.4038,28.4423,26.4808,24.5192,22.5577,20.5962,18.6346,16.6731,14.7115,12.7500,11.7692,10.7885,9.80769,8.82692,7.84615,6.86539,5.88461,4.90385,3.92308,2.94231,1.96154,0.980769,0.00000,2.46154,4.92308,7.38462,9.84616,12.3077,14.7692,17.2308,19.6923,22.1538,24.6154,27.0769,29.5385,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,32.0000,41.3077,50.6154,59.9231,69.2308,78.5385,87.8462,97.1539,106.462,115.769,125.077,134.385,143.692,153.000,156.923,160.846,164.769,168.692,172.615,176.538,180.462,184.385,188.308,192.231,196.154,200.077,204.000,205.962,207.923,209.885,211.846,213.808,215.769,217.731,219.692,221.654,223.615,225.577,227.538,229.500,230.481,231.462,232.442,233.423,234.404,235.385,236.365,237.346,238.327,239.308,240.288,241.269,242.250,242.838,243.427,244.015,244.604,245.192,245.781,246.369,246.958,247.546,248.135,248.723,249.312,249.900,250.096,250.292,250.488,250.685,250.881,251.077,251.273,251.469,251.665,251.862,252.058,252.254,252.450,252.682,252.914,253.145,253.377,253.609,253.841,254.073,254.305,254.536,254.768,255.000])
        "r": new Float32Array([0.00000,0.0,0.0,0.0,0.769231,0.0,0.0,0.0,1.53846,0.0,0.0,0.0,2.30769,0.0,0.0,0.0,3.07692,0.0,0.0,0.0,3.84615,0.0,0.0,0.0,4.61538,0.0,0.0,0.0,5.38462,0.0,0.0,0.0,6.15385,0.0,0.0,0.0,6.92308,0.0,0.0,0.0,7.69231,0.0,0.0,0.0,8.46154,0.0,0.0,0.0,9.23077,0.0,0.0,0.0,10.0000,0.0,0.0,0.0,11.5385,0.0,0.0,0.0,13.0769,0.0,0.0,0.0,14.6154,0.0,0.0,0.0,16.1538,0.0,0.0,0.0,17.6923,0.0,0.0,0.0,19.2308,0.0,0.0,0.0,20.7692,0.0,0.0,0.0,22.3077,0.0,0.0,0.0,23.8462,0.0,0.0,0.0,25.3846,0.0,0.0,0.0,26.9231,0.0,0.0,0.0,28.4615,0.0,0.0,0.0,30.0000,0.0,0.0,0.0,33.8462,0.0,0.0,0.0,37.6923,0.0,0.0,0.0,41.5385,0.0,0.0,0.0,45.3846,0.0,0.0,0.0,49.2308,0.0,0.0,0.0,53.0769,0.0,0.0,0.0,56.9231,0.0,0.0,0.0,60.7692,0.0,0.0,0.0,64.6154,0.0,0.0,0.0,68.4615,0.0,0.0,0.0,72.3077,0.0,0.0,0.0,76.1538,0.0,0.0,0.0,80.0000,0.0,0.0,0.0,88.5385,0.0,0.0,0.0,97.0769,0.0,0.0,0.0,105.615,0.0,0.0,0.0,114.154,0.0,0.0,0.0,122.692,0.0,0.0,0.0,131.231,0.0,0.0,0.0,139.769,0.0,0.0,0.0,148.308,0.0,0.0,0.0,156.846,0.0,0.0,0.0,165.385,0.0,0.0,0.0,173.923,0.0,0.0,0.0,182.462,0.0,0.0,0.0,191.000,0.0,0.0,0.0,193.846,0.0,0.0,0.0,196.692,0.0,0.0,0.0,199.538,0.0,0.0,0.0,202.385,0.0,0.0,0.0,205.231,0.0,0.0,0.0,208.077,0.0,0.0,0.0,210.923,0.0,0.0,0.0,213.769,0.0,0.0,0.0,216.615,0.0,0.0,0.0,219.462,0.0,0.0,0.0,222.308,0.0,0.0,0.0,225.154,0.0,0.0,0.0,228.000,0.0,0.0,0.0,229.182,0.0,0.0,0.0,230.364,0.0,0.0,0.0,231.545,0.0,0.0,0.0,232.727,0.0,0.0,0.0,233.909,0.0,0.0,0.0,235.091,0.0,0.0,0.0,236.273,0.0,0.0,0.0,237.455,0.0,0.0,0.0,238.636,0.0,0.0,0.0,239.818,0.0,0.0,0.0,241.000,0.0,0.0,0.0,241.000,0.0,0.0,0.0,241.364,0.0,0.0,0.0,241.727,0.0,0.0,0.0,242.091,0.0,0.0,0.0,242.455,0.0,0.0,0.0,242.818,0.0,0.0,0.0,243.182,0.0,0.0,0.0,243.545,0.0,0.0,0.0,243.909,0.0,0.0,0.0,244.273,0.0,0.0,0.0,244.636,0.0,0.0,0.0,245.000,0.0,0.0,0.0,245.231,0.0,0.0,0.0,245.462,0.0,0.0,0.0,245.692,0.0,0.0,0.0,245.923,0.0,0.0,0.0,246.154,0.0,0.0,0.0,246.385,0.0,0.0,0.0,246.615,0.0,0.0,0.0,246.846,0.0,0.0,0.0,247.077,0.0,0.0,0.0,247.308,0.0,0.0,0.0,247.538,0.0,0.0,0.0,247.769,0.0,0.0,0.0,248.000,0.0,0.0,0.0,248.146,0.0,0.0,0.0,248.292,0.0,0.0,0.0,248.438,0.0,0.0,0.0,248.585,0.0,0.0,0.0,248.731,0.0,0.0,0.0,248.877,0.0,0.0,0.0,249.023,0.0,0.0,0.0,249.169,0.0,0.0,0.0,249.315,0.0,0.0,0.0,249.462,0.0,0.0,0.0,249.608,0.0,0.0,0.0,249.754,0.0,0.0,0.0,249.900,0.0,0.0,0.0,249.312,0.0,0.0,0.0,248.723,0.0,0.0,0.0,248.135,0.0,0.0,0.0,247.546,0.0,0.0,0.0,246.958,0.0,0.0,0.0,246.369,0.0,0.0,0.0,245.781,0.0,0.0,0.0,245.192,0.0,0.0,0.0,244.604,0.0,0.0,0.0,244.015,0.0,0.0,0.0,243.427,0.0,0.0,0.0,242.838,0.0,0.0,0.0,242.250,0.0,0.0,0.0,239.308,0.0,0.0,0.0,236.365,0.0,0.0,0.0,233.423,0.0,0.0,0.0,230.481,0.0,0.0,0.0,227.538,0.0,0.0,0.0,224.596,0.0,0.0,0.0,221.654,0.0,0.0,0.0,218.712,0.0,0.0,0.0,215.769,0.0,0.0,0.0,212.827,0.0,0.0,0.0,209.885,0.0,0.0,0.0,206.942,0.0,0.0,0.0,204.000,0.0,0.0,0.0,201.000,0.0,0.0,0.0,198.000,0.0,0.0,0.0,195.000,0.0,0.0,0.0,192.000,0.0,0.0,0.0,189.000,0.0,0.0,0.0,186.000,0.0,0.0,0.0,183.000,0.0,0.0,0.0,180.000,0.0,0.0,0.0,177.000,0.0,0.0,0.0,174.000,0.0,0.0,0.0,171.000,0.0,0.0,0.0,168.000,0.0,0.0,0.0,165.000,0.0,0.0,0.0,161.077,0.0,0.0,0.0,157.154,0.0,0.0,0.0,153.231,0.0,0.0,0.0,149.308,0.0,0.0,0.0,145.385,0.0,0.0,0.0,141.462,0.0,0.0,0.0,137.538,0.0,0.0,0.0,133.615,0.0,0.0,0.0,129.692,0.0,0.0,0.0,125.769,0.0,0.0,0.0,121.846,0.0,0.0,0.0,117.923,0.0,0.0,0.0,114.000,0.0,0.0,0.0,115.038,0.0,0.0,0.0,116.077,0.0,0.0,0.0,117.115,0.0,0.0,0.0,118.154,0.0,0.0,0.0,119.192,0.0,0.0,0.0,120.231,0.0,0.0,0.0,121.269,0.0,0.0,0.0,122.308,0.0,0.0,0.0,123.346,0.0,0.0,0.0,124.385,0.0,0.0,0.0,125.423,0.0,0.0,0.0,126.462,0.0,0.0,0.0,127.500,0.0,0.0,0.0,131.423,0.0,0.0,0.0,135.346,0.0,0.0,0.0,139.269,0.0,0.0,0.0,143.192,0.0,0.0,0.0,147.115,0.0,0.0,0.0,151.038,0.0,0.0,0.0,154.962,0.0,0.0,0.0,158.885,0.0,0.0,0.0,162.808,0.0,0.0,0.0,166.731,0.0,0.0,0.0,170.654,0.0,0.0,0.0,174.577,0.0,0.0,0.0,178.500,0.0,0.0,0.0,180.462,0.0,0.0,0.0,182.423,0.0,0.0,0.0,184.385,0.0,0.0,0.0,186.346,0.0,0.0,0.0,188.308,0.0,0.0,0.0,190.269,0.0,0.0,0.0,192.231,0.0,0.0,0.0,194.192,0.0,0.0,0.0,196.154,0.0,0.0,0.0,198.115,0.0,0.0,0.0,200.077,0.0,0.0,0.0,202.038,0.0,0.0,0.0,204.000,0.0,0.0,0.0,205.962,0.0,0.0,0.0,207.923,0.0,0.0,0.0,209.885,0.0,0.0,0.0,211.846,0.0,0.0,0.0,213.808,0.0,0.0,0.0,215.769,0.0,0.0,0.0,217.731,0.0,0.0,0.0,219.692,0.0,0.0,0.0,221.654,0.0,0.0,0.0,223.615,0.0,0.0,0.0,225.577,0.0,0.0,0.0,227.538,0.0,0.0,0.0,229.500,0.0,0.0,0.0,230.481,0.0,0.0,0.0,231.462,0.0,0.0,0.0,232.442,0.0,0.0,0.0,233.423,0.0,0.0,0.0,234.404,0.0,0.0,0.0,235.385,0.0,0.0,0.0,236.365,0.0,0.0,0.0,237.346,0.0,0.0,0.0,238.327,0.0,0.0,0.0,239.308,0.0,0.0,0.0,240.288,0.0,0.0,0.0,241.269,0.0,0.0,0.0,242.250,0.0,0.0,0.0,242.642,0.0,0.0,0.0,243.035,0.0,0.0,0.0,243.427,0.0,0.0,0.0,243.819,0.0,0.0,0.0,244.212,0.0,0.0,0.0,244.604,0.0,0.0,0.0,244.996,0.0,0.0,0.0,245.388,0.0,0.0,0.0,245.781,0.0,0.0,0.0,246.173,0.0,0.0,0.0,246.565,0.0,0.0,0.0,246.958,0.0,0.0,0.0,247.350,0.0,0.0,0.0,247.814,0.0,0.0,0.0,248.277,0.0,0.0,0.0,248.741,0.0,0.0,0.0,249.205,0.0,0.0,0.0,249.668,0.0,0.0,0.0,250.132,0.0,0.0,0.0,250.595,0.0,0.0,0.0,251.059,0.0,0.0,0.0,251.523,0.0,0.0,0.0,251.986,0.0,0.0,0.0,252.450,0.0,0.0,0.0]),
        "g": new Float32Array([0.00000,0.0,0.0,0.0,1.53846,0.0,0.0,0.0,3.07692,0.0,0.0,0.0,4.61538,0.0,0.0,0.0,6.15385,0.0,0.0,0.0,7.69231,0.0,0.0,0.0,9.23077,0.0,0.0,0.0,10.7692,0.0,0.0,0.0,12.3077,0.0,0.0,0.0,13.8462,0.0,0.0,0.0,15.3846,0.0,0.0,0.0,16.9231,0.0,0.0,0.0,18.4615,0.0,0.0,0.0,20.0000,0.0,0.0,0.0,32.6154,0.0,0.0,0.0,45.2308,0.0,0.0,0.0,57.8462,0.0,0.0,0.0,70.4615,0.0,0.0,0.0,83.0769,0.0,0.0,0.0,95.6923,0.0,0.0,0.0,108.308,0.0,0.0,0.0,120.923,0.0,0.0,0.0,133.538,0.0,0.0,0.0,146.154,0.0,0.0,0.0,158.769,0.0,0.0,0.0,171.385,0.0,0.0,0.0,184.000,0.0,0.0,0.0,187.923,0.0,0.0,0.0,191.846,0.0,0.0,0.0,195.769,0.0,0.0,0.0,199.692,0.0,0.0,0.0,203.615,0.0,0.0,0.0,207.538,0.0,0.0,0.0,211.462,0.0,0.0,0.0,215.385,0.0,0.0,0.0,219.308,0.0,0.0,0.0,223.231,0.0,0.0,0.0,227.154,0.0,0.0,0.0,231.077,0.0,0.0,0.0,235.000,0.0,0.0,0.0,235.308,0.0,0.0,0.0,235.615,0.0,0.0,0.0,235.923,0.0,0.0,0.0,236.231,0.0,0.0,0.0,236.538,0.0,0.0,0.0,236.846,0.0,0.0,0.0,237.154,0.0,0.0,0.0,237.462,0.0,0.0,0.0,237.769,0.0,0.0,0.0,238.077,0.0,0.0,0.0,238.385,0.0,0.0,0.0,238.692,0.0,0.0,0.0,239.000,0.0,0.0,0.0,239.077,0.0,0.0,0.0,239.154,0.0,0.0,0.0,239.231,0.0,0.0,0.0,239.308,0.0,0.0,0.0,239.385,0.0,0.0,0.0,239.462,0.0,0.0,0.0,239.538,0.0,0.0,0.0,239.615,0.0,0.0,0.0,239.692,0.0,0.0,0.0,239.769,0.0,0.0,0.0,239.846,0.0,0.0,0.0,239.923,0.0,0.0,0.0,240.000,0.0,0.0,0.0,240.091,0.0,0.0,0.0,240.182,0.0,0.0,0.0,240.273,0.0,0.0,0.0,240.364,0.0,0.0,0.0,240.455,0.0,0.0,0.0,240.545,0.0,0.0,0.0,240.636,0.0,0.0,0.0,240.727,0.0,0.0,0.0,240.818,0.0,0.0,0.0,240.909,0.0,0.0,0.0,241.000,0.0,0.0,0.0,241.000,0.0,0.0,0.0,240.909,0.0,0.0,0.0,240.818,0.0,0.0,0.0,240.727,0.0,0.0,0.0,240.636,0.0,0.0,0.0,240.545,0.0,0.0,0.0,240.455,0.0,0.0,0.0,240.364,0.0,0.0,0.0,240.273,0.0,0.0,0.0,240.182,0.0,0.0,0.0,240.091,0.0,0.0,0.0,240.000,0.0,0.0,0.0,239.615,0.0,0.0,0.0,239.231,0.0,0.0,0.0,238.846,0.0,0.0,0.0,238.462,0.0,0.0,0.0,238.077,0.0,0.0,0.0,237.692,0.0,0.0,0.0,237.308,0.0,0.0,0.0,236.923,0.0,0.0,0.0,236.538,0.0,0.0,0.0,236.154,0.0,0.0,0.0,235.769,0.0,0.0,0.0,235.385,0.0,0.0,0.0,235.000,0.0,0.0,0.0,232.615,0.0,0.0,0.0,230.231,0.0,0.0,0.0,227.846,0.0,0.0,0.0,225.462,0.0,0.0,0.0,223.077,0.0,0.0,0.0,220.692,0.0,0.0,0.0,218.308,0.0,0.0,0.0,215.923,0.0,0.0,0.0,213.538,0.0,0.0,0.0,211.154,0.0,0.0,0.0,208.769,0.0,0.0,0.0,206.385,0.0,0.0,0.0,204.000,0.0,0.0,0.0,200.077,0.0,0.0,0.0,196.154,0.0,0.0,0.0,192.231,0.0,0.0,0.0,188.308,0.0,0.0,0.0,184.385,0.0,0.0,0.0,180.462,0.0,0.0,0.0,176.538,0.0,0.0,0.0,172.615,0.0,0.0,0.0,168.692,0.0,0.0,0.0,164.769,0.0,0.0,0.0,160.846,0.0,0.0,0.0,156.923,0.0,0.0,0.0,153.000,0.0,0.0,0.0,147.115,0.0,0.0,0.0,141.231,0.0,0.0,0.0,135.346,0.0,0.0,0.0,129.462,0.0,0.0,0.0,123.577,0.0,0.0,0.0,117.692,0.0,0.0,0.0,111.808,0.0,0.0,0.0,105.923,0.0,0.0,0.0,100.038,0.0,0.0,0.0,94.1538,0.0,0.0,0.0,88.2692,0.0,0.0,0.0,82.3846,0.0,0.0,0.0,76.5000,0.0,0.0,0.0,73.0769,0.0,0.0,0.0,69.6538,0.0,0.0,0.0,66.2308,0.0,0.0,0.0,62.8077,0.0,0.0,0.0,59.3846,0.0,0.0,0.0,55.9615,0.0,0.0,0.0,52.5385,0.0,0.0,0.0,49.1154,0.0,0.0,0.0,45.6923,0.0,0.0,0.0,42.2692,0.0,0.0,0.0,38.8462,0.0,0.0,0.0,35.4231,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,29.5385,0.0,0.0,0.0,27.0769,0.0,0.0,0.0,24.6154,0.0,0.0,0.0,22.1538,0.0,0.0,0.0,19.6923,0.0,0.0,0.0,17.2308,0.0,0.0,0.0,14.7692,0.0,0.0,0.0,12.3077,0.0,0.0,0.0,9.84615,0.0,0.0,0.0,7.38462,0.0,0.0,0.0,4.92308,0.0,0.0,0.0,2.46154,0.0,0.0,0.0,0.00000,0.0,0.0,0.0,9.80769,0.0,0.0,0.0,19.6154,0.0,0.0,0.0,29.4231,0.0,0.0,0.0,39.2308,0.0,0.0,0.0,49.0385,0.0,0.0,0.0,58.8462,0.0,0.0,0.0,68.6538,0.0,0.0,0.0,78.4615,0.0,0.0,0.0,88.2692,0.0,0.0,0.0,98.0769,0.0,0.0,0.0,107.885,0.0,0.0,0.0,117.692,0.0,0.0,0.0,127.500,0.0,0.0,0.0,131.423,0.0,0.0,0.0,135.346,0.0,0.0,0.0,139.269,0.0,0.0,0.0,143.192,0.0,0.0,0.0,147.115,0.0,0.0,0.0,151.038,0.0,0.0,0.0,154.962,0.0,0.0,0.0,158.885,0.0,0.0,0.0,162.808,0.0,0.0,0.0,166.731,0.0,0.0,0.0,170.654,0.0,0.0,0.0,174.577,0.0,0.0,0.0,178.500,0.0,0.0,0.0,180.462,0.0,0.0,0.0,182.423,0.0,0.0,0.0,184.385,0.0,0.0,0.0,186.346,0.0,0.0,0.0,188.308,0.0,0.0,0.0,190.269,0.0,0.0,0.0,192.231,0.0,0.0,0.0,194.192,0.0,0.0,0.0,196.154,0.0,0.0,0.0,198.115,0.0,0.0,0.0,200.077,0.0,0.0,0.0,202.038,0.0,0.0,0.0,204.000,0.0,0.0,0.0,205.962,0.0,0.0,0.0,207.923,0.0,0.0,0.0,209.885,0.0,0.0,0.0,211.846,0.0,0.0,0.0,213.808,0.0,0.0,0.0,215.769,0.0,0.0,0.0,217.731,0.0,0.0,0.0,219.692,0.0,0.0,0.0,221.654,0.0,0.0,0.0,223.615,0.0,0.0,0.0,225.577,0.0,0.0,0.0,227.538,0.0,0.0,0.0,229.500,0.0,0.0,0.0,230.481,0.0,0.0,0.0,231.462,0.0,0.0,0.0,232.442,0.0,0.0,0.0,233.423,0.0,0.0,0.0,234.404,0.0,0.0,0.0,235.385,0.0,0.0,0.0,236.365,0.0,0.0,0.0,237.346,0.0,0.0,0.0,238.327,0.0,0.0,0.0,239.308,0.0,0.0,0.0,240.288,0.0,0.0,0.0,241.269,0.0,0.0,0.0,242.250,0.0,0.0,0.0,242.642,0.0,0.0,0.0,243.035,0.0,0.0,0.0,243.427,0.0,0.0,0.0,243.819,0.0,0.0,0.0,244.212,0.0,0.0,0.0,244.604,0.0,0.0,0.0,244.996,0.0,0.0,0.0,245.388,0.0,0.0,0.0,245.781,0.0,0.0,0.0,246.173,0.0,0.0,0.0,246.565,0.0,0.0,0.0,246.958,0.0,0.0,0.0,247.350,0.0,0.0,0.0,247.814,0.0,0.0,0.0,248.277,0.0,0.0,0.0,248.741,0.0,0.0,0.0,249.205,0.0,0.0,0.0,249.668,0.0,0.0,0.0,250.132,0.0,0.0,0.0,250.595,0.0,0.0,0.0,251.059,0.0,0.0,0.0,251.523,0.0,0.0,0.0,251.986,0.0,0.0,0.0,252.450,0.0,0.0,0.0]),
        "b": new Float32Array([255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,255.000,0.0,0.0,0.0,254.615,0.0,0.0,0.0,254.231,0.0,0.0,0.0,253.846,0.0,0.0,0.0,253.462,0.0,0.0,0.0,253.077,0.0,0.0,0.0,252.692,0.0,0.0,0.0,252.308,0.0,0.0,0.0,251.923,0.0,0.0,0.0,251.538,0.0,0.0,0.0,251.154,0.0,0.0,0.0,250.769,0.0,0.0,0.0,250.385,0.0,0.0,0.0,250.000,0.0,0.0,0.0,249.615,0.0,0.0,0.0,249.231,0.0,0.0,0.0,248.846,0.0,0.0,0.0,248.462,0.0,0.0,0.0,248.077,0.0,0.0,0.0,247.692,0.0,0.0,0.0,247.308,0.0,0.0,0.0,246.923,0.0,0.0,0.0,246.538,0.0,0.0,0.0,246.154,0.0,0.0,0.0,245.769,0.0,0.0,0.0,245.385,0.0,0.0,0.0,245.000,0.0,0.0,0.0,242.000,0.0,0.0,0.0,239.000,0.0,0.0,0.0,236.000,0.0,0.0,0.0,233.000,0.0,0.0,0.0,230.000,0.0,0.0,0.0,227.000,0.0,0.0,0.0,224.000,0.0,0.0,0.0,221.000,0.0,0.0,0.0,218.000,0.0,0.0,0.0,215.000,0.0,0.0,0.0,212.000,0.0,0.0,0.0,212.000,0.0,0.0,0.0,208.636,0.0,0.0,0.0,205.273,0.0,0.0,0.0,201.909,0.0,0.0,0.0,198.545,0.0,0.0,0.0,195.182,0.0,0.0,0.0,191.818,0.0,0.0,0.0,188.455,0.0,0.0,0.0,185.091,0.0,0.0,0.0,181.727,0.0,0.0,0.0,178.364,0.0,0.0,0.0,175.000,0.0,0.0,0.0,171.538,0.0,0.0,0.0,168.077,0.0,0.0,0.0,164.615,0.0,0.0,0.0,161.154,0.0,0.0,0.0,157.692,0.0,0.0,0.0,154.231,0.0,0.0,0.0,150.769,0.0,0.0,0.0,147.308,0.0,0.0,0.0,143.846,0.0,0.0,0.0,140.385,0.0,0.0,0.0,136.923,0.0,0.0,0.0,133.462,0.0,0.0,0.0,130.000,0.0,0.0,0.0,122.942,0.0,0.0,0.0,115.885,0.0,0.0,0.0,108.827,0.0,0.0,0.0,101.769,0.0,0.0,0.0,94.7115,0.0,0.0,0.0,87.6539,0.0,0.0,0.0,80.5962,0.0,0.0,0.0,73.5385,0.0,0.0,0.0,66.4808,0.0,0.0,0.0,59.4231,0.0,0.0,0.0,52.3654,0.0,0.0,0.0,45.3077,0.0,0.0,0.0,38.2500,0.0,0.0,0.0,36.2885,0.0,0.0,0.0,34.3269,0.0,0.0,0.0,32.3654,0.0,0.0,0.0,30.4038,0.0,0.0,0.0,28.4423,0.0,0.0,0.0,26.4808,0.0,0.0,0.0,24.5192,0.0,0.0,0.0,22.5577,0.0,0.0,0.0,20.5962,0.0,0.0,0.0,18.6346,0.0,0.0,0.0,16.6731,0.0,0.0,0.0,14.7115,0.0,0.0,0.0,12.7500,0.0,0.0,0.0,11.7692,0.0,0.0,0.0,10.7885,0.0,0.0,0.0,9.80769,0.0,0.0,0.0,8.82692,0.0,0.0,0.0,7.84615,0.0,0.0,0.0,6.86539,0.0,0.0,0.0,5.88461,0.0,0.0,0.0,4.90385,0.0,0.0,0.0,3.92308,0.0,0.0,0.0,2.94231,0.0,0.0,0.0,1.96154,0.0,0.0,0.0,0.980769,0.0,0.0,0.0,0.00000,0.0,0.0,0.0,2.46154,0.0,0.0,0.0,4.92308,0.0,0.0,0.0,7.38462,0.0,0.0,0.0,9.84616,0.0,0.0,0.0,12.3077,0.0,0.0,0.0,14.7692,0.0,0.0,0.0,17.2308,0.0,0.0,0.0,19.6923,0.0,0.0,0.0,22.1538,0.0,0.0,0.0,24.6154,0.0,0.0,0.0,27.0769,0.0,0.0,0.0,29.5385,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,32.0000,0.0,0.0,0.0,41.3077,0.0,0.0,0.0,50.6154,0.0,0.0,0.0,59.9231,0.0,0.0,0.0,69.2308,0.0,0.0,0.0,78.5385,0.0,0.0,0.0,87.8462,0.0,0.0,0.0,97.1539,0.0,0.0,0.0,106.462,0.0,0.0,0.0,115.769,0.0,0.0,0.0,125.077,0.0,0.0,0.0,134.385,0.0,0.0,0.0,143.692,0.0,0.0,0.0,153.000,0.0,0.0,0.0,156.923,0.0,0.0,0.0,160.846,0.0,0.0,0.0,164.769,0.0,0.0,0.0,168.692,0.0,0.0,0.0,172.615,0.0,0.0,0.0,176.538,0.0,0.0,0.0,180.462,0.0,0.0,0.0,184.385,0.0,0.0,0.0,188.308,0.0,0.0,0.0,192.231,0.0,0.0,0.0,196.154,0.0,0.0,0.0,200.077,0.0,0.0,0.0,204.000,0.0,0.0,0.0,205.962,0.0,0.0,0.0,207.923,0.0,0.0,0.0,209.885,0.0,0.0,0.0,211.846,0.0,0.0,0.0,213.808,0.0,0.0,0.0,215.769,0.0,0.0,0.0,217.731,0.0,0.0,0.0,219.692,0.0,0.0,0.0,221.654,0.0,0.0,0.0,223.615,0.0,0.0,0.0,225.577,0.0,0.0,0.0,227.538,0.0,0.0,0.0,229.500,0.0,0.0,0.0,230.481,0.0,0.0,0.0,231.462,0.0,0.0,0.0,232.442,0.0,0.0,0.0,233.423,0.0,0.0,0.0,234.404,0.0,0.0,0.0,235.385,0.0,0.0,0.0,236.365,0.0,0.0,0.0,237.346,0.0,0.0,0.0,238.327,0.0,0.0,0.0,239.308,0.0,0.0,0.0,240.288,0.0,0.0,0.0,241.269,0.0,0.0,0.0,242.250,0.0,0.0,0.0,242.838,0.0,0.0,0.0,243.427,0.0,0.0,0.0,244.015,0.0,0.0,0.0,244.604,0.0,0.0,0.0,245.192,0.0,0.0,0.0,245.781,0.0,0.0,0.0,246.369,0.0,0.0,0.0,246.958,0.0,0.0,0.0,247.546,0.0,0.0,0.0,248.135,0.0,0.0,0.0,248.723,0.0,0.0,0.0,249.312,0.0,0.0,0.0,249.900,0.0,0.0,0.0,250.096,0.0,0.0,0.0,250.292,0.0,0.0,0.0,250.488,0.0,0.0,0.0,250.685,0.0,0.0,0.0,250.881,0.0,0.0,0.0,251.077,0.0,0.0,0.0,251.273,0.0,0.0,0.0,251.469,0.0,0.0,0.0,251.665,0.0,0.0,0.0,251.862,0.0,0.0,0.0,252.058,0.0,0.0,0.0,252.254,0.0,0.0,0.0,252.450,0.0,0.0,0.0,252.682,0.0,0.0,0.0,252.914,0.0,0.0,0.0,253.145,0.0,0.0,0.0,253.377,0.0,0.0,0.0,253.609,0.0,0.0,0.0,253.841,0.0,0.0,0.0,254.073,0.0,0.0,0.0,254.305,0.0,0.0,0.0,254.536,0.0,0.0,0.0,254.768,0.0,0.0,0.0,255.000,0.0,0.0,0.0])
        

    }
    RAINBOW = {
        "r": new Float32Array([0.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 9.0,0.0,0.0,0.0, 13.0,0.0,0.0,0.0, 18.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 27.0,0.0,0.0,0.0, 31.0,0.0,0.0,0.0, 36.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 54.0,0.0,0.0,0.0, 58.0,0.0,0.0,0.0, 61.0,0.0,0.0,0.0, 64.0,0.0,0.0,0.0, 68.0,0.0,0.0,0.0, 69.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 79.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 82.0,0.0,0.0,0.0, 83.0,0.0,0.0,0.0, 85.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 86.0,0.0,0.0,0.0, 87.0,0.0,0.0,0.0, 88.0,0.0,0.0,0.0, 86.0,0.0,0.0,0.0, 87.0,0.0,0.0,0.0, 87.0,0.0,0.0,0.0, 87.0,0.0,0.0,0.0, 85.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 83.0,0.0,0.0,0.0, 79.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 71.0,0.0,0.0,0.0, 70.0,0.0,0.0,0.0, 68.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 58.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 43.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 36.0,0.0,0.0,0.0, 33.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 16.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 33.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 51.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 89.0,0.0,0.0,0.0, 93.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 101.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 123.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 153.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 161.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 169.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 246.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0]),
        "g": new Float32Array([0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 16.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 51.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 89.0,0.0,0.0,0.0, 93.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 106.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 152.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 161.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 174.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 216.0,0.0,0.0,0.0, 220.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 246.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 216.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 174.0,0.0,0.0,0.0, 170.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 161.0,0.0,0.0,0.0, 153.0,0.0,0.0,0.0, 148.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 123.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 106.0,0.0,0.0,0.0, 102.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 89.0,0.0,0.0,0.0, 85.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 51.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 34.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 17.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0]),
        "b": new Float32Array([0.0,0.0,0.0,0.0, 3.0,0.0,0.0,0.0, 7.0,0.0,0.0,0.0, 10.0,0.0,0.0,0.0, 14.0,0.0,0.0,0.0, 19.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 28.0,0.0,0.0,0.0, 32.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 43.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 68.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 81.0,0.0,0.0,0.0, 86.0,0.0,0.0,0.0, 91.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 100.0,0.0,0.0,0.0, 104.0,0.0,0.0,0.0, 109.0,0.0,0.0,0.0, 113.0,0.0,0.0,0.0, 118.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 132.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 141.0,0.0,0.0,0.0, 145.0,0.0,0.0,0.0, 150.0,0.0,0.0,0.0, 154.0,0.0,0.0,0.0, 159.0,0.0,0.0,0.0, 163.0,0.0,0.0,0.0, 168.0,0.0,0.0,0.0, 173.0,0.0,0.0,0.0, 177.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 186.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 204.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 214.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 223.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 245.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 246.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 220.0,0.0,0.0,0.0, 216.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 174.0,0.0,0.0,0.0, 170.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 152.0,0.0,0.0,0.0, 148.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 123.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 106.0,0.0,0.0,0.0, 102.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 89.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 34.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 16.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.])
    }
    CMB = {
        // "r": new Float32Array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.0, 12.0, 18.0, 24.0, 30.0, 36.0, 42.0, 48.0, 54.0, 60.0, 66.0, 72.0, 78.0, 85.0, 91.0, 97.0, 103.0, 109.0, 115.0, 121.0, 127.0, 133.0, 139.0, 145.0, 151.0, 157.0, 163.0, 170.0, 176.0, 182.0, 188.0, 194.0, 200.0, 206.0, 212.0, 218.0, 224.0, 230.0, 236.0, 242.0, 248.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 251.0, 247.0, 244.0, 240.0, 236.0, 233.0, 229.0, 226.0, 222.0, 218.0, 215.0, 211.0, 208.0, 204.0, 200.0, 197.0, 193.0, 190.0, 186.0, 182.0, 179.0, 175.0, 172.0, 168.0, 164.0, 161.0, 157.0, 154.0, 150.0, 146.0, 143.0, 139.0, 136.0, 132.0, 128.0, 125.0, 121.0, 118.0, 114.0, 110.0, 107.0, 103.0, 100.0]),
        // "g": new Float32Array([0.0, 2.0, 5.0, 8.0, 10.0, 13.0, 16.0, 18.0, 21.0, 24.0, 26.0, 29.0, 32.0, 34.0, 37.0, 40.0, 42.0, 45.0, 48.0, 50.0, 53.0, 56.0, 58.0, 61.0, 64.0, 66.0, 69.0, 72.0, 74.0, 77.0, 80.0, 82.0, 85.0, 88.0, 90.0, 93.0, 96.0, 98.0, 101.0, 104.0, 106.0, 109.0, 112.0, 114.0, 117.0, 119.0, 122.0, 124.0, 127.0, 129.0, 132.0, 134.0, 137.0, 139.0, 142.0, 144.0, 147.0, 150.0, 152.0, 155.0, 157.0, 160.0, 162.0, 165.0, 167.0, 170.0, 172.0, 175.0, 177.0, 180.0, 182.0, 185.0, 188.0, 190.0, 193.0, 195.0, 198.0, 200.0, 203.0, 205.0, 208.0, 210.0, 213.0, 215.0, 218.0, 221.0, 221.0, 221.0, 222.0, 222.0, 222.0, 223.0, 223.0, 224.0, 224.0, 224.0, 225.0, 225.0, 225.0, 226.0, 226.0, 227.0, 227.0, 227.0, 228.0, 228.0, 229.0, 229.0, 229.0, 230.0, 230.0, 230.0, 231.0, 231.0, 232.0, 232.0, 232.0, 233.0, 233.0, 233.0, 234.0, 234.0, 235.0, 235.0, 235.0, 236.0, 236.0, 237.0, 235.0, 234.0, 233.0, 231.0, 230.0, 229.0, 227.0, 226.0, 225.0, 223.0, 222.0, 221.0, 219.0, 218.0, 217.0, 215.0, 214.0, 213.0, 211.0, 210.0, 209.0, 207.0, 206.0, 205.0, 203.0, 202.0, 201.0, 199.0, 198.0, 197.0, 195.0, 194.0, 193.0, 191.0, 190.0, 189.0, 187.0, 186.0, 185.0, 183.0, 182.0, 181.0, 180.0, 177.0, 175.0, 172.0, 170.0, 167.0, 165.0, 162.0, 160.0, 157.0, 155.0, 152.0, 150.0, 147.0, 145.0, 142.0, 140.0, 137.0, 135.0, 132.0, 130.0, 127.0, 125.0, 122.0, 120.0, 117.0, 115.0, 112.0, 110.0, 107.0, 105.0, 102.0, 100.0, 97.0, 95.0, 92.0, 90.0, 87.0, 85.0, 82.0, 80.0, 77.0, 75.0, 73.0, 71.0, 69.0, 68.0, 66.0, 64.0, 62.0, 61.0, 59.0, 57.0, 55.0, 54.0, 52.0, 50.0, 48.0, 47.0, 45.0, 43.0, 41.0, 40.0, 38.0, 36.0, 34.0, 33.0, 31.0, 29.0, 27.0, 26.0, 24.0, 22.0, 20.0, 19.0, 17.0, 15.0, 13.0, 12.0, 10.0, 8.0, 6.0, 5.0, 3.0, 1.0, 0.0]),
        // "b": new Float32Array([255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 254.0, 253.0, 252.0, 251.0, 250.0, 249.0, 248.0, 247.0, 246.0, 245.0, 245.0, 244.0, 243.0, 242.0, 241.0, 240.0, 239.0, 238.0, 237.0, 236.0, 236.0, 235.0, 234.0, 233.0, 232.0, 231.0, 230.0, 229.0, 228.0, 227.0, 226.0, 226.0, 225.0, 224.0, 223.0, 222.0, 221.0, 220.0, 219.0, 218.0, 217.0, 217.0, 211.0, 206.0, 201.0, 196.0, 191.0, 186.0, 181.0, 176.0, 171.0, 166.0, 161.0, 156.0, 151.0, 146.0, 141.0, 136.0, 131.0, 126.0, 121.0, 116.0, 111.0, 105.0, 100.0, 95.0, 90.0, 85.0, 80.0, 75.0, 70.0, 65.0, 60.0, 55.0, 50.0, 45.0, 40.0, 35.0, 30.0, 25.0, 20.0, 15.0, 10.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        "r": new Float32Array([0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 6.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 18.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 30.0,0.0,0.0,0.0, 36.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 54.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 85.0,0.0,0.0,0.0, 91.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 103.0,0.0,0.0,0.0, 109.0,0.0,0.0,0.0, 115.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 133.0,0.0,0.0,0.0, 139.0,0.0,0.0,0.0, 145.0,0.0,0.0,0.0, 151.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 163.0,0.0,0.0,0.0, 170.0,0.0,0.0,0.0, 176.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 188.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 206.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 248.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 251.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 244.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 204.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 197.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 190.0,0.0,0.0,0.0, 186.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 179.0,0.0,0.0,0.0, 175.0,0.0,0.0,0.0, 172.0,0.0,0.0,0.0, 168.0,0.0,0.0,0.0, 164.0,0.0,0.0,0.0, 161.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 154.0,0.0,0.0,0.0, 150.0,0.0,0.0,0.0, 146.0,0.0,0.0,0.0, 143.0,0.0,0.0,0.0, 139.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 132.0,0.0,0.0,0.0, 128.0,0.0,0.0,0.0, 125.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 118.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 107.0,0.0,0.0,0.0, 103.0,0.0,0.0,0.0, 100.0,0.0,0.0,0.0]),
        "g": new Float32Array([0.0,0.0,0.0,0.0, 2.0,0.0,0.0,0.0, 5.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 10.0,0.0,0.0,0.0, 13.0,0.0,0.0,0.0, 16.0,0.0,0.0,0.0, 18.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 32.0,0.0,0.0,0.0, 34.0,0.0,0.0,0.0, 37.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 56.0,0.0,0.0,0.0, 58.0,0.0,0.0,0.0, 61.0,0.0,0.0,0.0, 64.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 69.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 82.0,0.0,0.0,0.0, 85.0,0.0,0.0,0.0, 88.0,0.0,0.0,0.0, 90.0,0.0,0.0,0.0, 93.0,0.0,0.0,0.0, 96.0,0.0,0.0,0.0, 98.0,0.0,0.0,0.0, 101.0,0.0,0.0,0.0, 104.0,0.0,0.0,0.0, 106.0,0.0,0.0,0.0, 109.0,0.0,0.0,0.0, 112.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 117.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 124.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 129.0,0.0,0.0,0.0, 132.0,0.0,0.0,0.0, 134.0,0.0,0.0,0.0, 137.0,0.0,0.0,0.0, 139.0,0.0,0.0,0.0, 142.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 147.0,0.0,0.0,0.0, 150.0,0.0,0.0,0.0, 152.0,0.0,0.0,0.0, 155.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 160.0,0.0,0.0,0.0, 162.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 167.0,0.0,0.0,0.0, 170.0,0.0,0.0,0.0, 172.0,0.0,0.0,0.0, 175.0,0.0,0.0,0.0, 177.0,0.0,0.0,0.0, 180.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 185.0,0.0,0.0,0.0, 188.0,0.0,0.0,0.0, 190.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 213.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 223.0,0.0,0.0,0.0, 223.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 228.0,0.0,0.0,0.0, 228.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 234.0,0.0,0.0,0.0, 234.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 237.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 234.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 223.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 219.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 217.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 214.0,0.0,0.0,0.0, 213.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 206.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 202.0,0.0,0.0,0.0, 201.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 197.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 190.0,0.0,0.0,0.0, 189.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 186.0,0.0,0.0,0.0, 185.0,0.0,0.0,0.0, 183.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 181.0,0.0,0.0,0.0, 180.0,0.0,0.0,0.0, 177.0,0.0,0.0,0.0, 175.0,0.0,0.0,0.0, 172.0,0.0,0.0,0.0, 170.0,0.0,0.0,0.0, 167.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 162.0,0.0,0.0,0.0, 160.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 155.0,0.0,0.0,0.0, 152.0,0.0,0.0,0.0, 150.0,0.0,0.0,0.0, 147.0,0.0,0.0,0.0, 145.0,0.0,0.0,0.0, 142.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 137.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 132.0,0.0,0.0,0.0, 130.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 125.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 117.0,0.0,0.0,0.0, 115.0,0.0,0.0,0.0, 112.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 107.0,0.0,0.0,0.0, 105.0,0.0,0.0,0.0, 102.0,0.0,0.0,0.0, 100.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 92.0,0.0,0.0,0.0, 90.0,0.0,0.0,0.0, 87.0,0.0,0.0,0.0, 85.0,0.0,0.0,0.0, 82.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 75.0,0.0,0.0,0.0, 73.0,0.0,0.0,0.0, 71.0,0.0,0.0,0.0, 69.0,0.0,0.0,0.0, 68.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 64.0,0.0,0.0,0.0, 62.0,0.0,0.0,0.0, 61.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 54.0,0.0,0.0,0.0, 52.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 43.0,0.0,0.0,0.0, 41.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 36.0,0.0,0.0,0.0, 34.0,0.0,0.0,0.0, 33.0,0.0,0.0,0.0, 31.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 27.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 19.0,0.0,0.0,0.0, 17.0,0.0,0.0,0.0, 15.0,0.0,0.0,0.0, 13.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 10.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 6.0,0.0,0.0,0.0, 5.0,0.0,0.0,0.0, 3.0,0.0,0.0,0.0, 1.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0]),
        "b": new Float32Array([255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 254.0,0.0,0.0,0.0, 253.0,0.0,0.0,0.0, 252.0,0.0,0.0,0.0, 251.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 249.0,0.0,0.0,0.0, 248.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 246.0,0.0,0.0,0.0, 245.0,0.0,0.0,0.0, 245.0,0.0,0.0,0.0, 244.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 237.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 234.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 228.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 223.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 220.0,0.0,0.0,0.0, 219.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 217.0,0.0,0.0,0.0, 217.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 206.0,0.0,0.0,0.0, 201.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 186.0,0.0,0.0,0.0, 181.0,0.0,0.0,0.0, 176.0,0.0,0.0,0.0, 171.0,0.0,0.0,0.0, 166.0,0.0,0.0,0.0, 161.0,0.0,0.0,0.0, 156.0,0.0,0.0,0.0, 151.0,0.0,0.0,0.0, 146.0,0.0,0.0,0.0, 141.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 126.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 116.0,0.0,0.0,0.0, 111.0,0.0,0.0,0.0, 105.0,0.0,0.0,0.0, 100.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 90.0,0.0,0.0,0.0, 85.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 75.0,0.0,0.0,0.0, 70.0,0.0,0.0,0.0, 65.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 35.0,0.0,0.0,0.0, 30.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 15.0,0.0,0.0,0.0, 10.0,0.0,0.0,0.0, 5.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0])
    }
    CUBEHELIX = {
        "r": new Float32Array([0.0,0.0,0.0,0.0, 1.0,0.0,0.0,0.0, 3.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 6.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 9.0,0.0,0.0,0.0, 10.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 13.0,0.0,0.0,0.0, 14.0,0.0,0.0,0.0, 15.0,0.0,0.0,0.0, 17.0,0.0,0.0,0.0, 18.0,0.0,0.0,0.0, 19.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 27.0,0.0,0.0,0.0, 27.0,0.0,0.0,0.0, 28.0,0.0,0.0,0.0, 30.0,0.0,0.0,0.0, 31.0,0.0,0.0,0.0, 32.0,0.0,0.0,0.0, 33.0,0.0,0.0,0.0, 35.0,0.0,0.0,0.0, 36.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 39.0,0.0,0.0,0.0, 41.0,0.0,0.0,0.0, 43.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 49.0,0.0,0.0,0.0, 51.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 62.0,0.0,0.0,0.0, 65.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 70.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 75.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 81.0,0.0,0.0,0.0, 83.0,0.0,0.0,0.0, 86.0,0.0,0.0,0.0, 89.0,0.0,0.0,0.0, 92.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 98.0,0.0,0.0,0.0, 101.0,0.0,0.0,0.0, 104.0,0.0,0.0,0.0, 107.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 113.0,0.0,0.0,0.0, 116.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 123.0,0.0,0.0,0.0, 126.0,0.0,0.0,0.0, 129.0,0.0,0.0,0.0, 132.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 138.0,0.0,0.0,0.0, 141.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 147.0,0.0,0.0,0.0, 150.0,0.0,0.0,0.0, 153.0,0.0,0.0,0.0, 155.0,0.0,0.0,0.0, 158.0,0.0,0.0,0.0, 161.0,0.0,0.0,0.0, 164.0,0.0,0.0,0.0, 166.0,0.0,0.0,0.0, 169.0,0.0,0.0,0.0, 171.0,0.0,0.0,0.0, 174.0,0.0,0.0,0.0, 176.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 181.0,0.0,0.0,0.0, 183.0,0.0,0.0,0.0, 185.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 189.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 201.0,0.0,0.0,0.0, 202.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 204.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 206.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 206.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 204.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 202.0,0.0,0.0,0.0, 201.0,0.0,0.0,0.0, 201.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 197.0,0.0,0.0,0.0, 197.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 197.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 202.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 204.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 206.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 213.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 217.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 220.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 223.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 234.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 244.0,0.0,0.0,0.0, 245.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 249.0,0.0,0.0,0.0, 251.0,0.0,0.0,0.0, 253.0,0.0,0.0,0.0, 255.0]),
        "g": new Float32Array([0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 1.0,0.0,0.0,0.0, 1.0,0.0,0.0,0.0, 2.0,0.0,0.0,0.0, 2.0,0.0,0.0,0.0, 3.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 5.0,0.0,0.0,0.0, 6.0,0.0,0.0,0.0, 6.0,0.0,0.0,0.0, 7.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 9.0,0.0,0.0,0.0, 10.0,0.0,0.0,0.0, 11.0,0.0,0.0,0.0, 11.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 13.0,0.0,0.0,0.0, 14.0,0.0,0.0,0.0, 15.0,0.0,0.0,0.0, 17.0,0.0,0.0,0.0, 18.0,0.0,0.0,0.0, 19.0,0.0,0.0,0.0, 20.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 24.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 26.0,0.0,0.0,0.0, 28.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 31.0,0.0,0.0,0.0, 32.0,0.0,0.0,0.0, 34.0,0.0,0.0,0.0, 35.0,0.0,0.0,0.0, 37.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 41.0,0.0,0.0,0.0, 43.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 52.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 58.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 62.0,0.0,0.0,0.0, 64.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 69.0,0.0,0.0,0.0, 71.0,0.0,0.0,0.0, 73.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 79.0,0.0,0.0,0.0, 81.0,0.0,0.0,0.0, 83.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 86.0,0.0,0.0,0.0, 88.0,0.0,0.0,0.0, 89.0,0.0,0.0,0.0, 91.0,0.0,0.0,0.0, 92.0,0.0,0.0,0.0, 94.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 98.0,0.0,0.0,0.0, 99.0,0.0,0.0,0.0, 101.0,0.0,0.0,0.0, 102.0,0.0,0.0,0.0, 103.0,0.0,0.0,0.0, 104.0,0.0,0.0,0.0, 106.0,0.0,0.0,0.0, 107.0,0.0,0.0,0.0, 108.0,0.0,0.0,0.0, 109.0,0.0,0.0,0.0, 110.0,0.0,0.0,0.0, 111.0,0.0,0.0,0.0, 112.0,0.0,0.0,0.0, 113.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 115.0,0.0,0.0,0.0, 116.0,0.0,0.0,0.0, 116.0,0.0,0.0,0.0, 117.0,0.0,0.0,0.0, 118.0,0.0,0.0,0.0, 118.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 123.0,0.0,0.0,0.0, 123.0,0.0,0.0,0.0, 124.0,0.0,0.0,0.0, 124.0,0.0,0.0,0.0, 125.0,0.0,0.0,0.0, 125.0,0.0,0.0,0.0, 126.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 128.0,0.0,0.0,0.0, 129.0,0.0,0.0,0.0, 130.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 132.0,0.0,0.0,0.0, 133.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 137.0,0.0,0.0,0.0, 138.0,0.0,0.0,0.0, 139.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 142.0,0.0,0.0,0.0, 143.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 146.0,0.0,0.0,0.0, 147.0,0.0,0.0,0.0, 149.0,0.0,0.0,0.0, 150.0,0.0,0.0,0.0, 152.0,0.0,0.0,0.0, 154.0,0.0,0.0,0.0, 155.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 158.0,0.0,0.0,0.0, 160.0,0.0,0.0,0.0, 162.0,0.0,0.0,0.0, 164.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 167.0,0.0,0.0,0.0, 169.0,0.0,0.0,0.0, 171.0,0.0,0.0,0.0, 172.0,0.0,0.0,0.0, 174.0,0.0,0.0,0.0, 176.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 180.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 183.0,0.0,0.0,0.0, 185.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 189.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 193.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 202.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 213.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 216.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 219.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 228.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 237.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 244.0,0.0,0.0,0.0, 244.0,0.0,0.0,0.0, 245.0,0.0,0.0,0.0, 246.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 248.0,0.0,0.0,0.0, 248.0,0.0,0.0,0.0, 249.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 251.0,0.0,0.0,0.0, 251.0,0.0,0.0,0.0, 252.0,0.0,0.0,0.0, 252.0,0.0,0.0,0.0, 253.0,0.0,0.0,0.0, 253.0,0.0,0.0,0.0, 254.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0]),
        "b": new Float32Array([0.0,0.0,0.0,0.0, 1.0,0.0,0.0,0.0, 3.0,0.0,0.0,0.0, 4.0,0.0,0.0,0.0, 6.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 9.0,0.0,0.0,0.0, 11.0,0.0,0.0,0.0, 13.0,0.0,0.0,0.0, 15.0,0.0,0.0,0.0, 17.0,0.0,0.0,0.0, 19.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 25.0,0.0,0.0,0.0, 27.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 31.0,0.0,0.0,0.0, 33.0,0.0,0.0,0.0, 35.0,0.0,0.0,0.0, 37.0,0.0,0.0,0.0, 39.0,0.0,0.0,0.0, 41.0,0.0,0.0,0.0, 43.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 52.0,0.0,0.0,0.0, 54.0,0.0,0.0,0.0, 56.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 62.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 65.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 69.0,0.0,0.0,0.0, 70.0,0.0,0.0,0.0, 71.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 73.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 75.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 77.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 75.0,0.0,0.0,0.0, 75.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 73.0,0.0,0.0,0.0, 73.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 71.0,0.0,0.0,0.0, 70.0,0.0,0.0,0.0, 69.0,0.0,0.0,0.0, 68.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 66.0,0.0,0.0,0.0, 65.0,0.0,0.0,0.0, 64.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 61.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 58.0,0.0,0.0,0.0, 58.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 56.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 54.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 52.0,0.0,0.0,0.0, 51.0,0.0,0.0,0.0, 51.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 49.0,0.0,0.0,0.0, 49.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 46.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 49.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 51.0,0.0,0.0,0.0, 52.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 56.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 60.0,0.0,0.0,0.0, 62.0,0.0,0.0,0.0, 64.0,0.0,0.0,0.0, 65.0,0.0,0.0,0.0, 67.0,0.0,0.0,0.0, 69.0,0.0,0.0,0.0, 71.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 81.0,0.0,0.0,0.0, 83.0,0.0,0.0,0.0, 86.0,0.0,0.0,0.0, 88.0,0.0,0.0,0.0, 91.0,0.0,0.0,0.0, 94.0,0.0,0.0,0.0, 96.0,0.0,0.0,0.0, 99.0,0.0,0.0,0.0, 102.0,0.0,0.0,0.0, 105.0,0.0,0.0,0.0, 108.0,0.0,0.0,0.0, 111.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 117.0,0.0,0.0,0.0, 120.0,0.0,0.0,0.0, 124.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 130.0,0.0,0.0,0.0, 133.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 143.0,0.0,0.0,0.0, 146.0,0.0,0.0,0.0, 149.0,0.0,0.0,0.0, 153.0,0.0,0.0,0.0, 156.0,0.0,0.0,0.0, 159.0,0.0,0.0,0.0, 162.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 169.0,0.0,0.0,0.0, 172.0,0.0,0.0,0.0, 175.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 181.0,0.0,0.0,0.0, 184.0,0.0,0.0,0.0, 186.0,0.0,0.0,0.0, 189.0,0.0,0.0,0.0, 192.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 197.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 210.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 214.0,0.0,0.0,0.0, 216.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 220.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 234.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 236.0,0.0,0.0,0.0, 237.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 240.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 244.0,0.0,0.0,0.0, 245.0,0.0,0.0,0.0, 246.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 248.0,0.0,0.0,0.0, 249.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 252.0,0.0,0.0,0.0, 253.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0])
    }
    EOSB = {
        "r": new Float32Array([0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 9.0,0.0,0.0,0.0, 18.0,0.0,0.0,0.0, 27.0,0.0,0.0,0.0, 36.0,0.0,0.0,0.0, 45.0,0.0,0.0,0.0, 49.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 81.0,0.0,0.0,0.0, 91.0,0.0,0.0,0.0, 100.0,0.0,0.0,0.0, 109.0,0.0,0.0,0.0, 118.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 139.0,0.0,0.0,0.0, 163.0,0.0,0.0,0.0, 173.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 218.0,0.0,0.0,0.0, 227.0,0.0,0.0,0.0, 213.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 253.0,0.0,0.0,0.0, 251.0,0.0,0.0,0.0, 249.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 245.0,0.0,0.0,0.0, 243.0,0.0,0.0,0.0, 241.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 214.0,0.0,0.0,0.0, 235.0,0.0,0.0,0.0, 234.0,0.0,0.0,0.0, 232.0,0.0,0.0,0.0, 230.0,0.0,0.0,0.0, 228.0,0.0,0.0,0.0, 226.0,0.0,0.0,0.0, 224.0,0.0,0.0,0.0, 222.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 216.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 213.0,0.0,0.0,0.0, 211.0,0.0,0.0,0.0, 209.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 205.0,0.0,0.0,0.0, 203.0,0.0,0.0,0.0, 181.0,0.0,0.0,0.0, 179.0,0.0,0.0,0.0, 197.0,0.0,0.0,0.0, 196.0,0.0,0.0,0.0, 194.0,0.0,0.0,0.0, 192.0,0.0,0.0,0.0, 190.0,0.0,0.0,0.0, 188.0,0.0,0.0,0.0, 186.0,0.0,0.0,0.0, 184.0,0.0,0.0,0.0, 164.0,0.0,0.0,0.0, 162.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 176.0,0.0,0.0,0.0, 175.0,0.0,0.0,0.0, 173.0,0.0,0.0,0.0, 171.0,0.0,0.0,0.0, 169.0,0.0,0.0,0.0, 167.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 147.0,0.0,0.0,0.0, 145.0,0.0,0.0,0.0, 159.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 156.0,0.0,0.0,0.0, 154.0,0.0,0.0,0.0, 152.0,0.0,0.0,0.0, 150.0,0.0,0.0,0.0, 148.0,0.0,0.0,0.0, 146.0,0.0,0.0,0.0, 130.0,0.0,0.0,0.0, 128.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 138.0,0.0,0.0,0.0, 137.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 133.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 129.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 113.0,0.0,0.0,0.0, 111.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 117.0,0.0,0.0,0.0, 117.0,0.0,0.0,0.0]),
        "g": new Float32Array([0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 7.0,0.0,0.0,0.0, 15.0,0.0,0.0,0.0, 23.0,0.0,0.0,0.0, 31.0,0.0,0.0,0.0, 39.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 64.0,0.0,0.0,0.0, 79.0,0.0,0.0,0.0, 87.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 103.0,0.0,0.0,0.0, 111.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 129.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 159.0,0.0,0.0,0.0, 167.0,0.0,0.0,0.0, 175.0,0.0,0.0,0.0, 183.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 200.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 250.0,0.0,0.0,0.0, 246.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 198.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 208.0,0.0,0.0,0.0, 204.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 160.0,0.0,0.0,0.0, 156.0,0.0,0.0,0.0, 169.0,0.0,0.0,0.0, 165.0,0.0,0.0,0.0, 161.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 153.0,0.0,0.0,0.0, 148.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 122.0,0.0,0.0,0.0, 118.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 125.0,0.0,0.0,0.0, 123.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 116.0,0.0,0.0,0.0, 114.0,0.0,0.0,0.0, 112.0,0.0,0.0,0.0, 99.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 106.0,0.0,0.0,0.0, 104.0,0.0,0.0,0.0, 102.0,0.0,0.0,0.0, 99.0,0.0,0.0,0.0, 97.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 93.0,0.0,0.0,0.0, 91.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 84.0,0.0,0.0,0.0, 82.0,0.0,0.0,0.0, 80.0,0.0,0.0,0.0, 78.0,0.0,0.0,0.0, 76.0,0.0,0.0,0.0, 74.0,0.0,0.0,0.0, 72.0,0.0,0.0,0.0, 70.0,0.0,0.0,0.0, 61.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 61.0,0.0,0.0,0.0, 59.0,0.0,0.0,0.0, 57.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 53.0,0.0,0.0,0.0, 50.0,0.0,0.0,0.0, 48.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 42.0,0.0,0.0,0.0, 40.0,0.0,0.0,0.0, 38.0,0.0,0.0,0.0, 36.0,0.0,0.0,0.0, 33.0,0.0,0.0,0.0, 31.0,0.0,0.0,0.0, 29.0,0.0,0.0,0.0, 27.0,0.0,0.0,0.0, 22.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 19.0,0.0,0.0,0.0, 16.0,0.0,0.0,0.0, 14.0,0.0,0.0,0.0, 12.0,0.0,0.0,0.0, 13.0,0.0,0.0,0.0, 8.0,0.0,0.0,0.0, 6.0,0.0,0.0,0.0, 3.0,0.0,0.0,0.0, 1.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0]),
        "b": new Float32Array([116.0,0.0,0.0,0.0, 121.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 131.0,0.0,0.0,0.0, 136.0,0.0,0.0,0.0, 140.0,0.0,0.0,0.0, 144.0,0.0,0.0,0.0, 148.0,0.0,0.0,0.0, 153.0,0.0,0.0,0.0, 157.0,0.0,0.0,0.0, 145.0,0.0,0.0,0.0, 149.0,0.0,0.0,0.0, 170.0,0.0,0.0,0.0, 174.0,0.0,0.0,0.0, 178.0,0.0,0.0,0.0, 182.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 191.0,0.0,0.0,0.0, 195.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 183.0,0.0,0.0,0.0, 187.0,0.0,0.0,0.0, 212.0,0.0,0.0,0.0, 216.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 229.0,0.0,0.0,0.0, 233.0,0.0,0.0,0.0, 238.0,0.0,0.0,0.0, 242.0,0.0,0.0,0.0, 221.0,0.0,0.0,0.0, 225.0,0.0,0.0,0.0, 255.0,0.0,0.0,0.0, 247.0,0.0,0.0,0.0, 239.0,0.0,0.0,0.0, 231.0,0.0,0.0,0.0, 223.0,0.0,0.0,0.0, 215.0,0.0,0.0,0.0, 207.0,0.0,0.0,0.0, 199.0,0.0,0.0,0.0, 172.0,0.0,0.0,0.0, 164.0,0.0,0.0,0.0, 175.0,0.0,0.0,0.0, 167.0,0.0,0.0,0.0, 159.0,0.0,0.0,0.0, 151.0,0.0,0.0,0.0, 143.0,0.0,0.0,0.0, 135.0,0.0,0.0,0.0, 127.0,0.0,0.0,0.0, 119.0,0.0,0.0,0.0, 100.0,0.0,0.0,0.0, 93.0,0.0,0.0,0.0, 95.0,0.0,0.0,0.0, 87.0,0.0,0.0,0.0, 79.0,0.0,0.0,0.0, 71.0,0.0,0.0,0.0, 63.0,0.0,0.0,0.0, 55.0,0.0,0.0,0.0, 47.0,0.0,0.0,0.0, 39.0,0.0,0.0,0.0, 28.0,0.0,0.0,0.0, 21.0,0.0,0.0,0.0, 15.0,0.0,0.0,0.0, 7.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0])


    }

}

const colorMap = new ColorMap();

/***/ }),

/***/ "./src/js/model/hipsnew/FoVHelper.js":
/*!*******************************************!*\
  !*** ./src/js/model/hipsnew/FoVHelper.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fovHelper: () => (/* binding */ fovHelper)
/* harmony export */ });

/**
 * @author Fabrizio Giordano (Fab77)
 */

class FoVHelper {

    constructor() {

    }

    getHiPSNorder(fov) {

        let order = 3;

        // if (fov >= 179) {
        //     order = 0;
        // } else if (fov >= 90) {
        //     order = 1;
        // } else if (fov >= 30) {
        //     order = 2;
        // } else if (fov >= 12.5) {
        //     order = 3;
        if (fov >= 179) {
            order = 0;
        } else if (fov >= 90) {
            order = 1;
        } else if (fov >= 30) {
            order = 2;
        } else if (fov >= 20) {
            order = 3;

        } else if (fov >= 6) {
            order = 4;
        } else if (fov >= 3.2) {
            order = 5;
        } else if (fov >= 1.6) {
            order = 6;
        } else if (fov >= 0.85) {
            order = 7;
        } else if (fov >= 0.42) {
            order = 8;
        } else if (fov >= 0.21) {
            order = 9;
        } else if (fov >= 0.12) {
            order = 10;
        } else if (fov >= 0.06) {
            order = 11;
        } else if (fov < 0.015) {
            order = 12;
        } else {
            order = 13;
        }
        return order;
    }

    getRADegSteps(fov) {


        let raStep = 0;
        let decStep = 0;

        if (fov >= 179) {
            raStep = 10;
            decStep = 10;
        } else if (fov >= 25) {
            raStep = 9;
            decStep = 9;
        } else if (fov >= 12.5) {
            raStep = 8;
            decStep = 8;
        } else if (fov >= 6) {
            raStep = 6;
            decStep = 6;
        } else if (fov >= 3.2) {
            raStep = 5;
            decStep = 5;
        } else if (fov >= 1.6) {
            raStep = 4;
            decStep = 4;
        } else if (fov >= 0.85) {
            raStep = 3;
            decStep = 3;
        } else if (fov >= 0.42) {
            raStep = 2;
            decStep = 2;
        } else if (fov >= 0.21) {
            raStep = 1;
            decStep = 1;
        } else if (fov >= 0.12) {
            raStep = 0.5;
            decStep = 0.5;
        } else if (fov >= 0.06) {
            raStep = 0.25;
            decStep = 0.25;
        } else {
            raStep = 10;
            decStep = 10;
        }
        return {
            "raStep": raStep,
            "decStep": decStep
        };
    }

    getRefOrder(order) {
        switch (order) {
            case 0:
            case 1:
            case 2:
            case 3:
                return order + 6;
            case 4:
            case 5:
            case 6:
            case 7:
                return order + 5;

            case 8:
                return order + 4;
            default:
                return order + 3;
        }
    }

    // getRefOrder(order) {
    //     switch (order) {
    //         case 0:
    //         case 1:
    //         case 2:
    //         case 3:
    //         case 4:
    //             return order + 7;
    //         case 5:
    //         case 6:
    //             return order + 6;
    //         case 7:
    //         case 8:
    //             return order + 5;
    //         default:
    //             return order + 4;
    //     }
    // }

}

const fovHelper = new FoVHelper();

/***/ }),

/***/ "./src/js/model/hipsnew/HPXGeometryCache.js":
/*!**************************************************!*\
  !*** ./src/js/model/hipsnew/HPXGeometryCache.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hpxGeometryCache: () => (/* binding */ hpxGeometryCache)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");



/**
 * the idea is to have one TileBuffer per HiPS, 
 * in order to permit the multi-HiPS and handling
 * limit on orders (global.order > hips.order)
 */
class HPXGeometryCache {

    _geometry;

    constructor() {

        this._orderGeometry = [];
        // this._geometry = new Map(); // <Xyf, [vertexPosition(20)]


        // let minutesToLiveInCache = 1;
        // this._cacheAliveMilliSeconds = minutesToLiveInCache * 60 * 1000;
        // setInterval(() => { this.cacheCleaner() }, 10000)

    }

    

    /**
     * 
     * @param {number} order 
     * @param {Xyf} xyf 
     */
    getGeometry(order, xyf) {
        if (this._orderGeometry[order] === undefined) {
            this._orderGeometry[order] = new Map()
            return null;
        }
        
        // if (!this._orderGeometry[order].has(xyf)) {
            // const vtp = this.setupPositionAndTexture(order, orderjump, parentXyf, x, y);
            // this._orderGeometry[order].get(xyf).push(vtp)
        // }

        return this._orderGeometry[order].get(xyf)

    }

    addGeometry(order, xyf, vecTexPosArray){
        if (this._orderGeometry[order] === undefined) {
            this._orderGeometry[order] = new Map()
        }
        this._orderGeometry[order].set(xyf, vecTexPosArray)

    }



}

const hpxGeometryCache = new HPXGeometryCache();


/***/ }),

/***/ "./src/js/model/hipsnew/HiPS.js":
/*!**************************************!*\
  !*** ./src/js/model/hipsnew/HiPS.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AbstractSkyEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbstractSkyEntity.js */ "./src/js/model/AbstractSkyEntity.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _FoVHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FoVHelper.js */ "./src/js/model/hipsnew/FoVHelper.js");
/* harmony import */ var _TileBuffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TileBuffer.js */ "./src/js/model/hipsnew/TileBuffer.js");
/* harmony import */ var _modules_dataexplorer_model_ColorMaps_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../modules/dataexplorer/model/ColorMaps.js */ "./src/js/modules/dataexplorer/model/ColorMaps.js");
/* harmony import */ var _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shaders/HiPSShaderProgram.js */ "./src/js/shaders/HiPSShaderProgram.js");
/* harmony import */ var _AncestorTile_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AncestorTile.js */ "./src/js/model/hipsnew/AncestorTile.js");
/* harmony import */ var _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./VisibleTilesManager.js */ "./src/js/model/hipsnew/VisibleTilesManager.js");
/* harmony import */ var _AllSky7_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AllSky7.js */ "./src/js/model/hipsnew/AllSky7.js");

/**
 * @author Fabrizio Giordano (Fab77)
 * @param in_radius - number
 * @param in_gl - GL context
 * @param in_position - array of double e.g. [0.0, 0.0, -7]
 */

// import { Healpix, Pointing, Vec3 } from "healpixjs";




// import RayPickingUtils from '../../utils/RayPickingUtils.js';





// import AllSky from './AllSky3.js';
// import AllSky from './AllSky3-pseudo.js';
// import AllSky from './AllSky4.js';
// import AllSky from './AllSky5.js';
// import AllSky from './AllSky6.js';


/**
 * HiPS always has pixels geometry in Norder3 ( => 768 tiles). 
 * Texture are always in Norder0 (12 in total). Texture generation is managed by Tile.js
 * Tile.js is in charge to merge all the images of displayed norder into a single Norder0 texture
 * The Norder0 texture will be split in 768 textures and assigned the the corrext pixel
 */
class HiPS extends _AbstractSkyEntity_js__WEBPACK_IMPORTED_MODULE_0__["default"] {

	_ancestorTiles;

	constructor(radius, position, xrad, yrad, name, baseurl, format, opacity, isgalactic, descriptor) {

		super(radius, position, xrad, yrad, name, descriptor.isGalactic);
		// super(radius, position, xrad, yrad, name, false);

		_TileBuffer_js__WEBPACK_IMPORTED_MODULE_3__.newTileBuffer.addHiPS(this);
		console.log("HiPS frame " + descriptor._hipsFrame)
		console.log("HiPS minOrder " + descriptor.minOrder)
		this._allSky = (descriptor.minOrder >= 3) ? true : false;




		this.samplerIdx = 0;

		this._descriptor = descriptor;

		this._format = format;

		this._baseurl = descriptor.url;
		this._maxorder = descriptor.maxOrder;
		this._minorder = descriptor.minOrder;

		this._viewmatrix = undefined;

		this.colorMapIdx = 0;

		this.initShaders();

		let fov = 180; // <== TODO this must be a constructor parameter

		let order = _FoVHelper_js__WEBPACK_IMPORTED_MODULE_2__.fovHelper.getHiPSNorder(fov);
		// this._tileBuffer = new TilesBuffer(this._descriptor, this._format, this.shaderProgram, this.samplerIdx, order, this);
		this._visibleorder = order;


		if (order > this._maxorder) {
			order = this._maxorder
		}


		this.visiblePixelByOrder = {
			"pixels": [],
			"order": order
		}

		//  TODO just use one tiles array. It will containes only on tile when allsky
		this._ancestorTiles = [];
		this._allSkyTile = null;
		
		// TODO check if Allsky HiPS.
		this._allSky = true
		if (this._allSky) {
			this._allSkyTile = new _AllSky7_js__WEBPACK_IMPORTED_MODULE_8__["default"](this)
		} else {
			for (let t = 0; t < 12; t++) {
				this._ancestorTiles.push(new _AncestorTile_js__WEBPACK_IMPORTED_MODULE_6__["default"](t, 0, this));
			}
		}

	}

	get maxOrder() {
		return this._maxorder;
	}

	get minOrder() {
		return this._minorder;
	}

	get baseURL() {
		return this._baseurl;
	}

	get format() {
		return this._format;
	}

	changeFormat(format) {
		this._format = format;
		this._tileBuffer.clearAll();
		this._tileBuffer._format = this._format;
		let pixelByOrder = _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.visibleTilesByOrder;
		this.updateTiles(pixelByOrder.pixels, pixelByOrder.order);
	}

	/**
	defined in the shader
	0 -> native
	1 -> planck
	2 -> cmb
	3 -> grayscale
	4 -> rainbow
	5 -> eosb
	6 -> cubehelix
	 * @param {ColorMaps} colorMap 
	 */
	changeColorMap(colorMap) {



		switch (colorMap.name) {
			case 'grayscale':
				// console.warn('Grayscale no t implemented yet');
				this.colorMapIdx = 1;
				_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.setGrayscaleShader();
				break;
			case 'planck':
				this.colorMapIdx = 2;
				_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.setColorMapShader(colorMap);
				break;
			case 'cmb':
				this.colorMapIdx = 3;
				_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.setColorMapShader(colorMap);
				break;

			case 'rainbow':
				this.colorMapIdx = 4;
				_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.setColorMapShader(colorMap);
				break;
			case 'eosb':
				this.colorMapIdx = 5;
				_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.setColorMapShader(colorMap);
				break;
			case 'cubehelix':
				this.colorMapIdx = 6;
				_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.setColorMapShader(colorMap);
				break;
			default:
				this.colorMapIdx = 0;
				_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.setNativeShader();
		}
	}

	addHiPS() {

	}

	initShaders() {
		_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.enableProgram();
		this.shaderProgram = _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_5__.hipsShaderProgram.shaderProgram;
	}




	updateTiles(caller) {
		caller.visiblePixelByOrder = _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.visibleTilesByOrder;
		const pixels = caller.visiblePixelByOrder.pixels;
		const order = caller.visiblePixelByOrder.order;
		caller._tileBuffer.updateTiles(pixels, order);

	}



	getCurrentHealpixOrder() {
		return this._visibleorder;
	}

	refresh() {

		this.refreshFoV(false);

		let fov = this.getMinFoV();
		this._visibleorder = _FoVHelper_js__WEBPACK_IMPORTED_MODULE_2__.fovHelper.getHiPSNorder(fov);
		if (this._visibleorder > this._maxorder) {
			this._visibleorder = this._maxorder
		}

	}

	/**
	 * 
	 * @param {*} pMatrix 
	 * @param {*} vMatrix 
	 * @param {boolean} cameraRotated 
	 */
	draw(pMatrix, vMatrix, cameraRotated) {
		this.refresh();

		if (this._allSky) {
			// TODO handle galactic
			if (this.isGalacticHips) {
				this._allSkyTile.draw(_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.galVisibleTilesByOrder.order, _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.galAncestorsMap, pMatrix, vMatrix, this.modelMatrix, this.colorMapIdx)
			} else {
				this._allSkyTile.draw(_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.visibleTilesByOrder.order, _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.ancestorsMap, pMatrix, vMatrix, this.modelMatrix, this.colorMapIdx)
			}
			
		} else {
			if (this.isGalacticHips) {
				this._ancestorTiles.forEach((ancestor) => {
					ancestor.draw(_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.galVisibleTilesByOrder.order, _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.galAncestorsMap, pMatrix, vMatrix, this.modelMatrix, this.colorMapIdx);
				})
			} else {
				this._ancestorTiles.forEach((ancestor) => {
					ancestor.draw(_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.visibleTilesByOrder.order, _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_7__.newVisibleTilesManager.ancestorsMap, pMatrix, vMatrix, this.modelMatrix, this.colorMapIdx);
				})
			}

		}




	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HiPS);

/***/ }),

/***/ "./src/js/model/hipsnew/Tile2.js":
/*!***************************************!*\
  !*** ./src/js/model/hipsnew/Tile2.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var wcslight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wcslight */ "./node_modules/wcslight/lib-esm/index.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shaders/HiPSShaderProgram.js */ "./src/js/shaders/HiPSShaderProgram.js");
/* harmony import */ var _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileBuffer.js */ "./src/js/model/hipsnew/TileBuffer.js");
/* harmony import */ var _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VisibleTilesManager.js */ "./src/js/model/hipsnew/VisibleTilesManager.js");
/* harmony import */ var _FoVHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FoVHelper.js */ "./src/js/model/hipsnew/FoVHelper.js");
/* harmony import */ var _HPXGeometryCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./HPXGeometryCache.js */ "./src/js/model/hipsnew/HPXGeometryCache.js");










class Tile {

    _hips;
    _tilebuffer;
    _tileno;
    _baseurl;
    _order;

    // constructor(tileno, descriptor, format, order, shaderprogram, tilebuffer, hips, samplerIdx) {
    constructor(tileno, order, hips) {

        this._ready = false;
        this._abort = false;

        this._hips = hips;
        this._tileno = tileno;

        this._format = hips.format;
        this._baseurl = hips.baseURL;
        this._maxorder = hips.maxOrder;
        this._minorder = hips.minOrder;
        this._isGalacticHips = hips.isGalacticHips;

        this._order = order;

        this.opacity = 1.00;

        this._hipsShaderIndex = 0; // <== used for multi hips 
        this._pixels = [];

        this._texture = undefined;

        this._cacheTime0 = undefined;

        this._inView = true;

        // setTimeout(() => {
        //     this.amIStillInFoV()
        // }, 1000);
        this._amIStillInFoV_requsetID = setInterval( () => { this.amIStillInFoV() }, 5000);

        this.initImage();
    }

    destroyIntervals(){
        clearInterval(this._amIStillInFoV_requsetID);
    }

    get cacheTime0() {
        return this._cacheTime0
    }

    resetCacheTime0(){
        this._cacheTime0 = undefined
    }

    setCacheTime0(){
        this._cacheTime0 = new Date().getTime()
    }

    initImage() {

        this._image = new Image();
        this._downloading = true;
        this._imageLoaded = false;

        let dirnumber = Math.floor(this._tileno / 10000) * 10000;
        this._texurl = this._baseurl + "/Norder";
        this._texurl += this._order + "/Dir" + dirnumber + "/Npix" + this._tileno + "." + this._format;

        this._image.onload = () => {
            this.imageLoaded();

        };
        this._image.onerror = () => {
            console.error("File not found? {}", this._texurl)
            this._ready = false;
            this._abort = true;
        };

        this._image.setAttribute('crossorigin', 'anonymous');
        this._image.src = this._texurl;
        // this.loadImage();

    }

    imageLoaded() {
        this._imageLoaded = true;
        this._downloading = false;
        
        this.textureLoaded();
        this.initModelBuffer();

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texImage2D(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, 0, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.RGBA, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.RGBA, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNSIGNED_BYTE, this._image);
        // global.gl.generateMipmap(global.gl.TEXTURE_2D);
        this._textureLoaded = true;

        if (this._textureLoaded) {
            this._ready = true;
        }

    }



    textureLoaded() {

        _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.enableProgram();

        this._texture = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createTexture();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.pixelStorei(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNPACK_FLIP_Y_WEBGL, true);
        // global.gl.pixelStorei(global.gl.UNPACK_FLIP_Y_WEBGL, false);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);

        // from WW
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_WRAP_S, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.CLAMP_TO_EDGE);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_WRAP_T, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.CLAMP_TO_EDGE);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_S, global.gl.CLAMP_TO_BORDER);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_T, global.gl.CLAMP_TO_BORDER);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_S, global.gl.CLAMP);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_WRAP_T, global.gl.CLAMP);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_MIN_FILTER, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINEAR);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.texParameteri(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_MAG_FILTER, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.LINEAR);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_MIN_FILTER, global.gl.GL_LINEAR_MIPMAP_LINEAR);
        // global.gl.texParameteri(global.gl.TEXTURE_2D, global.gl.TEXTURE_MAG_FILTER, global.gl.GL_LINEAR);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniform1i(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.shaderProgram.samplerUniform, this._hipsShaderIndex);

        if (!_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.isTexture(this._texture)) {
            console.log("error in texture");
        }

    }

    initModelBuffer() {

        this.vertexPosition = [];
        this.vertexPositionBuffer = [];
        this.vertexIndices = [];
        this.vertexIndexBuffer = [];

        const reforder = _FoVHelper_js__WEBPACK_IMPORTED_MODULE_6__.fovHelper.getRefOrder(this._order);

        const orighealpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(this._order)
        // let orighealpix = new Healpix(2 ** this._order);
        const origxyf = orighealpix.nest2xyf(this._tileno);

        const orderjump = reforder - this._order;

        // let dxmin = origxyf.ix * Math.pow(2, orderjump);
        // let dxmax = (origxyf.ix * Math.pow(2, orderjump)) + Math.pow(2, orderjump);
        // let dymin = origxyf.iy * Math.pow(2, orderjump);
        // let dymax = (origxyf.iy * Math.pow(2, orderjump)) + Math.pow(2, orderjump);

        const dxmin = origxyf.ix << orderjump;
        const dxmax = (origxyf.ix << orderjump) + (1 << orderjump);
        const dymin = origxyf.iy << orderjump;
        const dymax = (origxyf.iy << orderjump) + (1 << orderjump);

        const healpix = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].getHealpix(reforder)
        // let healpix = new Healpix(2 ** reforder);

        this._pixels = [];
        this.setupPositionAndTexture4Quadrant2(dxmin, dxmin + (dxmax - dxmin) / 2, dymin, dymin + (dymax - dymin) / 2, 0, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant2(dxmin + (dxmax - dxmin) / 2, dxmax, dymin, dymin + (dymax - dymin) / 2, 1, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant2(dxmin, dxmin + (dxmax - dxmin) / 2, dymin + (dymax - dymin) / 2, dymax, 2, healpix, orderjump, origxyf);
        this.setupPositionAndTexture4Quadrant2(dxmin + (dxmax - dxmin) / 2, dxmax, dymin + (dymax - dymin) / 2, dymax, 3, healpix, orderjump, origxyf);

        // this.setupPositionAndTexture4Quadrant(dxmin, dxmin + (dxmax - dxmin) / 2, dymin, dymin + (dymax - dymin) / 2, 0, healpix, orderjump, origxyf);
        // this.setupPositionAndTexture4Quadrant(dxmin + (dxmax - dxmin) / 2, dxmax, dymin, dymin + (dymax - dymin) / 2, 1, healpix, orderjump, origxyf);
        // this.setupPositionAndTexture4Quadrant(dxmin, dxmin + (dxmax - dxmin) / 2, dymin + (dymax - dymin) / 2, dymax, 2, healpix, orderjump, origxyf);
        // this.setupPositionAndTexture4Quadrant(dxmin + (dxmax - dxmin) / 2, dxmax, dymin + (dymax - dymin) / 2, dymax, 3, healpix, orderjump, origxyf);

        // let pixelsXQuadrant = this._pixels.length / 4;
        let pixelsXQuadrant = this.vertexPosition[0].length / 20;
        this.vertexIndices = this.computeVertexIndices(pixelsXQuadrant);
        this.vertexIndexBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndices, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);

        // global.gl.activeTexture(global.gl.TEXTURE0 + this._hipsShaderIndex);
        // global.gl.bindTexture(global.gl.TEXTURE_2D, this._texture);
        // global.gl.texImage2D(global.gl.TEXTURE_2D, 0, global.gl.RGBA, global.gl.RGBA, global.gl.UNSIGNED_BYTE, this._image);
        // this._textureLoaded = true;

    }

    computeVertexIndices(pixelsXQuadrant) {
        let vertexIndices = new Uint16Array(6 * pixelsXQuadrant);
        let baseFaceIndex = 0;
        for (let j = 0; j < pixelsXQuadrant; j++) {

            vertexIndices[6 * j] = baseFaceIndex;
            vertexIndices[6 * j + 1] = baseFaceIndex + 1;
            vertexIndices[6 * j + 2] = baseFaceIndex + 2;

            vertexIndices[6 * j + 3] = baseFaceIndex + 2;
            vertexIndices[6 * j + 4] = baseFaceIndex + 3;
            vertexIndices[6 * j + 5] = baseFaceIndex;

            baseFaceIndex = baseFaceIndex + 4;

        }
        return vertexIndices;
    }

    setupPositionAndTexture4Quadrant2(dxmin, dxmax, dymin, dymax, qidx, healpix, orderjump, origxyf) {

        let facesVec3Array = new Array();
        this.vertexPosition[qidx] = new Float32Array(20 * (dxmax - dxmin) * (dymax - dymin));

        // const imgW = this._image.width
        // const pxSizeST = 1 / imgW
        // const pxXSubTile = imgW / (2 ** orderjump)
        // const step = pxXSubTile * pxSizeST

        let step = 1 / (1 << orderjump);
        let uindex = 0;
        let vindex = 0;
        let p = 0;

        const s_pixel_size = 0
        const t_pixel_size = 0

        for (let dx = dxmin; dx < dxmax; dx++) {
            for (let dy = dymin; dy < dymax; dy++) {
        
                facesVec3Array = healpix.getPointsForXyfNoStep(dx, dy, origxyf.face);
                uindex = dy - (origxyf.iy << orderjump);
                vindex = dx - (origxyf.ix << orderjump);

                this.vertexPosition[qidx][20 * p] = facesVec3Array[0].x;
                this.vertexPosition[qidx][20 * p + 1] = facesVec3Array[0].y;
                this.vertexPosition[qidx][20 * p + 2] = facesVec3Array[0].z;
                this.vertexPosition[qidx][20 * p + 3] = step + (step * uindex) + s_pixel_size
                this.vertexPosition[qidx][20 * p + 4] = 1 - (step + step * vindex) - t_pixel_size 

                this.vertexPosition[qidx][20 * p + 5] = facesVec3Array[1].x;
                this.vertexPosition[qidx][20 * p + 6] = facesVec3Array[1].y;
                this.vertexPosition[qidx][20 * p + 7] = facesVec3Array[1].z;
                this.vertexPosition[qidx][20 * p + 8] = step + (step * uindex) + s_pixel_size
                this.vertexPosition[qidx][20 * p + 9] = 1 - (step * vindex) + t_pixel_size 

                this.vertexPosition[qidx][20 * p + 10] = facesVec3Array[2].x;
                this.vertexPosition[qidx][20 * p + 11] = facesVec3Array[2].y;
                this.vertexPosition[qidx][20 * p + 12] = facesVec3Array[2].z;
                this.vertexPosition[qidx][20 * p + 13] = step * uindex - s_pixel_size
                this.vertexPosition[qidx][20 * p + 14] = 1 - (step * vindex) + t_pixel_size 

                this.vertexPosition[qidx][20 * p + 15] = facesVec3Array[3].x;
                this.vertexPosition[qidx][20 * p + 16] = facesVec3Array[3].y;
                this.vertexPosition[qidx][20 * p + 17] = facesVec3Array[3].z;
                this.vertexPosition[qidx][20 * p + 18] = step * uindex - s_pixel_size
                this.vertexPosition[qidx][20 * p + 19] = 1 - (step + step * vindex) - t_pixel_size 
                p++;
            }
        }

        this.vertexPositionBuffer[qidx] = _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.createBuffer();
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPositionBuffer[qidx]);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPosition[qidx], _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.STATIC_DRAW);

    }


    get inView(){
        return this._inView;
    }
    

    amIStillInFoV() {
        if (this._textureLoaded) {
            this._ready = true;
        }

        if (this._isGalacticHips){
            if (_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.galAncestorsMap.has(this._order)) {
                if (!_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.galAncestorsMap.get(this._order).includes(this._tileno)) {
                    _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.moveTileToCache(this._tileno, this._order, this._hips);
                    this._inView = false;
                } else {
                    this._inView = true;
                }
            } 
            
            if (this._order == _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.visibleOrder) {
             
                if (!_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.galVisibleTilesByOrder.pixels.includes(this._tileno)) {
                    _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.moveTileToCache(this._tileno, this._order, this._hips);
                    this._inView = false;
                } else {
                    this._inView = true;
                }
            
            }
        } else {
            if (_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.ancestorsMap.has(this._order)) {
                if (!_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.ancestorsMap.get(this._order).includes(this._tileno)) {
                    _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.moveTileToCache(this._tileno, this._order, this._hips);
                    this._inView = false;
                } else {
                    this._inView = true;
                }
            } 
            
            if (this._order == _VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.visibleOrder) {
             
                if (!_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_5__.newVisibleTilesManager.visibleTilesByOrder.pixels.includes(this._tileno)) {
                    _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.moveTileToCache(this._tileno, this._order, this._hips);
                    this._inView = false;
                } else {
                    this._inView = true;
                }
            
            }
        }

    }


    draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx) {

        if (!this._ready || this._abort) {
            return;
        }

        let quadrantsToDraw = new Set([0, 1, 2, 3]);
        if (visibleOrder > this._order && this._order < this._maxorder) {
            quadrantsToDraw = this.drawChildren(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx);
        }

        _shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.enableShaders(pMatrix, vMatrix, mMatrix, colorMapIdx);
        // TODO check if the enable below can be moved into hipsShaderProgram.enableShaders
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.enableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.vertexPositionAttribute);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.enableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureCoordAttribute);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.activeTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE0 + this._hipsShaderIndex);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindTexture(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TEXTURE_2D, this._texture);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.uniform1f(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureAlpha, this.opacity);

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        let elemno = this.vertexIndices.length;

        quadrantsToDraw.forEach((qidx) => {
            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.ARRAY_BUFFER, this.vertexPositionBuffer[qidx]);

            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.vertexAttribPointer(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.vertexPositionAttribute, 3, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FLOAT, false, 5 * 4, 0);
            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.vertexAttribPointer(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureCoordAttribute, 2, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.FLOAT, false, 5 * 4, 3 * 4);

            _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.drawElements(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.TRIANGLES, elemno, _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.UNSIGNED_SHORT, 0);
        });

        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.disableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.vertexPositionAttribute);
        _Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].gl.disableVertexAttribArray(_shaders_HiPSShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__.hipsShaderProgram.locations.textureCoordAttribute);
        
    }


    drawChildren(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx) {

        let quadrantsToDraw = new Set([0, 1, 2, 3]);
        let childrenOrder = this._order + 1;
        if (!visibleTilesMap.has(childrenOrder)) {
            return;
        }
        for (let c = 0; c < 4; c++) {
            let childTileNo = (this._tileno << 2) + c;
            if (visibleTilesMap.get(childrenOrder).includes(childTileNo)) {
                let childTile = undefined
                if (this._isGalacticHips){
                    childTile = _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.getGalTile(childTileNo, childrenOrder, this._hips);
                }else{
                    childTile = _TileBuffer_js__WEBPACK_IMPORTED_MODULE_4__.newTileBuffer.getTile(childTileNo, childrenOrder, this._hips);
                }

                
                childTile.draw(visibleOrder, visibleTilesMap, pMatrix, vMatrix, mMatrix, colorMapIdx);
                if (childTile._ready) {
                    quadrantsToDraw.delete(childTile._tileno - (this._tileno << 2));
                }

            }
        }
        return quadrantsToDraw;
    }

    // getRefOrder() {
    //     switch (this._order) {
    //         case 0:
    //         case 1:
    //         case 2:
    //         case 3:
    //         case 4:
    //             return this._order + 5;
    //         case 5:
    //         case 6:
    //             return this._order + 6;
    //         case 7:
    //         case 8:
    //             return this._order + 5;
    //         default:
    //             return this._order + 4;
    //     }
    // }


}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tile);

/***/ }),

/***/ "./src/js/model/hipsnew/TileBuffer.js":
/*!********************************************!*\
  !*** ./src/js/model/hipsnew/TileBuffer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   newTileBuffer: () => (/* binding */ newTileBuffer)
/* harmony export */ });
/* harmony import */ var _hipsnew_Tile2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hipsnew/Tile2.js */ "./src/js/model/hipsnew/Tile2.js");


/**
 * the idea is to have one TileBuffer per HiPS, 
 * in order to permit the multi-HiPS and handling
 * limit on orders (global.order > hips.order)
 */
class TileBuffer {

    _tiles;
    _ancestorTiles;
    _cachedTiles;
    _activeHiPS;

    constructor() {
        this._tiles = new Map();;
        this._cachedTiles = new Map();
        this._activeHiPS = new Map();
        
        this._galTiles = new Map();;
        this._galCachedTiles = new Map();
        this._galActiveHiPS = new Map();

        let minutesToLiveInCache = 1;
        this._cacheAliveMilliSeconds = minutesToLiveInCache * 60 * 1000; 

        setInterval( () => { this.cacheCleaner() }, 10000)
    }


    addHiPS(hips) {
        if (this._activeHiPS.has(hips)) {
            console.error("HiPS already present in TileBuffer")
            return;
        }
        this._activeHiPS.set(hips, new Map());
    }

    addGalHiPS(hips) {
        if (this._galActiveHiPS.has(hips)) {
            console.error("HiPS already present in TileBuffer")
            return;
        }
        this._galActiveHiPS.set(hips, new Map());
    }

    addTile(order, tileno) {
        for (const [hips, tiles] of Object.entries(this._activeHiPS)) {
            this.getTile(tileno, order, hips);
        }
    }
    
    addGalTile(order, tileno) {
        for (const [hips, tiles] of Object.entries(this._galActiveHiPS)) {
            this.getTile(tileno, order, hips);
        }
    }

    getTile(tileno, order, hips) {
        const tileKey = order + "#" + tileno + "#" + hips.baseURL;

        if (!this._tiles.has(tileKey)) {
            if (this._cachedTiles.has(tileKey)) {
                let tile = this._cachedTiles.get(tileKey)
                this._tiles.set(tileKey, tile);
                this._cachedTiles.delete(tileKey);
                tile.resetCacheTime0()
            } else {
                const tile = new _hipsnew_Tile2_js__WEBPACK_IMPORTED_MODULE_0__["default"](tileno, order, hips);
                this._tiles.set(tileKey, tile);
            }
        }
        return this._tiles.get(tileKey);
    }

    getGalTile(tileno, order, hips) {
        const tileKey = order + "#" + tileno + "#" + hips.baseURL;

        if (!this._galTiles.has(tileKey)) {
            if (this._galCachedTiles.has(tileKey)) {
                let tile = this._galCachedTiles.get(tileKey)
                this._galTiles.set(tileKey, tile);
                this._galCachedTiles.delete(tileKey);
                tile.resetCacheTime0()
            } else {
                const tile = new _hipsnew_Tile2_js__WEBPACK_IMPORTED_MODULE_0__["default"](tileno, order, hips);
                this._galTiles.set(tileKey, tile);
            }
        }
        return this._galTiles.get(tileKey);
    }

    moveTileToCache(tileno, order, hips){
        const tileKey = order + "#" + tileno + "#" + hips.baseURL;

        if (this._tiles.has(tileKey)) {
            // console.log(`moveTileToCache: ${tileKey}`)
            let tile = this._tiles.get(tileKey)
            tile.setCacheTime0()
            this._cachedTiles.set(tileKey, tile);
            this._tiles.delete(tileKey);
        }
        if (this._galTiles.has(tileKey)) {
            // console.log(`moveTileToCache: ${tileKey}`)
            let tile = this._galTiles.get(tileKey)
            tile.setCacheTime0()
            this._galCachedTiles.set(tileKey, tile);
            this._galTiles.delete(tileKey);
        }
    }

    cacheCleaner(){
        // console.log(this._cachedTiles)
        const now = new Date().getTime()
        for (const [tileKey, tile] of this._cachedTiles ) {
            if (!tile.inView && (now - tile.cacheTime0 > this._cacheAliveMilliSeconds) ){
                tile.destroyIntervals()
                this._cachedTiles.delete(tileKey)
            }
        }
        for (const [tileKey, tile] of this._galCachedTiles ) {
            if (!tile.inView && (now - tile.cacheTime0 > this._cacheAliveMilliSeconds) ){
                tile.destroyIntervals()
                this._galCachedTiles.delete(tileKey)
            }
        }
        // console.log(this._cachedTiles)
    }


}

const newTileBuffer = new TileBuffer();


/***/ }),

/***/ "./src/js/model/hipsnew/VisibleTilesManager.js":
/*!*****************************************************!*\
  !*** ./src/js/model/hipsnew/VisibleTilesManager.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   newVisibleTilesManager: () => (/* binding */ newVisibleTilesManager)
/* harmony export */ });
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/RayPickingUtils.js */ "./src/js/utils/RayPickingUtils.js");
/* harmony import */ var _TileBuffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TileBuffer.js */ "./src/js/model/hipsnew/TileBuffer.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec4.js");








class VisibleTilesManager {

	_visibleTilesByOrder;
	_ancestorsMap;
	healpixGrid;
	initialised;

	constructor() {
		this._visibleTilesByOrder = [];
		this._ancestorsMap = new Map();
		this.initialised = false;


		this._galVisibleTilesByOrder = [];
		this._galAncestorsMap = new Map();
		this._galacticMatrixInverted = gl_matrix__WEBPACK_IMPORTED_MODULE_4__.create();

		// for gal precision check Planck-2015-Pol-Synchrotron 168.6332 -61.4506
		// from https://observablehq.com/@fil/galactic-rotations
		gl_matrix__WEBPACK_IMPORTED_MODULE_4__.set(this._galacticMatrixInverted,
			-0.054876, -0.873437, -0.483835, 0,
			0.494109, -0.444830, 0.746982, -0,
			-0.867666, -0.198076, 0.455984, 0,
		  	0, 0, 0, 1);
		// mat4.set(this._galacticMatrixInverted,
		// 	-0.054875582456588745, -0.8734370470046997, -0.48383501172065735, 0,
		// 	0.49410945177078247, -0.4448296129703522, 0.7469822764396667, -0,
		// 	-0.8676661849021912, -0.19807636737823486, 0.4559837877750397, 0,
		// 	0, 0, 0, 1);

		/* [Ref. DOI https://doi.org/10.1051/0004-6361/201116947 
			J.-C. Liu1,2, Z. Zhu1,2 and B. Hu3,4
			Constructing a Galactic coordinate system based on near-infrared and radio catalogs]
			Method 1: z-axis fixed condition 2Mass
		*/
		// mat4.set(this._galacticMatrixInverted,
		// 	-0.05505347007, -0.8719028362, -0.4870643574, 0,
		// 	0.4897972973, -0.4466482209, 0.7487349160, -0,
		// 	-0.8703705255, -0.2007257110, 0.4496268868, 0,
		// 	0, 0, 0, 1);
		/* [Ref. DOI https://doi.org/10.1051/0004-6361/201116947 
			J.-C. Liu1,2, Z. Zhu1,2 and B. Hu3,4
			Constructing a Galactic coordinate system based on near-infrared and radio catalogs]
			Method 1: z-axis fixed condition Specfind
		*/
		// mat4.set(this._galacticMatrixInverted,
		// 	-0.0518807421, -0.8722226427, -0.4863497200, 0,
		// 	0.4846922369, -0.4477920852, 0.7513692061, -0,
		// 	-0.8731447899, -0.1967483417, 0.4459913295, 0,
		// 	0, 0, 0, 1);
		/* [Ref. DOI https://doi.org/10.1051/0004-6361/201116947 
			J.-C. Liu1,2, Z. Zhu1,2 and B. Hu3,4
			Constructing a Galactic coordinate system based on near-infrared and radio catalogs]
			Method 1: x-axis fixed condition 2MASS
		*/
		// mat4.set(this._galacticMatrixInverted,
		// 	-0.0546572359, -0.8728439269, -0.4849289286, 0,
		// 	0.4888603641, -0.4468595864, 0.7492209651, -0,
		// 	-0.8706481098, -0.1961121855, 0.4511229097, 0,
		// 	0, 0, 0, 1);
		/* [Ref. DOI https://doi.org/10.1051/0004-6361/201116947 
			J.-C. Liu1,2, Z. Zhu1,2 and B. Hu3,4
			Constructing a Galactic coordinate system based on near-infrared and radio catalogs]
			Method 1: x-axis fixed condition Specfind
		*/
		// mat4.set(this._galacticMatrixInverted,
		// 	-0.0546572359, -0.8728439269, -0.4849289286, 0,
		// 	0.4838685275, -0.4479748647, 0.7517910405, -0,
		// 	-0.8734322153, -0.1935510264, 0.4468267735, 0,
		// 	0, 0, 0, 1);
		this._galacticMatrix = new Map();
		gl_matrix__WEBPACK_IMPORTED_MODULE_4__.invert(this._galacticMatrix, this._galacticMatrixInverted)

	}

	init(healpixGrid) {
		this.healpixGrid = healpixGrid;
		this.initialised = true;
		this.computeVisiblePixels();
		setInterval(() => this.computeVisiblePixels(), 500);

	}

	getVisibleOrder(){
		return this.healpixGrid._visibleorder;
	}

	computeVisiblePixels() {

		if (!this.initialised) {
			return [];
		}

		let order = this.healpixGrid._visibleorder;
		if (_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].insideSphere){
			if (order < 3){
				order = 3;
			}
		}
		this._ancestorsMap.set(order, []);
		this._galAncestorsMap.set(order, []);
		let pixels = [];
		let galTiles = [];

		if (order == 0) {

			const geomhealpix = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].getHealpix(0);
			const npix = geomhealpix.getNPix();
			pixels = [npix];
			pixels.splice(0, npix);
			galTiles.splice(0, npix);
			for (let i = 0; i < npix; i++) {
				pixels.push(i);
				this._ancestorsMap.get(order).push(i);
			}
			for (let i = 0; i < npix; i++) {
				galTiles.push(i);
				this._galAncestorsMap.get(order).push(i);
			}
			
		} else {

			const geomhealpix = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].getHealpix(order);
			const maxX = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.canvas.width;
			const maxY = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.canvas.height;

			let intersectionWithModel;
			let intersectionPoint = null;
			let currP, currPixNo;
			let galVec, galPoint, galTileNo;

			// for (let i = 0; i <= maxX; i += maxX / 10) {
			// 	for (let j = 0; j <= maxY; j += maxY / 10) {
			for (let i = 0; i <= maxX; i += maxX / 30) {
				for (let j = 0; j <= maxY; j += maxY / 30) {

					intersectionWithModel = {
						"intersectionPoint": null,
						"pickedObject": null
					};



					intersectionWithModel = _utils_RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersectionPointWithSingleModel(i, j, this.healpixGrid);
					intersectionPoint = intersectionWithModel.intersectionPoint;

					if (intersectionPoint.length > 0) {


						galVec = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.create();
						gl_matrix__WEBPACK_IMPORTED_MODULE_5__.transformMat4(galVec, [intersectionPoint[0], intersectionPoint[1], intersectionPoint[2], 1], this._galacticMatrix)
						galPoint = new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Pointing(new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Vec3(galVec[0], galVec[1], galVec[2]));
						galTileNo = geomhealpix.ang2pix(galPoint);

						currP = new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Pointing(new healpixjs__WEBPACK_IMPORTED_MODULE_1__.Vec3(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2]));
						currPixNo = geomhealpix.ang2pix(currP);

						if (!pixels.includes(currPixNo)) {
							pixels.push(currPixNo)
							this._ancestorsMap.get(order).push(currPixNo);
							_TileBuffer_js__WEBPACK_IMPORTED_MODULE_3__.newTileBuffer.addTile(order, currPixNo);
						}

						if (!galTiles.includes(galTileNo)) {
							galTiles.push(galTileNo)
							this._galAncestorsMap.get(order).push(galTileNo);
							_TileBuffer_js__WEBPACK_IMPORTED_MODULE_3__.newTileBuffer.addGalTile(order, galTileNo);
						}

					}
				}
			}
		}

		this._visibleTilesByOrder = {
			"pixels": pixels,
			"order": order
		};
		this._galVisibleTilesByOrder = {
			"pixels": galTiles,
			"order": order
		};


		/**
		 * 1. visibleTileManager calls tileBuffer to create all visible tile, ancestor include
		 * 2. tileBuffer tries to get the requested tile from cache or tiles array and in case
		 * it generates one and add it to tiles array
		 * 3. when HiPS draws, calls Ancestor.draw
		 * 4. each Anchestor gets needed tiles by calling Tilebubber.get (which checks tiles array or cache)
		 * 5. each Tile called by Anchestor, will get needed tiles by calling Tilebubber.get (which checks tiles array or cache)
		 */


		for (let o = 1; o < order; o++) {
			this._ancestorsMap.set(order - o, []);
			for (let p = 0; p < pixels.length; p++) {
				let parent = pixels[p] >> (2 * o)
				if (!this._ancestorsMap.get(order - o).includes(parent)) {
					this._ancestorsMap.get(order - o).push(parent);
					_TileBuffer_js__WEBPACK_IMPORTED_MODULE_3__.newTileBuffer.addTile(order - o, parent);
				}
			}
		}

		for (let o = 1; o < order; o++) {
			this._galAncestorsMap.set(order - o, []);
			for (let p = 0; p < galTiles.length; p++) {
				let parent = galTiles[p] >> (2 * o)
				if (!this._galAncestorsMap.get(order - o).includes(parent)) {
					this._galAncestorsMap.get(order - o).push(parent);
					_TileBuffer_js__WEBPACK_IMPORTED_MODULE_3__.newTileBuffer.addGalTile(order - o, parent);
				}
			}
		}
		// if (global.insideSphere){
		// 	console.log(`Ancestors `)
		// 	console.log(this._ancestorsMap)

		// 	console.log(`VisibleTiles `)
		// 	console.log(this._visibleTilesByOrder)
		// }
	}

	get visibleTilesByOrder() {
		return this._visibleTilesByOrder;
	}

	get ancestorsMap() {
		return this._ancestorsMap;
	}

	get galVisibleTilesByOrder() {
		return this._galVisibleTilesByOrder;
	}

	get galAncestorsMap() {
		return this._galAncestorsMap;
	}

	get visibleOrder() {
		return this._visibleTilesByOrder.order;
	}
}


const newVisibleTilesManager = new VisibleTilesManager();

/***/ }),

/***/ "./src/js/modules/controlpanel/ControlPanelPresenter.js":
/*!**************************************************************!*\
  !*** ./src/js/modules/controlpanel/ControlPanelPresenter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/OpenPanelEvent.js */ "./src/js/events/OpenPanelEvent.js");
/* harmony import */ var _ControlPanelView_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ControlPanelView.js */ "./src/js/modules/controlpanel/ControlPanelView.js");
/* harmony import */ var _footprintpanel_FootprintPanelView_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./footprintpanel/FootprintPanelView.js */ "./src/js/modules/controlpanel/footprintpanel/FootprintPanelView.js");
/* harmony import */ var _footprintpanel_FootprintListPresenter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./footprintpanel/FootprintListPresenter.js */ "./src/js/modules/controlpanel/footprintpanel/FootprintListPresenter.js");
/* harmony import */ var _footprintpanel_events_FootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./footprintpanel/events/FootprintSettingsEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsEvent.js");
/* harmony import */ var _footprintpanel_FootprintSettingsView_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./footprintpanel/FootprintSettingsView.js */ "./src/js/modules/controlpanel/footprintpanel/FootprintSettingsView.js");
/* harmony import */ var _footprintpanel_FootprintSettingsPresenter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./footprintpanel/FootprintSettingsPresenter.js */ "./src/js/modules/controlpanel/footprintpanel/FootprintSettingsPresenter.js");
/* harmony import */ var _footprintpanel_events_CloseFootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./footprintpanel/events/CloseFootprintSettingsEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/CloseFootprintSettingsEvent.js");
/* harmony import */ var _hipspanel_HiPSPanelView_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hipspanel/HiPSPanelView.js */ "./src/js/modules/controlpanel/hipspanel/HiPSPanelView.js");
/* harmony import */ var _hipspanel_HiPSListPresenter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./hipspanel/HiPSListPresenter.js */ "./src/js/modules/controlpanel/hipspanel/HiPSListPresenter.js");
/* harmony import */ var _view_SettingsPanelView_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../view/SettingsPanelView.js */ "./src/js/view/SettingsPanelView.js");
/* harmony import */ var _presenter_SettingsPresenter_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../presenter/SettingsPresenter.js */ "./src/js/presenter/SettingsPresenter.js");
/* harmony import */ var _cutoutpanel_CutoutPanelView_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./cutoutpanel/CutoutPanelView.js */ "./src/js/modules/controlpanel/cutoutpanel/CutoutPanelView.js");
/* harmony import */ var _cutoutpanel_CutoutPanelPresenter_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cutoutpanel/CutoutPanelPresenter.js */ "./src/js/modules/controlpanel/cutoutpanel/CutoutPanelPresenter.js");
/* harmony import */ var _cutoutpanel_events_CloseCutoutCloseEvent_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./cutoutpanel/events/CloseCutoutCloseEvent.js */ "./src/js/modules/controlpanel/cutoutpanel/events/CloseCutoutCloseEvent.js");
/* harmony import */ var _cataloguepanel_CataloguePanelView_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cataloguepanel/CataloguePanelView.js */ "./src/js/modules/controlpanel/cataloguepanel/CataloguePanelView.js");
/* harmony import */ var _cataloguepanel_CatalogueListPresenter_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./cataloguepanel/CatalogueListPresenter.js */ "./src/js/modules/controlpanel/cataloguepanel/CatalogueListPresenter.js");
/* harmony import */ var _repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../repos/tap/TapRepoService.js */ "./src/js/repos/tap/TapRepoService.js");
/* harmony import */ var _cataloguepanel_events_CatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./cataloguepanel/events/CatalogueSettingsEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsEvent.js");
/* harmony import */ var _cataloguepanel_CatalogueSettingsView_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./cataloguepanel/CatalogueSettingsView.js */ "./src/js/modules/controlpanel/cataloguepanel/CatalogueSettingsView.js");
/* harmony import */ var _cataloguepanel_CatalogueSettingsPresenter_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./cataloguepanel/CatalogueSettingsPresenter.js */ "./src/js/modules/controlpanel/cataloguepanel/CatalogueSettingsPresenter.js");
/* harmony import */ var _cataloguepanel_events_CloseCatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./cataloguepanel/events/CloseCatalogueSettingsEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CloseCatalogueSettingsEvent.js");
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../utils/Session.js */ "./src/js/utils/Session.js");
/* harmony import */ var _gotopanel_GoToView_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./gotopanel/GoToView.js */ "./src/js/modules/controlpanel/gotopanel/GoToView.js");
/* harmony import */ var _gotopanel_GoToPresenter_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./gotopanel/GoToPresenter.js */ "./src/js/modules/controlpanel/gotopanel/GoToPresenter.js");
/* harmony import */ var _events_HiPSSelectedEvent_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../events/HiPSSelectedEvent.js */ "./src/js/events/HiPSSelectedEvent.js");
/* harmony import */ var _dataexplorer_DEView_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../dataexplorer/DEView.js */ "./src/js/modules/dataexplorer/DEView.js");
/* harmony import */ var _dataexplorer_DEPresenter_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../dataexplorer/DEPresenter.js */ "./src/js/modules/dataexplorer/DEPresenter.js");
/* harmony import */ var _events_OpenDataExplorerPanelEvent_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../../events/OpenDataExplorerPanelEvent.js */ "./src/js/events/OpenDataExplorerPanelEvent.js");
/**
 * @author Fabrizio Giordano (Fab)
 */





















// import HiPSSettingsView from './hipspanel/HiPSSettingsView.js';
// import HiPSSettingsPresenter from './hipspanel/HiPSSettingsPresenter.js';
// import HiPSSettingsEvent from "./hipspanel/events/HiPSSettingsEvent.js";
// import CloseHiPSSettingsEvent from "./hipspanel/events/CloseHiPSSettingsEvent.js";
























class ControlPanelPresenter{
	
	_view;
	_parentView;

	_gotoPresenter;
	_catalogueListPresenter;
	_footprintsListPresenter;
	_hipsListPresenter;
	_settingsPresenter;
	_cutoutPresenter;

	_catalogueRepo;
	_footprintRepo;
	_menuOpen = false;
	// _dataExplorerView;
	
	constructor(in_parentView){
		
		this._parentView = in_parentView;
		
		this._view  = new _ControlPanelView_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
		
		this.initPresenters();
		
		this._parentView.appendChild2(this._view.html);
		
		this.addButtonsClickHandlers();
		
		this.registerForEvents();

	}
	

	initPresenters(){

		let gotoView = new _gotopanel_GoToView_js__WEBPACK_IMPORTED_MODULE_26__["default"]();
		this.view.appendChild(gotoView.getHtml());
		this._gotoPresenter = new _gotopanel_GoToPresenter_js__WEBPACK_IMPORTED_MODULE_27__["default"](gotoView);
		

		let cataloguePanelView = new _cataloguepanel_CataloguePanelView_js__WEBPACK_IMPORTED_MODULE_18__["default"]();
		this._catalogueListPresenter = new _cataloguepanel_CatalogueListPresenter_js__WEBPACK_IMPORTED_MODULE_19__["default"](cataloguePanelView);
		this.view.appendChild(cataloguePanelView.getHtml());
		
		let footprintPanelView = new _footprintpanel_FootprintPanelView_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
		this._footprintsListPresenter = new _footprintpanel_FootprintListPresenter_js__WEBPACK_IMPORTED_MODULE_6__["default"](footprintPanelView);
		this.view.appendChild(footprintPanelView.getHtml());
		
		let tapUrls = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].getTAPProviders();
		for (let tapurl of tapUrls) {
			
			_repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_20__.tapRepoSingleton.addRepos(tapurl).then( (tapRepo) => {

				_utils_Session_js__WEBPACK_IMPORTED_MODULE_25__.session.addTapRepo(tapRepo);
				// TODO need to pass the TapRepo here that will be used in the _footprintsListPresenter->footprintPresenter->TapService.retrieveByFoV
				// this._catalogueListPresenter.addCatalogues(tapRepo.cataloguesList, tapurl);
				this._catalogueListPresenter.addCatalogues(tapRepo);
				this._footprintsListPresenter.addFootprintsSet(tapRepo);
				// this._footprintsListPresenter.addFootprintsSet(tapRepo.observationsList, tapurl);

				// TODO addNotClassified

			});
		}


		

		let hipsPanelView = new _hipspanel_HiPSPanelView_js__WEBPACK_IMPORTED_MODULE_11__["default"]();
		this.view.appendChild(hipsPanelView.getHtml());
		this._hipsListPresenter = new _hipspanel_HiPSListPresenter_js__WEBPACK_IMPORTED_MODULE_12__["default"](hipsPanelView);
		

		let settingsPanelView = new _view_SettingsPanelView_js__WEBPACK_IMPORTED_MODULE_13__["default"](_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].insideSphere);
		this._settingsPresenter = new _presenter_SettingsPresenter_js__WEBPACK_IMPORTED_MODULE_14__["default"](settingsPanelView);
		this.view.appendChild(settingsPanelView.getHtml());

		let cutoutPanelView = new _cutoutpanel_CutoutPanelView_js__WEBPACK_IMPORTED_MODULE_15__["default"]();
		this._cutoutPresenter = new _cutoutpanel_CutoutPanelPresenter_js__WEBPACK_IMPORTED_MODULE_16__["default"](cutoutPanelView);
		this.view.appendChild(cutoutPanelView.getHtml());
		
	}

	refreshRepos(){
		
		let tapUrls = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].getTAPProviders();
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_25__.session.clearTapRepoList();
		this._catalogueListPresenter.refreshCataloguesView();
		this._footprintsListPresenter.refreshCataloguesView();
		
		for (let tapurl of tapUrls) {
			
			_repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_20__.tapRepoSingleton.addRepos(tapurl).then( (tapRepo) => {
				
				_utils_Session_js__WEBPACK_IMPORTED_MODULE_25__.session.addTapRepo(tapRepo);
				this._catalogueListPresenter.addCatalogues(tapRepo);
				this._footprintsListPresenter.addFootprintsSet(tapRepo);
				
				// TODO addNotClassified

			});
		}
	}
	
	get view(){
        return this._view;
    }

	addButtonsClickHandlers(){
		jquery__WEBPACK_IMPORTED_MODULE_0__("#hamburgerButton").on("click", ()=>{
			this.menuOpen = !this.menuOpen;
			jquery__WEBPACK_IMPORTED_MODULE_0__("#hamburgerButton").toggleClass("open") 
			jquery__WEBPACK_IMPORTED_MODULE_0__("#gotoButton").toggleClass("controlButtonVisible");	
			jquery__WEBPACK_IMPORTED_MODULE_0__("#cataloguesButton").toggleClass("controlButtonVisible");	
			jquery__WEBPACK_IMPORTED_MODULE_0__("#footprintsButton").toggleClass("controlButtonVisible");	
			jquery__WEBPACK_IMPORTED_MODULE_0__("#mapsButton").toggleClass("controlButtonVisible");	
			jquery__WEBPACK_IMPORTED_MODULE_0__("#settingsButton").toggleClass("controlButtonVisible");
			jquery__WEBPACK_IMPORTED_MODULE_0__("#cutoutButton").toggleClass("controlButtonVisible");
			// $("#dataExplorerButton").toggleClass("controlButtonVisible");
			
			if(!this.menuOpen){
				this._catalogueListPresenter.view.close()
				this._footprintsListPresenter.view.close()
				this._hipsListPresenter.view.close()
				this._settingsPresenter.close()
				this._cutoutPresenter.close()
			}
		} );
		jquery__WEBPACK_IMPORTED_MODULE_0__("#gotoButton").on("click", function(){_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]("GoTo")) } );
		jquery__WEBPACK_IMPORTED_MODULE_0__("#cataloguesButton").on("click", function(){_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]("Catalogues")) } );
		jquery__WEBPACK_IMPORTED_MODULE_0__("#footprintsButton").on("click", function(){_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]("Imaging")) } );
		jquery__WEBPACK_IMPORTED_MODULE_0__("#mapsButton").on("click", function(){_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]("Maps")) } );
		jquery__WEBPACK_IMPORTED_MODULE_0__("#settingsButton").on("click", function(){_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]("Settings")) } );
		// $("#cutoutButton").on("click", function(){eventBus.fireEvent(new OpenPanelEvent("Cutout")) } );
		jquery__WEBPACK_IMPORTED_MODULE_0__("#dataExplorerButton").on("click", function(){_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]("DataExplorer")) } );
		

	}

	registerForEvents(){
		// eventBus.registerForEvent(this, OpenPanelEvent.name);
		
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _cataloguepanel_events_CatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_21__["default"].name);
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _cataloguepanel_events_CloseCatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_24__["default"].name);
		
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _footprintpanel_events_FootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_7__["default"].name);
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _footprintpanel_events_CloseFootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_10__["default"].name);
		
		// eventBus.registerForEvent(this, HiPSSettingsEvent.name);
		// eventBus.registerForEvent(this, CloseHiPSSettingsEvent.name);

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _events_HiPSSelectedEvent_js__WEBPACK_IMPORTED_MODULE_28__["default"].name);
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _cutoutpanel_events_CloseCutoutCloseEvent_js__WEBPACK_IMPORTED_MODULE_17__["default"].name);

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _events_OpenDataExplorerPanelEvent_js__WEBPACK_IMPORTED_MODULE_31__["default"].name);
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"].name);
	}
	
	notify(in_event){

		console.log(`Received OpenPanelEvent ${in_event.panelName} `)

		if (in_event instanceof _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]){
			
			if (in_event.panelName == "GoTo"){

				this._gotoPresenter.view.toggle()

			} else if (in_event.panelName == "Catalogues"){

				this._catalogueListPresenter.view.toggle()

			} else if (in_event.panelName == "Imaging"){

				this._footprintsListPresenter.view.toggle()

			} else if (in_event.panelName == "Maps"){

				this._hipsListPresenter.view.toggle()

			} else if (in_event.panelName == "Settings"){

				this._settingsPresenter.toggle()

			} else if (in_event.panelName == "Cutout"){

				this._cutoutPresenter.toggle()
			
			}  else if (in_event.panelName == "DataExplorer"){
				this._dataExplorerPresenter.toggle();
			}

			if (in_event.panelName !== "GoTo"){
				this._gotoPresenter.view.close()
			}
			if (in_event.panelName !== "Catalogues"){
				this._catalogueListPresenter.view.close()
			}
			if (in_event.panelName !== "Imaging"){
				this._footprintsListPresenter.view.close()
			}
			if (in_event.panelName !== "Maps"){
				this._hipsListPresenter.view.close()
			}
			if (in_event.panelName !== "Settings"){
				this._settingsPresenter.close()
			}
			if (in_event.panelName !== "Cutout"){
				this._cutoutPresenter.close()
			}
			// if (in_event.panelName !== "DataExplorer"){
			// 	this._dataExplorerPresenter.close()
			// }
			

		} else if (in_event instanceof _cataloguepanel_events_CatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_21__["default"]) {
			
			let catSettingsView = new _cataloguepanel_CatalogueSettingsView_js__WEBPACK_IMPORTED_MODULE_22__["default"](in_event.catalogue);
			// ???
			let catSettingsPresenter = new _cataloguepanel_CatalogueSettingsPresenter_js__WEBPACK_IMPORTED_MODULE_23__["default"](catSettingsView, in_event.catalogue, in_event.tapRepo);
			this._view.showPopup(catSettingsView.getHtml());
		
		} else if (in_event instanceof _cataloguepanel_events_CloseCatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_24__["default"]) {

			this._view.hidePopup();

		} else if (in_event instanceof _footprintpanel_events_FootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_7__["default"]) {
		
			let fsSettingsView = new _footprintpanel_FootprintSettingsView_js__WEBPACK_IMPORTED_MODULE_8__["default"](in_event.footprintSet);
			// ???
			let fsSettingsPresenter = new _footprintpanel_FootprintSettingsPresenter_js__WEBPACK_IMPORTED_MODULE_9__["default"](fsSettingsView, in_event.footprintSet);
			this._view.showPopup(fsSettingsView.getHtml());

		} else if (in_event instanceof _footprintpanel_events_CloseFootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {

			this._view.hidePopup();

		// } else if (in_event instanceof HiPSSettingsEvent) {
			
		// 	// ???
		// 	let hipsSettingsView = new HiPSSettingsView(in_event.descriptor);
		// 	this._view.showPopup(hipsSettingsView.getHtml());
		// 	let hipsSettingsPresenter = new HiPSSettingsPresenter(hipsSettingsView, in_event.descriptor);
			

		// }else if (in_event instanceof CloseHiPSSettingsEvent) {
		// 	this._view.hidePopup();

		} else if (in_event instanceof _events_HiPSSelectedEvent_js__WEBPACK_IMPORTED_MODULE_28__["default"]){
			this.toggleFunctionalities();
		} else if (in_event instanceof _events_OpenDataExplorerPanelEvent_js__WEBPACK_IMPORTED_MODULE_31__["default"]){
			console.log("OpenDataExplorerPanelEvent")
			console.log(_events_OpenDataExplorerPanelEvent_js__WEBPACK_IMPORTED_MODULE_31__["default"])
			if (!this._dataExplorerPresenter) {
				this._dataExplorerView = new _dataexplorer_DEView_js__WEBPACK_IMPORTED_MODULE_29__["default"]();
				this._dataExplorerPresenter = new _dataexplorer_DEPresenter_js__WEBPACK_IMPORTED_MODULE_30__["default"](this._dataExplorerView);
				this.view.openDataExplorer(this._dataExplorerView.getHtml());
			}
			this._dataExplorerPresenter.toggle();
			this._dataExplorerPresenter.refreshModel(in_event.pxSize, in_event.craDeg, in_event.cdecDeg, in_event.radiusDeg, in_event.projectionName, in_event._hipsURL);
		}



	}
	
	toggleFunctionalities() {
		if (_utils_Session_js__WEBPACK_IMPORTED_MODULE_25__.session.activeHiPS.length >= 1) {
			let hips = _utils_Session_js__WEBPACK_IMPORTED_MODULE_25__.session.activeHiPS[0];
			if (hips._descriptor._imgformats.includes("fits") || 
				hips._descriptor._imgformats.includes("FITS") ){
					
					this._view.enableCutOutButton();
					jquery__WEBPACK_IMPORTED_MODULE_0__("#cutoutButton").on("click", function(){_events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]("Cutout")) } );
			} else {
				// disable cutout panel
				this._view.disableCutOutButton();
				jquery__WEBPACK_IMPORTED_MODULE_0__("#cutoutButton").off("click", "**" );
			}
		}
	}


	get hipsListPresenter(){
		return this._hipsListPresenter;
	}

	refreshModel(){
		this._settingsPresenter.refreshModel();
		// this.toggleFunctionalities();
		
	}

	setSphericalCoordinates(phiThetaDeg){
		this._settingsPresenter.setSphericalCoordinates(phiThetaDeg);
	}
	
	
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ControlPanelPresenter);

/***/ }),

/***/ "./src/js/modules/controlpanel/ControlPanelView.js":
/*!*********************************************************!*\
  !*** ./src/js/modules/controlpanel/ControlPanelView.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_controlpanelcontainer_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css/controlpanelcontainer.css */ "./src/css/controlpanelcontainer.css");
/* harmony import */ var _css_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css/style.css */ "./src/css/style.css");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/**
 * @author Fabrizio Giordano (Fab)
 */




class ControlPanelView {

	_html;

	constructor() {
		this._html = "<div id='controlButtonContainer'>" +
			"	<div id='hamburgerButton'>" +
			"		<span></span><span></span><span></span><span></span>" +
			"	</div>" +
			"	<img id='gotoButton' class='controlButton' src='images/new_search.png'/>" +
			"	<div id='gotoButtonText'>Search</div>" +
			"	<img id='cataloguesButton' class='controlButton' src='images/new_catalogue.png' />" +
			"	<div id='catalogueButtonText'>Overlay source catalogues on top of a map</div>" +
			"	<img id='footprintsButton' class='controlButton' src='images/new_footprints.png' />" +
			"	<div id='footprintButtonText'>Overlay observation footprints on top of a map</div>" +
			"	<img id='mapsButton' class='controlButton' src='images/new_maps.png' />" +
			"	<div id='mapsButtonText'>Sky map selection</div>" +
			"	<img id='settingsButton' class='controlButton' src='images/new_settings.png' />" +
			"	<div id='settingsButtonText'>Settings</div>" +
			"	<img id='cutoutButton' class='controlButton' src='images/new_scissors.png' />" +
			"	<div id='cutoutButtonText'>Data Explorer</div>" +
			"</div>" +
			"<div id='settings-popup'></div>";
		// this._html = "<div id='controlButtonContainer'>" +
		// 	"	<div id='hamburgerButton'>" +
		// 	"		<span></span><span></span><span></span><span></span>" +
		// 	"	</div>" +
		// 	"	<img id='gotoButton' class='controlButton' src='images/catbutton2.png'/>" +
		// 	"	<div id='gotoButtonText'>Search</div>" +
		// 	"	<img id='cataloguesButton' class='controlButton' src='images/catbutton2.png' />" +
		// 	"	<div id='catalogueButtonText'>Overlay source catalogues on top of a map</div>" +
		// 	"	<img id='footprintsButton' class='controlButton' src='images/imgbutton2.png' />" +
		// 	"	<div id='footprintButtonText'>Overlay observation footprints on top of a map</div>" +
		// 	"	<img id='mapsButton' class='controlButton' src='images/mapbutton2.png' />" +
		// 	"	<div id='mapsButtonText'>Sky map selection</div>" +
		// 	"	<img id='settingsButton' class='controlButton' src='images/settings.png' />" +
		// 	"	<div id='settingsButtonText'>Settings</div>" +
		// 	"	<img id='cutoutButton' class='controlButton' src='images/settings.png' />" +
		// 	"	<div id='cutoutButtonText'>Data Explorer</div>" +
		// 	"</div>" +
		// 	"<div id='settings-popup'></div>";
		
	}

	get html() {
		return this._html;
	}

	appendChild(html) {
		jquery__WEBPACK_IMPORTED_MODULE_2__("#controlpanel2container").append(html);
	};

	showPopup(html) {
		jquery__WEBPACK_IMPORTED_MODULE_2__("#settings-popup").empty();
		jquery__WEBPACK_IMPORTED_MODULE_2__("#settings-popup").append(html);
		jquery__WEBPACK_IMPORTED_MODULE_2__("#settings-popup").css("display", "block");
	}

	hidePopup() {
		jquery__WEBPACK_IMPORTED_MODULE_2__("#settings-popup").empty();
		jquery__WEBPACK_IMPORTED_MODULE_2__("#settings-popup").css("display", "none");
	}

	enableCutOutButton() {
		jquery__WEBPACK_IMPORTED_MODULE_2__("#cutoutButton").prop('disabled', false)
	}

	disableCutOutButton(){
		jquery__WEBPACK_IMPORTED_MODULE_2__("#cutoutButton").prop('disabled', true)
	}
	
	openDataExplorer(html)  {
		jquery__WEBPACK_IMPORTED_MODULE_2__("#controlButtonContainer").append(html);
	}



}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ControlPanelView);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/CatalogueListPresenter.js":
/*!******************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/CatalogueListPresenter.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/Session.js */ "./src/js/utils/Session.js");
/* harmony import */ var _repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../repos/tap/TapRepoService.js */ "./src/js/repos/tap/TapRepoService.js");
/* harmony import */ var _events_CatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/CatalogueSettingsEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsEvent.js");
/* harmony import */ var _events_CatalogueSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/CatalogueSettingsChangeEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsChangeEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_CatalogueCloseEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events/CatalogueCloseEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueCloseEvent.js");












class CatalogueListPresenter {

	_view;
	_model;
	_id;

	constructor(in_view) {

		this._view = in_view;
		this._model = null;
		this._id = 0;
		this.registerForEvents();
	}

	get view() {
		return this._view;
	}

	/**
	 * 
	 * @param {TapRepopo} tapRepo 
	 */
	addCatalogues(tapRepo) {

		let catalogues = tapRepo.cataloguesList;
		let tableData = [];
		for (const [key, catalogue] of catalogues.entries()) {
			tableData.push({ id: this._id, selected: false, name: catalogue.name, settings: 'gear', model: catalogue })
			this._id++
		}
		if (tableData.length > 0) {
			this._view.addTapRepo(tapRepo, tableData, this.catalogueSelected, this.openCatalogueSettingsPanel);
		}

	}

	refreshCataloguesView() {
		this._view.clear();
	}

	catalogueSelected(tapRepo, catalogue, checked) {
		if (checked) {
			_repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_1__.tapRepoSingleton.queryCatalogueByFoV(tapRepo, catalogue, null);
			_utils_Session_js__WEBPACK_IMPORTED_MODULE_0__.session.activateCatalogue(catalogue);
		} else {
			// tapRepoSingleton.removeCatalogue(_self._model.name);
			_utils_Session_js__WEBPACK_IMPORTED_MODULE_0__.session.deactivateCatalogue(catalogue);
			_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent(new _events_CatalogueCloseEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](catalogue))
		}
	}

	openCatalogueSettingsPanel(catalogue, tapRepo) {
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent(new _events_CatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](catalogue, tapRepo));
	}

	registerForEvents() {
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].registerForEvent(this, _events_CatalogueSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"].name);
	}

	notify(event) {
		if (event instanceof _events_CatalogueSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {

			let refreshQueryByFov = event.catalogue.updateColumnMappingByName(event.ra, event.dec, event.sourcename, event.shape, event.color, event.hue);
			if (refreshQueryByFov) {
				_repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_1__.tapRepoSingleton.queryCatalogueByFoV(event.tapRepo, event.catalogue, null);
			}

		}

	}
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CatalogueListPresenter);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/CataloguePanelView.js":
/*!**************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/CataloguePanelView.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var tabulator_tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tabulator-tables */ "./node_modules/tabulator-tables/dist/js/tabulator_esm.js");


/**
 * @author Fabrizio Giordano (Fab77)
 */






class CataloguePanelView {

    _html;
    _visible;
    _rootDomId;
    _dataTables;


    constructor() {

        this._dataTables = new Map();
        this.init();

        var _public = {
            getHtml: () => {
                return this._html;
            },
            // TODO move this into Utils
            urlSanifier: (url) => {
                let sanified = url.replace('https://', '').replace('http://', '').replaceAll("/", "_").replaceAll(".", "_");
                return sanified;
            },
            addTapRepo: (tapRepo, tableData, catalogueSelectionHandler, catalogueSettingsHandler) => {

                const tapUrl = tapRepo.tapBaseUrl;
                const tapID = _public.urlSanifier(tapUrl);

                jquery__WEBPACK_IMPORTED_MODULE_0__("#" + this._rootDomId).append("<label for='" + tapID + "'>" + tapUrl + "</label><div id='" + tapID + "'></div>");

                let tableHeight = 250;
                if ((tableData.length * 35) < 200) {
                    tableHeight = tableData.length * 35;
                }

                let table = new tabulator_tables__WEBPACK_IMPORTED_MODULE_1__.TabulatorFull("#" + tapID, {
                    height: tableHeight, // set height of table (in CSS or here), this enables the Virtual DOM and improves render speed dramatically (can be any valid css height value)
                    data: tableData, //assign data to table
                    layout: "fitColumns", //fit columns to width of table (optional)
                    columns: [ //Define Table Columns
                        {
                            title: "#", field: "selected", width: 15,
                            formatter: (cell) => {
                                const value = cell.getValue();
                                if (value) {
                                    return `<input type="checkbox" checked/>`;
                                } else {
                                    return `<input type="checkbox" />`;
                                }
                            },
                        },
                        {
                            title: "Name",
                            field: "name",
                            width: 350,
                            hozAlign: "left",
                            formatter: "plaintext",
                            headerFilter:"input"
                        },
                        {
                            title: "Settings", field: "settings", width: 25, formatter: "image", formatterParams: {
                                height: "20px",
                                width: "20px",
                                // urlPrefix: "media/",
                                urlPrefix: "images/",
                                urlSuffix: ".png",
                            }
                        },
                        {
                            title: "Model",
                            field: "model",
                            visible: false
                        }
                    ],
                });

                this._dataTables.set(tapUrl, table);
                table.on("cellClick", function (e, cell) {
                    //e - the click event object
                    //cell - cell component
                    if (e.target.type == 'checkbox') {
                        catalogueSelectionHandler(tapRepo, cell._cell.row.data.model, e.target.checked)
                    } else if (e.target.nodeName == 'IMG') {
                        // console.log("IMAGE");
                        catalogueSettingsHandler(cell._cell.row.data.model, tapRepo)
                    }
                });
            },
            clear: () => {
                jquery__WEBPACK_IMPORTED_MODULE_0__('#cataloguePanel').html('');
            },
            toggle: () => {
                this._html.toggle();
            },
            close: () => {
                // if (this._visible) {
                this._html.css("display", "none");
                this._visible = false;
                // }
            }
        }

        return _public;
    }

    init() {
        this._rootDomId = "cataloguePanel";
        this._visible = false;
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div id='" + this._rootDomId + "' class='controlPanel'></div>");
        this._html.css("display", "none");


    }



}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CataloguePanelView);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/CatalogueSettingsPresenter.js":
/*!**********************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/CatalogueSettingsPresenter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_CloseCatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/CloseCatalogueSettingsEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CloseCatalogueSettingsEvent.js");
/* harmony import */ var _events_CatalogueSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/CatalogueSettingsChangeEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsChangeEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */

 
 
 


class CatalogueSettingsPresenter {

    constructor (view, catalogue, tapRepo) {
        this._view = view;
        this._model = catalogue;
        this._tapRepo = tapRepo;
        var _self = this;
        this._view.addCloseHandler( function () {
            _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_CloseCatalogueSettingsEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]());
        });
        this._view.addChangeHandler( function (ra, dec, name, shape, color, hue) {
            // console.log(ra, dec, name, shape, color), hue;
            // eventBus.fireEvent(new CatalogueSettingsChangeEvent(ra, dec, name, shape, color, hue, _self._model._name));
            _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_CatalogueSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"](ra, dec, name, shape, color, hue, _self._model, _self._tapRepo));
            
        });
    }

    get view(){
        return this._view;
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CatalogueSettingsPresenter);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/CatalogueSettingsView.js":
/*!*****************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/CatalogueSettingsView.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */

 

class CatalogueSettingsView {
    
    _catalogue;
    _ra;
    _dec;
    _name;
    _size;
    _color;
    constructor(catalogue) {

        this._catalogue = catalogue;
        this.init();

        var _public = {
            getHtml: ()=>{
                return this._html;
            },
            addCloseHandler: (handler) => {
                
                this._html.find("#close-settings").on("click", function(e){
                    e.stopPropagation();
                    handler();
                });

            },
            addChangeHandler: (handler) => {
                this._html.find("#change-settings").on("click", function(e){
                    e.stopPropagation();
                    let ra = jquery__WEBPACK_IMPORTED_MODULE_0__("#ra-select").children("option:selected").val();
                    let dec = jquery__WEBPACK_IMPORTED_MODULE_0__("#dec-select").children("option:selected").val();
                    let name = jquery__WEBPACK_IMPORTED_MODULE_0__("#name-select").children("option:selected").val();
                    let hue = jquery__WEBPACK_IMPORTED_MODULE_0__("#hue-select").children("option:selected").val();
                    let shape = jquery__WEBPACK_IMPORTED_MODULE_0__("#size-select").children("option:selected").val();
                    let shapeColor = jquery__WEBPACK_IMPORTED_MODULE_0__("#shape-color").val();

                    handler(ra, dec, name, shape, shapeColor, hue);
                });

            }
        }

        return _public;
    }

    init() {
        this._visible = false;
        
        let raSelectBox = "<select id='ra-select'>";
        for (let column of this._catalogue._columns ) {
            if (column.name == this._catalogue._raColumn.name) {
                raSelectBox += "<option value='"+column.name+"' selected>"+column.name+"</option>";
            } else {
                raSelectBox += "<option value='"+column.name+"'>"+column.name+"</option>";
            }
        }
        raSelectBox += "</select>";

        let decSelectBox = "<select id='dec-select'>";
        for (let column of this._catalogue._columns ) {
            if (column.name == this._catalogue._decColumn.name) {
                decSelectBox += "<option value='"+column.name+"' selected>"+column.name+"</option>";
            } else {
                decSelectBox += "<option value='"+column.name+"'>"+column.name+"</option>";
            }
        }
        decSelectBox += "</select>";

        let nameFound = false;
        let nameSelectBox = "<select id='name-select'>";
        for (let column of this._catalogue._columns ) {
            if (this._catalogue._nameColumn !== undefined && column.name == this._catalogue._nameColumn.name) {
                nameFound = true;
                nameSelectBox += "<option value='"+column.name+"' selected>"+column.name+"</option>";
            } else {
                nameSelectBox += "<option value='"+column.name+"'>"+column.name+"</option>";
            }
        }
        if (!nameFound) {
            nameSelectBox += "<option value='--' selected>--</option>";
        }
        nameSelectBox += "</select>";

        let sizeFound = false;
        let sizeSelectBox = "<select id='size-select'>";
        for (let column of this._catalogue._columns ) {
            // TODO handle the case when datatype is undefined
            
            if (column.datatype !== undefined && ["SHORT", "LONG", "INT", "FLOAT", "DOUBLE", "INTEGER", "BIGINT"].includes(column.datatype.toUpperCase())) {
                if (this._catalogue._sizeColumn !== undefined && column.name == this._catalogue._sizeColumn.name) {
                    sizeFound = true;
                    sizeSelectBox += "<option value='"+column.name+"' selected>"+column.name+"</option>";
                } else {
                    sizeSelectBox += "<option value='"+column.name+"'>"+column.name+"</option>";
                }
            }
        
                
        }
        if (!sizeFound) {
            sizeSelectBox += "<option value='--' selected>--</option>";
        }
        sizeSelectBox += "</select>";

        let colorFound = false;
        let hueSelectBox = "<select id='hue-select'>";
        for (let column of this._catalogue._columns ) {
            // TODO handle the case when datatype is undefined
            
            if (column.datatype !== undefined && ["SHORT", "LONG", "INT", "FLOAT", "DOUBLE", "INTEGER", "BIGINT"].includes(column.datatype.toUpperCase())) {
                
                if (this._catalogue._shapeColumn !== undefined && column.name == this._catalogue._shapeColumn.name) {
                    colorFound = true;
                    hueSelectBox += "<option value='"+column.name+"' selected>"+column.name+"</option>";
                } else {
                    hueSelectBox += "<option value='"+column.name+"'>"+column.name+"</option>";
                }

            }    
        
        }
        if (!colorFound) {
            hueSelectBox += "<option value='--' selected>--</option>";
        }
        hueSelectBox += "</select>";



        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div class='cat-settings'>"+this._catalogue.name+"<button id='close-settings'>X</button>" +
                        "<table>" +
                        "<tr><td>RA</td><td>"+raSelectBox+"</td></tr>" +
                        "<tr><td>Dec</td><td>"+decSelectBox+"</td></tr>" +
                        "<tr><td>Name</td><td>"+nameSelectBox+"</td></tr>" +
                        "<tr><td>Shape size</td><td>"+sizeSelectBox+"</td></tr>" +
                        "<tr><td>Shape hue</td><td>"+hueSelectBox+"</td></tr>" +
                        "<tr><td><input type='color' id='shape-color' value='"+this._catalogue._shapeColor+"'></input></td></tr>" +
                        "</table><button id='change-settings'>change</button></div>");

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CatalogueSettingsView);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueCloseEvent.js":
/*!**********************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/events/CatalogueCloseEvent.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class CatalogueCloseEvent{
	
	_catalogue;
	static name = "CatalogueCloseEvent";
	
	constructor(catalogue){
		this._catalogue = catalogue;
		
	}
	
	get name(){
		return CatalogueCloseEvent.name;
	}
	
	get catalogue(){
		return this._catalogue;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CatalogueCloseEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsChangeEvent.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsChangeEvent.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class CatalogueSettingsChangeEvent{
	
	_ra;
	_dec;
	_sourcename;
	_shape;
	_color;
	_hue;
	// _cataloguename;
	_catalogue;
	_tapRepo;

	static name = "CatalogueSettingsChangeEvent";
	
	// constructor(ra, dec, name, shape, color, hue, cataloguename){
	constructor(ra, dec, name, shape, color, hue, catalogue, tapRepo){
		this._ra = ra;
		this._dec = dec;
		this._sourcename = name;
		this._shape = shape;
		this._color = color;
		this._hue = hue;
		// this._cataloguename = cataloguename;
		this._catalogue = catalogue;
		this._tapRepo = tapRepo;
	}
	
	get name(){
		return CatalogueSettingsChangeEvent.name;
	}

	get ra() {
		return this._ra;
	}

	get dec() {
		return this._dec;
	}

	get sourcename() {
		return this._sourcename;
	}

	get shape() {
		return this._shape;
	}

	get hue() {
		return this._hue;
	}

	get color() {
		return this._color;
	}

	// get cataloguename() {
	// 	return this._cataloguename;
	// }
	get catalogue() {
		return this._catalogue;
	}
	
	get tapRepo(){
		return this._tapRepo;
	}
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CatalogueSettingsChangeEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsEvent.js":
/*!*************************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/events/CatalogueSettingsEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class CatalogueSettingsEvent{
	
	_catalogue;
	_tapRepo;
	static name = "CatalogueSettingsEvent";
	
	constructor(catalogue, tapRepo){
		this._catalogue = catalogue;
		this._tapRepo = tapRepo;
	}
	
	get name(){
		return CatalogueSettingsEvent.name;
	}
	
	get catalogue(){
		return this._catalogue;
	}

	get tapRepo() {
		return this._tapRepo;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CatalogueSettingsEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/events/CloseCatalogueSettingsEvent.js":
/*!******************************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/events/CloseCatalogueSettingsEvent.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class CloseCatalogueSettingsEvent{
	
	_catalogue;
	static name = "CloseCatalogueSettingsEvent";
	
	constructor(){
		
	}
	
	get name(){
		return CloseCatalogueSettingsEvent.name;
	}
	
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CloseCatalogueSettingsEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/model/Catalogue.js":
/*!***********************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/model/Catalogue.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _utils_Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utils/Point.js */ "./src/js/utils/Point.js");
/* harmony import */ var _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/CoordsType.js */ "./src/js/utils/CoordsType.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Source.js */ "./src/js/modules/controlpanel/cataloguepanel/model/Source.js");
/* harmony import */ var _utils_ShaderUtility_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../utils/ShaderUtility.js */ "./src/js/utils/ShaderUtility.js");
/* harmony import */ var _repos_tap_TapMetadataList_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../repos/tap/TapMetadataList.js */ "./src/js/repos/tap/TapMetadataList.js");
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../utils/Session.js */ "./src/js/utils/Session.js");
/* harmony import */ var _model_hipsnew_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../model/hipsnew/VisibleTilesManager.js */ "./src/js/model/hipsnew/VisibleTilesManager.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */












class Catalogue {

	static ELEM_SIZE;
	static BYTES_X_ELEM;
	_TYPE;
	_name;
	_shaderProgram;
	_gl;
	_vertexCataloguePositionBuffer;
	_vertexhoveredCataloguePositionBuffer;
	_sources;
	_oldMouseCoords;
	_vertexCataloguePosition;
	_attribLocations;
	_hoveredIndexes;
	_descriptor;
	_healpixDensityMap;

	_ready;


	/**
	 * 
	 * @param {Column[]} columns 
	 * @param {Column} raColumn 
	 * @param {Column} decColumn 
	 * @param {Column} nameColumn 
	 * @param {*} tablename 
	 * @param {*} tabledesc 
	 * @param {*} tablesurl 
	 * @param {TapMetadataList} tapMetadataList 
	 */
	constructor(columns, raColumn, decColumn, nameColumn, tablename, tabledesc, tablesurl, tapMetadataList) {
		// constructor(in_name, in_metadata, in_raIdx, in_decIdx, in_nameIdx, in_descriptor){

		this._ready = false;
		this._TYPE = "SOURCE_CATALOGUE";
		Catalogue.ELEM_SIZE = 6;
		Catalogue.BYTES_X_ELEM = new Float32Array().BYTES_PER_ELEMENT;
		this._columns = columns;
		this._sources = [];
		this._attribLocations = {};

		this._name = tablename;


		this._tapMetadataList = tapMetadataList;
		this._raColumn = undefined;
		this._decColumn = undefined;
		this._nameColumn = undefined;
		this.setPositionColumns(tapMetadataList);
		this.setNameColumn(tapMetadataList);

		this._shapeColumn = undefined;
		this._colorColumn = undefined;

		this._tableDescription = tabledesc;
		this._tableUrl = tablesurl;

		this._gl = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl;
		this._shaderProgram = this._gl.createProgram();
		this._vertexCataloguePositionBuffer = this._gl.createBuffer();
		this._vertexhoveredCataloguePositionBuffer = this._gl.createBuffer();

		this._vertexCataloguePosition = [];

		this._hoveredIndexes = [];
		this._selectedIndexes = [];
		this._extHoveredIndexes = [];

		this._oldMouseCoords = null;

		this._attribLocations = {
			position: 0,
			selected: 1,
			pointSize: 2,
			color: [0.0, 1.0, 0.0, 1.0],
			brightness: 3
		};

		this._healpixDensityMap = new Map();
		this._shapeColor = "#8F00FF";

		this.initShaders();

	}

	get ready() {
		return this._ready;
	}

	/**
	 * @param {Boolean} bool
	 */
	set ready(bool) {
		this._ready = bool;
	}

	/**
	 * 
	 * @param {TapMetadataList} tapMetadataList 
	 */
	setPositionColumns(tapMetadataList) {
		for (let tapMetadata of tapMetadataList._posEqRAMetaColumns) {
			if (tapMetadata.ucd !== undefined && tapMetadata.ucd.includes("pos.eq.ra")) {

				if (tapMetadata.ucd.includes("meta.main")) {
					this._raColumn = tapMetadata;
					break;
				}

				// getting the first one
				if (this._raColumn === undefined) {
					this._raColumn = tapMetadata;
				}
			}
		}


		for (let tapMetadata of tapMetadataList._posEqDecMetaColumns) {

			if (tapMetadata.ucd !== undefined && tapMetadata.ucd.includes("pos.eq.dec")) {

				if (tapMetadata.ucd.includes("meta.main")) {
					this._decColumn = tapMetadata;
					break;
				}

				// getting the first one
				if (this._decColumn === undefined) {
					this._decColumn = tapMetadata;
				}
			}

		}
	}

	/**
	 * 
	 * @param {TapMetadataList} tapMetadataList 
	 */
	setNameColumn(tapMetadataList) {
		for (let tapMetadata of tapMetadataList._metadataList) {
			if (tapMetadata.ucd !== undefined && tapMetadata.ucd.includes("meta.id") && tapMetadata.ucd.includes("meta.main")) {

				this._nameColumn = tapMetadata;

			}
		}
	}


	initShaders() {

		var gl = this._gl;
		var shaderProgram = this._shaderProgram;

		var fragmentShader = this.loadShaderFromDOM("cat-shader-fs");
		var vertexShader = this.loadShaderFromDOM("cat-shader-vs");

		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		_utils_ShaderUtility_js__WEBPACK_IMPORTED_MODULE_5__.shaderUtility.useProgram(shaderProgram);


	}


	loadShaderFromDOM(shaderId) {
		var gl = this._gl;

		var shaderScript = document.getElementById(shaderId);

		if (!shaderScript) {
			return null;
		}

		var shaderSource = "";
		var currentChild = shaderScript.firstChild;
		while (currentChild) {
			if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
				shaderSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}

		var shader;
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, shaderSource);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(shader));
			return null;
		}
		return shader;
	}


	get name() {
		return this._name;
	}

	get sources() {
		return this._sources;
	}

	addSource(in_source) {
		this._sources.push(in_source);
	}

	/**
	 * 
	 * @param {Array.Array<Object>} in_data 
	 * @param {TapMetadataList} columnsmeta 
	 */
	addSources(in_data, columnsmeta) {
		var j,
			point,
			source;

		// TODO columnsmeta ??? pass it to each source object or handle it in Catalogue2?
		this._columns = columnsmeta;

		let idRa = this._raColumn.index;
		for (let cid = 0; cid < columnsmeta._posEqRAMetaColumns; cid++) {
			let currCol = columnsmeta._posEqRAMetaColumns[cid];
			if (currCol._name == this._raColumn._name) {
				this._raColumn = currCol;
				break;
			}
		}

		for (let cid = 0; cid < columnsmeta._posEqDecMetaColumns; cid++) {
			let currCol = columnsmeta._posEqDecMetaColumns[cid];
			if (currCol._name == this._decColumn._name) {
				this._decColumn = currCol;
				break;
			}
		}

		for (j = 0; j < in_data.length; j++) {

			point = new _utils_Point_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
				"raDeg": in_data[j][this._raColumn.index],
				"decDeg": in_data[j][this._decColumn.index]
			}, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_3__["default"].ASTRO);
			source = new _Source_js__WEBPACK_IMPORTED_MODULE_4__["default"](point, in_data[j]);

			this.addSource(source);
		}
		this.initBuffer();
		this._ready = true;
	}

	clearSources() {
		this._sources = [];
		this._hoveredIndexes = [];
	}



	extHighlightSource(source, highlighted) {
		const sIdx = this._sources.indexOf(source)
		if (highlighted) {
			if (! (this._extHoveredIndexes.indexOf(sIdx) > 0)){
				this._extHoveredIndexes.push(sIdx);
			}
		} else {
			const indexOfSourceHovered = this._extHoveredIndexes.indexOf(sIdx)
			this._extHoveredIndexes.splice(indexOfSourceHovered, 1)
		}
		let hoveredSources = []
		for (let hidx of this._extHoveredIndexes) {
			hoveredSources.push(this._sources[hidx])
		}
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.updateHoveredSources(this, hoveredSources);
	}

/**
 * 
 * @param {Source[]} sources 
 */
	extAddSources2Selected(sources) {
		for (let s of sources) {
			const sIdx = this._sources.indexOf(s)
			if (sIdx > 0 && !this._selectedIndexes.includes(sIdx)) {
				this._selectedIndexes.push(sIdx);
			}
		}

	}

	/**
	 * 
	 * @param {Source} source
	 */
	extRemoveSourceFromSelection(source) {
		const indexOfObject = this._sources.indexOf(source)
		if (indexOfObject >= 0) {
			const sidx = this._selectedIndexes.indexOf(indexOfObject)
			this._selectedIndexes.splice(sidx, 1);
			const eidx = this._extHoveredIndexes.indexOf(indexOfObject)
			this._extHoveredIndexes.splice(eidx, 1);
			this._vertexCataloguePosition[(indexOfObject * Catalogue.ELEM_SIZE) + 3] = 0.0; // not hovered
		}
	}




	updateColumnMappingByName(raColName, decColName, nameColName, sizeColName, color, hueColName) {
		this._shapeColor = color;
		let refreshQueryByFov = false;
		if (this._raColumn._name != raColName || this._decColumn._name != decColName) {
			// change ra mapping
			for (let column of this._columns) {
				if (column._name == raColName) {
					this._raColumn = column;
				}
				if (column._name == decColName) {
					this._decColumn = column;
				}
			}
			refreshQueryByFov = true;
		}


		if (this._nameColumn === undefined || this._nameColumn._name != nameColName) {
			for (let column of this._columns) {
				if (column._name == nameColName) {
					this._nameColumn = column;
					break;
				}
			}
		}

		if (sizeColName != "--") {
			if (this._shapeColumn === undefined || this._shapeColumn._name != sizeColName) {
				for (let column of this._columns) {
					if (column._name == sizeColName) {
						this._shapeColumn = column;
						break;
					}
				}

				let minmax = this.minMax(this._shapeColumn._index);
				for (let source of this._sources) {

					let normsize = ((source._details[this._shapeColumn._index] - minmax.min) / (minmax.max - minmax.min)) * (20 - 8) + 8;
					source.shapeSize = normsize;
				}
				this.initBuffer();

			}
		}

		if (hueColName != "--") {
			if (this._colorColumn === undefined || this._colorColumn._name != hueColName) {
				for (let column of this._columns) {
					if (column._name == hueColName) {
						this._colorColumn = column;
						break;
					}
				}
			}

			let minmax = this.minMax(this._colorColumn._index);
			for (let source of this._sources) {

				let normsize = - (((source._details[this._colorColumn._index] - minmax.min) / (minmax.max - minmax.min)) * 2 - 1);
				source.brightnessFactor = normsize;
			}
			this.initBuffer();
		}
		return refreshQueryByFov;

	}

	minMax(columnindex) {
		let min = this._sources[0]._details[columnindex];
		let max = min;

		for (let source of this._sources) {
			if (source._details[columnindex] < min) {
				min = source._details[columnindex];
			}
			if (source._details[columnindex] > max) {
				max = source._details[columnindex];
			}
		}
		return {
			"min": min,
			"max": max
		}
	}

	initBuffer() {

		var gl = this._gl;

		var sources = this._sources;

		gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexCataloguePositionBuffer);
		var nSources = sources.length;

		this._vertexCataloguePosition = new Float32Array(nSources * Catalogue.ELEM_SIZE);
		var positionIndex = 0;

		// max num of decimal places is 17
		let R = 1.0000000000000000;

		for (var j = 0; j < nSources; j++) {


			let currSource = sources[j];
			let currPix = currSource.healpixPixel;

			if (this._healpixDensityMap.has(currPix)) {
				let sourceList = this._healpixDensityMap.get(currPix);

				if (!sourceList.includes(j)) {
					sourceList.push(j);
				}
			} else {
				this._healpixDensityMap.set(currPix, [j]);
			}

			// source position on index 0, 1, 2
			this._vertexCataloguePosition[positionIndex] = currSource.point.x;
			this._vertexCataloguePosition[positionIndex + 1] = currSource.point.y;
			this._vertexCataloguePosition[positionIndex + 2] = currSource.point.z;

			// source hovered (0 = not hovered or 1 = hovered) on index 3
			this._vertexCataloguePosition[positionIndex + 3] = 0.0;

			// source size (not used for the moment) on index 4
			// this._vertexCataloguePosition[positionIndex+4] = 8.0;
			this._vertexCataloguePosition[positionIndex + 4] = this._sources[j].shapeSize;

			this._vertexCataloguePosition[positionIndex + 5] = this._sources[j].brightnessFactor;

			positionIndex += Catalogue.ELEM_SIZE;

		}
		this._gl.bufferData(this._gl.ARRAY_BUFFER, this._vertexCataloguePosition, this._gl.STATIC_DRAW);


		/* 
		 * check https://stackoverflow.com/questions/27714014/3d-point-on-circumference-of-a-circle-with-a-center-radius-and-normal-vector
		 * for a strategy to create circle on the surface of the sphere instead of creating the circle-point in the fragment shader. This 
		 * should solve the issue of having the circles always parallel to the screen
		 */

		/*
		 * https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html
		 */

	}



	getSelectionRadius(){
		const order = _model_hipsnew_VisibleTilesManager_js__WEBPACK_IMPORTED_MODULE_8__.newVisibleTilesManager.getVisibleOrder()
		switch (order){
			case 0:
			case 1:
			case 2:
				return 0.005
			case 3:
				return 0.001
			case 4:
				return 0.0009
			case 5:
				return 0.0005
			case 6:
				return 0.0001
			case 7:
				return 0.00009
			case 8:
				return 0.00005
			case 9:
				return 0.00001
			default:
				return 0.000005
		}
	}

	checkSelection(in_mouseHelper) {

		let hoveredIndexes = [];
		let sourcesHovered = [];
		let mousePix = in_mouseHelper.computeNpix256();

		if (mousePix != null) {

			// let mousePoint = new Point({ x: in_mouseHelper.x, y: in_mouseHelper.y, z: in_mouseHelper.z }, CoordsType.CARTESIAN);

			if (this._healpixDensityMap.has(mousePix)) {

				for (let i = 0; i < this._healpixDensityMap.get(mousePix).length; i++) {

					let sourceIdx = this._healpixDensityMap.get(mousePix)[i];
					let source = this.sources[sourceIdx];

					// let mouseCoords = in_mouseHelper.xyz;

					if (source === undefined){
						// console.log(`Source undefined ${i} ${this.sources}`)
						// console.log(this.sources)
						continue;
					}
					let dist = Math.sqrt((source.point.x - in_mouseHelper.x) * (source.point.x - in_mouseHelper.x) + (source.point.y - in_mouseHelper.y) * (source.point.y - in_mouseHelper.y) + (source.point.z - in_mouseHelper.z) * (source.point.z - in_mouseHelper.z));
					// if (dist <= 0.01) {
					const selectionRadius = this.getSelectionRadius();
					if (dist <= selectionRadius) {

						hoveredIndexes.push(sourceIdx);
						sourcesHovered.push(source)

					} 
					// else {
					// 	console.log(`dist > ${selectionRadius}`)
					// }

				}

			}
		} else {
			console.log("mousepix is null")
		}
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_7__.session.updateHoveredSources(this, sourcesHovered);
		return hoveredIndexes;

	}




	enableShader(in_mMatrix) {

		_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.useProgram(this._shaderProgram);
		this._shaderProgram.catUniformMVMatrixLoc = this._gl.getUniformLocation(this._shaderProgram, "uMVMatrix");
		this._shaderProgram.catUniformProjMatrixLoc = this._gl.getUniformLocation(this._shaderProgram, "uPMatrix");

		this._attribLocations.position = this._gl.getAttribLocation(this._shaderProgram, 'aCatPosition');

		this._attribLocations.hovered = this._gl.getAttribLocation(this._shaderProgram, 'a_selected');

		this._attribLocations.pointSize = this._gl.getAttribLocation(this._shaderProgram, 'a_pointsize');

		this._attribLocations.color = this._gl.getUniformLocation(this._shaderProgram, 'u_fragcolor');

		this._attribLocations.brightness = this._gl.getAttribLocation(this._shaderProgram, 'a_brightness');

		var mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
		mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.multiply(mvMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].camera.getCameraMatrix(), in_mMatrix);
		this._gl.uniformMatrix4fv(this._shaderProgram.catUniformMVMatrixLoc, false, mvMatrix);
		this._gl.uniformMatrix4fv(this._shaderProgram.catUniformProjMatrixLoc, false, _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].pMatrix);

	}

	/**
	 * @param in_Matrix: model matrix the current catalogue is associated to (e.g. HiPS matrix)
	 */
	draw(in_mMatrix, in_mouseHelper) {


		// shaderUtility.useProgram(this._shaderProgram);

		this.enableShader(in_mMatrix);

		this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexCataloguePositionBuffer);

		// setting source position
		this._gl.vertexAttribPointer(this._attribLocations.position, 3, this._gl.FLOAT, false, Catalogue.BYTES_X_ELEM * Catalogue.ELEM_SIZE, 0);
		this._gl.enableVertexAttribArray(this._attribLocations.position);

		// setting hovered sources
		this._gl.vertexAttribPointer(this._attribLocations.hovered, 1, this._gl.FLOAT, false, Catalogue.BYTES_X_ELEM * Catalogue.ELEM_SIZE, Catalogue.BYTES_X_ELEM * 3);
		this._gl.enableVertexAttribArray(this._attribLocations.hovered);

		// TODO The size can be set with uniform or directly in the shader. setting point size (for variable catalogue)
		this._gl.vertexAttribPointer(this._attribLocations.pointSize, 1, this._gl.FLOAT, false, Catalogue.BYTES_X_ELEM * Catalogue.ELEM_SIZE, Catalogue.BYTES_X_ELEM * 4);
		this._gl.enableVertexAttribArray(this._attribLocations.pointSize);

		this._gl.vertexAttribPointer(this._attribLocations.brightness, 1, this._gl.FLOAT, false, Catalogue.BYTES_X_ELEM * Catalogue.ELEM_SIZE, Catalogue.BYTES_X_ELEM * 5);
		this._gl.enableVertexAttribArray(this._attribLocations.brightness);

		// setting source shape color 
		// var rgb = colorHex2RGB(this._descriptor.shapeColor);
		var rgb = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_0__.colorHex2RGB)(this._shapeColor);

		var alpha = 1.0;
		rgb[3] = alpha;
		this._gl.uniform4f(this._attribLocations.color, rgb[0], rgb[1], rgb[2], rgb[3]);

		if (in_mouseHelper != null && in_mouseHelper.xyz != this._oldMouseCoords) {

			// removing old hovered
			for (var k = 0; k < this._hoveredIndexes.length; k++) {
				this._vertexCataloguePosition[(this._hoveredIndexes[k] * Catalogue.ELEM_SIZE) + 3] = 0.0; // not hovered
				this._vertexCataloguePosition[(this._hoveredIndexes[k] * Catalogue.ELEM_SIZE) + 4] = this._sources[this._hoveredIndexes[k]].shapeSize; // point size
			}

			this._hoveredIndexes = this.checkSelection(in_mouseHelper);

			let hoveredSources = [];
			for (var i = 0; i < this._hoveredIndexes.length; i++) {
				hoveredSources.push(this._sources[this._hoveredIndexes[i]]);
			}


			// new hovered applied
			for (var i = 0; i < this._hoveredIndexes.length; i++) {
				this._vertexCataloguePosition[(this._hoveredIndexes[i] * Catalogue.ELEM_SIZE) + 3] = 1.0; // hovered
				this._vertexCataloguePosition[(this._hoveredIndexes[i] * Catalogue.ELEM_SIZE) + 4] = this._sources[this._hoveredIndexes[i]].shapeSize; // point size
				// this._vertexCataloguePosition[ (this._hoveredIndexes[i] * Catalogue2.ELEM_SIZE) + 4] = 10.0; // point size
			}
			
		}

		for (let s = 0; s < this._selectedIndexes.length; s++) {
			this._vertexCataloguePosition[(this._selectedIndexes[s] * Catalogue.ELEM_SIZE) + 3] = 2.0; // selected
			this._vertexCataloguePosition[(this._selectedIndexes[s] * Catalogue.ELEM_SIZE) + 4] = this._sources[this._selectedIndexes[s]].shapeSize; // point size				
		}

		for (let e = 0; e < this._extHoveredIndexes.length; e++) {
			this._vertexCataloguePosition[(this._extHoveredIndexes[e] * Catalogue.ELEM_SIZE) + 3] = 1.0; // selected
			this._vertexCataloguePosition[(this._extHoveredIndexes[e] * Catalogue.ELEM_SIZE) + 4] = this._sources[this._extHoveredIndexes[e]].shapeSize; // point size				
		}

		this._gl.bufferData(this._gl.ARRAY_BUFFER, this._vertexCataloguePosition, this._gl.STATIC_DRAW);



		var numItems = this._vertexCataloguePosition.length / Catalogue.ELEM_SIZE;

		this._gl.drawArrays(this._gl.POINTS, 0, numItems);

		this._oldMouseCoords = in_mouseHelper.xyz;

	}


}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Catalogue);

/***/ }),

/***/ "./src/js/modules/controlpanel/cataloguepanel/model/Source.js":
/*!********************************************************************!*\
  !*** ./src/js/modules/controlpanel/cataloguepanel/model/Source.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../Global.js */ "./src/js/Global.js");


// import Point from '../utils/Point.js';




class Source{
	
	_point;
	_name;
	_details;
	_h_pix;
	_shapesize;
	/**
	 * 
	 * @param in_point:
	 *            Point.js
	 * @param in_name:
	 *            String - source name
	 * @param in_details:
	 *            Object {"key": <key>, "value": <value>, "valueType":
	 *            <valueType>, "unit": <unit>}
	 */
	// constructor(in_point, in_name, in_details=[]){
	constructor(in_point, in_details=[]){
		this._point = in_point;
		// this._name = in_name;
		this._details = in_details;
		this._shapesize = 8.0;
		this._brightnessFactor = -99;
		this.computeHealpixPixel();
	}



	computeHealpixPixel(){
		
		// let healpix = new Healpix(global.nsideForSelection);
		let healpix = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].getHealpix(_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].nsideForSelection);
		let vec3 = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Vec3(this._point.x, this._point.y, this._point.z);
		let ptg = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(vec3, false);
		this._h_pix = healpix.ang2pix(ptg, false);
		
	}
	
	get point(){
		return this._point;
	}

	get name () {
		return this._name;
	}
	
	get healpixPixel(){
		return this._h_pix;
	}

	get shapeSize() {
		return this._shapesize;
	}

	setShapeSize (columnindex) {
		
		this._shapesize = this._details[columnindex];
		
	}

	set shapeSize (size) {
		
		this._shapesize = size;
		
	}

	get brightnessFactor() {
		return this._brightnessFactor;
	}

	/**
	 * 
	 * @param {*} factor [-1..1]
	 */
	setBrightnessFactor(factor){
		this._brightnessFactor = factor;
	}

	/**
	 * 
	 * @param {*} factor [-1..1]
	 */
	set brightnessFactor(factor) {
		this._brightnessFactor = factor;
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Source);


/***/ }),

/***/ "./src/js/modules/controlpanel/cutoutpanel/CutoutPanelPresenter.js":
/*!*************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cutoutpanel/CutoutPanelPresenter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/FoVUtils.js */ "./src/js/utils/FoVUtils.js");
/* harmony import */ var _events_OpenDataExplorerPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../events/OpenDataExplorerPanelEvent.js */ "./src/js/events/OpenDataExplorerPanelEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/Session.js */ "./src/js/utils/Session.js");






// import OpenPanelEvent from '../../../events/OpenPanelEvent.js';




class CutoutPanelPresenter {

	_view;
	_center;
	_handlerInitialized;
	_refreshId;
	_descriptor;


	constructor(in_view) {

		this.init(in_view);

		// this.register4Events();

		const _public = {

			toggle: (descriptor) => {
				// console.log(session)
				
				const hips = _utils_Session_js__WEBPACK_IMPORTED_MODULE_5__.session._activeHiPS[0]
				const url = hips._descriptor.url;
				this._descriptor = hips._descriptor;

				// const url = descriptor.url;
				// this._descriptor = descriptor;

				if (!this._handlerInitialized) {
					this.addButtonsClickHandlers();
				}

				// this._view.toggle(hips.descriptor.surveyName);
				this._view.toggle(this._descriptor.surveyName);

				if (this._view.isVisible()) {

					let self = this;
					let getCenterFunction = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getCenterJ2000;
					let canvas = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.canvas;
					this._refreshId = setInterval(function () {
						self._center = getCenterFunction(canvas);
						self._view.setModel(self._center);
					}, 500);

				} else {
					clearInterval(this._refreshId);
				}
			},
			close: () => {
				this._view.close();
			}
		}

		return _public;
	}

	init(_view) {

		this._view = _view;
		this._handlerInitialized = false;

	}

	// register4Events() {
	// 	eventBus.registerForEvent(this, OpenPanelEvent.name);
	// }

	// notify(in_event) {

	// 	switch (in_event.constructor) {
	// 		case OpenPanelEvent:
	// 			if (in_event.panelName == "DataExplorer") {
	// 				this._dePresenter.toggle();
	// 			}
	// 			break;
	// 	}
	// }

	get view() {
		return this._view;
	}

	addButtonsClickHandlers() {

		let self = this;

		jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_go").on("click", () => {

			console.log("clicked on Data explorer button");

			let pxSize = Number(jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_pxsize").val());
			let cRA = Number(jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_cRA").val());
			let cDec = Number(jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_cDec").val());
			let radius = Number(jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_radius").val());
			let projection = jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_proj :selected").text();

			const url = this._descriptor.url;
			_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent(new _events_OpenDataExplorerPanelEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](cRA, cDec, pxSize, radius, projection, this._descriptor.url));
			self.view.toggle();

		});
		this._handlerInitialized = true;
	}

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CutoutPanelPresenter);

/***/ }),

/***/ "./src/js/modules/controlpanel/cutoutpanel/CutoutPanelView.js":
/*!********************************************************************!*\
  !*** ./src/js/modules/controlpanel/cutoutpanel/CutoutPanelView.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

class CutoutPanelView{

    _html;
    _visible;
    
    constructor(){
        
        this.init();
        

        let _public = {
            getHtml: ()=>{
                return this._html;
            },
            setModel : (model)=> { // model type of Point.js
                if (model !== null) {
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_cRA").val(model.raDeg);
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#cto_cDec").val(model.decDeg);
                }
            },
            addCutoutHandler : (handler) => {
                this._html.find("#cto_go").on("click", handler);
            },
            toggle: (hipsName)=>{
                this._visible = !this._visible;
                this._html.toggle();
                this.updateHiPSName(hipsName);
            },
            close: ()=>{
            	if (this._visible){
            		this._html.css("display","none");
            		this._visible = false;
            	}
            },
            isVisible: ()=>{
                return this._visible;
            }
        }
        return _public;
    }		

    updateHiPSName(hipsName){
        // $("#hipsname").html=hipsName
        document.getElementById("hipsname").innerHTML = hipsName
        // $("#"+this._dom_hipsname_id).text(hipsName);
    }

    init(){
        this._visible = false;
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div id='ctoPanel' class='controlPanel'>"
        + "<span id='hipsname'></span>"
        + "<div>"
        + " <label for='cto_pxsize'>pixel size:</label>" 
        + " <input name='cto_pxsize' id='cto_pxsize' type='text' value='0.0005'/>(deg)" 
        + "</div>"
        + "<div>"
        + " <label for='cto_cRA'>central RA:</label>" 
        + " <input name='cto_cRA' id='cto_cRA' type='text'/>(deg)" 
        + " <label for='cto_cDec'>central Dec:</label>" 
        + " <input name='cto_cDec' id='cto_cDec' type='text'/>(deg)" 
        + "</div>"
        + "<div>"
        + " <label for='cto_radius'>radius:</label>" 
        + " <input name='cto_radius' id='cto_radius' type='text' value='0.1'/>(deg)" 
        + "</div>"
        + "<div>"
        + " <label for='cto_proj'>Projection:</label>" 
        + " <select name='cto_proj' id='cto_proj' onmousedown='event.stopPropagation()'>"
        + "  <option value='mercator'>Mercator</option>"
        + "  <option value='mercator'>HiPS</option>"
        + " </select>"
        + "</div>"
        + "<div><button id='cto_go'>Data explorer</button>"
        + "</div>");
        this._html.css("display","none");
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CutoutPanelView);

/***/ }),

/***/ "./src/js/modules/controlpanel/cutoutpanel/events/CloseCutoutCloseEvent.js":
/*!*********************************************************************************!*\
  !*** ./src/js/modules/controlpanel/cutoutpanel/events/CloseCutoutCloseEvent.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class CloseCutoutCloseEvent{
	
	static name = "CloseCutoutCloseEvent";
	
	constructor(){}
	
	get name(){
		return CloseCutoutCloseEvent.name;
	}
	
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CloseCutoutCloseEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/FootprintListPresenter.js":
/*!******************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/FootprintListPresenter.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _repos_tap_TapRepo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../repos/tap/TapRepo.js */ "./src/js/repos/tap/TapRepo.js");
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/Session.js */ "./src/js/utils/Session.js");
/* harmony import */ var _repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../repos/tap/TapRepoService.js */ "./src/js/repos/tap/TapRepoService.js");
/* harmony import */ var _events_FootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/FootprintSettingsEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_FootprintSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events/FootprintSettingsChangeEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsChangeEvent.js");
/* harmony import */ var _events_FootprintSetCloseEvent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events/FootprintSetCloseEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSetCloseEvent.js");


/**
 * @author Fabrizio Giordano (Fab77)
 */








class FootprintListPresenter {
	_view;
	_id;

	constructor(in_view) {
		this._view = in_view;
		this._id = 0;
		this.registerForEvents();
	}

	get view() {
		return this._view;
	}


	/**
	 * 
	 * @param {TapRepo} tapRepo 
	 */
	addFootprintsSet = (tapRepo) => {

		let footprints = tapRepo.observationsList;
		let tableData = [];
		for (const [key, fpSet] of footprints.entries()) {
			tableData.push({ id: this._id, selected: false, name: fpSet.name, settings: 'gear', model: fpSet })
			this._id++

		}
		if (tableData.length > 0) {
			this._view.addTapRepo(tapRepo, tableData, this.fpsetSelected, this.openFpSetSettingsPanel);
		}

	}

	refreshCataloguesView() {
		this._view.clear();
	}

	fpsetSelected(tapRepo, fpset, checked) {
		if (checked) {
			_repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_2__.tapRepoSingleton.queryObservationByFoV(tapRepo, fpset, null);
			_utils_Session_js__WEBPACK_IMPORTED_MODULE_1__.session.activateFootprintSet(fpset);
		} else {
			_utils_Session_js__WEBPACK_IMPORTED_MODULE_1__.session.deactivateFootprintSet(fpset);
			_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent(new _events_FootprintSetCloseEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](fpset))
		}
	}

	openFpSetSettingsPanel(fpset, tapRepo) {
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent(new _events_FootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](fpset, tapRepo));
	}

	registerForEvents() {
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].registerForEvent(this, _events_FootprintSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"].name);
	}

	notify(event) {
		if (event instanceof _events_FootprintSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {


			let refreshQueryByFov = event.fpSet.updateColumnMappingByName(event.geometry, event.obsName, event.color, event.hue);
			if (refreshQueryByFov) {
				_repos_tap_TapRepoService_js__WEBPACK_IMPORTED_MODULE_2__.tapRepoSingleton.queryObservationByFoV(event.tapRepo, event.fpSet, null);
			}
		}
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintListPresenter);



/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/FootprintPanelView.js":
/*!**************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/FootprintPanelView.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var tabulator_tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tabulator-tables */ "./node_modules/tabulator-tables/dist/js/tabulator_esm.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */




class FootprintPanelView {
    _html;
    _visible;
    _rootDomId;
    _dataTables;

    constructor() {

        this._dataTables = new Map();
        this.init();


        var _public = {
            getHtml: () => {
                return this._html;
            },
            // TODO move this into Utils
            urlSanifier: (url) => {
                let sanified = url.replace('https://', '').replace('http://', '').replaceAll("/", "_").replaceAll(".", "_");
                return sanified;
            },
            addTapRepo: (tapRepo, tableData, fpsetSelectionHandler, fpsetSettingsHandler) => {
                const tapUrl = tapRepo.tapBaseUrl;
                const tapID = "obs_" + _public.urlSanifier(tapUrl);

                jquery__WEBPACK_IMPORTED_MODULE_0__("#" + this._rootDomId).append("<label for='" + tapID + "'>" + tapUrl + "</label><div id='" + tapID + "'></div>");

                let tableHeight = 250;
                if ((tableData.length * 40) < 200) {
                    tableHeight = tableData.length * 40;
                }

                let table = new tabulator_tables__WEBPACK_IMPORTED_MODULE_1__.TabulatorFull("#" + tapID, {
                    height: tableHeight, // set height of table (in CSS or here), this enables the Virtual DOM and improves render speed dramatically (can be any valid css height value)
                    data: tableData, //assign data to table
                    layout: "fitColumns", //fit columns to width of table (optional)
                    columns: [ //Define Table Columns
                        {
                            title: "#", field: "selected", width: 15,
                            formatter: (cell) => {
                                const value = cell.getValue();
                                if (value) {
                                    return `<input type="checkbox" checked/>`;
                                } else {
                                    return `<input type="checkbox" />`;
                                }
                            },
                        },
                        {
                            title: "Name",
                            field: "name",
                            width: 350,
                            hozAlign: "left",
                            formatter: "plaintext",
                            headerFilter:"input"
                        },
                        {
                            title: "Settings", field: "settings", width: 25, formatter: "image", formatterParams: {
                                height: "20px",
                                width: "20px",
                                // urlPrefix: "media/",
                                urlPrefix: "images/",
                                urlSuffix: ".png",
                            }
                        },
                        {
                            title: "Model",
                            field: "model",
                            visible: false
                        }
                    ],
                });

                this._dataTables.set(tapUrl, table);
                table.on("cellClick", function (e, cell) {
                    //e - the click event object
                    //cell - cell component
                    if (e.target.type == 'checkbox') {
                        fpsetSelectionHandler(tapRepo, cell._cell.row.data.model, e.target.checked)
                    } else if (e.target.nodeName == 'IMG') {
                        fpsetSettingsHandler(cell._cell.row.data.model, tapRepo)
                    }
                });


            },
            clear: () => {
                jquery__WEBPACK_IMPORTED_MODULE_0__('#footprintPanel').html('');
            },
            toggle: () => {
                this._html.toggle();
            },
            close: () => {

                // if (this._visible){
                this._html.css("display", "none");
                this._visible = false;
                // }
            }
        }

        return _public;
    }

    init() {
        this._rootDomId = "footprintPanel";
        this._visible = false;
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div id='" + this._rootDomId + "' class='controlPanel'></div>");
        this._html.css("display", "none");
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintPanelView);



/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/FootprintSettingsPresenter.js":
/*!**********************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/FootprintSettingsPresenter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_CloseFootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/CloseFootprintSettingsEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/CloseFootprintSettingsEvent.js");
/* harmony import */ var _events_FootprintSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/FootprintSettingsChangeEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsChangeEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */




class FootprintSettingsPresenter {
    
    constructor (view, footprintset, tapRepo) {
        this._view = view;
        this._model = footprintset;
        this._tapRepo = tapRepo;
        var _self = this;
        this._view.addCloseHandler( function () {
            _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_CloseFootprintSettingsEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]());
        });
        this._view.addChangeHandler( function (geom, name, color, hue) {
            console.log(geom, name, color, hue);
            _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].fireEvent(new _events_FootprintSettingsChangeEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"](geom, name, color, hue, _self._model, _self._tapRepo));
            
        });
    }

    get view(){
        return this._view;
    }
    
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintSettingsPresenter);



/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/FootprintSettingsView.js":
/*!*****************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/FootprintSettingsView.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */

 

class FootprintSettingsView {
    _footprintset;
    _ra;
    _dec;
    _name;
    _size;
    _color;
    constructor(footprintset) {

        this._footprintset = footprintset;
        this.init();

        var _public = {
            getHtml: ()=>{
                return this._html;
            },
            addCloseHandler: (handler) => {
                
                this._html.find("#close-settings").on("click", function(e){
                    e.stopPropagation();
                    handler();
                });

            },
            addChangeHandler: (handler) => {
                this._html.find("#change-settings").on("click", function(e){
                    e.stopPropagation();
                    let geom = jquery__WEBPACK_IMPORTED_MODULE_0__("#geom-select").children("option:selected").val();
                    let name = jquery__WEBPACK_IMPORTED_MODULE_0__("#name-select").children("option:selected").val();
                    // let hue = $("#hue-select").children("option:selected").val();
                    let hue = null;
                    let shapeColor = jquery__WEBPACK_IMPORTED_MODULE_0__("#shape-color").val();
                    
                    handler(geom, name, shapeColor, hue);
                });

            }
        }

        return _public;
    }

    init() {
        this._visible = false;
        
        let geomSelectBox = "<select id='geom-select'>";
        for (let column of this._footprintset._columns ) {
            if (column._name == this._footprintset._geomColumn._name) {
                geomSelectBox += "<option value='"+column._name+"' selected>"+column._name+"</option>";
            } else {
                geomSelectBox += "<option value='"+column._name+"'>"+column._name+"</option>";
            }
        }
        geomSelectBox += "</select>";

        let nameFound = false;
        let nameSelectBox = "<select id='name-select'>";
        for (let column of this._footprintset._columns ) {
            if (this._footprintset._nameColumn !== undefined && column._name == this._footprintset._nameColumn._name) {
                nameFound = true;
                nameSelectBox += "<option value='"+column._name+"' selected>"+column._name+"</option>";
            } else {
                nameSelectBox += "<option value='"+column._name+"'>"+column._name+"</option>";
            }
        }
        if (!nameFound) {
            nameSelectBox += "<option value='--' selected>--</option>";
        }
        nameSelectBox += "</select>";

        // TODO SHAPE HUE in the shader
        // let colorFound = false;
        // let colorSelectBox = "<select id='hue-select'>";
        // for (let column of this._footprintset._columns ) {
        //     if (["SHORT", "LONG", "INT", "FLOAT", "DOUBLE", "INTEGER", "BIGINT"].includes(column._datatype.toUpperCase())) {
                
        //         if (this._footprintset._shapeColumn !== undefined && column._name == this._footprintset._shapeColumn._name) {
        //             colorFound = true;
        //             colorSelectBox += "<option value='"+column._name+"' selected>"+column._name+"</option>";
        //         } else {
        //             colorSelectBox += "<option value='"+column._name+"'>"+column._name+"</option>";
        //         }

        //     }    
        // }
        // if (!colorFound) {
        //     colorSelectBox += "<option value='--' selected>--</option>";
        // }
        // colorSelectBox += "</select>";



        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div class='fs-settings'>"+this._footprintset._name+"<button id='close-settings'>X</button>" +
                        "<table>" +
                        "<tr><td>Geometry</td><td>"+geomSelectBox+"</td></tr>" +
                        "<tr><td>Name</td><td>"+nameSelectBox+"</td></tr>" +
                        "<tr><td><input type='color' id='shape-color' value='"+this._footprintset._shapeColor+"'></input></td></tr>" +
                        // "<tr><td>Shape hue</td><td>"+colorSelectBox+"</td></tr>" +
                        "</table><button id='change-settings'>change</button></div>");

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintSettingsView);



/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/events/CloseFootprintSettingsEvent.js":
/*!******************************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/events/CloseFootprintSettingsEvent.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class CloseFootprintSettingsEvent{
	
	_catalogue;
	static name = "CloseFootprintSettingsEvent";
	
	constructor(){
		
	}
	
	get name(){
		return CloseFootprintSettingsEvent.name;
	}
	
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CloseFootprintSettingsEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSetCloseEvent.js":
/*!*************************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/events/FootprintSetCloseEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class FootprintSetCloseEvent{
	
	_footprintset;
	static name = "FootprintSetCloseEvent";
	
	constructor(footprintset){
		this._footprintset = footprintset;
		
	}
	
	get name(){
		return FootprintSetCloseEvent.name;
	}
	
	get footprintSet(){
		return this._footprintset;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintSetCloseEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsChangeEvent.js":
/*!*******************************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsChangeEvent.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class FootprintSettingsChangeEvent {

	_geometry;
	_obsname;
	_color;
	_hue;
	_fpset;
	_tapRepo;
	static name = "FootprintSettingsChangeEvent";

	constructor(geometry, name, color, hue, fpset, tapRepo) {
		this._geometry = geometry;
		this._obsname = name;
		this._color = color;
		this._hue = hue;
		this._fpset = fpset;
		this._tapRepo = tapRepo;
	}

	get name() {
		return FootprintSettingsChangeEvent.name;
	}

	get geometry() {
		return this._geometry;
	}

	get obsName() {
		return this._obsname;
	}

	get hue() {
		return this._hue;
	}

	get color() {
		return this._color;
	}

	get fpSet() {
		return this._fpset;
	}

	get tapRepo () {
		return this._tapRepo;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintSettingsChangeEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsEvent.js":
/*!*************************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/events/FootprintSettingsEvent.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class FootprintSettingsEvent{
	
	_footprintset;
	_tapRepo;
	static name = "FootprintSettingsEvent";
	
	constructor(footprintset, tapRepo){
		this._footprintset = footprintset;
		this._tapRepo = tapRepo;
	}
	
	get name(){
		return FootprintSettingsEvent.name;
	}
	
	get footprintSet(){
		return this._footprintset;
	}

	get tapRepo(){
		return this._tapRepo;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintSettingsEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/model/Footprint.js":
/*!***********************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/model/Footprint.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var _utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utils/GeomUtils.js */ "./src/js/utils/GeomUtils.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _utils_STCSParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../utils/STCSParser.js */ "./src/js/utils/STCSParser.js");

/**
 * @author Fabrizio Giordano (Fab)
 */










class Footprint{
	
	_polygons; // array of polygons (-> array of points)
	_convexPolygons; // array of convex polygons (-> array of points) 
	_stcs; // STC-S Space-Time Coordinate Metadata Linear String Implementation 
	
	_details;
	_totPoints;
	_totConvexPoints;
	_npix256;
	_footprintsPointsOrder; // 1-> clockwise, -1 counter clockwise
	 

	/**
	 * 
	 * @param in_point: Point.js - center
	 * @param in_identifier: String - observation name/identifier
	 * @param in_stcs: String - STC-S representation of the footprint
	 * @param in_details: Object {"key": <key>, "value": <value>, "valueType": <valueType>, "unit": <unit>}
	 */
	//  constructor(in_point, in_identifier, in_stcs, in_details=[], footprintsPointsOrder){
	constructor(in_stcs, in_details=[], footprintsPointsOrder){
		
		// this._center = in_point;
		this._stcs = in_stcs.toUpperCase();
		// this._identifier = in_identifier;
		this._details = in_details;
		this._polygons = [];
		this._totPoints = 0;
		this._totConvexPoints = 0;
		
		// this._footprintsPointsOrder = footprintsPointsOrder;
		this.computePoints();
		// this._footprintsPointsOrder = GeomUtils.isPolyClockwise(this._polygons);
		// this.computeConvexPoly();
		this.computeSelectionObject();
		if (_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].healpix4footprints){
			this._npix256 = this.computeNpix256();	
		}
		
	}

	computeSelectionObject(){
		this._selectionObj = _utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].computeSelectionObject(this._polygons);
	}
	
	
	computeConvexPoly(){
		
		// this._convexPolygons = GeomUtils.computeConvexPolygons3(this._polygons, this._footprintsPointsOrder, this);
		this._convexPolygons = _utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].computeConvexPolygons4(this._polygons, this._footprintsPointsOrder, this);
		
		for (let i = 0; i < this._convexPolygons.length; i++){
			let poly = this._convexPolygons[i];
//			this._totConvexPoints += Object.values(poly).length;
			this._totConvexPoints += poly.length;
		}
		
	}
	
	/**
	 * return: array of int representing the HEALPix pixels covering the footprint 
	 */
	// TODO wrong method name. No more fixed nside=256. nside is now defined into Global.js
	computeNpix256(){

//		this._convexPolygons = GeomUtils.computeConvexPolygons(this._polygons);
		
		let healpix256 = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Healpix(_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].nsideForSelection);

		let points = [];
		for (let i = 0; i < this._convexPolygons.length; i++){
			let poly = this._convexPolygons[i];
			for (let j = 0; j < poly.length; j++){

				let currPoint = poly[j];

				let phiTheta = currPoint.computeHealpixPhiTheta();
				let phiRad = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__.degToRad)(phiTheta.phi);
				let thetaRad = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_1__.degToRad)(phiTheta.theta);
				
				let pointing = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(null, false, thetaRad, phiRad);

				points.push(pointing);
			}
		}
		
		let rangeSet = healpix256.queryPolygonInclusive(points, 32);

		return rangeSet.r;
		
	};

	
	computePoints(){
		
		let res =  _utils_STCSParser_js__WEBPACK_IMPORTED_MODULE_4__["default"].parseSTCS(this._stcs);
		this._polygons = res.polygons;
		this._totPoints = res.totpoints;
		
	}
	
	get totPoints(){
		return this._totPoints;
	}
	
	get totConvexPoints(){
		return this._totConvexPoints;
	}

	get polygons(){
		return this._polygons;
	}
	
	get convexPolygons(){
		return this._convexPolygons;
	}

	get identifier () {
		return this._identifier;
	}
	
	get center(){
		return this._center;
	}
	
	get pixels(){
		return this._npix256;
	}
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Footprint);


/***/ }),

/***/ "./src/js/modules/controlpanel/footprintpanel/model/FootprintSet.js":
/*!**************************************************************************!*\
  !*** ./src/js/modules/controlpanel/footprintpanel/model/FootprintSet.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _utils_Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utils/Point.js */ "./src/js/utils/Point.js");
/* harmony import */ var _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/CoordsType.js */ "./src/js/utils/CoordsType.js");
/* harmony import */ var _Footprint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Footprint.js */ "./src/js/modules/controlpanel/footprintpanel/model/Footprint.js");
/* harmony import */ var _utils_ShaderUtility_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../utils/ShaderUtility.js */ "./src/js/utils/ShaderUtility.js");
/* harmony import */ var _utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../utils/GeomUtils.js */ "./src/js/utils/GeomUtils.js");
/* harmony import */ var _repos_tap_TapMetadataList_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../repos/tap/TapMetadataList.js */ "./src/js/repos/tap/TapMetadataList.js");
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../utils/Session.js */ "./src/js/utils/Session.js");













class FootprintSet {

	static ELEM_SIZE;
	static BYTES_X_ELEM;

	_shaderProgram;
	_gl;
	_vertexCataloguePositionBuffer;
	_indexes;
	_indexBuffer;
	// _vertexSelectionCataloguePositionBuffer;
	_footprints;
	_oldMouseCoords;
	_vertexCataloguePosition;
	_attribLocations;
	_selectionIndexes;
	_descriptor;
	_totPoints;	// Used to compute item size in the GL buffer
	_indexes;
	_footprintsInPix256;
	_nPrimitiveFlags;

	_footprintsPointsOrder; // 1 -> clockwise, -1 -> counter clockwise

	_totConvexPoints;
	_convexIndexes;
	_convexIndexBuffer;
	_vertexConvexPolyPosition;
	_vertexConvexPolyPositionBuffer;

	_ready;
	/**
	 * 
	 * @param {*} columns 
	 * @param {*} geomColumn 
	 * @param {*} nameColumn 
	 * @param {*} tablename 
	 * @param {*} tabledesc 
	 * @param {*} tablesurl 
	 * @param {*} raColumn 
	 * @param {*} decColumn 
	 * @param {TapMetadataList} tapMetadataList 
	 */
	constructor(columns, geomColumn, nameColumn, tablename, tabledesc, tablesurl, raColumn, decColumn, tapMetadataList) {

		this._ready = false;
		this._TYPE = "FOOTPRINT_CATALOGUE";

		FootprintSet.ELEM_SIZE = 3;

		FootprintSet.CONVEXPOLY_ELEM_SIZE = 3;
		FootprintSet.BYTES_X_ELEM = new Float32Array().BYTES_PER_ELEMENT;
		this._columns = columns;
		this._footprints = [];
		this._attribLocations = {};

		this._name = tablename;

		this._tapMetadataList = tapMetadataList;
		this._geomColumn = undefined;
		this._nameColumn = undefined;
		this._raColumn = undefined;
		this._decColumn = undefined;
		this._pgSphereColumn = undefined;
		this.setPositionColumns(tapMetadataList);
		this.setNameColumn(tapMetadataList);


		if (nameColumn === undefined) {
			this._nameColumn = "NAME NOT SET";
		}
		this._colorColumn = undefined;

		this._tableDescription = tabledesc;
		this._tableUrl = tablesurl;




		this._nPrimitiveFlags = 0;
		this._totPoints = 0;

		this._gl = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl;
		this._shaderProgram = this._gl.createProgram();

		this._vertexCataloguePositionBuffer = this._gl.createBuffer();
		this._indexBuffer = this._gl.createBuffer();

		this._vertexCataloguePosition = [];

		this._selectionIndexes = [];

		this._oldMouseCoords = null;

		this._attribLocations = {
			position: 0,
			selected: 1,
			pointSize: 2,
			color: [0.0, 1.0, 0.0, 1.0]
		};

		this._footprintsInPix256 = new Map();


		this._hoveredFootprints = [];
		this._hoveredVertexPositionBuffer = this._gl.createBuffer();
		this._hoveredIndexBuffer = this._gl.createBuffer();
		this._totHoveredPoints = 0;

		this._selectedFootprints = [];
		this._selectedVertexPositionBuffer = this._gl.createBuffer();
		this._selectedIndexBuffer = this._gl.createBuffer();
		this._totSelectedPoints = 0;


		this._shapeColor = "#8F00FF";

		this.initShaders();

	}

	get raColumn() {
		return this._raColumn;
	}

	get decColumn() {
		return this._decColumn;
	}

	get ready() {
		return this._ready;
	}

	/**
	 * @param {Boolean} bool
	 */
	set ready(bool) {
		this._ready = bool;
	}


	/**
	 * 
	 * @param {TapMetadataList} tapMetadataList 
	 */
	setPositionColumns(tapMetadataList) {

		for (let tapMetadata of tapMetadataList.pgSphereMetaColumns) {
			this._pgSphereColumn = tapMetadata;
		}

		for (let tapMetadata of tapMetadataList.sRegionMetaColumns) {

			if (tapMetadata.ucd !== undefined && tapMetadata.ucd.includes("pos.outline;obs.field")) {
				this._geomColumn = tapMetadata;
				break;
			}

			// getting the first one
			if (this._geomColumn === undefined) {
				this._geomColumn = tapMetadata;
			}
		}





		for (let tapMetadata of tapMetadataList._posEqRAMetaColumns) {
			if (tapMetadata.ucd !== undefined && tapMetadata.ucd.includes("meta.main")) {
				this._raColumn = tapMetadata;
				break;
			}

			// getting the first one
			if (this._raColumn === undefined) {
				this._raColumn = tapMetadata;
			}
		}


		for (let tapMetadata of tapMetadataList._posEqDecMetaColumns) {

			if (tapMetadata.ucd !== undefined && tapMetadata.ucd.includes("meta.main")) {
				this._decColumn = tapMetadata;
				break;
			}

			// getting the first one
			if (this._decColumn === undefined) {
				this._decColumn = tapMetadata;
			}
		}
	}

	/**
	 * 
	 * @param {TapMetadataList} tapMetadataList 
	 */
	setNameColumn(tapMetadataList) {
		for (let tapMetadata of tapMetadataList._metadataList) {
			if (tapMetadata.ucd !== undefined && tapMetadata.ucd.includes("meta.id") && tapMetadata.ucd.includes("meta.main")) {

				this._nameColumn = tapMetadata;

			}
		}
	}


	initShaders() {

		var _self = this;
		var gl = this._gl;
		// var shaderProgram = this._shaderProgram;

		var fragmentShader = this.loadShaderFromDOM("fpcat-shader-fs");
		var vertexShader = this.loadShaderFromDOM("fpcat-shader-vs");

		gl.attachShader(this._shaderProgram, vertexShader);
		gl.attachShader(this._shaderProgram, fragmentShader);
		gl.linkProgram(this._shaderProgram);

		if (!gl.getProgramParameter(this._shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		_utils_ShaderUtility_js__WEBPACK_IMPORTED_MODULE_5__.shaderUtility.useProgram(this._shaderProgram);

		// TODO USELESS
		this.setUniformLocation();

	}


	loadShaderFromDOM(shaderId) {
		var gl = this._gl;

		var shaderScript = document.getElementById(shaderId);

		// If we don't find an element with the specified id
		// we do an early exit
		if (!shaderScript) {
			return null;
		}

		// Loop through the children for the found DOM element and
		// build up the shader source code as a string
		var shaderSource = "";
		var currentChild = shaderScript.firstChild;
		while (currentChild) {
			if (currentChild.nodeType == 3) { // 3 corresponds to TEXT_NODE
				shaderSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}

		var shader;
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, shaderSource);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(shader));
			return null;
		}
		return shader;
	}


	// TODO USELESS
	setUniformLocation() {

		var gl = this._gl;

		this._shaderProgram.pMatrixUniform = gl.getUniformLocation(this._shaderProgram, "uPMatrix");
		this._shaderProgram.mvMatrixUniform = gl.getUniformLocation(this._shaderProgram, "uMVMatrix");

	}


	get name() {
		return this._name;
	}

	get footprints() {
		return this._footprints;
	}

	addFootprint(in_footprint) {
		this._footprints.push(in_footprint);
	}


	/**
	 * 
	 * @param {Array} in_data 
	 * @param {TapMetadataList} columnsmeta : 
	 */
	addFootprints(in_data, columnsmeta) {
		let j,
			footprint;

		this._columns = columnsmeta;

		for (j = 0; j < in_data.length; j++) {

			if (in_data[j][0] !== null) {
				// footprint = new Footprint(in_data[j][0], in_data[j]);
				footprint = new _Footprint_js__WEBPACK_IMPORTED_MODULE_4__["default"](in_data[j][this._geomColumn._index], in_data[j]);
				this.addFootprint(footprint);
				this._totPoints += footprint.totPoints;
				this._totConvexPoints += footprint.totConvexPoints;
			}
		}

		this.initBuffer();

		this._ready = true;
	}


	// TODO Change the above. It should be computed at runtime
	/**
	 * 
	 * @param {*} datasetName 
	 * @deprecated
	 */
	footprintsClockwiseOrder(datasetName) {

		let isCloclWise = _utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_6__["default"].isPolyClockwise(this._footprints[0]._polygons[0]);
		this._footprintsPointsOrder = isCloclWise;

		// let order = 1; // clockwise order
		// if(datasetName == 'observations.mv_akari_irc_fdw' || datasetName == 'observations.mv_v_v_hsa_esasky_photo_fdw_fdw' || 'observations.mv_v_v_hsa_esasky_spectra_fdw_fdw'){
		// 	order = -1;
		// }
		// return order;
	}

	clearFootprints() {

		this._footprints = [];
		this._indexes = [];
		this._vertexCataloguePosition = [];
		this._totPoints = 0;


		this._hoveredFootprints = [];
		this._hoveredIndex = [];
		this._hoveredVertexPosition = [];
		this._totHoveredPoints = 0;

		this._selectedFootprints = [];
		this._selectedIndex = [];
		this._selectedVertexPosition = [];
		this._totsSelectedPoints = 0;

		// this._convexIndexes = [];
		// this._vertexConvexPolyPosition = [];
		// this._totConvexPoints = 0;


	}



	updateColumnMappingByName(geomColName, nameColName, color, hue) {

		let refreshQueryByFov = false;
		if (this._geomColumn._name != geomColName) {
			for (let column of this._columns) {
				if (column._name == geomColName) {
					this._geomColumn = column;
				}
			}
			refreshQueryByFov = true;
		}

		if (this._nameColumn === undefined || this._nameColumn._name != nameColName) {
			for (let column of this._columns) {
				if (column._name == nameColName) {
					this._nameColumn = column;
					break;
				}
			}
		}
		this._shapeColor = color;
		this._hue = hue;

		return refreshQueryByFov;

	}

	initBuffer() {


		let nFootprints = this._footprints.length;

		let npolygons = nFootprints - 1;
		for (let j = 0; j < nFootprints; j++) {
			npolygons += this._footprints[j].polygons.length - 1; // TODO ,-- compute number of subpolygons in the Footprint2.js constructor
		}

		// this._indexes = new Uint16Array(this._totPoints + npolygons + 1);
		// let MAX_UNSIGNED_SHORT = 65535; // this is used to enable and disable GL_PRIMITIVE_RESTART_FIXED_INDEX

		this._indexes = new Uint32Array(this._totPoints + npolygons + 1);
		let MAX_UNSIGNED_SHORT = 0xFFFFFFFF; // this is used to enable and disable GL_PRIMITIVE_RESTART_FIXED_INDEX
		// let MAX_UNSIGNED_SHORT = 2147483647;
		// let MAX_UNSIGNED_SHORT = Number.MAX_SAFE_INTEGER;

		let gl = this._gl;

		gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexCataloguePositionBuffer);

		// this._vertexCataloguePosition = new Float32Array( 3 * this._totPoints);
		this._vertexCataloguePosition = new Float32Array(3 * this._totPoints);
		let positionIndex = 0;
		let vIdx = 0;

		let R = 1.0;
		this._nPrimitiveFlags = 0;

		var footprintsInPix256 = this._footprintsInPix256;
		for (let j = 0; j < nFootprints; j++) {

			let footprint = this._footprints[j];
			let footprintPoly = this._footprints[j].polygons;
			var identifier = this._footprints[j].identifier;


			if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].healpix4footprints) {
				this._footprints[j].pixels.forEach(function (pix) {

					if (footprintsInPix256.has(pix)) {

						let currFootprints = footprintsInPix256.get(pix);
						if (!currFootprints.includes(identifier)) {
							currFootprints.push(footprint);
						}

					} else {
						footprintsInPix256.set(pix, [footprint]);
					}
				});
			}
			if (j > 0) {
				this._indexes[vIdx] = MAX_UNSIGNED_SHORT;
				this._nPrimitiveFlags += 1;
				vIdx += 1;
			}
			for (let polyIdx in footprintPoly) {
				// 
				if (polyIdx > 0) {
					this._indexes[vIdx] = MAX_UNSIGNED_SHORT;
					this._nPrimitiveFlags += 1;
					vIdx += 1;
				}
				for (let pointIdx in footprintPoly[polyIdx]) {
					this._vertexCataloguePosition[positionIndex] = R * footprintPoly[polyIdx][pointIdx].x;
					this._vertexCataloguePosition[positionIndex + 1] = R * footprintPoly[polyIdx][pointIdx].y;
					this._vertexCataloguePosition[positionIndex + 2] = R * footprintPoly[polyIdx][pointIdx].z;


					this._indexes[vIdx] = Math.floor(positionIndex / 3);



					vIdx += 1;
					positionIndex += 3;

				}

				// this._indexes[vIdx] = MAX_UNSIGNED_SHORT;
				// vIdx += 1;

			}

		}
		this._indexes[this._indexes.length - 1] = MAX_UNSIGNED_SHORT;
		// this._indexes.splice(this._indexes - 1, 1);

		this._footprintsInPix256 = footprintsInPix256;
		console.log("Buffer initialized");

		// if (this.showConvexPolygons){
		// this.initConvexPolyBuffer();
		// }

		// glEnable ( GL_PRIMITIVE_RESTART_FIXED_INDEX ); // 65535

	}



	initConvexPolyBuffer() {
		let nFootprints = this._footprints.length;

		this._convexIndexes = new Uint16Array(this._totConvexPoints + nFootprints);
		//		this._indexes = [];

		let MAX_UNSIGNED_SHORT = 65535; // this is used to enable and disable
		// GL_PRIMITIVE_RESTART_FIXED_INDEX

		let gl = this._gl;

		gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexConvexPolyPositionBuffer);

		this._vertexConvexPolyPosition = new Float32Array(3 * this._totConvexPoints);
		let positionIndex = 0;
		let vIdx = 0;

		let R = 1.0;

		for (let j = 0; j < nFootprints; j++) {

			let footprintPoly = this._footprints[j].convexPolygons;

			for (let polyIdx in footprintPoly) {
				for (let pointIdx in footprintPoly[polyIdx]) {
					this._vertexConvexPolyPosition[positionIndex] = R * footprintPoly[polyIdx][pointIdx].x;
					this._vertexConvexPolyPosition[positionIndex + 1] = R * footprintPoly[polyIdx][pointIdx].y;
					this._vertexConvexPolyPosition[positionIndex + 2] = R * footprintPoly[polyIdx][pointIdx].z;

					this._convexIndexes[vIdx] = Math.floor(positionIndex / 3);

					vIdx += 1;
					positionIndex += 3;
				}

				this._convexIndexes[vIdx] = MAX_UNSIGNED_SHORT;
				vIdx += 1;

			}
		}

		console.log("Buffer for convex polygons initialized");
	}

	/**
	 * @param in_mouseHelper
	 *            MouseHelper
	 */
	checkSelection(in_mouseHelper) {

		let mousePix = in_mouseHelper.computeNpix256();
		if (mousePix !== null) {
			this._hoveredFootprints = [];
			this._totHoveredPoints = 0;
			let mousePoint = new _utils_Point_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ x: in_mouseHelper.x, y: in_mouseHelper.y, z: in_mouseHelper.z }, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CARTESIAN);

			if (mousePix != null) {
				if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].healpix4footprints) {
					if (this._footprintsInPix256.has(mousePix)) {
						// console.log("mouse pixel (n=8): "+mousePix+ "
						// "+this._footprintsInPix256.get(mousePix).length+" possible x-matches");

						for (let i = 0; i < this._footprintsInPix256.get(mousePix).length; i++) {

							let footprint = this._footprintsInPix256.get(mousePix)[i];
							// console.log(footprint.identifier+" pixels (n=8): "+ footprint.pixels ) ;

							if (_utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_6__["default"].pointInsidePolygons2(footprint.convexPolygons, mousePoint)) {
								console.log("INSIDE " + footprint.identifier + " pixel " + mousePix);
							}

						}

					}

				} else {

					for (let i = 0; i < this._footprints.length; i++) {

						let footprint = this._footprints[i];

						if (_utils_GeomUtils_js__WEBPACK_IMPORTED_MODULE_6__["default"].checkPointInsidePolygon5(footprint._selectionObj, mousePoint)) {

							let details = [...footprint._details]
							details.splice(this._geomColumn._index, 1);
							this._hoveredFootprints.push(footprint);
							this._totHoveredPoints += footprint.totPoints;
						}

					}
					// if (this._hoveredFootprints.length > 0) {
						this.initHoveringBuffer();

					// }

				}
			}
		}
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.updateHoveredFootprints(this, this._hoveredFootprints);
	}

	highlightFootprint(footprint, highlighted) {
		if (highlighted) {
			this._hoveredFootprints.push(footprint);
			this._totHoveredPoints += footprint.totPoints;
		} else {
			const indexOfFootprint = this._hoveredFootprints.indexOf(footprint)
			this._hoveredFootprints.splice(indexOfFootprint, 1)
			this._totHoveredPoints -= footprint.totPoints;
		}
		this.initHoveringBuffer();
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.updateHoveredFootprints(this, this._hoveredFootprints);

	}

	/**
	 * 
	 * @param {Footprint[]} footprints
	 */

	addFootprint2Selected(footprints) {
		let refreshBuffer = false;
		for (let f of footprints) {
			if (!this._selectedFootprints.includes(f)) {
				this._selectedFootprints.push(f);
				this._totSelectedPoints += f.totPoints;
				refreshBuffer = true;
			}
		}
		if (refreshBuffer) {
			this.initSelectionBuffer();
		}
	}

	/**
	 * 
	 * @param {Footprint} footprint 
	 */
	removeFootprintFromSelection(footprint) {
		const indexOfObject = this._selectedFootprints.indexOf(footprint)
		if (indexOfObject >= 0) {

			this._selectedFootprints.splice(indexOfObject, 1);
			this._totSelectedPoints -= footprint.totPoints;
			if (this._selectedFootprints.length > 0) {
				this.initSelectionBuffer();
			}

		}

		// const h = this._hoveredFootprints.indexOf(footprint)
		// const f = this._footprints.indexOf(footprint)
		// console.log(f)

	}

	initHoveringBuffer() {

		/*
		TODO better approach. when creating the indexbuffer of footprints, 
		add 1 extra position for the selection (set to 0 == not selected), 
		and save the position "positionIndex" in an array (selectionIndexes).
		When checking the selection, I get the index of the footprint, which
		matches with the index in the selectionIndexes to retrieve the position 
		of the flag to be set to 1 in the vertexposition
		This will ease checking the selection in the vertex/fragment shader and
		set the pointsize and shape color.
		*/

		if (this._hoveredFootprints.length == 0) {
			return
		}
		let nFootprints = this._hoveredFootprints.length;

		let npolygons = nFootprints - 1;
		for (let j = 0; j < nFootprints; j++) {
			npolygons += this._hoveredFootprints[j].polygons.length - 1;
		}
		// this._selectedIndex = new Uint16Array(this._totSelectedPoints + npolygons);
		// let MAX_UNSIGNED_SHORT = 65535; // this is used to enable and disable GL_PRIMITIVE_RESTART_FIXED_INDEX

		this._hoveredIndex = new Uint32Array(this._totHoveredPoints + npolygons);
		let MAX_UNSIGNED_SHORT = 0xFFFFFFFF; // this is used to enable and disable GL_PRIMITIVE_RESTART_FIXED_INDEX
		// let MAX_UNSIGNED_SHORT = Number.MAX_SAFE_INTEGER;

		let gl = this._gl;

		gl.bindBuffer(gl.ARRAY_BUFFER, this._hoveredVertexPositionBuffer);

		this._hoveredVertexPosition = new Float32Array(3 * this._totHoveredPoints);
		let positionIndex = 0;
		let vIdx = 0;

		let R = 1.0;
		this._nHoveredPrimitiveFlags = 0;

		for (let j = 0; j < nFootprints; j++) {

			let footprintPoly = this._hoveredFootprints[j].polygons;

			if (j > 0) {
				this._hoveredIndex[vIdx] = MAX_UNSIGNED_SHORT;
				this._nHoveredPrimitiveFlags += 1;
				vIdx += 1;
			}

			for (let polyIdx in footprintPoly) {
				if (polyIdx > 0) {
					this._hoveredIndex[vIdx] = MAX_UNSIGNED_SHORT;
					this._nHoveredPrimitiveFlags += 1;
					vIdx += 1;
				}
				for (let pointIdx in footprintPoly[polyIdx]) {

					this._hoveredVertexPosition[positionIndex] = R * footprintPoly[polyIdx][pointIdx].x;
					this._hoveredVertexPosition[positionIndex + 1] = R * footprintPoly[polyIdx][pointIdx].y;
					this._hoveredVertexPosition[positionIndex + 2] = R * footprintPoly[polyIdx][pointIdx].z;

					this._hoveredIndex[vIdx] = Math.floor(positionIndex / 3);

					vIdx += 1;
					positionIndex += 3;

				}


			}
		}



	}

	initSelectionBuffer() {

		/*
		TODO better approach. when creating the indexbuffer of footprints, 
		add 1 extra position for the selection (set to 0 == not selected), 
		and save the position "positionIndex" in an array (selectionIndexes).
		When checking the selection, I get the index of the footprint, which
		matches with the index in the selectionIndexes to retrieve the position 
		of the flag to be set to 1 in the vertexposition
		This will ease checking the selection in the vertex/fragment shader and
		set the pointsize and shape color.
		*/


		let nFootprints = this._selectedFootprints.length;

		let npolygons = nFootprints - 1;
		for (let j = 0; j < nFootprints; j++) {
			npolygons += this._selectedFootprints[j].polygons.length - 1;
		}
		// this._selectedIndex = new Uint16Array(this._totSelectedPoints + npolygons);
		// let MAX_UNSIGNED_SHORT = 65535; // this is used to enable and disable GL_PRIMITIVE_RESTART_FIXED_INDEX

		this._selectedIndex = new Uint32Array(this._totSelectedPoints + npolygons);
		let MAX_UNSIGNED_SHORT = 0xFFFFFFFF; // this is used to enable and disable GL_PRIMITIVE_RESTART_FIXED_INDEX
		// let MAX_UNSIGNED_SHORT = Number.MAX_SAFE_INTEGER;

		let gl = this._gl;

		gl.bindBuffer(gl.ARRAY_BUFFER, this._selectedVertexPositionBuffer);

		this._selectedVertexPosition = new Float32Array(3 * this._totSelectedPoints);
		let positionIndex = 0;
		let vIdx = 0;

		let R = 1.0;
		this._nSlectedPrimitiveFlags = 0;

		for (let j = 0; j < nFootprints; j++) {

			let footprintPoly = this._selectedFootprints[j].polygons;

			if (j > 0) {
				this._selectedIndex[vIdx] = MAX_UNSIGNED_SHORT;
				this._nSlectedPrimitiveFlags += 1;
				vIdx += 1;
			}
			for (let polyIdx in footprintPoly) {
				if (polyIdx > 0) {
					this._selectedIndex[vIdx] = MAX_UNSIGNED_SHORT;
					this._nSlectedPrimitiveFlags += 1;
					vIdx += 1;
				}
				for (let pointIdx in footprintPoly[polyIdx]) {

					this._selectedVertexPosition[positionIndex] = R * footprintPoly[polyIdx][pointIdx].x;
					this._selectedVertexPosition[positionIndex + 1] = R * footprintPoly[polyIdx][pointIdx].y;
					this._selectedVertexPosition[positionIndex + 2] = R * footprintPoly[polyIdx][pointIdx].z;

					this._selectedIndex[vIdx] = Math.floor(positionIndex / 3);

					vIdx += 1;
					positionIndex += 3;

				}


			}
		}



	}

	enableShader(in_mMatrix) {

		_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.useProgram(this._shaderProgram);
		this._shaderProgram.catUniformMVMatrixLoc = this._gl.getUniformLocation(this._shaderProgram, "uMVMatrix");
		this._shaderProgram.catUniformProjMatrixLoc = this._gl.getUniformLocation(this._shaderProgram, "uPMatrix");
		this._shaderProgram.pointsize = this._gl.getUniformLocation(this._shaderProgram, "u_pointsize");



		this._attribLocations.position = this._gl.getAttribLocation(this._shaderProgram, 'aCatPosition');

		this._attribLocations.color = this._gl.getUniformLocation(this._shaderProgram, 'u_fragcolor');


		var mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.create();
		mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__.multiply(mvMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].camera.getCameraMatrix(), in_mMatrix);
		this._gl.uniformMatrix4fv(this._shaderProgram.catUniformMVMatrixLoc, false, mvMatrix);
		this._gl.uniformMatrix4fv(this._shaderProgram.catUniformProjMatrixLoc, false, _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].pMatrix);
		this._gl.uniform1f(this._shaderProgram.pointsize, 14.0);
	}

	/**
	 * @param in_Matrix:
	 *            model matrix the current catalogue is associated to (e.g. HiPS
	 *            matrix)
	 */
	draw(in_mMatrix, in_mouseHelper) {

		this.enableShader(in_mMatrix);



		// MOUSE selection
		if (in_mouseHelper != null && in_mouseHelper.xyz != this._oldMouseCoords) {

			this.checkSelection(in_mouseHelper);

		}
		if (this._hoveredFootprints.length > 0) {

			// TODO POINT_SIZE doesn't have any effect on line thickness!! it only applies to points
			let rgb = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_0__.colorHex2RGB)("#00FF00");
			let alpha = 1.0;
			rgb[3] = alpha;
			this._gl.uniform4f(this._attribLocations.color, rgb[0], rgb[1], rgb[2], rgb[3]);
			this._gl.uniform1f(this._shaderProgram.pointsize, 14.0);	// <--- POINT_SIZE in LINE_LOOP is not applicable

			this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._hoveredVertexPositionBuffer);
			this._gl.bufferData(this._gl.ARRAY_BUFFER, this._hoveredVertexPosition, this._gl.STATIC_DRAW);

			// setting footprint position
			this._gl.vertexAttribPointer(this._attribLocations.position, FootprintSet.ELEM_SIZE, this._gl.FLOAT, false, FootprintSet.BYTES_X_ELEM * FootprintSet.ELEM_SIZE, 0);
			this._gl.enableVertexAttribArray(this._attribLocations.position);

			this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._hoveredIndexBuffer);
			this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, this._hoveredIndex, this._gl.STATIC_DRAW);

			// this._gl.drawElements (this._gl.LINE_LOOP, this._selectedVertexPosition.length / 3 + this._nSlectedPrimitiveFlags,this._gl.UNSIGNED_SHORT, 0);
			this._gl.drawElements(this._gl.LINE_LOOP, this._hoveredVertexPosition.length / 3 + this._nHoveredPrimitiveFlags, this._gl.UNSIGNED_INT, 0);
		}

		if (this._selectedFootprints.length > 0) {


			let rgb = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_0__.colorHex2RGB)("#ECB462");
			let alpha = 1.0;
			rgb[3] = alpha;
			this._gl.uniform4f(this._attribLocations.color, rgb[0], rgb[1], rgb[2], rgb[3]);
			this._gl.uniform1f(this._shaderProgram.pointsize, 14.0);	// <--- POINT_SIZE in LINE_LOOP is not applicable

			this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._selectedVertexPositionBuffer);
			this._gl.bufferData(this._gl.ARRAY_BUFFER, this._selectedVertexPosition, this._gl.STATIC_DRAW);

			// setting footprint position
			this._gl.vertexAttribPointer(this._attribLocations.position, FootprintSet.ELEM_SIZE, this._gl.FLOAT, false, FootprintSet.BYTES_X_ELEM * FootprintSet.ELEM_SIZE, 0);
			this._gl.enableVertexAttribArray(this._attribLocations.position);

			this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._selectedIndexBuffer);
			this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, this._selectedIndex, this._gl.STATIC_DRAW);

			// this._gl.drawElements (this._gl.LINE_LOOP, this._selectedVertexPosition.length / 3 + this._nSlectedPrimitiveFlags,this._gl.UNSIGNED_SHORT, 0);
			this._gl.drawElements(this._gl.LINE_LOOP, this._selectedVertexPosition.length / 3 + this._nSlectedPrimitiveFlags, this._gl.UNSIGNED_INT, 0);

		}

		// TODO move this out of the draw method <- ?
		this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexCataloguePositionBuffer);
		this._gl.bufferData(this._gl.ARRAY_BUFFER, this._vertexCataloguePosition, this._gl.STATIC_DRAW);

		// setting footprint position
		this._gl.vertexAttribPointer(this._attribLocations.position, FootprintSet.ELEM_SIZE, this._gl.FLOAT, false, FootprintSet.BYTES_X_ELEM * FootprintSet.ELEM_SIZE, 0);
		this._gl.enableVertexAttribArray(this._attribLocations.position);

		this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
		this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, this._indexes, this._gl.STATIC_DRAW);

		// setting footprint shape color
		var rgb = (0,_utils_Utils_js__WEBPACK_IMPORTED_MODULE_0__.colorHex2RGB)(this._shapeColor);
		var alpha = 1.0;
		rgb[3] = alpha;
		this._gl.uniform4f(this._attribLocations.color, rgb[0], rgb[1], rgb[2], rgb[3]);

		this._gl.uniform1f(this._shaderProgram.pointsize, 4.0);
		/**
		 * OPENGL code sample * polygons = [ * 0,0, 10,0, 10,5, 5,10, // polygon
		 * 1 * 20,20, 30,20, 30,30 // polygon 2 * ] *
		 * glEnable(GL_PRIMITIVE_RESTART); * glPrimitiveRestartIndex(65535); *
		 * index = [0,1,2,3,65535,4,5,6,65535,...] * //bind and fill
		 * GL_ELEMENT_ARRAY_BUFFER * glDrawElements(GL_LINE_LOOP, index.size,
		 * GL_UNSIGNED_INT, 0); * //will draw lines `0,1 1,2 2,3 3,0 4,5 5,6
		 * 6,4`
		 */



		/*
		 * this is not needed in WebGL since it's enabled by default
		 * this._gl.glEnable ( GL_PRIMITIVE_RESTART_FIXED_INDEX ); // 65535
		 * https://www.khronos.org/registry/webgl/specs/latest/2.0/#4.1.4
		 * https://github.com/KhronosGroup/glTF/issues/1142
		 */
		var ext = this._gl.getExtension('OES_element_index_uint');
		this._gl.drawElements(this._gl.LINE_LOOP, this._vertexCataloguePosition.length / 3 + this._nPrimitiveFlags, this._gl.UNSIGNED_INT, 0);
		// this._gl.drawElements (this._gl.LINE_LOOP, this._vertexCataloguePosition.length / 3 + this._nPrimitiveFlags,this._gl.UNSIGNED_SHORT, 0);
		if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].showPointsInPolygons) {
			// this._gl.drawElements (this._gl.POINT, this._vertexCataloguePosition.length / 3 + 1,this._gl.UNSIGNED_SHORT, 0);
			this._gl.drawElements(this._gl.POINT, this._vertexCataloguePosition.length / 3 + 1, this._gl.UNSIGNED_SHORT, 0);
			//		this._gl.drawElements (this._gl.POINT, 1,this._gl.UNSIGNED_SHORT, 0);
		}








		// if (global.showConvexPolygons){

		// 	rgb = colorHex2RGB(this._shapeColor);
		// 	var alpha = 0.3;
		// 	rgb[3] = alpha;
		// 	this._gl.uniform4f(this._attribLocations.color, 1., 0., 0., rgb[3]);

		// 	this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._vertexConvexPolyPositionBuffer);
		// 	this._gl.bufferData(this._gl.ARRAY_BUFFER, this._vertexConvexPolyPosition, this._gl.STATIC_DRAW);
		// 	this._gl.vertexAttribPointer(this._attribLocations.position, FootprintSet.CONVEXPOLY_ELEM_SIZE, this._gl.FLOAT, false, FootprintSet.BYTES_X_ELEM * FootprintSet.CONVEXPOLY_ELEM_SIZE, 0);
		// 	this._gl.enableVertexAttribArray(this._attribLocations.position);			
		// 	this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._convexIndexBuffer);
		// 	this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, this._convexIndexes, this._gl.STATIC_DRAW);
		// 	this._gl.drawElements (this._gl.LINE_LOOP, this._vertexConvexPolyPosition.length / 3 + 1,this._gl.UNSIGNED_SHORT, 0);

		// }



		this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);
		this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, null);
		this._oldMouseCoords = in_mouseHelper.xyz;

	}


}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FootprintSet);

/***/ }),

/***/ "./src/js/modules/controlpanel/gotopanel/GoToPresenter.js":
/*!****************************************************************!*\
  !*** ./src/js/modules/controlpanel/gotopanel/GoToPresenter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_GoToEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/GoToEvent.js */ "./src/js/modules/controlpanel/gotopanel/events/GoToEvent.js");
/* harmony import */ var _GoToView_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GoToView.js */ "./src/js/modules/controlpanel/gotopanel/GoToView.js");
/* harmony import */ var _services_SesameService_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services/SesameService.js */ "./src/js/modules/controlpanel/gotopanel/services/SesameService.js");







/**
 * @author Fabrizio Giordano (Fab77)
 */

class GoToPresenter {

    _view;

    /**
     * 
     * @param {GoToView} view 
     */
    constructor(view) {
        this._view = view;
        var _self = this;
        // console.log(this._view.getSearchButton());
        this._view.getTargetName().keydown(function(event) {
            event.stopPropagation();
        });

        this._view.getSearchButton().on("click", () => {

            if (_self._view.getRADec().val() !== undefined && _self._view.getRADec().val() != '') {

                // TODO parse _self._view.getRADec().val()
                let raDec = _self._view.getRADec().val().replace(/  +/g, ' ').split(" ");
                _events_EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].fireEvent(new _events_GoToEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"](raDec[0], raDec[1]));

            } else if (_self._view.getTargetName().val() !== undefined && _self._view.getTargetName().val() != '') {
                let nmResolver = _self._view.getNameResolver().val();
                let tName = _self._view.getTargetName().val();
                _services_SesameService_js__WEBPACK_IMPORTED_MODULE_3__["default"].queryByTargetName(tName).then((radecdeg) => {

                    _events_EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].fireEvent(new _events_GoToEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"](radecdeg.ra, radecdeg.dec));

                }
                );
                // TODO call name resolver service and compute coordinates
                // and than eventBus.fireEvent(new GoToEvent(raDec[0], raDec[1]));
            }
        });

    }

    get view() {
        return this._view;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GoToPresenter);

/***/ }),

/***/ "./src/js/modules/controlpanel/gotopanel/GoToView.js":
/*!***********************************************************!*\
  !*** ./src/js/modules/controlpanel/gotopanel/GoToView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */



class GoToView {

    constructor() {

        this.init();

        var _public = {
            getHtml: () => {
                return this._html;
            },
            toggle: () => {
                if (this._visible) {
                    this._html.css("display", "none");
                    this._visible = false;
                } else {
                    this._html.css("display", "block");
                    this._visible = true;
                }

            },
            close: () => {
                // if (this._visible){
                this._html.css("display", "none");
                this._visible = false;
                // }
            },
            getSearchButton: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__('#goto_search');
            },
            getRADec: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__('#gotoRADec');
            },
            getTargetName: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__('#gotoName');
            },
            getNameResolver: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__('#gotoNameResolver');
            }
        }

        return _public;

    }

    init() {
        this._visible = false;
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__(`
        <div id='gotoPanel' class='controlPanel'>
            <div><span>RA, Dec:</span>&nbsp;<input type='text' id='gotoRADec'/></div>
            <div><span>Name:</span>&nbsp;<input type='text' id='gotoName'/></div>
            <!-- <select id='gotoNameResolver' onmousedown='event.stopPropagation()'>
                <option value='simbad'>SIMBAD</option>
                <option value='ned'>NED</option>
            </select> -->
            <button class='button' id='goto_search'>search</button>
        </div>`);
        this._html.css("display", "none");
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GoToView);

/***/ }),

/***/ "./src/js/modules/controlpanel/gotopanel/events/GoToEvent.js":
/*!*******************************************************************!*\
  !*** ./src/js/modules/controlpanel/gotopanel/events/GoToEvent.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class GoToEvent{

    _raDeg;
    _decDeg;
    static name = "GoToEvent";

    constructor(raDeg, decDeg) {
        this._decDeg = decDeg;
        this._raDeg = raDeg;
    }

    get name(){
		return GoToEvent.name;
	}

    get raDeg() {
        return this._raDeg
    }

    get decDeg() {
        return this._decDeg
    }


}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GoToEvent);

/***/ }),

/***/ "./src/js/modules/controlpanel/gotopanel/services/SesameService.js":
/*!*************************************************************************!*\
  !*** ./src/js/modules/controlpanel/gotopanel/services/SesameService.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * @author Fabrizio Giordano (Fab)
 */


class SesameService {

    constructor(){
        // TODO move this URL into Config
        this._baseURL = "https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-ox?";
    }

    async queryByTargetName(targetName) {
        let url = this._baseURL+targetName;
        return window.fetch(url, {
            method: 'GET',
            mode: 'cors',
        }).then( res => res.text()
        ).then(xmlStr => {
            xmlStr = xmlStr.replaceAll('\n\t', '');
            xmlStr = xmlStr.replaceAll('\t', '');
            xmlStr = xmlStr.replaceAll('\n', '');
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlStr, "application/xml");
            // console.log(doc);
            if (doc.childElementCount > 1) {
                console.error("Error parsing Sesame XML. More than 1 node from root");
                return null;
            }

            for (let i = 0; i < doc.childNodes[0].childElementCount; i++) {
                let target = doc.childNodes[0].childNodes[i];
    
                if (target.nodeName != 'Target') {
                    continue;
                }
                for (let t = 0; t < target.childNodes.length; t++ ) {
                    let child = target.childNodes[t];
                    if (child.nodeName == 'Resolver') {
                        let raDeg = child.getElementsByTagName("jradeg")[0].innerHTML;
                        let decDeg = child.getElementsByTagName("jdedeg")[0].innerHTML;
                        console.log(raDeg, decDeg);
                        return {"ra": raDeg, "dec": decDeg}
                    }
                }

            }

        });
    }

}


var sesameService = new SesameService();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sesameService);

/***/ }),

/***/ "./src/js/modules/controlpanel/hipspanel/HiPSListPresenter.js":
/*!********************************************************************!*\
  !*** ./src/js/modules/controlpanel/hipspanel/HiPSListPresenter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cutoutpanel_CutoutPanelView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cutoutpanel/CutoutPanelView.js */ "./src/js/modules/controlpanel/cutoutpanel/CutoutPanelView.js");
/* harmony import */ var _cutoutpanel_CutoutPanelPresenter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cutoutpanel/CutoutPanelPresenter.js */ "./src/js/modules/controlpanel/cutoutpanel/CutoutPanelPresenter.js");
/* harmony import */ var _events_InsideSphereSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../events/InsideSphereSelectionChangedEvent.js */ "./src/js/events/InsideSphereSelectionChangedEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _model_hipsnew_HiPS_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../model/hipsnew/HiPS.js */ "./src/js/model/hipsnew/HiPS.js");
/* harmony import */ var _repos_HiPSNodeRepo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../repos/HiPSNodeRepo.js */ "./src/js/repos/HiPSNodeRepo.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _config_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../config.json */ "./src/js/config.json");
/* harmony import */ var _utils_Session_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/Session.js */ "./src/js/utils/Session.js");
/* harmony import */ var _dataexplorer_model_ColorMaps_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../dataexplorer/model/ColorMaps.js */ "./src/js/modules/dataexplorer/model/ColorMaps.js");


















class HiPSListPresenter {

	_id;
	_view;
	_visibileHiPS;

	constructor(in_view) {
		this._visibileHiPS = [];
		this._view = in_view;
		this._model = null;
		this.hipsPresenters = [];
		this.timeCounter = 0;
		this._id = 0;
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].registerForEvent(this, _events_InsideSphereSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"].name);

		let _self = this;


		_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"]._HiPSNodes.forEach((hipsNodeUrl) => {

			let tableData = [];
			(0,_repos_HiPSNodeRepo_js__WEBPACK_IMPORTED_MODULE_5__.addHiPSNode)(hipsNodeUrl).then((hipslist) => {

				let promises = [];

				if (hipslist !== undefined) {
					hipslist.forEach((hipsurl) => {

						promises.push((0,_repos_HiPSNodeRepo_js__WEBPACK_IMPORTED_MODULE_5__.addHiPS)(hipsurl).then((descriptor) => {

							// let dtIcon = undefined;
							// const dtEnabled = descriptor.imgFormats.includes("fits") ? true : false;
							// if (dtEnabled) {
							// 	dtIcon = "scissor.svg";
							// }

							// console.log(config.defaultHipsUrl)
							// console.log(hipsurl.replace('http:','').replace('https:',''))
							// console.log(hipsurl.replace('http:','').replace('https:','') == config)

							// DEFAULT HIPS SELECTION!!!
							// let selected = global.defaultHips.name === descriptor.surveyName && config.defaultHipsUrl == hipsurl.replace('/http:','').replace('/https:','') ? true : false;
							let selected = _config_json__WEBPACK_IMPORTED_MODULE_7__.defaultHipsUrl == hipsurl.replace('http:','').replace('https:','') ? true : false;
							if (selected) {
								_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.activateHiPS(_Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultHips);
							}
							let hips = selected ? _Global_js__WEBPACK_IMPORTED_MODULE_6__["default"].defaultHips : null;
							const coordSystem = descriptor.isGalactic ? "galactic" : "equatorial"
							tableData.push({
								id: _self._id,
								selected: selected,
								name: descriptor.surveyName,
								image_format: descriptor.imgFormats,
								coord_sys: coordSystem,
								// data_explorer: dtIcon,
								em_min: descriptor.emMin,
								em_max: descriptor.emMax,
								descriptor: descriptor,
								hips: hips
							})

							_self._id++;

						}));

					})


					// promises.push(addHiPS("https://alasky.cds.unistra.fr/Pan-STARRS/DR1/g").then((descriptor) => {

					// 	let dtIcon = undefined;
					// 	const dtEnabled = descriptor.imgFormats.includes("fits") ? true : false;
					// 	if (dtEnabled) {
					// 		dtIcon = "scissor.svg";
					// 	}
					// 	let selected = (global.defaultHips.name === descriptor.surveyName) ? true : false;
					// 	if (selected) {
					// 		session.activateHiPS(global.defaultHips);
					// 	}
					// 	let hips = selected ? global.defaultHips : null;
					// 	const coordSystem = descriptor.isGalactic ? "galactic" : "equatorial"
					// 	tableData.push({
					// 		id: _self._id,
					// 		selected: selected,
					// 		name: descriptor.surveyName,
					// 		image_format: descriptor.imgFormats,
					// 		coord_sys: coordSystem,
					// 		data_explorer: dtIcon,
					// 		descriptor: descriptor,
					// 		hips: hips
					// 	})

					// 	_self._id++;

					// }));


					Promise.all(promises).then(() => {
						if (tableData.length > 0) {
							_self._view.addHiPSNode(hipsNodeUrl, tableData, _self.hipsSelectionHandler, _self.cutoutFormHandler, _self);
						}
					})

				}
			}).catch(function (err) {
				console.log("[HiPSListPresenter] " + err);
			});

		});

		this.addButtonsClickHandlers();
		this.registerForEvents();
		// this.initCutoutForm();
	}

	registerForEvents() {
		// eventBus.registerForEvent(this, OpenDataExplorerPanelEvent.name);
		// eventBus.registerForEvent(this, OpenPanelEvent.name);
	}

	notify(event) {

		// switch (event.constructor) {
		// 	case OpenDataExplorerPanelEvent:
		// 		console.log("OpenDataExplorerPanelEvent")
		// 		if (!this._dataExplorerPresenter) {
		// 			this._dataExplorerView = new DEView();
		// 			this._dataExplorerPresenter = new DEPresenter(this._dataExplorerView);
		// 			this.view.openDataExplorer(this._dataExplorerView.getHtml());
		// 		}
		// 		this._dataExplorerPresenter.toggle();
		// 		this._dataExplorerPresenter.refreshModel(event.pxSize, event.craDeg, event.cdecDeg, event.radiusDeg, event.projectionName, event._hipsURL);
		// 		break;

		// 	case OpenPanelEvent:
		// 		console.log("OpenPanelEvent")
		// 		if (event.panelName == "DataExplorer") {
		// 			this._dataExplorerPresenter.toggle();
		// 		}
		// 		break;
		// }
	}

	initCutoutForm() {
		this._cutoutPanelView = new _cutoutpanel_CutoutPanelView_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
		this._cutoutPresenter = new _cutoutpanel_CutoutPanelPresenter_js__WEBPACK_IMPORTED_MODULE_1__["default"](this._cutoutPanelView);
		this.view.openCutoutForm(this._cutoutPanelView.getHtml());
	}

	cutoutFormHandler(descriptor, caller) {
		caller._cutoutPresenter.toggle(descriptor)
	}

	hipsSelectionHandler(descriptor, checked, rowId, remove_thi_variable_hips, hipsNodeId, caller) {
		console.log(_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.activeHiPS)
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.activeHiPS.forEach( (h) => {
			console.log("deactivating hips "+ h)
			_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.deactivateHiPS(h);
		})
		console.log(_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.activeHiPS)

		let formats = descriptor.imgFormats; // getting first format available (//TODO check that it's not fits)
		let format;
		formats.forEach( (f) => {
			if (f == 'png' || f == 'jpg')
				format = f;
		});
		// let opacity = this.view.getSelectedOpacity() / 100; // TODO handle opacity here
		let opacity = 1.0; // TODO not used in HiPS. review it! and review global.defaultHiPS in which I am passing 9 (max order) instead of opacity
		// const isGalactic = descriptor.hipsFrame == 'galactic' ? true : false; // TODO handle Galactic frame
		const isGalactic = false;
		let hips = new _model_hipsnew_HiPS_js__WEBPACK_IMPORTED_MODULE_4__["default"](1, [0.0, 0.0, 0.0],
			0,
			0, descriptor.surveyName,
			descriptor.url, format,
			opacity, isGalactic, descriptor);
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.activateHiPS(hips);
		caller._view.hipsActivated(rowId, hips, hipsNodeId);


		// if (!checked) {
		// 	session.deactivateHiPS(hips);
		// } else {
		// 	// let format = descriptor.imgFormats[1]; // getting first format available (//TODO check that it's not fits)
		// 	let formats = descriptor.imgFormats; // getting first format available (//TODO check that it's not fits)
		// 	let format;
		// 	formats.forEach( (f) => {
		// 		if (f == 'png' || f == 'jpg')
		// 			format = f;
		// 	});
		// 	// let opacity = this.view.getSelectedOpacity() / 100; // TODO handle opacity here
		// 	let opacity = 1.0; // TODO not used in HiPS. review it! and review global.defaultHiPS in which I am passing 9 (max order) instead of opacity
		// 	// const isGalactic = descriptor.hipsFrame == 'galactic' ? true : false; // TODO handle Galactic frame
		// 	const isGalactic = false;
		// 	let hips = new HiPS(1, [0.0, 0.0, 0.0],
		// 		0,
		// 		0, descriptor.surveyName,
		// 		descriptor.url, format,
		// 		opacity, isGalactic, descriptor);
		// 	session.activateHiPS(hips);
		// 	caller._view.hipsActivated(rowId, hips, hipsNodeId);
		// }
	}



	addButtonsClickHandlers() {

		this.view.colorMapDropDown().on("change", { caller: this }, this.colorMapChanged);
		this.view.invertColorMap().on("change", { caller: this }, this.invertColorChanged);

		this.view.filterField().on("change", { caller: this }, this.updateFilter)
        this.view.filterType().on("change", { caller: this }, this.updateFilter)
        this.view.filterValue().on("keyup", { caller: this }, this.updateFilter)
        this.view.clearFilter().on("click", { caller: this  }, this.clearFilterClicked)
        

	}

	clearFilterClicked(event) {
        console.log("clearFilter")
		let view = event.data.caller.view
        view.clearFilterClicked();
    }

    updateFilter(event) {
        console.log("updateFilter")
		let view = event.data.caller.view
        let filterVal = view.filterField().val();
        let typeVal = view.filterType().val();
		let value = view.filterValue().val()

        let filter = filterVal;
        view.filterType().disabled = false;
        view.filterValue().disabled = false;


        if (filterVal) {
            view.filterTable(filter, typeVal, value);
        }
    }
	colorMapChanged(event) {
		let valueSelected = this.value;
		console.log(valueSelected)
		let caller = event.data.caller;
		_utils_Session_js__WEBPACK_IMPORTED_MODULE_8__.session.activeHiPS.forEach(hips => {
			hips.changeColorMap(_dataexplorer_model_ColorMaps_js__WEBPACK_IMPORTED_MODULE_9__["default"][valueSelected]);
		});

	}

	invertColorChanged(event) {
		let target = event.target;
		let checked = target.checked;
		console.log(checked)

	}


	get view() {
		return this._view;
	}



	toggle() {
		this._view.toggle();
	}



}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HiPSListPresenter);

/***/ }),

/***/ "./src/js/modules/controlpanel/hipspanel/HiPSPanelView.js":
/*!****************************************************************!*\
  !*** ./src/js/modules/controlpanel/hipspanel/HiPSPanelView.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var _dataexplorer_model_ColorMaps_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dataexplorer/model/ColorMaps.js */ "./src/js/modules/dataexplorer/model/ColorMaps.js");
/* harmony import */ var tabulator_tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tabulator-tables */ "./node_modules/tabulator-tables/dist/js/tabulator_esm.js");





class HiPSPanelView {

    _html;
    _visible;
    _dataTables;

    constructor() {

        this._dataTables = new Map();

        this.init();

        const _public = {
            getHtml: () => {
                return this._html;
            },
            // TODO move this into Utils
            urlSanifier: (url) => {
                let sanified = url.replace('https://', '').replace('http://', '').replaceAll("/", "_").replaceAll(".", "_");
                return sanified;
            },
            addHiPSNode: (hipsNodeUrl, tableData, hipsSelectionHandler, cutoutFormHandler, caller) => {
                const hipsNodeId = _public.urlSanifier(hipsNodeUrl);
                jquery__WEBPACK_IMPORTED_MODULE_0__("#" + this._hipsNodesId).append("<label for='" + hipsNodeId + "'>" + hipsNodeUrl + "</label><div id='" + hipsNodeId + "'></div>");

                let tableHeight = 250;
                if ((tableData.length * 40) < 200) {
                    tableHeight = tableData.length * 40;
                }

                let table = new tabulator_tables__WEBPACK_IMPORTED_MODULE_2__.TabulatorFull("#" + hipsNodeId, {
                    height: tableHeight, // set height of table (in CSS or here), this enables the Virtual DOM and improves render speed dramatically (can be any valid css height value)
                    width: '550px',
                    data: tableData, //assign data to table
                    // layout: "fitColumns", //fit columns to width of table (optional)
                    columns: [ //Define Table Columns
                        {
                            title: "#",
                            field: "selected",
                            width: 15,
                            formatter: (cell) => {
                                const value = cell.getValue();
                                if (value) {
                                    // return `<input type="checkbox" checked/>`;
                                    return `<input name="hips_selection" type="radio" checked/>`;
                                } else {
                                    // return `<input type="checkbox" />`;
                                    return `<input name="hips_selection" type="radio" />`;
                                }
                            },

                        },
                        {
                            title: "Name",
                            field: "name",
                            width: 131,
                            hozAlign: "left",
                            formatter: "textarea",
                            headerFilter:"input"
                        },
                        {
                            title: "Image format",
                            field: "image_format",
                            width: 112,
                            hozAlign: "left",
                            formatter: "textarea",
                            headerFilter:"input"
                        },
                        {
                            title: "CoordFrame",
                            field: "coord_sys",
                            width: 95,
                            hozAlign: "left",
                            formatter: "plaintext",
                            headerFilter:"input"
                        },
                        {
                            title: "em_min",
                            field: "em_min",
                            width: 95,
                            hozAlign: "left",
                            formatter: "plaintext",
                            headerFilter:"input",
                            sorter: "number"
                        },
                        {
                            title: "em_max",
                            field: "em_max",
                            width: 95,
                            hozAlign: "left",
                            formatter: "plaintext",
                            headerFilter:"input",
                            sorter: "number"
                        },
                        // {
                        //     title: "Data Explorer",
                        //     field: "data_explorer",
                        //     width: 25,
                        //     formatter: (cell, formatterParams) => {
                        //         if (cell.getValue() !== undefined ){
                        //             return "<img src='images/"+cell.getValue()+"' style='height: 20px; width: 20px;'>"
                        //         }else{
                        //             return "";
                        //         }
                        //     },
                        // },
                        {
                            title: "Descriptor",
                            field: "descriptor",
                            visible: false
                        },
                        {
                            title: "HiPS",
                            field: "hips",
                            visible: false
                        }
                    ],
                });

                this._dataTables.set(hipsNodeId, table);
                table.on("cellClick", function (e, cell) {
                    //e - the click event object
                    //cell - cell component
                    if (e.target.type == 'checkbox' || e.target.type == 'radio') {
                        hipsSelectionHandler(cell._cell.row.data.descriptor, e.target.checked, cell._cell.row.data.id, cell._cell.row.data.hips, hipsNodeId, caller)
                        cell._cell.row.moveToRow(0, true)
                        // cell._cell.row.move(1, true)
                    } 
                    // else if (e.target.nodeName == 'IMG') {
                    //     cutoutFormHandler(cell._cell.row.data.descriptor, caller)
                    // }
                });

            },
            hipsActivated: (rowId, hips, hipsNodeId) => {
                let table = this._dataTables.get(hipsNodeId);
                table.updateRow(rowId, { hips: hips });
            },
            // openCutoutForm: (html) => {
            //     $("#" + this._cutoutForm).append(html);

            // },
            openDataExplorer: (html) => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#" + this._rootDomId).append(html);

            },

            toggle: () => {
                this._html.toggle();
            },
            close: () => {
                // if (this._visible){
                this._html.css("display", "none");
                this._visible = false;
                // }
            },
            colorMapDropDown: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#hips_cmap");
            },
            invertColorMap: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#hips_inverse");
            },

            filterField: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#filter-field");
            },
            filterType: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#filter-type");
            },
            filterValue: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#filter-value");
            },
            clearFilter: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#filter-clear");
            },
            filterTable: (filter, typeVal, value) => {
                console.log("filtering")
                console.log(filter, typeVal, value)
                this._dataTables.forEach((table) => table.setFilter(filter, typeVal, value) );   
            },
            clearFilterClicked: () => {
                console.log("clearing filter")
                jquery__WEBPACK_IMPORTED_MODULE_0__("#filter-field").val("")
                jquery__WEBPACK_IMPORTED_MODULE_0__("#filter-type").val("=")
                jquery__WEBPACK_IMPORTED_MODULE_0__("#filter-value").val("")
                this._dataTables.forEach((table) => table.clearFilter() );   
            }


        }

        return _public;
    }

    

    init() {
        this._rootDomId = "hipsRootPanel";
        this._hipsNodesId = "hipsNodesPanel";
        this._hipsGeneralOptions = "hipsOptionsPanel";
        // this._cutoutForm = "cutoutForm";

        this._visible = false;

        let cmapOptions = "";
        for (let ckey in _dataexplorer_model_ColorMaps_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            if (ckey == 'native') {
                cmapOptions += "<option id='hips_cmap_opt' selected>" + ckey + "</option>";
            } else {
                cmapOptions += "<option id='hips_cmap_opt'>" + ckey + "</option>";
            }

        }


        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__(`
            <div class='controlPanel' id='${this._rootDomId}'>
                <div id='${this._hipsNodesId}' ></div>
                <div id='${this._hipsGeneralOptions}'>
                    <div>
                        <select id="filter-field">
                            <option></option>
                            <option>em_min</option>
                            <option>em_max</option>
                        </select>
                        <select id="filter-type">
                            <option value="=">=</option>
                            <option value="<"><</option>
                            <option value="<="><=</option>
                            <option value=">">></option>
                            <option value=">=">>=</option>
                            <option value="!=">!=</option>
                        </select>
                        <input id="filter-value" type="text" placeholder="value to filter">
                        <button id="filter-clear">Clear Filter</button>
                    </div>
                    Color Map: <select id='hips_cmap'>${cmapOptions}</select> &nbsp;
                    inverse: <input type='checkbox' id='hips_inverse' > 
                    <br/>
                    <!-- <button type='button'>add HiPS node</button>&nbsp; -->
                    <!-- <button type='button'>add HiPS URL</button> -->
                </div>
            </div>`);
        // this._html = $(`
        //     <div class='controlPanel' id='${this._rootDomId}'>
        //         <div id='${this._hipsNodesId}' ></div>
        //         <div id='${this._hipsGeneralOptions}'>
        //             Color Map: <select id='hips_cmap'>${cmapOptions}</select> &nbsp;
        //             inverse: <input type='checkbox' id='hips_inverse' > 
        //             <br/>
        //             <button type='button'>add HiPS node</button>&nbsp;
        //             <button type='button'>add HiPS URL</button>
        //         </div>
        //         <div id='${this._cutoutForm}'></div>
        //     </div>`);
        this._html.css("display", "none");
    }



}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HiPSPanelView);

/***/ }),

/***/ "./src/js/modules/dataexplorer/DEPresenter.js":
/*!****************************************************!*\
  !*** ./src/js/modules/dataexplorer/DEPresenter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var wcslight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wcslight */ "./node_modules/wcslight/lib-esm/index.js");
/* harmony import */ var _ctrlpanel_CtrlPanelPresenter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctrlpanel/CtrlPanelPresenter.js */ "./src/js/modules/dataexplorer/ctrlpanel/CtrlPanelPresenter.js");
/* harmony import */ var _ctrlpanel_CtrlPanelView_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ctrlpanel/CtrlPanelView.js */ "./src/js/modules/dataexplorer/ctrlpanel/CtrlPanelView.js");
/* harmony import */ var _model_Canvas2D_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/Canvas2D.js */ "./src/js/modules/dataexplorer/model/Canvas2D.js");
/* harmony import */ var _canvaspanel_CanvasPanelView_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canvaspanel/CanvasPanelView.js */ "./src/js/modules/dataexplorer/canvaspanel/CanvasPanelView.js");
/* harmony import */ var _canvaspanel_CanvasPanelPresenter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./canvaspanel/CanvasPanelPresenter.js */ "./src/js/modules/dataexplorer/canvaspanel/CanvasPanelPresenter.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_ColorMapChangeEvent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./events/ColorMapChangeEvent.js */ "./src/js/modules/dataexplorer/events/ColorMapChangeEvent.js");
/* harmony import */ var _events_ScaleFunctionChangeEvent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./events/ScaleFunctionChangeEvent.js */ "./src/js/modules/dataexplorer/events/ScaleFunctionChangeEvent.js");
/* harmony import */ var _events_InvertColorMapEvent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./events/InvertColorMapEvent.js */ "./src/js/modules/dataexplorer/events/InvertColorMapEvent.js");
/* harmony import */ var _toolbarpanel_ToolbarPanelView_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./toolbarpanel/ToolbarPanelView.js */ "./src/js/modules/dataexplorer/toolbarpanel/ToolbarPanelView.js");
/* harmony import */ var _toolbarpanel_ToolabarPanelPresenter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./toolbarpanel/ToolabarPanelPresenter.js */ "./src/js/modules/dataexplorer/toolbarpanel/ToolabarPanelPresenter.js");
/* harmony import */ var _footbar_FooterView_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./footbar/FooterView.js */ "./src/js/modules/dataexplorer/footbar/FooterView.js");
/* harmony import */ var _footbar_FooterPresenter_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./footbar/FooterPresenter.js */ "./src/js/modules/dataexplorer/footbar/FooterPresenter.js");

/**
 * @author Fabrizio Giordano (Fab)
 */

// import DEView from "./DEView.js";


















class DEPresenter {

	_pxSize;
	_raDeg;
	_decDeg;
	_radius;
	_projection;
	_ctrlView;
	_model;
	_canvas2d;



	constructor(view) {

		this.init(view);
		this._ctrlPresenter = undefined;
		var _public = {

			refreshModel: (pxSize, raDeg, decDeg, radius, projectionName, fitsURL) => {
				this.setModel(pxSize, raDeg, decDeg, radius, projectionName, fitsURL);
				this.callWCS();
			},
			toggle: () => {
				this._view.toggle();
				if (this._view.isVisible()) {
					if (this._ctrlPresenter == undefined) {
						this.initChildrenPresenters();
					}
					this._canvasPresenter.clear();
					this._footerPresenter.clear();
				}
			},
			close: () => {
				this._view.close();
			}

		}
		// this.addButtonsClickHandlers();
		return _public;
	}

	init(view) {
		this._view = view;
		this.registerForEvents();

	}


	registerForEvents() {

		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_7__["default"].registerForEvent(this, _events_ColorMapChangeEvent_js__WEBPACK_IMPORTED_MODULE_8__["default"].name);
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_7__["default"].registerForEvent(this, _events_ScaleFunctionChangeEvent_js__WEBPACK_IMPORTED_MODULE_9__["default"].name);
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_7__["default"].registerForEvent(this, _events_InvertColorMapEvent_js__WEBPACK_IMPORTED_MODULE_10__["default"].name);

		// eventBus.registerForEvent(this, ShowFITSHeaderEvent.name);
		// eventBus.registerForEvent(this, ExportFITSEvent.name);
		// eventBus.registerForEvent(this, ExportImageEvent.name);

	}

	notify(in_event) {

		if (in_event instanceof _events_ColorMapChangeEvent_js__WEBPACK_IMPORTED_MODULE_8__["default"]) {
			console.log("catched ColorMapChangeEvent " + in_event.colorMapName);
			this._canvas2d.setColorMap(in_event.colorMapName);
			this._canvas2d.applyColorAndTransferFunction();
			let img = this._canvas2d.getBrowseImage();
			this._canvasPresenter.refreshModel(img);
			this._tbarPresenter.refreshImage(this._canvas2d.getBrowseImage());

		} else if (in_event instanceof _events_ScaleFunctionChangeEvent_js__WEBPACK_IMPORTED_MODULE_9__["default"]) {
			console.log("catched ScaleFunctionChangeEvent " + in_event.scaleFunctionName);
			this._canvas2d.setTransferFunction(in_event.scaleFunctionName);
			this._canvas2d.applyColorAndTransferFunction();
			let img = this._canvas2d.getBrowseImage();
			this._canvasPresenter.refreshModel(img);
			this._tbarPresenter.refreshImage(this._canvas2d.getBrowseImage());

		} else if (in_event instanceof _events_InvertColorMapEvent_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
			console.log("catched InvertColorMapEvent " + in_event.isInverted)
			this._canvas2d.setInverseColorMap(in_event.isInverted);
			this._canvas2d.applyColorAndTransferFunction();
			let img = this._canvas2d.getBrowseImage();
			this._canvasPresenter.refreshModel(img);
			this._tbarPresenter.refreshImage(this._canvas2d.getBrowseImage());

		}
		//  else if (in_event instanceof ShowFITSHeaderEvent) {
		// 	console.log("Catched ShowFITSHeaderEvent");
		// 	console.log(this._model);
		// 	this._tbarPresenter.showFITSHeader();

		// } else if (in_event instanceof ExportFITSEvent) {
		// 	console.log("Catched ExportFITSEvent");
		// 	console.log(this._model);
		// 	this._tbarPresenter.saveFITS();

		// } else if (in_event instanceof ExportImageEvent) {
		// 	console.log("Catched ExportImageEvent");
		// 	console.log(this._canvas2d.getBrowseImage());
		// 	this._tbarPresenter.refreshImage(this._canvas2d.getBrowseImage());
		// 	this._tbarPresenter.saveImage();

		// }

	}


	setModel(pxSize, raDeg, decDeg, radius, projectionName, fitsURL) {

		this._pxSize = pxSize;
		this._raDeg = raDeg;
		this._decDeg = decDeg;
		this._radius = radius;
		this._projection = wcslight__WEBPACK_IMPORTED_MODULE_1__.WCSLight.getProjection(projectionName);
		this._ctrlView.setModel(this._pxSize, this._raDeg, this._decDeg, this._radius, projectionName);
		this._fitsURL = fitsURL;
	}

	callWCS() {
		/** HiPS to MER */
		// let center = {"ra": this._raDeg, "dec": this._decDeg};

		this._canvasPresenter.showLoading(true);
		let _self = this;

		let center = new wcslight__WEBPACK_IMPORTED_MODULE_1__.Point(wcslight__WEBPACK_IMPORTED_MODULE_1__.CoordsType.ASTRO, wcslight__WEBPACK_IMPORTED_MODULE_1__.NumberType.DEGREES, this._raDeg, this._decDeg);
		let radius = this._radius;
		let pxsize = this._pxSize;
		// TODO this must be passed
		// let hipsBaseUri = "https://skies.esac.esa.int/Herschel/normalized/PACS_hips160/";
		let hipsBaseUri = this._fitsURL;

		let inproj = new wcslight__WEBPACK_IMPORTED_MODULE_1__.HiPSProjection();
		
		inproj.parsePropertiesFile(hipsBaseUri).then(async propFile => {

			inproj.initFromHiPSLocationAndPxSize(hipsBaseUri, pxsize)
			let outproj = new wcslight__WEBPACK_IMPORTED_MODULE_1__.MercatorProjection();
			let canvasPresenter = this._canvasPresenter;
			let tbarPresenter = this._tbarPresenter;
			let dePresenter = this;

			wcslight__WEBPACK_IMPORTED_MODULE_1__.WCSLight.cutout(center, radius, pxsize, inproj, outproj).then((result) => {
				if (result.fitsused.length > 0){
					dePresenter._model = result;
					dePresenter._canvas2d = new _model_Canvas2D_js__WEBPACK_IMPORTED_MODULE_4__["default"](result.fitsdata, result.fitsheader, result.outproj);
					let img = dePresenter._canvas2d.getBrowseImage();
	
					tbarPresenter.setModel(dePresenter._model, img);
					canvasPresenter.refreshModel(img);
					dePresenter.setImageListener();
					_self._canvasPresenter.showLoading(false);
					_self._footerPresenter.addFitsUrls(result.fitsused)
				} else {
					_self._canvasPresenter.showNoDataFound();
				}
				
			})
			// .catch(function (err) {
			// 	console.log("[index.js] " + err);
			// 	_self._canvasPresenter.showLoading(false);
			// });

		});



	}

	setImageListener() {

		let dePresenter = this;
		jquery__WEBPACK_IMPORTED_MODULE_0__("#canvas_img").mousemove(function (e) {

			let bounds = this.getBoundingClientRect();
			let left = Math.floor(bounds.left);
			let top = Math.floor(bounds.top);
			let imgWidth = this.width;
			let imgHeight = this.height;
			let x = e.pageX - left;
			// FITS image is flipped in respect at HTML Image
			let y = imgHeight - (e.pageY - top);

			if (x <= imgWidth && y <= imgHeight && x > 0 && y > 0) {
				let p_value = dePresenter._canvas2d.getValueByCanvasCoords(x - 1, y - 1);
				let p_coord = dePresenter._canvas2d.getRaDecByCanvasCoords(x - 1, y - 1);
				dePresenter._ctrlPresenter.refreshPixelDetails(p_value, x, y, p_coord);

			}


		});
	}

	initChildrenPresenters() {

		this._ctrlView = new _ctrlpanel_CtrlPanelView_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
		this._view.attachCtrlPanel(this._ctrlView.getHtml());
		this._ctrlPresenter = new _ctrlpanel_CtrlPanelPresenter_js__WEBPACK_IMPORTED_MODULE_2__["default"](this._ctrlView);

		this._canvasView = new _canvaspanel_CanvasPanelView_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
		this._canvasPresenter = new _canvaspanel_CanvasPanelPresenter_js__WEBPACK_IMPORTED_MODULE_6__["default"](this._canvasView);
		this._view.attachCanvasPanel(this._canvasView.getHtml());

		this._tbarView = new _toolbarpanel_ToolbarPanelView_js__WEBPACK_IMPORTED_MODULE_11__["default"]();
		this._view.attachToolbarPanel(this._tbarView.getHtml());
		this._tbarPresenter = new _toolbarpanel_ToolabarPanelPresenter_js__WEBPACK_IMPORTED_MODULE_12__["default"](this._tbarView);

		this._footerView = new _footbar_FooterView_js__WEBPACK_IMPORTED_MODULE_13__["default"]();
		this._view.attachFooterPanel(this._footerView.getHtml());
		this._footerPresenter = new _footbar_FooterPresenter_js__WEBPACK_IMPORTED_MODULE_14__["default"](this._footerView);


	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DEPresenter);

/***/ }),

/***/ "./src/js/modules/dataexplorer/DEView.js":
/*!***********************************************!*\
  !*** ./src/js/modules/dataexplorer/DEView.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");


class DEView {

    _html;
    _visible;

    constructor() {

        this.init();

        var _public = {
            getHtml: () => {
                return this._html;
            },
            setModel: () => {
                // TODO

            },
            addSaveHandler: (handler) => {
                this._html.find("#de_save").on("click", handler);
            },
            toggle: () => {
                if (this._visible) {
                    this._html.css("display", "none");
                    this._visible = false;
                } else {
                    this._html.css("display", "block");
                    this._visible = true;
                }
            },
            close: () => {
                if (this._visible) {
                    this._html.css("display", "none");
                    this._visible = false;
                }
            },
            isVisible: () => {
                return this._visible;
            },
            attachCtrlPanel: (html) => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_controls").append(html);
            },
            attachCanvasPanel: (html) => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_canvas_container").append(html);
            },
            attachToolbarPanel: (html) => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_toolbar").append(html);
            },
            attachFooterPanel: (html) => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_footer").append(html);
            }

        }
        return _public;
    }

    init() {
        this._visible = false;
        // this._html = $(
        //     "<div id='de_view'>"
        //     + "     <div id='de_toolbar'></div>"
        //     + "     <div id='de_controls'></div>"
        //     + "     <div id='de_canvas_container'></div>"
        //     + "</div>");
            this._html = jquery__WEBPACK_IMPORTED_MODULE_0__(`
                <div id='de_view'>
                    <div id='de_toolbar'></div>
                    <div id='de_controls'></div>
                    <div id='de_canvas_container'></div>
                    <div id='de_footer'></div>
                </div>`);

                
        this._html.css("display", "none");
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DEView);

/***/ }),

/***/ "./src/js/modules/dataexplorer/canvaspanel/CanvasPanelPresenter.js":
/*!*************************************************************************!*\
  !*** ./src/js/modules/dataexplorer/canvaspanel/CanvasPanelPresenter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * @author Fabrizio Giordano (Fab)
 */


class CanvasPanelPresenter {

    _model; 

    constructor(in_view) {

        this.init(in_view);
		let self = this;

		var _public = {

			refreshModel: (image)=>{
				this.setModel(image);
			},
			clear: () => {
				this.clearView();
			}, 
			showLoading: (show) => {
				this.showLoadingInView(show);
			},
			showNoDataFound: () => {
				self._view.showNoDataFound();
			}
		}
        this.addButtonsClickHandlers();
		return _public;
	}


    init(_view){

		this._view = _view;

	}
	
    addButtonsClickHandlers() {
        
    }
	
	setModel(model){

        this._model = model;
        this.view.setModel(this._model);
		
	}

	clearView() {
		this.view.clear();
	}

	showLoadingInView(show){
		this.view.showLoading(show);
	}
    
    get view(){
		return this._view;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasPanelPresenter);

/***/ }),

/***/ "./src/js/modules/dataexplorer/canvaspanel/CanvasPanelView.js":
/*!********************************************************************!*\
  !*** ./src/js/modules/dataexplorer/canvaspanel/CanvasPanelView.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");


/**
 * @author Fabrizio Giordano (Fab)
 */



class CanvasPanelView {

    constructor() {
        this.init();

        var _public = {
            getHtml: () => {
                return this._html;
            },
            setModel: (imageData) => {

                jquery__WEBPACK_IMPORTED_MODULE_0__('#canvas_img').attr('src', imageData)

            },
            clear: () => {
                jquery__WEBPACK_IMPORTED_MODULE_0__('#canvas_img').attr('src', '')
            },
            showLoading: (show) => {
                if (show) {
                    jquery__WEBPACK_IMPORTED_MODULE_0__('#canvas_loading').html("Loading ... ")
                } else {
                    jquery__WEBPACK_IMPORTED_MODULE_0__('#canvas_loading').html("")
                }
                
            },
            showNoDataFound: () => {
                jquery__WEBPACK_IMPORTED_MODULE_0__('#canvas_loading').html("No FITS found in input.")
            },
            addSomeHandler: (handler) => {
                this._html.find("#???").on("click", handler);
            }
        }
        return _public;
    }

    init() {
        this._html = "<img id='canvas_img'/><span id='canvas_loading'></span> ";
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasPanelView);

/***/ }),

/***/ "./src/js/modules/dataexplorer/ctrlpanel/CtrlPanelPresenter.js":
/*!*********************************************************************!*\
  !*** ./src/js/modules/dataexplorer/ctrlpanel/CtrlPanelPresenter.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_ColorMapChangeEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/ColorMapChangeEvent.js */ "./src/js/modules/dataexplorer/events/ColorMapChangeEvent.js");
/* harmony import */ var _events_ScaleFunctionChangeEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/ScaleFunctionChangeEvent.js */ "./src/js/modules/dataexplorer/events/ScaleFunctionChangeEvent.js");
/* harmony import */ var _events_InvertColorMapEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/InvertColorMapEvent.js */ "./src/js/modules/dataexplorer/events/InvertColorMapEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");


/**
 * @author Fabrizio Giordano (Fab)
 */






class CtrlPanelPresenter {

    _view;

    constructor(in_view){

		this._view = in_view;
		let self  = this;
		var _public = {

			refreshModel: ()=>{
				self.setModel();
			},
			toggle: ()=> {
				self._view.toggle();
			},
			close: ()=> {
				self._view.close();
			},
			refreshPixelDetails(pxvalue, imgi, imgj, raDec) {
				self._view.refreshPixelDetails(pxvalue, imgi, imgj, raDec);
			}
		}
        this.addButtonsClickHandlers();
		return _public;
	}


    // init(_view){

	// 	this._view = _view;

	// }
	
    addButtonsClickHandlers() {

		this.view.colorMapDropDown().on("change", this.colorMapChanged);
		this.view.scaleFunctionDropDown().on("change", this.scaleFunctionChanged);
		this.view.invertColorMap().on("change", this.invertColorChanged);
		
    }

	
	colorMapChanged() {
        let valueSelected = this.value;
		console.log(valueSelected)
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].fireEvent(new _events_ColorMapChangeEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"](valueSelected));
    }

	scaleFunctionChanged() {
		let valueSelected = this.value;
		console.log(valueSelected)
		_events_EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].fireEvent(new _events_ScaleFunctionChangeEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"](valueSelected));
	}

	invertColorChanged(event) {
		let target = event.target;
		let checked = target.checked;
		console.log(checked)
        _events_EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].fireEvent(new _events_InvertColorMapEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](checked));
	}
    
	setModel(){

        this._center = FoVUtils.getCenterJ2000(global.gl.canvas);
        this.view.setModel(this._center);
		
	}

	

    get view(){
		return this._view;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CtrlPanelPresenter);

/***/ }),

/***/ "./src/js/modules/dataexplorer/ctrlpanel/CtrlPanelView.js":
/*!****************************************************************!*\
  !*** ./src/js/modules/dataexplorer/ctrlpanel/CtrlPanelView.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var wcslight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wcslight */ "./node_modules/wcslight/lib-esm/index.js");
/* harmony import */ var _model_ColorMaps_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/ColorMaps.js */ "./src/js/modules/dataexplorer/model/ColorMaps.js");
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Constants.js */ "./src/js/Constants.js");

/**
 * @author Fabrizio Giordano (Fab)
 */






 
class CtrlPanelView {

    _html;
    _selectedColorMap;
    
    constructor(){
        
        this.init();
    
        var _public = {
            getHtml: ()=>{
                return this._html;
            },
            setModel : (pxSize, raDeg, decDeg, radius, projectionName)=> {
                
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_cRA").text(raDeg.toFixed((0,_Constants_js__WEBPACK_IMPORTED_MODULE_3__.getMaxDecimals4AstroCoords)()));
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_cDec").text(decDeg.toFixed((0,_Constants_js__WEBPACK_IMPORTED_MODULE_3__.getMaxDecimals4AstroCoords)()));
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_radius").text(radius);
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_pxSize").text(pxSize);
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_projection").text(projectionName);
                
            },
            colorMapDropDown: ()  => {
                return  jquery__WEBPACK_IMPORTED_MODULE_0__("#de_colorMap");
            }, 
            scaleFunctionDropDown: ()  => {
                return  jquery__WEBPACK_IMPORTED_MODULE_0__("#de_sfunc");
            }, 
            invertColorMap: ()  => {
                return  jquery__WEBPACK_IMPORTED_MODULE_0__("#de_inverse");
            },
            refreshPixelDetails: (pxvalue, imgi, imgj, raDec) => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_i").text(imgi);
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_j").text(imgj);

                // $("#de_ra").text(raDec[0].toFixed(getMaxDecimals4AstroCoords()));
                // $("#de_dec").text(raDec[1].toFixed(getMaxDecimals4AstroCoords()));
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_ra").text(raDec.astro.raDeg.toFixed((0,_Constants_js__WEBPACK_IMPORTED_MODULE_3__.getMaxDecimals4AstroCoords)()));
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_dec").text(raDec.astro.decDeg.toFixed((0,_Constants_js__WEBPACK_IMPORTED_MODULE_3__.getMaxDecimals4AstroCoords)()));
                
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_pxvalue").text(pxvalue.toFixed((0,_Constants_js__WEBPACK_IMPORTED_MODULE_3__.getMaxDecimals4PixelValue)()));
            }

        }
        return _public;
    }		

    init(){
        let projList = wcslight__WEBPACK_IMPORTED_MODULE_1__.WCSLight.getAvaillableProjections();
        let projOptions = "";
        for (let p in projList) {
            projOptions += "<option id='de_proj_opt'>"+projList[p]+"</option>";
        }

        let cmapOptions = "";
        for (let ckey in _model_ColorMaps_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            cmapOptions += "<option id='de_map_opt'>"+ckey+"</option>";
        }

        // TODO define scale functions into an object
        let sfuncOptions = "";
        sfuncOptions += "<option id='de_sfunc_opt' value='linear' selected>linear</option>";
        sfuncOptions += "<option id='de_sfunc_opt' value='log'>log</option>";
        sfuncOptions += "<option id='de_sfunc_opt' value='sqrt'>sqrt</option>";
        

        this._visible = false;
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__(
          "<div id='de_params_container'>"
        + "     <table id='de_param_table'>"
        + "     <tr><td>central RA (deg):</td><td><span id='de_cRA'></span></td></tr>" 
        + "     <tr><td>central Dec (deg):</td><td><span id='de_cDec'></span></td></tr>" 
        + "     <tr><td>Radius (deg):</td><td><span id='de_radius'></span></td></tr>" 
        + "     <tr><td>Pixel size (deg):</td><td><span id='de_pxSize'></span></td></tr>" 
        + "     <tr><td>Projection:</td><td><span id='de_projection'></span></td></tr>" 
        + "     </table>"
        + "</div>"

        + "<br>"
        + "<hr>"
        + "<br>"

        + "Analysis"
        + "<div id='de_colorMap_container'>"
        + "     <span>Color map:</span>"
        + "     <select id='de_colorMap'>"+ cmapOptions + "<select>"
        + "</div>"

        + "<div id='de_scaleFunction_container'>"
        + "     <span>Scale function:</span>"
        + "     <select id='de_sfunc'>"+ sfuncOptions+ "<select>"
        + "</div>"
        
        + "<div id='de_inverse_container'>"
        + "     <span>Inverse:</span>"
        + "     <input type='checkbox' id='de_inverse' >"
        + "</div>"

        + "<br>"
        + "<hr>"
        + "<br>"
        
        + "<div id='de_pixel_container'>"
        + "     <table id='de_pixel_table'>"
        + "     <tr><td>Image coords (i, j):</td><td><span id='de_i'>-</span>,<span id='de_j'>-</span></td></tr>"
        + "     <tr><td>WCS coords (RA, Dec):</td><td><span id='de_ra'>-</span>,<span id='de_dec'>-</span></td></tr>"
        + "     <tr><td>Pixel value:</td><td><span id='de_pxvalue'>-</span></td></tr>"
        + "     </table>"
        + "</div>"

        // + "<div id='de_projection_container'>"
        // + "     <span>Projection:</span>"
        // + "     <select id='de_proj'>"+ projOptions + "<select>"
        // + "</div>"
        
        
        );
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CtrlPanelView);

/***/ }),

/***/ "./src/js/modules/dataexplorer/events/ColorMapChangeEvent.js":
/*!*******************************************************************!*\
  !*** ./src/js/modules/dataexplorer/events/ColorMapChangeEvent.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class ColorMapChangeEvent{
	
	_colorMapName;
	static name = "ColorMapChangeEvent";
	
	constructor(colorMapName){
		this._colorMapName = colorMapName;
	}
	
	get name(){
		return ColorMapChangeEvent.name;
	}

	get colorMapName(){
		return this._colorMapName;
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorMapChangeEvent);

/***/ }),

/***/ "./src/js/modules/dataexplorer/events/InvertColorMapEvent.js":
/*!*******************************************************************!*\
  !*** ./src/js/modules/dataexplorer/events/InvertColorMapEvent.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class InvertColorMapEvent{
	
	_inverted;
	static name = "InvertColorMapEvent";
	
	constructor(inverted){
		this._inverted = inverted;
	}
	
	get name(){
		return InvertColorMapEvent.name;
	}

	get isInverted(){
		return this._inverted;
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InvertColorMapEvent);

/***/ }),

/***/ "./src/js/modules/dataexplorer/events/ScaleFunctionChangeEvent.js":
/*!************************************************************************!*\
  !*** ./src/js/modules/dataexplorer/events/ScaleFunctionChangeEvent.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class ScaleFunctionChangeEvent{
	
	_sfName;
	static name = "ScaleFunctionChangeEvent";
	
	constructor(sfName){
		this._sfName = sfName;
	}
	
	get name(){
		return ScaleFunctionChangeEvent.name;
	}

	get scaleFunctionName(){
		return this._sfName;
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScaleFunctionChangeEvent);

/***/ }),

/***/ "./src/js/modules/dataexplorer/footbar/FooterPresenter.js":
/*!****************************************************************!*\
  !*** ./src/js/modules/dataexplorer/footbar/FooterPresenter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });



class FooterPresenter {

    _view;
    constructor(view){
        
        this._view = view;
        let self = this;

        var _public = {
            clear: ()=>{
				self._view.clear();
			},
            addFitsUrls: (fitsUrls) => {
                self._view.addFitsURLs(fitsUrls)
            }
        }
        return _public;
    }

    
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FooterPresenter);

/***/ }),

/***/ "./src/js/modules/dataexplorer/footbar/FooterView.js":
/*!***********************************************************!*\
  !*** ./src/js/modules/dataexplorer/footbar/FooterView.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");


class FooterView {
    _html;
    constructor() {

        this.init();

        var _public = {
            getHtml: () => {
                return this._html;
            },
            addFitsURLs: (fitsUrls) => {
                for (let fUrl of fitsUrls) {
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#"+this._rootDomId).append("<a href='"+fUrl+"'>"+fUrl+"</a><br>");
                }
            },
            clear: () => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#"+this._rootDomId).html("")
            }
        }
        return _public;
    }

    init() {
        this._rootDomId = "de_footer";
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__(`
            <div id='${this._rootDomId}'></div>
        `);

    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FooterView);

/***/ }),

/***/ "./src/js/modules/dataexplorer/model/Canvas2D.js":
/*!*******************************************************!*\
  !*** ./src/js/modules/dataexplorer/model/Canvas2D.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ColorMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorMaps.js */ "./src/js/modules/dataexplorer/model/ColorMaps.js");
/* harmony import */ var canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! canvas */ "./node_modules/canvas/browser.js");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "?5648");
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");

/**
 * Summary. (bla bla bla)
 *
 * Description. (bla bla bla)
 * 
 * @link   github https://github.com/fab77/wcslight
 * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>
 */



const { createCanvas } = canvas__WEBPACK_IMPORTED_MODULE_1__;



class Canvas2D {

    _imgData;
    _physicalvalues;
    _width;
    _height;
    _min;
    _max;
    _currmin;
    _currmax;
    _colormap;
    _tfunction;
    _projection;
    _canvas;

    /**
     * 
     * @param {*} pvmin minimum phisical value
     * @param {*} pvmax maximum phisical value
     * @param {*} data [] of [] of decimal values
     */
    constructor(pixelvalues, fitsheader, projection, tfunction = "linear", colormap = "grayscale", inverse = false) {

        // initial settings use to reset the image to its initial status
        this._orig_tfunction = tfunction;
        this._orig_colormap = colormap;
        this._orig_inverse = inverse;
        this._orig_min = fitsheader[0].get("DATAMIN");
        this._orig_max = fitsheader[0].get("DATAMAX");

        this._currmin = this._orig_min;
        this._currmax = this._orig_max;

        this._bzero = fitsheader[0].get("BZERO") || 0.0;
        this._bscale = fitsheader[0].get("BSCALE") || 1.0;
        this._blank = fitsheader[0].get("BLANK");
        this._bitpix = fitsheader[0].get("BITPIX");

        let bytesXelem = Math.abs(this._bitpix / 8);
        // this._width = pixelvalues[0].length / bytesXelem;
        this._width = pixelvalues.get(0)[0].length  / bytesXelem;
        
        // this._height = pixelvalues.length;
        this._height = pixelvalues.get(0).length;

        this._physicalvalues = [];
        // this._pixelvalues = pixelvalues;
        this._pixelvalues = pixelvalues.get(0);
        this._RGBvalues = [];

        this._inverse = inverse;

        this._tfunction = tfunction;
        this._colormap = colormap;

        this._projection = projection;

        this.initRGBImage();
        this.process();
        this.normalize();
        this.applyColorAndTransferFunction();
    }

    initRGBImage() {
        /** https://flaviocopes.com/canvas-node-generate-image/ */
        let width = this._width;
        let height = this._height;
        this._canvas = createCanvas(width, height)
        this._canvasCtx = this._canvas.getContext('2d')

        this._imgData = this._canvasCtx.createImageData(this._canvas.width, this._canvas.height);

    }

    normalize() {

        // let minMaxRange = this._origmax - this._origmin;
        let minMaxRange = this._currmax - this._currmin;
        this._normvalues = [];

        for (let j = 0; j < this._height; j++) {
            this._normvalues[j] = new Array(this._width);
            for (let i = 0; i < this._width; i++) {
                // this._normvalues[j][i] = (this._physicalvalues[j][i] - this._origmin) / minMaxRange;
                this._normvalues[j][i] = (this._physicalvalues[j][i] - this._currmin) / minMaxRange;
            }
        }
    }

    applyColorAndTransferFunction() {
        let rgbval;
        let values = [];

        // this._currmin = this.appylyTransferFunction2Val(this._normvalues[0][0]);
        // this._currmax = this._currmin;

        this._currmin = NaN;
        this._currmax = NaN;

        for (let j = 0; j < this._height; j++) {
            values[j] = new Array(this._width);
            for (let i = 0; i < this._width; i++) {
                values[j][i] = this.appylyTransferFunction2Val(this._normvalues[j][i]);
                if (!isNaN(values[j][i])) {
                    if (isNaN(this._currmin) || values[j][i] < this._currmin) {
                        this._currmin = values[j][i];
                    }
                    if (isNaN(this._currmax) || values[j][i] > this._currmax) {
                        this._currmax = values[j][i];
                    }
                }
            }
        }

        for (let j = 0; j < this._height; j++) {
            for (let i = 0; i < this._width; i++) {

                rgbval = this.colorPixel(values[j][i]);
                let rgbpos = ((this._width - j) * this._width + i) * 4;
                this._imgData.data[rgbpos] = rgbval.r;
                this._imgData.data[rgbpos + 1] = rgbval.g;
                this._imgData.data[rgbpos + 2] = rgbval.b;
                this._imgData.data[rgbpos + 3] = 0xff; // alpha
            }

        }
        this._canvasCtx.putImageData(this._imgData, 0, 0);
    }
    /**
     * function to be called after minmax or transfer function has changed to update the 
     * this._processedData containing pixels values
     */
    process() {

        this._physicalvalues = new Array(this._height);
        let bytesXelem = Math.abs(this._bitpix / 8);

        // this._currmin = this.appylyTransferFunction2Val(this._currmin);
        // this._currmax = this.appylyTransferFunction2Val(this._currmax);

        // this._origmin = undefined;
        // this._origmax = undefined;

        for (let j = 0; j < this._height; j++) {
            this._physicalvalues[j] = new Array(this._width);
            for (let i = 0; i < this._width; i++) {
                let val;
                // let rgbval;
                let pixval = jsfitsio__WEBPACK_IMPORTED_MODULE_3__.ParseUtils.extractPixelValue(0, this._pixelvalues[j].slice(i * bytesXelem, (i + 1) * bytesXelem), this._bitpix);

                // let rgbpos = ( (this._width - j) * this._width + i ) * 4;


                if (this._blank !== undefined && pixval === this._blank) {
                    val = NaN;
                    // rgbval = NaN;
                } else {

                    val = this.pixel2Physical(pixval);
                    this._physicalvalues[j][i] = val;
                    if (this._orig_min === undefined || val < this._orig_min) {
                        this._orig_min = val;
                    }
                    if (this._orig_max === undefined || val > this._orig_max) {
                        this._orig_max = val;
                    }

                    // let tfval = this.appylyTransferFunction2Val(val);
                    // rgbval = this.colorPixel(tfval);

                }

                // this._imgData.data[rgbpos] = rgbval.r;
                // this._imgData.data[rgbpos+1] = rgbval.g;
                // this._imgData.data[rgbpos+2] = rgbval.b;
                // this._imgData.data[rgbpos+3] = 0xff; // alpha

            }
        }
        // this._canvasCtx.putImageData(this._imgData, 0, 0);
        this._currmin = this._orig_min;
        this._currmax = this._orig_max;
    }

    pixel2Physical(value) {
        let pval = this._bzero + this._bscale * value;
        return pval;
    }

    getBrowseImage() {
        return this._canvas.toDataURL();
    }

    reset() {

        this._tfunction = this._orig_tfunction;
        this._colormap = this._orig_colormap;
        this._inverse = this._orig_inverse;
        this._currmin = this._orig_min;
        this._currmax = this._orig_max;
        this.process();

    }

    appylyTransferFunction2Val(val) {
        if (this._tfunction == "linear") {
            return val;
        } else if (this._tfunction == "log") {
            if (val > 0) {
                return Math.log(val);
            }
        } else if (this._tfunction == "sqrt") {
            if (val > 0) {
                return Math.sqrt(val);
            }
        }
        return NaN;
    }

    appylyTransferFunction(tfunction) {
        this._tfunction = tfunction;
        let f;

        if (this._tfunction == 'linear') {
            f = function linearval(inval) { return inval };
        } else if (this._tfunction == 'log') {
            f = Math.log;
        } else if (this._tfunction == 'sqrt') {
            f = Math.sqrt;
        }
        // else {
        //     throw new TransferFunctionNotDefined(tFunction);
        // }
        this.initRGBImage();
        this._currmin = f(this._currmin);
        // TODO check the case when in log and val are < 0
        if (this._currmin === NaN) {
            this._currmin = 0;
        }
        this._currmax = f(this._currmax);
        let val;
        let rgbval;
        for (let j = 0; j < this._height; j++) {

            for (let i = 0; i < this._width; i++) {

                let rgbpos = ((this._width - j) * this._width + i) * 4;
                if (this._blank !== undefined && pixval === this._blank) {
                    val = NaN;
                    rgbval = NaN;
                } else {
                    val = this._physicalvalues[j][i];;
                    val = f(val);

                    rgbval = this.colorPixel(val);

                }
                this._physicalvalues[j][i] = val;
                this._imgData.data[rgbpos] = rgbval.r;
                this._imgData.data[rgbpos + 1] = rgbval.g;
                this._imgData.data[rgbpos + 2] = rgbval.b;
                this._imgData.data[rgbpos + 3] = 0xff; // alpha

            }
        }

        this._canvasCtx.putImageData(this._imgData, 0, 0);

    }

    setInverseColorMap(inverted) {
        this._inverse = inverted;
    }

    setColorMap(cmap) {

        if (cmap == "grayscale") {
            this._colormap = "grayscale";
        } else if (cmap == "planck") {
            this._colormap = "planck";
        } else if (cmap == "eosb") {
            this._colormap = "eosb";
        } else if (cmap == "rainbow") {
            this._colormap = "rainbow";
        } else if (cmap == "cmb") {
            this._colormap = "cmb";
        } else if (cmap == "cubehelix") {
            this._colormap = "cubehelix";
        }
        //  else {
        //     throw new ColorMapNotDefined(cmap);
        // }
    }

    setTransferFunction(tFunction) {

        if (tFunction == "linear") {
            this._tfunction = "linear";
        } else if (tFunction == "log") {
            this._tfunction = "log";
        } else if (tFunction == "sqrt") {
            this._tfunction = "sqrt";
        }
        // else {
        //     throw new TransferFunctionNotDefined(tFunction);
        // }

    }



    writeToFile(path, filename) {
        const buffer = this._canvas.toBuffer('image/png');
        fs__WEBPACK_IMPORTED_MODULE_2__.writeFileSync(path + '/' + filename + '.png', buffer);
    }

    colorPixel(v) {

        if (isNaN(v)) {
            if (this._inverse) {
                return {
                    r: 255,
                    g: 255,
                    b: 255
                };
            }
            return {
                r: 0,
                g: 0,
                b: 0
            };
        }

        // // TODO Check that. Probably better to use normalized values on [0, 1]
        // // and this._currentpvmin and this._currentpvmax
        // if ( v < 0 ) v = -v;
        let colormap_idx = ((v - this._currmin) / (this._currmax - this._currmin)) * 256;


        let idx = Math.round(colormap_idx);

        // if (idx<0){
        // 	idx = -idx;
        // }

        if (this._colormap == 'grayscale') {
            if (this._inverse) {
                return {
                    r: (255 - idx),
                    g: (255 - idx),
                    b: (255 - idx)
                };
            }

            return {
                r: idx,
                g: idx,
                b: idx
            };
        } else {
            let colorMap = _ColorMaps_js__WEBPACK_IMPORTED_MODULE_0__["default"][this._colormap];
            if (this._inverse) {
                return {
                    r: (255 - colorMap.r[idx]),
                    g: (255 - colorMap.g[idx]),
                    b: (255 - colorMap.b[idx])
                };
            }

            return {
                r: colorMap.r[idx],
                g: colorMap.g[idx],
                b: colorMap.b[idx]
            };
        }

    }

    getValueByRaDec(ra, dec) {
        let [i, j] = this._projection.world2pix(ra, dec);
        return this.getValueByPixelCoords(i, j);
    }

    getValueByPixelCoords(i, j) {
        let [cx, cy] = this.ij2canvasxy(i, j);
        return this.getValueByCanvasCoords(cx, cy);
    }

    getValueByCanvasCoords(cx, cy) {
        return this._physicalvalues[cy][cx];
    }

    getRaDecByCanvasCoords(cx, cy) {
        // let [i, j] = this.canvasxy2ij(cx, cy);
        // return this.getRaDecByPixelCoords(i, j);
        let i = cx;
        let j = cy;
        return this._projection.pix2world(i, j);
    }

    getRaDecByPixelCoords(i, j) {
        let [ra, dec] = this._projection.pix2world(i, j);
        return [ra, dec];
    }



}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Canvas2D);

/***/ }),

/***/ "./src/js/modules/dataexplorer/model/ColorMaps.js":
/*!********************************************************!*\
  !*** ./src/js/modules/dataexplorer/model/ColorMaps.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


var ColorMaps = [];

ColorMaps['grayscale'] = {
	name: 'grayscale',
    r: [], g: [], b: []
};

ColorMaps['native'] = {
	name: 'native',
    r: [], g: [], b: []
};

ColorMaps['planck'] = {
	name: 'planck',
    r: [0.00000, 0.769231, 1.53846, 2.30769, 3.07692, 3.84615, 4.61538, 5.38462, 6.15385, 6.92308, 7.69231, 8.46154,
	    9.23077, 10.0000, 11.5385, 13.0769, 14.6154, 16.1538, 17.6923, 19.2308, 20.7692, 22.3077, 23.8462, 25.3846,
	    26.9231, 28.4615, 30.0000, 33.8462, 37.6923, 41.5385, 45.3846, 49.2308, 53.0769, 56.9231, 60.7692, 64.6154,
	    68.4615, 72.3077, 76.1538, 80.0000, 88.5385, 97.0769, 105.615, 114.154, 122.692, 131.231, 139.769, 148.308,
	    156.846, 165.385, 173.923, 182.462, 191.000, 193.846, 196.692, 199.538, 202.385, 205.231, 208.077, 210.923,
	    213.769, 216.615, 219.462, 222.308, 225.154, 228.000, 229.182, 230.364, 231.545, 232.727, 233.909, 235.091,
	    236.273, 237.455, 238.636, 239.818, 241.000, 241.000, 241.364, 241.727, 242.091, 242.455, 242.818, 243.182,
	    243.545, 243.909, 244.273, 244.636, 245.000, 245.231, 245.462, 245.692, 245.923, 246.154, 246.385, 246.615,
	    246.846, 247.077, 247.308, 247.538, 247.769, 248.000, 248.146, 248.292, 248.438, 248.585, 248.731, 248.877,
	    249.023, 249.169, 249.315, 249.462, 249.608, 249.754, 249.900, 249.312, 248.723, 248.135, 247.546, 246.958,
	    246.369, 245.781, 245.192, 244.604, 244.015, 243.427, 242.838, 242.250, 239.308, 236.365, 233.423, 230.481,
	    227.538, 224.596, 221.654, 218.712, 215.769, 212.827, 209.885, 206.942, 204.000, 201.000, 198.000, 195.000,
	    192.000, 189.000, 186.000, 183.000, 180.000, 177.000, 174.000, 171.000, 168.000, 165.000, 161.077, 157.154,
	    153.231, 149.308, 145.385, 141.462, 137.538, 133.615, 129.692, 125.769, 121.846, 117.923, 114.000, 115.038,
	    116.077, 117.115, 118.154, 119.192, 120.231, 121.269, 122.308, 123.346, 124.385, 125.423, 126.462, 127.500,
	    131.423, 135.346, 139.269, 143.192, 147.115, 151.038, 154.962, 158.885, 162.808, 166.731, 170.654, 174.577,
	    178.500, 180.462, 182.423, 184.385, 186.346, 188.308, 190.269, 192.231, 194.192, 196.154, 198.115, 200.077,
	    202.038, 204.000, 205.962, 207.923, 209.885, 211.846, 213.808, 215.769, 217.731, 219.692, 221.654, 223.615,
	    225.577, 227.538, 229.500, 230.481, 231.462, 232.442, 233.423, 234.404, 235.385, 236.365, 237.346, 238.327,
	    239.308, 240.288, 241.269, 242.250, 242.642, 243.035, 243.427, 243.819, 244.212, 244.604, 244.996, 245.388,
	    245.781, 246.173, 246.565, 246.958, 247.350, 247.814, 248.277, 248.741, 249.205, 249.668, 250.132, 250.595,
	    251.059, 251.523, 251.986, 252.450],
	g: [0.00000, 1.53846, 3.07692, 4.61538, 6.15385, 7.69231, 9.23077, 10.7692, 12.3077, 13.8462, 15.3846, 16.9231,
	    18.4615, 20.0000, 32.6154, 45.2308, 57.8462, 70.4615, 83.0769, 95.6923, 108.308, 120.923, 133.538, 146.154,
	    158.769, 171.385, 184.000, 187.923, 191.846, 195.769, 199.692, 203.615, 207.538, 211.462, 215.385, 219.308,
	    223.231, 227.154, 231.077, 235.000, 235.308, 235.615, 235.923, 236.231, 236.538, 236.846, 237.154, 237.462,
	    237.769, 238.077, 238.385, 238.692, 239.000, 239.077, 239.154, 239.231, 239.308, 239.385, 239.462, 239.538,
	    239.615, 239.692, 239.769, 239.846, 239.923, 240.000, 240.091, 240.182, 240.273, 240.364, 240.455, 240.545,
	    240.636, 240.727, 240.818, 240.909, 241.000, 241.000, 240.909, 240.818, 240.727, 240.636, 240.545, 240.455,
	    240.364, 240.273, 240.182, 240.091, 240.000, 239.615, 239.231, 238.846, 238.462, 238.077, 237.692, 237.308,
	    236.923, 236.538, 236.154, 235.769, 235.385, 235.000, 232.615, 230.231, 227.846, 225.462, 223.077, 220.692,
	    218.308, 215.923, 213.538, 211.154, 208.769, 206.385, 204.000, 200.077, 196.154, 192.231, 188.308, 184.385,
	    180.462, 176.538, 172.615, 168.692, 164.769, 160.846, 156.923, 153.000, 147.115, 141.231, 135.346, 129.462,
	    123.577, 117.692, 111.808, 105.923, 100.038, 94.1538, 88.2692, 82.3846, 76.5000, 73.0769, 69.6538, 66.2308,
	    62.8077, 59.3846, 55.9615, 52.5385, 49.1154, 45.6923, 42.2692, 38.8462, 35.4231, 32.0000, 29.5385, 27.0769,
	    24.6154, 22.1538, 19.6923, 17.2308, 14.7692, 12.3077, 9.84615, 7.38462, 4.92308, 2.46154, 0.00000, 9.80769,
	    19.6154, 29.4231, 39.2308, 49.0385, 58.8462, 68.6538, 78.4615, 88.2692, 98.0769, 107.885, 117.692, 127.500,
	    131.423, 135.346, 139.269, 143.192, 147.115, 151.038, 154.962, 158.885, 162.808, 166.731, 170.654, 174.577,
	    178.500, 180.462, 182.423, 184.385, 186.346, 188.308, 190.269, 192.231, 194.192, 196.154, 198.115, 200.077,
	    202.038, 204.000, 205.962, 207.923, 209.885, 211.846, 213.808, 215.769, 217.731, 219.692, 221.654, 223.615,
	    225.577, 227.538, 229.500, 230.481, 231.462, 232.442, 233.423, 234.404, 235.385, 236.365, 237.346, 238.327,
	    239.308, 240.288, 241.269, 242.250, 242.642, 243.035, 243.427, 243.819, 244.212, 244.604, 244.996, 245.388,
	    245.781, 246.173, 246.565, 246.958, 247.350, 247.814, 248.277, 248.741, 249.205, 249.668, 250.132, 250.595,
	    251.059, 251.523, 251.986, 252.450],
	b: [255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000,
	    255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000,
	    255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000, 255.000,
	    255.000, 255.000, 255.000, 255.000, 254.615, 254.231, 253.846, 253.462, 253.077, 252.692, 252.308, 251.923,
	    251.538, 251.154, 250.769, 250.385, 250.000, 249.615, 249.231, 248.846, 248.462, 248.077, 247.692, 247.308,
	    246.923, 246.538, 246.154, 245.769, 245.385, 245.000, 242.000, 239.000, 236.000, 233.000, 230.000, 227.000,
	    224.000, 221.000, 218.000, 215.000, 212.000, 212.000, 208.636, 205.273, 201.909, 198.545, 195.182, 191.818,
	    188.455, 185.091, 181.727, 178.364, 175.000, 171.538, 168.077, 164.615, 161.154, 157.692, 154.231, 150.769,
	    147.308, 143.846, 140.385, 136.923, 133.462, 130.000, 122.942, 115.885, 108.827, 101.769, 94.7115, 87.6539,
	    80.5962, 73.5385, 66.4808, 59.4231, 52.3654, 45.3077, 38.2500, 36.2885, 34.3269, 32.3654, 30.4038, 28.4423,
	    26.4808, 24.5192, 22.5577, 20.5962, 18.6346, 16.6731, 14.7115, 12.7500, 11.7692, 10.7885, 9.80769, 8.82692,
	    7.84615, 6.86539, 5.88461, 4.90385, 3.92308, 2.94231, 1.96154, 0.980769, 0.00000, 2.46154, 4.92308, 7.38462,
	    9.84616, 12.3077, 14.7692, 17.2308, 19.6923, 22.1538, 24.6154, 27.0769, 29.5385, 32.0000, 32.0000, 32.0000,
	    32.0000, 32.0000, 32.0000, 32.0000, 32.0000, 32.0000, 32.0000, 32.0000, 32.0000, 32.0000, 32.0000, 41.3077,
	    50.6154, 59.9231, 69.2308, 78.5385, 87.8462, 97.1539, 106.462, 115.769, 125.077, 134.385, 143.692, 153.000,
	    156.923, 160.846, 164.769, 168.692, 172.615, 176.538, 180.462, 184.385, 188.308, 192.231, 196.154, 200.077,
	    204.000, 205.962, 207.923, 209.885, 211.846, 213.808, 215.769, 217.731, 219.692, 221.654, 223.615, 225.577,
	    227.538, 229.500, 230.481, 231.462, 232.442, 233.423, 234.404, 235.385, 236.365, 237.346, 238.327, 239.308,
	    240.288, 241.269, 242.250, 242.838, 243.427, 244.015, 244.604, 245.192, 245.781, 246.369, 246.958, 247.546,
	    248.135, 248.723, 249.312, 249.900, 250.096, 250.292, 250.488, 250.685, 250.881, 251.077, 251.273, 251.469,
	    251.665, 251.862, 252.058, 252.254, 252.450, 252.682, 252.914, 253.145, 253.377, 253.609, 253.841, 254.073,
	    254.305, 254.536, 254.768, 255.000]
};

ColorMaps['cmb'] = {
    name: 'cmb',
    r: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 12,  18,  24,  30,  36,  42,  48,  54,  60, 66, 72, 78, 85, 91, 97, 103, 109, 115, 121, 127, 133, 139, 145, 151, 157, 163, 170, 176, 182, 188, 194, 200, 206, 212, 218, 224, 230, 236, 242, 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 251, 247, 244, 240, 236, 233, 229, 226, 222, 218, 215, 211, 208, 204, 200, 197, 193, 190, 186, 182, 179, 175, 172, 168, 164, 161, 157, 154, 150, 146, 143, 139,136, 132, 128, 125, 121, 118, 114, 110, 107, 103, 100],
    g: [0, 2, 5, 8, 10, 13, 16, 18, 21, 24, 26, 29, 32, 34, 37, 40, 42, 45, 48, 50, 53, 56, 58, 61, 64, 66, 69, 72, 74, 77, 80, 82, 85, 88, 90, 93, 96, 98, 101, 104, 106, 109, 112, 114, 117, 119, 122, 124, 127,129, 132, 134, 137, 139, 142, 144, 147, 150, 152, 155, 157, 160, 162, 165, 167, 170, 172, 175, 177, 180, 182, 185, 188, 190, 193, 195, 198, 200, 203, 205, 208, 210, 213, 215, 218, 221, 221, 221, 222, 222, 222, 223, 223, 224, 224, 224, 225, 225, 225, 226, 226, 227, 227, 227, 228, 228, 229, 229, 229, 230, 230, 230, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 237, 235, 234, 233, 231, 230, 229, 227, 226, 225, 223, 222, 221, 219, 218, 217, 215, 214, 213, 211,210, 209, 207, 206, 205, 203, 202, 201, 199, 198, 197, 195, 194, 193, 191, 190, 189, 187, 186, 185, 183, 182, 181, 180, 177, 175, 172, 170, 167, 165, 162, 160, 157, 155, 152, 150, 147, 145, 142, 140, 137, 135, 132, 130, 127, 125, 122, 120, 117, 115, 112, 110, 107, 105, 102, 100, 97, 95, 92, 90, 87, 85, 82, 80, 77, 75, 73, 71, 69, 68, 66, 64, 62, 61, 59, 57, 55, 54, 52, 50, 48, 47, 45, 43, 41, 40, 38, 36, 34, 33, 31, 29, 27, 26, 24, 22, 20, 19,17, 15, 13, 12, 10, 8, 6, 5, 3, 1, 0],
    b:[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 245, 244,243, 242, 241, 240, 239, 238, 237, 236, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 217, 211, 206, 201, 196, 191, 186, 181, 176, 171, 166, 161, 156, 151, 146, 141, 136, 131, 126, 121,116, 111, 105, 100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
};
	
ColorMaps['rainbow'] = {
	name: 'rainbow',
    r: [0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 45, 50, 54,
        58, 61, 64, 68, 69, 72, 74, 77, 79, 80, 82, 83, 85, 84, 86, 87, 88, 86, 87, 87, 87, 85, 84, 84,
        84, 83, 79, 78, 77, 76, 71, 70, 68, 66, 60, 58, 55, 53, 46, 43, 40, 36, 33, 25, 21, 16, 12, 4, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 21, 25, 29, 33, 42,
        46, 51, 55, 63, 67, 72, 76, 80, 89, 93, 97, 101, 110, 114, 119, 123, 131, 135, 140, 144, 153,
        157, 161, 165, 169, 178, 182, 187, 191, 199, 203, 208, 212, 221, 225, 229, 233, 242, 246,
        250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
    ],
    g: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 16, 21, 25, 29, 38, 42, 46, 51, 55, 63, 67, 72, 76, 84, 89, 93, 97,
        106, 110, 114, 119, 127, 131, 135, 140, 144, 152, 157, 161, 165, 174, 178, 182, 187, 195,
        199, 203, 208, 216, 220, 225, 229, 233, 242, 246, 250, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 250, 242, 238, 233, 229, 221, 216, 212, 208, 199, 195, 191, 187, 178, 174, 170, 165,
        161, 153, 148, 144, 140, 131, 127, 123, 119, 110, 106, 102, 97, 89, 85, 80, 76, 72, 63, 59,
        55, 51, 42, 38, 34, 29, 21, 17, 12, 8, 0
    ],
    b: [0, 3, 7, 10, 14, 19, 23, 28, 32, 38, 43, 48, 53,
        59, 63, 68, 72, 77, 81, 86, 91, 95, 100, 104, 109, 113, 118, 122, 127, 132, 136, 141, 145,
        150, 154, 159, 163, 168, 173, 177, 182, 186, 191, 195, 200, 204, 209, 214, 218, 223, 227,
        232, 236, 241, 245, 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 246, 242, 238, 233, 225, 220, 216, 212, 203, 199, 195, 191,
        187, 178, 174, 170, 165, 157, 152, 148, 144, 135, 131, 127, 123, 114, 110, 106, 102, 97,
        89, 84, 80, 76, 67, 63, 59, 55, 46, 42, 38, 34, 25, 21, 16, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ]	
};
	
ColorMaps['eosb'] = {
	name: 'eosb',
    r: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 18, 27, 36, 45, 49, 57, 72, 81, 91, 100, 109, 118, 127,
        136, 131, 139, 163, 173, 182, 191, 200, 209, 218, 227, 213, 221, 255, 255, 255, 255, 255,
        255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255,
        255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255,
        255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229,
        229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255,
        255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 253, 251, 249, 247,
        245, 243, 241, 215, 214, 235, 234, 232, 230, 228, 226, 224, 222, 198, 196, 216, 215, 213,
        211, 209, 207, 205, 203, 181, 179, 197, 196, 194, 192, 190, 188, 186, 184, 164, 162, 178,
        176, 175, 173, 171, 169, 167, 165, 147, 145, 159, 157, 156, 154, 152, 150, 148, 146, 130,
        128, 140, 138, 137, 135, 133, 131, 129, 127, 113, 111, 121, 119, 117, 117
    ],
    g: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 15, 23, 31, 39, 47, 55, 57, 64, 79, 87, 95,
        103, 111, 119, 127, 135, 129, 136, 159, 167, 175, 183, 191, 199, 207, 215, 200, 207, 239,
        247, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229,
        229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 250, 246, 242, 238, 233, 229,
        225, 198, 195, 212, 208, 204, 199, 195, 191, 187, 182, 160, 156, 169, 165, 161, 157, 153,
        148, 144, 140, 122, 118, 127, 125, 123, 121, 119, 116, 114, 112, 99, 97, 106, 104, 102,
        99, 97, 95, 93, 91, 80, 78, 84, 82, 80, 78, 76, 74, 72, 70, 61, 59, 63, 61, 59, 57, 55, 53, 50,
        48, 42, 40, 42, 40, 38, 36, 33, 31, 29, 27, 22, 21, 21, 19, 16, 14, 12, 13, 8, 6, 3, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ],
    b: [116, 121, 127, 131, 136, 140, 144, 148, 153,
        157, 145, 149, 170, 174, 178, 182, 187, 191, 195, 199, 183, 187, 212, 216, 221, 225, 229,
        233, 238, 242, 221, 225, 255, 247, 239, 231, 223, 215, 207, 199, 172, 164, 175, 167, 159,
        151, 143, 135, 127, 119, 100, 93, 95, 87, 79, 71, 63, 55, 47, 39, 28, 21, 15, 7, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0
    ]
};
	
ColorMaps['cubehelix'] = {
	name: 'cubehelix',
    r: [0, 1, 3, 4, 6, 8, 9, 10, 12, 13, 14, 15, 17, 18,
        19, 20, 20, 21, 22, 23, 23, 24, 24, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25,
        25, 25, 25, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 21, 21, 21, 21, 21, 21, 20, 20, 20, 21, 21,
        21, 21, 21, 22, 22, 22, 23, 23, 24, 25, 26, 27, 27, 28, 30, 31, 32, 33, 35, 36, 38, 39, 41, 43,
        45, 47, 49, 51, 53, 55, 57, 60, 62, 65, 67, 70, 72, 75, 78, 81, 83, 86, 89, 92, 95, 98, 101, 104,
        107, 110, 113, 116, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 155, 158,
        161, 164, 166, 169, 171, 174, 176, 178, 181, 183, 185, 187, 189, 191, 193, 194, 196, 198,
        199, 201, 202, 203, 204, 205, 206, 207, 208, 209, 209, 210, 211, 211, 211, 212, 212, 212,
        212, 212, 212, 212, 212, 211, 211, 211, 210, 210, 210, 209, 208, 208, 207, 207, 206, 205,
        205, 204, 203, 203, 202, 201, 201, 200, 199, 199, 198, 197, 197, 196, 196, 195, 195, 194,
        194, 194, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 194, 194, 195, 195, 196, 196,
        197, 198, 199, 200, 200, 202, 203, 204, 205, 206, 208, 209, 210, 212, 213, 215, 217, 218,
        220, 222, 223, 225, 227, 229, 231, 232, 234, 236, 238, 240, 242, 244, 245, 247, 249, 251,
        253, 255
    ],
    g: [0, 0, 1, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 10,
        11, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 29, 31, 32, 34, 35, 37, 38, 40,
        41, 43, 45, 46, 48, 50, 52, 53, 55, 57, 58, 60, 62, 64, 66, 67, 69, 71, 73, 74, 76, 78, 79, 81,
        83, 84, 86, 88, 89, 91, 92, 94, 95, 97, 98, 99, 101, 102, 103, 104, 106, 107, 108, 109, 110,
        111, 112, 113, 114, 114, 115, 116, 116, 117, 118, 118, 119, 119, 120, 120, 120, 121, 121,
        121, 121, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 121,
        121, 121, 121, 121, 121, 121, 121, 121, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120,
        121, 121, 121, 121, 121, 122, 122, 122, 123, 123, 124, 124, 125, 125, 126, 127, 127, 128,
        129, 130, 131, 131, 132, 133, 135, 136, 137, 138, 139, 140, 142, 143, 144, 146, 147, 149,
        150, 152, 154, 155, 157, 158, 160, 162, 164, 165, 167, 169, 171, 172, 174, 176, 178, 180,
        182, 183, 185, 187, 189, 191, 193, 194, 196, 198, 200, 202, 203, 205, 207, 208, 210, 212,
        213, 215, 216, 218, 219, 221, 222, 224, 225, 226, 228, 229, 230, 231, 232, 233, 235, 236,
        237, 238, 239, 240, 240, 241, 242, 243, 244, 244, 245, 246, 247, 247, 248, 248, 249, 250,
        250, 251, 251, 252, 252, 253, 253, 254, 255
    ],
    b: [0, 1, 3, 4, 6, 8, 9, 11, 13, 15, 17, 19, 21, 23,
        25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 48, 50, 52, 54, 56, 57, 59, 60, 62, 63, 65, 66,
        67, 69, 70, 71, 72, 73, 74, 74, 75, 76, 76, 77, 77, 77, 78, 78, 78, 78, 78, 78, 78, 77, 77, 77,
        76, 76, 75, 75, 74, 73, 73, 72, 71, 70, 69, 68, 67, 66, 66, 65, 64, 63, 61, 60, 59, 58, 58, 57,
        56, 55, 54, 53, 52, 51, 51, 50, 49, 49, 48, 48, 47, 47, 47, 46, 46, 46, 46, 46, 47, 47, 47, 48,
        48, 49, 50, 50, 51, 52, 53, 55, 56, 57, 59, 60, 62, 64, 65, 67, 69, 71, 74, 76, 78, 81, 83, 86,
        88, 91, 94, 96, 99, 102, 105, 108, 111, 114, 117, 120, 124, 127, 130, 133, 136, 140, 143,
        146, 149, 153, 156, 159, 162, 165, 169, 172, 175, 178, 181, 184, 186, 189, 192, 195, 197,
        200, 203, 205, 207, 210, 212, 214, 216, 218, 220, 222, 224, 226, 227, 229, 230, 231, 233,
        234, 235, 236, 237, 238, 239, 239, 240, 241, 241, 242, 242, 242, 243, 243, 243, 243, 243,
        243, 243, 243, 243, 243, 242, 242, 242, 242, 241, 241, 241, 241, 240, 240, 240, 239, 239,
        239, 239, 239, 238, 238, 238, 238, 238, 238, 238, 238, 239, 239, 239, 240, 240, 240, 241,
        242, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 255
    ]	
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorMaps);


/***/ }),

/***/ "./src/js/modules/dataexplorer/toolbarpanel/ToolabarPanelPresenter.js":
/*!****************************************************************************!*\
  !*** ./src/js/modules/dataexplorer/toolbarpanel/ToolabarPanelPresenter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jsfitsio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsfitsio */ "./node_modules/jsfitsio/lib-esm/index.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../events/OpenPanelEvent.js */ "./src/js/events/OpenPanelEvent.js");

/**
 * @author Fabrizio Giordano (Fab)
 */







class ToolbarPanelPresenter {

    _view;
    _fitsdata;
    _img;

    // TODO check where to pass the FITS and the IMAGE
    constructor(in_view){

		this._view = in_view;
		let self  = this;

		var _public = {

			refreshModel: (fitsdata, img)=>{
				self.setModel(fitsdata, img);
			},
            refreshImage: (img)=>{
				self._img = img;
			},
            setModel: (fitsdata, img)=>{
                self._fitsdata = fitsdata;
                self._img = img;
                let url = self.generateFITSUrl();
                self._view.setDownloadFits(url);
			},
            saveFITS: ()=> {
                // TODO implement save method
                console.log("SAVE FITS");
                this.exportFITS();
            },
            saveImage: ()=>{
                // TODO implement save method
                console.log("SAVE IMAGE");
                this.exportImage();
            },
            showFITSHeader: ()=>{
                // TODO this must call the view
                console.log("SHOW FITS HEADER");
                this.showFITSHeader();
            },
			toggle: ()=> {
				self._view.toggle();
			},
			close: ()=> {
				self._view.close();
			}
		}
        this.addButtonsClickHandlers();
		return _public;
	}

    addButtonsClickHandlers() {

        this._view.fitsHeaderButton().on("click", {caller: this}, this.showFITSHeader);
		// this._view.fitsExportButton().on("click", {caller: this}, this.exportFITS);
		this._view.imageExportButton().on("click", {caller: this}, this.exportImage);

        this._view.closeDataExplorerButton().on("click", {caller: this}, function() {
            _events_EventBus_js__WEBPACK_IMPORTED_MODULE_1__["default"].fireEvent(new _events_OpenPanelEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"]("DataExplorer"));
        });
		
    }

	showFITSHeader(event) {
        console.log("clicked on showFITSHeader");

        event.data.caller._view.toggleFITSPanel();

        

        console.log(event.data.caller._fitsdata.fitsheader);
        // TODO update view
        event.data.caller._view.fillFitsHeaderPopup(event.data.caller._fitsdata.fitsheader[0]);
    }

	exportFITS(event) {
        console.log("clicked on exportFITS");
        console.log(event.data.caller._fitsdata);
        // let fw = new FITSWriter();
        // fw.run(event.data.caller._fitsdata.fitsheader, event.data.caller._fitsdata.fitsdata);
        // fw.typedArrayToURL();
		// TODO save the file
        // possible solution <a href="path_to_file" download="proposed_file_name"><button>export fits</button></a>

	}

    generateFITSUrl(){
        let fw = new jsfitsio__WEBPACK_IMPORTED_MODULE_0__.FITSWriter();
        fw.run(this._fitsdata.fitsheader[0], this._fitsdata.fitsdata.get(0));
        return fw.typedArrayToURL();
    }

	exportImage(event) {
        console.log("clicked on exportImage");
        console.log(event.data.caller._img);
		// TODO save the file
	}

    get view(){
		return this._view;
	}

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolbarPanelPresenter);

/***/ }),

/***/ "./src/js/modules/dataexplorer/toolbarpanel/ToolbarPanelView.js":
/*!**********************************************************************!*\
  !*** ./src/js/modules/dataexplorer/toolbarpanel/ToolbarPanelView.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

/**
 * @author Fabrizio Giordano (Fab)
 */



class ToolbarPanelView {
    _html;
    _image;
    _fits;
    _headerPanelVisible;

    constructor() {

        this.init();
        let self = this;

        var _public = {
            getHtml: () => {
                return this._html;
            },
            setModel: (image, fits) => { // ??? probably not neded here. Handled in the presenter

                this._fits = fits;
                this._image = image;
            },
            fitsHeaderButton: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#de_show_fits_header");
            },
            fitsExportButton: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#de_save_fits");
            },
            imageExportButton: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#de_save_png");
            },
            closeDataExplorerButton: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#de_view_close");
            },
            closeFITSHeaderButton: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#de_fits_header_popup_close")
            },
            fillFitsHeaderPopup: (header) => {
                let str = "";

                str += " <div id='de_fits_header_popup_top'><button class='button' id='de_fits_header_popup_close'>x</button></div>";
                header.forEach((value, key) => {
                    str += key + ": " + value + "<br>";
                });
                // $("#de_fits_header_popup").text(str);
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_fits_header_popup").html(str);
                self.dragElement(document.getElementById("de_fits_header_popup"));
                jquery__WEBPACK_IMPORTED_MODULE_0__("#de_fits_header_popup_close").on("click", function () {
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_fits_header_popup").css("display", "none");
                    self._headerPanelVisible = false;
                });

            },
            setDownloadFits: (url) => {
                jquery__WEBPACK_IMPORTED_MODULE_0__("#test").attr("href", url);
            },
            toggleFITSPanel: () => {
                if (this._headerPanelVisible) {
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_fits_header_popup").css("display", "none");
                    this._headerPanelVisible = false;
                } else {
                    jquery__WEBPACK_IMPORTED_MODULE_0__("#de_fits_header_popup").css("display", "block");
                    this._headerPanelVisible = true;
                }
            }

        }
        return _public;
    }


    closeFITSHeaderPopup() {
        jquery__WEBPACK_IMPORTED_MODULE_0__("#de_fits_header_popup").css("display", "none");
        this._headerPanelVisible = false;
    }
    //Make the DIV element draggagle:
    // dragElement(document.getElementById("mydiv"));

    dragElement(elmnt) {
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        if (document.getElementById(elmnt.id + "header")) {
            /* if present, the header is where you move the DIV from:*/
            document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
        } else {
            /* otherwise, move the DIV from anywhere inside the DIV:*/
            elmnt.onmousedown = dragMouseDown;
        }

        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // set the element's new position:
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
        }

        function closeDragElement() {
            /* stop moving when mouse button is released:*/
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }

    init() {
        this._headerPanelVisible = false;
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__(
            "<button class='button' id='de_show_fits_header'>FITS header</button> &nbsp; "
            + " <a href='' id='test' download='fabviewer.fits'><button class='button' id='de_save_fits'>export FITS</button></a> &nbsp; "
            + " <button class='button' id='de_save_png'>export PNG</button>"
            + "<button class='button' id='de_view_close'>x</button></div>"
            + " <div id='de_fits_header_popup'>"
            + " </div>"
        );

    }

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolbarPanelView);

/***/ }),

/***/ "./src/js/modules/datapanel/DataPanelPresenter.js":
/*!********************************************************!*\
  !*** ./src/js/modules/datapanel/DataPanelPresenter.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DataPanelView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataPanelView.js */ "./src/js/modules/datapanel/DataPanelView.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _controlpanel_footprintpanel_events_FootprintSetCloseEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controlpanel/footprintpanel/events/FootprintSetCloseEvent.js */ "./src/js/modules/controlpanel/footprintpanel/events/FootprintSetCloseEvent.js");
/* harmony import */ var _controlpanel_cataloguepanel_model_Catalogue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../controlpanel/cataloguepanel/model/Catalogue.js */ "./src/js/modules/controlpanel/cataloguepanel/model/Catalogue.js");
/* harmony import */ var _controlpanel_cataloguepanel_model_Source_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../controlpanel/cataloguepanel/model/Source.js */ "./src/js/modules/controlpanel/cataloguepanel/model/Source.js");
/* harmony import */ var _controlpanel_footprintpanel_model_FootprintSet_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../controlpanel/footprintpanel/model/FootprintSet.js */ "./src/js/modules/controlpanel/footprintpanel/model/FootprintSet.js");
/* harmony import */ var _controlpanel_footprintpanel_model_Footprint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../controlpanel/footprintpanel/model/Footprint.js */ "./src/js/modules/controlpanel/footprintpanel/model/Footprint.js");
/* harmony import */ var _controlpanel_cataloguepanel_events_CatalogueCloseEvent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../controlpanel/cataloguepanel/events/CatalogueCloseEvent.js */ "./src/js/modules/controlpanel/cataloguepanel/events/CatalogueCloseEvent.js");











class DataPanelPresenter {

    _view;
    _footprintsMap;
    _sourcesMap;
    _rootDomId;

    constructor(rootDomId) {
        this._rootDomId = rootDomId;
        this._view = new _DataPanelView_js__WEBPACK_IMPORTED_MODULE_0__["default"](rootDomId);;
        this._footprintsMap = new Map()
        this._sourcesMap = new Map()
        this.registerForEvents()
    }

    registerForEvents() {
        _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _controlpanel_footprintpanel_events_FootprintSetCloseEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"].name);
        _events_EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].registerForEvent(this, _controlpanel_cataloguepanel_events_CatalogueCloseEvent_js__WEBPACK_IMPORTED_MODULE_8__["default"].name);
    }

    notify(event) {
        if (event instanceof _controlpanel_footprintpanel_events_FootprintSetCloseEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
            this.removeDataset(event.footprintSet._name)
        } else if (event instanceof _controlpanel_cataloguepanel_events_CatalogueCloseEvent_js__WEBPACK_IMPORTED_MODULE_8__["default"]) {
            this.removeDataset(event.catalogue._name)
        }
    }

    get view() {
        return this._view;
    }

    toggleView() {
        jquery__WEBPACK_IMPORTED_MODULE_1__("#" + this._rootDomId).toggle()
    }

    refresh(selectedFootprints, selectedSources) {
        this.refreshSelectedFootprints(selectedFootprints)
        this.refreshSelectedSources(selectedSources)
    }

    refreshSelectedSources(selections) {
        for (const [catalogue, sources] of selections.entries()) {
            if (!this._sourcesMap.has(catalogue)) {
                if (sources.length == 0) {
                    break;
                }
                this._sourcesMap.set(catalogue, sources)
                this.addNewSourceDataset(catalogue._name, catalogue._columns, sources, catalogue)
                catalogue.extAddSources2Selected(sources)
            } else {
                this.look4NewSources(catalogue, sources)
            }
        }
    }

    /**
     * 
     * @param {Map<FootprintSet, Footprint[]>} selections 
     */
    refreshSelectedFootprints(selections) {
        // console.log(selections)
        for (const [fpset, footprints] of selections.entries()) {
            if (!this._footprintsMap.has(fpset)) {
                if (footprints.length == 0) {
                    break;
                }
                this._footprintsMap.set(fpset, footprints)
                this.addNewFootprintDataset(fpset._name, fpset._columns, footprints, fpset)
                fpset.addFootprint2Selected(footprints)
            } else {
                this.look4NewFootprints(fpset, footprints)
            }
        }
    }


    /**
     * 
     * @param {String} datasetname 
     * @param {TapMetadataList} metadata 
     * @param {Footprint[]} footprints 
     * @param {FootprintSet} fpset 
     */
    addNewFootprintDataset(datasetname, metadata, footprints, fpset) {

        this._view.addNewTable(datasetname, metadata, footprints, fpset, this.footprintRemovedFromView, this.footprintHighlighted);
    }
    
    /**
     * 
     * @param {String} datasetname 
     * @param {TapMetadataList} metadata 
     * @param {Source[]} sources 
     * @param {Catalogue} catalogue 
     */
    addNewSourceDataset(datasetname, metadata, sources, catalogue) {

        this._view.addNewTable(datasetname, metadata, sources, catalogue, this.sourceRemovedFromView, this.sourceHighlighted);
    }
    
    

    /**
     * 
     * @param {Catalogue} catalogue 
     * @param {Source[]} sources 
     */
     look4NewSources(catalogue, sources) {
        const existingSources = this._sourcesMap.get(catalogue);
        for (let news of sources) {
            if (!existingSources.includes(news)) {
                this.add2ExistingDataset(catalogue._name, catalogue._columns, news, catalogue)
                this._sourcesMap.get(catalogue).push(news)
                catalogue.extAddSources2Selected(sources)
            }
        }
    }

    /**
     * 
     * @param {FootprintSet} fpSet 
     * @param {Footprint[]} footprints 
     */
    look4NewFootprints(fpSet, footprints) {
        const existingFootprint = this._footprintsMap.get(fpSet);
        for (let newf of footprints) {
            if (!existingFootprint.includes(newf)) {
                this.add2ExistingDataset(fpSet._name, fpSet._columns, newf, fpSet)
                this._footprintsMap.get(fpSet).push(newf)
                fpSet.addFootprint2Selected(footprints)
            }
        }
    }

    add2ExistingDataset(datasetname, metadata, footprint, fpset) {
        this._view.addEntry2Table(datasetname, metadata, footprint, fpset);
    }


    footprintRemovedFromView(fpset, footprint) {
        fpset.removeFootprintFromSelection(footprint)
    }

    footprintHighlighted(fpset, footprint, highlighted) {
        fpset.highlightFootprint(footprint, highlighted)
    }
    
    sourceRemovedFromView(catalogue, source) {
        catalogue.extRemoveSourceFromSelection(source)
    }

    sourceHighlighted(catalogue, source, highlighted) {
        catalogue.extHighlightSource(source, highlighted)
    }

    removeDataset(tableName) { // better ID set in the view
        this._view.removeTable(tableName)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataPanelPresenter);

/***/ }),

/***/ "./src/js/modules/datapanel/DataPanelView.js":
/*!***************************************************!*\
  !*** ./src/js/modules/datapanel/DataPanelView.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var tabulator_tables__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tabulator-tables */ "./node_modules/tabulator-tables/dist/js/tabulator_esm.js");
/* harmony import */ var _repos_tap_TapMetadataList_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../repos/tap/TapMetadataList.js */ "./src/js/repos/tap/TapMetadataList.js");





class DataPanelView {

    _html;
    _rootDomId;
    _dataMap;

    constructor(rootDomId) {

        this._rootDomId = rootDomId;
        this._dataMap = new Map();
        this.init();
        let self = this;

        let _public = {
            getHtml: () => {
                return this._html;
            },
            urlSanifier: (url) => {
                let sanified = url.replace('https://', '').replace('http://', '').replaceAll("/", "_").replaceAll(".", "_");
                return sanified;
            },
            /**
             * 
             * @param {*} tableName 
             * @param {TapMetadataList} metadata 
             * @param {*} footprints 
             */
            addNewTable(tableName, metadata, footprints, fpset, removeRowHandler, footprintHighlighted) {

                const tabID = _public.urlSanifier(tableName);
                jquery__WEBPACK_IMPORTED_MODULE_0__("#" + self._rootDomId).append("<label for='" + tabID + "'>" + tableName + "</label><div id='" + tabID + "'></div>");

                // metadata columns definition
                let tableColumns = [];
                for (let m = 0; m < metadata.length; m++) {

                    tableColumns.push({
                        title: metadata[m]._name,
                        field: metadata[m]._name,
                        // width: 350,
                        hozAlign: "left",
                        formatter: "plaintext"
                    })
                }

                // delete column
                tableColumns.push({
                    title: "Actions",
                    field: "actions",
                    width: 25,
                    formatter: "image",
                    formatterParams: {
                        height: "20px",
                        width: "20px",
                        // urlPrefix: "media/"
                        urlPrefix: "images/"
                    },
                    cellClick: function(e, cell){
                        // console.log(cell.getRow())
                        removeRowHandler(cell._cell.row.data.fpset, cell._cell.row.data.footprint)
                        cell.getRow().delete();
                        
                    }
                })

                // model columns
                tableColumns.push({
                    title: "fpset",
                    field: "fpset",
                    visible: false
                })
                tableColumns.push({
                    title: "footprint",
                    field: "footprint",
                    visible: false
                })



                // adding data 
                let tableData = [];
                for (let f = 0; f < footprints.length; f++) {
                    let row = {};
                    for (let m = 0; m < metadata.length; m++) {
                        row[metadata[m]._name] = footprints[f]._details[m]
                    }
                    row["actions"] = "trash-bin.png"
                    row["fpset"] = fpset;
                    row["footprint"] = footprints[f];
                    tableData.push(row)
                }


                let tableHeight = 250;
                if ((tableData.length * 40) < 250) {
                    tableHeight = tableData.length * 50;
                }
                let table = new tabulator_tables__WEBPACK_IMPORTED_MODULE_2__.TabulatorFull("#" + tabID, {
                    maxHeight: 250, // set height of table (in CSS or here), this enables the Virtual DOM and improves render speed dramatically (can be any valid css height value)
                    data: tableData, //assign data to table
                    layout: "fitColumns", //fit columns to width of table (optional)
                    columns: tableColumns,
                });

                table.on("rowMouseEnter", function(e, row){
                    footprintHighlighted(row._row.data.fpset, row._row.data.footprint, true)
                });

                table.on("rowMouseLeave", function(e, row){
                    footprintHighlighted(row._row.data.fpset, row._row.data.footprint, false)
                });

                self._dataMap.set(tableName, table)

            },
            /**
             * 
             * @param {*} tableName 
             * @param {TapMetadataList} metadata 
             * @param {*} footprint 
             */
            addEntry2Table(tableName, metadata, footprint, fpset) {
                let table = self._dataMap.get(tableName)
                let row = {};
                for (let m = 0; m < metadata.length; m++) {
                    row[metadata[m]._name] = footprint._details[m]
                }
                row["actions"] = "trash-bin.png"
                row["fpset"] = fpset;
                row["footprint"] = footprint;
                table.addData([row]);
                const numRows = table.getDataCount();
                let tableHeight = 250;
                if ((numRows.length * 40) < 250) {
                    tableHeight = numRows.length * 50;
                }

            },
            removeEntryFromTable(tableName, footprint) {

            },
            removeTable(tableName) {
                
                self._dataMap.delete(tableName)
                const tabID = _public.urlSanifier(tableName);
                jquery__WEBPACK_IMPORTED_MODULE_0__("#"+tabID).remove();
                jquery__WEBPACK_IMPORTED_MODULE_0__('label[for=' + tabID + ']').remove();
            }
        }

        return _public;
    }

    init() {
        this._html = "";
    }


}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataPanelView);

/***/ }),

/***/ "./src/js/modules/debug/DebugPresenter.js":
/*!************************************************!*\
  !*** ./src/js/modules/debug/DebugPresenter.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DebugView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DebugView.js */ "./src/js/modules/debug/DebugView.js");



class DebugPresenter {

    _view;
    constructor(){
        this._view = new _DebugView_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }

    get view() {
        return this._view;
    }

    refresh(pxMap, pxCacheMap){
        this._view.setModel(pxMap, pxCacheMap);
        this._view.refresh();
    }


}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DebugPresenter);

/***/ }),

/***/ "./src/js/modules/debug/DebugView.js":
/*!*******************************************!*\
  !*** ./src/js/modules/debug/DebugView.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");


class DebugView {

    _html;
    _pxMap;
    _pxCacheMap;
    constructor() {
        this.initHtml();
    }

    setModel(pxMap, pxCacheMap) {
        this._pxMap = pxMap;
        this._pxCacheMap = pxCacheMap;
    }

    refresh() {

        let tr = '';
        let order;
        let pixno;

        for (let [key, tile] of this._pxMap) {
            order = key.split('#')[0];
            pixno = key.split('#')[1];
            if (tile.parentTile) {
                tr += `<tr><td>${order}</td><td>${pixno}</td><td>${tile.isLoaded}</td><td>${tile.parentTile.key}</td></tr>`;
            } else {
                tr += `<tr><td>${order}</td><td>${pixno}</td><td>${tile.isLoaded}</td><td>${tile.parentTile}</td></tr>`;
            }
            
        }
        document.getElementById('debug_px_body').innerHTML = tr;
        document.getElementById('debug_px_caption').innerHTML = `Tiles drawn ${this._pxMap.size}`;

        tr = '';
        order;
        pixno;
        for (let [key, tile] of this._pxCacheMap) {
            order = key.split('#')[0];
            pixno = key.split('#')[1];
            tr += `<tr><td>${order}</td><td>${pixno}</td><td>${tile.isLoaded}</td></tr>`;
        }
        document.getElementById('debug_px_cache_body').innerHTML = tr;
        document.getElementById('debug_px_cache_caption').innerHTML = `Tiles cache ${this._pxCacheMap.size}`;


        this.applyStyle();
    }

    applyStyle() {

        let height = '350px';
        this._html.css("position", "absolute");
        this._html.css("width", "446px");
        this._html.css("height", height);
        this._html.css("border", "1px solid green");
        this._html.css("left", "200px");
        this._html.css("bottom", "10%");
        this._html.css("color", "white");
        
        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px').css("overflow", "scroll");
        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px').css("float", "left");
        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px').css("border-right", "1px solid green");
        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px').css("height", height);
        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px').css("width", '48%');

        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px_cache').css("float", "right");
        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px_cache').css("overflow", "scroll");
        jquery__WEBPACK_IMPORTED_MODULE_0__('#debug_px_cache').css("height", height);
    }

    get html() {
        return this._html;
    }

    show() {
        // this._html.css("display","none");
        this._html.css("display", "block");
    }

    initHtml() {

        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__(`
            <div id='debug'>
                <div  id='debug_px'>
                    <table>
                        <caption id='debug_px_caption'>Tiles drawn</caption>
                        <thead>
                            <tr>
                                <th>order</th>
                                <th>pixno</th>
                                <th>texture</th>
                                <th>PL</th>
                            </tr>
                        </thead>
                        <tbody id='debug_px_body'>
                        </tbody>
                    </table>
                </div>

                <div id='debug_px_cache'>
                    <table>
                        <caption id='debug_px_cache_caption'>Tiles cache</caption>
                        <thead>
                            <tr>
                                <th>order</th>
                                <th>pixno</th>
                                <th>texture</th>
                            </tr>
                        </thead>
                        <tbody id='debug_px_cache_body'>    
                        </tbody>
                    </table>
                </div>
            </div>
        `);
        this.applyStyle();
    }


}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DebugView);

/***/ }),

/***/ "./src/js/presenter/CoordinatesPanelPresenter.js":
/*!*******************************************************!*\
  !*** ./src/js/presenter/CoordinatesPanelPresenter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _view_CoordinatesPanelView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/CoordinatesPanelView.js */ "./src/js/view/CoordinatesPanelView.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */



class CoordinatesPanelPresenter {

	_parentView;
	_view;
	_showSphericalCoords;
	
	constructor(in_parentView){
		
		this._view = new _view_CoordinatesPanelView_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
		this._showSphericalCoords = true;
		this._view.showSphericalCoords(this._showSphericalCoords); 

		// this._parentView = in_parentView;
		// this._view = new CoordinatesPanelView();
		// this._parentView.append2Body(this._view.getHtml());
		// this._showSphericalCoords = false;
		// this._view.showSphericalCoords(this._showSphericalCoords); 

	}
	
	get view(){
        return this._view;
    }
	
	update(in_raDecDeg, in_raHMS, in_decDMS, in_phi, in_theta){
		this.view.setModel(in_raDecDeg, in_raHMS, in_decDMS, in_phi, in_theta);
	}
	
	showSphericalCoords(show){
		this._showSphericalCoords(show);
		this._view.showSphericalCoords(show); 
	}
	
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoordinatesPanelPresenter);

/***/ }),

/***/ "./src/js/presenter/FoVPresenter.js":
/*!******************************************!*\
  !*** ./src/js/presenter/FoVPresenter.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _view_FoVView_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/FoVView.js */ "./src/js/view/FoVView.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */



class FoVPresenter {

	_view;
	
	/**
	 * 
	 * @param {FoVView} view 
	 */
	constructor(view){
		// this._view = view;
		this._view = new _view_FoVView_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
		
	}
	
	get view(){
        return this._view;
    }
	
	updateFoV(in_fovObj){
		this.view.setModel(in_fovObj);
	}
	
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FoVPresenter);

/***/ }),

/***/ "./src/js/presenter/SettingsPresenter.js":
/*!***********************************************!*\
  !*** ./src/js/presenter/SettingsPresenter.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_SystemEntity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/SystemEntity.js */ "./src/js/model/SystemEntity.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");
/* harmony import */ var _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/FoVUtils.js */ "./src/js/utils/FoVUtils.js");
/* harmony import */ var _events_ShowHealpixGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/ShowHealpixGridSelectionChangedEvent.js */ "./src/js/events/ShowHealpixGridSelectionChangedEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_ShowCoordsGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/ShowCoordsGridSelectionChangedEvent.js */ "./src/js/events/ShowCoordsGridSelectionChangedEvent.js");
/* harmony import */ var _events_CORSTAPReposEvent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/CORSTAPReposEvent.js */ "./src/js/events/CORSTAPReposEvent.js");









class SettingsPresenter{
	
	_view;
	
	constructor(in_view){
		this.init(in_view);
		var _public = {

			refreshModel: ()=>{
				this.setModel();
			},
			setSphericalCoordinates: (phiThetaDeg)=>{
				this.view.setSphericalCoordinates(phiThetaDeg);
			},
			getElapsedTime: ()=>{
				return this.elapsedTime;
			},
			toggle: ()=> {
				this.view.toggle();
			},
			close: ()=> {
				this.view.close();
			}
		}

		return _public;
	}

	init(_view){
		this._view = _view;
		this.frameTimes = [];
		this.frameCursor = 0;
		this.numFrames = 0;   
		this.maxFrames = 20;
		this.totalFPS = 0;
		this.fps = 0;
		var now = (new Date()).getTime() * 0.001;
		this.lastDrawTime = now;
		this.model = new _model_SystemEntity_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
		this.updateFpsInteger = 0;

		this.view.addFovPolyHandler(()=>{this.getFovPoly()});

		this.view.addHealpixGridCheckboxHandler((event)=>{
			_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent(new _events_ShowHealpixGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](event.target.checked));
		});
		this.view.addCoordsGridCheckboxHandler((event)=>{
			_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent(new _events_ShowCoordsGridSelectionChangedEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](event.target.checked));
		});
		this.view.addInsideSphereCheckboxHandler((event)=>{
			_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].camera.setInsideSphere(event.target.checked);
			_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].insideSphere = event.target.checked;
		});
		this.view.addCORSProxyCheckboxHandler((event)=>{
			_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].useCORSProxy = event.target.checked;
			_events_EventBus_js__WEBPACK_IMPORTED_MODULE_4__["default"].fireEvent( new _events_CORSTAPReposEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"]());
		});
		let self = this;
		this.view.addUpdateCorsProxyHandler((event)=>{
			_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].corsProxyUrl = this.view.getProxyUrl();
		});

	}
	
	setModel(){
		this.updateFpsInteger++;
		if(this.updateFpsInteger % 50 == 0){
		
			var now = (new Date()).getTime() * 0.001;
			
			this.elapsedTime = now - this.lastDrawTime;
			this.lastDrawTime = now;
			
			this.fps = 50 / this.elapsedTime;

			// add the current fps and remove the oldest fps
			this.totalFPS += this.fps - (this.frameTimes[this.frameCursor] || 0);
			// record the newest fps
			this.frameTimes[this.frameCursor++] = this.fps;
			// needed so the first N frames, before we have maxFrames, is correct.
			this.numFrames = Math.max(this.numFrames, this.frameCursor);
			// wrap the cursor
			this.frameCursor %= this.maxFrames;
			let averageFPS = this.totalFPS / this.numFrames;

			this.model.setFps(this.fps);
			this.model.setAvgFps(averageFPS);
			this.view.setModel(this.model);
		}
	}

	get view(){
		return this._view;
	}

	getFovPoly(){
		var raDecDeg = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getFoVPolygon(
				_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].pMatrix,
				_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].camera,
				_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].gl.canvas,
				_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].defaultHips
				);

		console.log(raDecDeg);
	};



}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SettingsPresenter);

/***/ }),

/***/ "./src/js/repos/HiPSNodeRepo.js":
/*!**************************************!*\
  !*** ./src/js/repos/HiPSNodeRepo.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addHiPS: () => (/* binding */ addHiPS),
/* harmony export */   addHiPSNode: () => (/* binding */ addHiPSNode)
/* harmony export */ });
/* harmony import */ var _model_HiPSDescriptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/HiPSDescriptor.js */ "./src/js/model/HiPSDescriptor.js");


/**
 * @author Fabrizio Giordano (Fab77)
 */






async function addHiPSNode (nodeurl) {
    let hipslistfile = new URL(nodeurl+"/hipslist");
    let hips = [];
    return window.fetch(hipslistfile, {
        method: 'GET',
        mode: 'cors',
        // headers: {
        //   'Access-Control-Allow-Origin':'*'
        // }
    }).then( 
        res => 
        res.text()
    ).then(
        text => {
        const allLines = text.split(/\r\n|\n/);
        allLines.forEach( (line) => {
            if (line.startsWith("hips_service_url")) {
                let hipsurl = line.split("=")[1];
                if (hipsurl !== undefined && hipsurl !== "") {
                    hips.push(hipsurl.trim());
                }
            }
        });
        return hips;
    }).catch(function(err) {
        console.log("[HiPSNodeRepo] "+err);
    });
}

async function addHiPS(hipsurl) {
    // TODO bad workaround
    hipsurl = hipsurl.replace("http:", "https:");
    let hipspropfile = new URL(hipsurl+"/properties");
    return window.fetch(hipspropfile, {
        method: 'GET',
        mode: 'cors',
        // headers: {
        //     'Access-Control-Allow-Origin':'*'
        //   }
    }).then( res => res.text()
    ).then(text => {
        return new _model_HiPSDescriptor_js__WEBPACK_IMPORTED_MODULE_0__["default"](text, hipsurl);
    }).catch(function(err) {
        console.log("[HiPSNodeRepo] url "+hipsurl+ "[Error]" +err);
    });
}


/***/ }),

/***/ "./src/js/repos/tap/TapMetadata.js":
/*!*****************************************!*\
  !*** ./src/js/repos/tap/TapMetadata.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * @author Fabrizio Giordano (Fab77)
 */

class TapMetadata {

    _name;
    _description;
    _unit;
    _dataType;
    _ucd;
    _uType;
    _index;

    /**
     * 
     * @param {String} name 
     * @param {String} description 
     * @param {String} unit 
     * @param {String} datatype 
     * @param {String} ucd 
     * @param {String} utype 
     */
    constructor(name, description, unit, datatype, ucd, utype){
        this._name = name;
        this._description = description;
        this._unit = unit;
        this._dataType = datatype;
        this._ucd = ucd;
        this._uType = utype;
    }

    get name() {
        return this._name;
    }

    get description() {
        return this._description;
    }

    get unit() {
        return this._unit;
    }

    get datatype() {
        return this._dataType;
    }

    get ucd() {
        return this._ucd;
    }

    get uType() {
        return this._uType;
    }

    
    /**
     * @param {Integer} idx
     */
    set index(idx) {
        this._index = idx;
    }

    get index() {
        return this._index;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TapMetadata);

/***/ }),

/***/ "./src/js/repos/tap/TapMetadataList.js":
/*!*********************************************!*\
  !*** ./src/js/repos/tap/TapMetadataList.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TapMetadata_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TapMetadata.js */ "./src/js/repos/tap/TapMetadata.js");




/**
 * @author Fabrizio Giordano (Fab77)
 */

class TapMetadataList {

    _posEqRAMetaColumns; // TapMetadata with ucd.includes('pos.eq.ra')
    
    _posEqDecMetaColumns; // TapMetadata with ucd.includes('pos.eq.dec') 
    
    /**
     * TapMetadata with at least one of the below list:
     * - ucd.includes('pos.outline;obs.field')
     * - utype.includes('obscore....) -> (OBSCore)
     * - utype.includes('regiobscore....) -> (OBSCore?)
     * - name='stc_s' -> (only for ESASky)
     * - name='s_region' -> (OBSCore)
     */
    _sRegionMetaColumns; 
    
    _pgSphereMetaColumns; // TapMetadata with ucd.includes('pos.outline.meta.pgsphere') 

    _metadataList; // list of all TapMetadata

    constructor(){
        this._metadataList = [];
        this._posEqRAMetaColumns = [];
        this._posEqDecMetaColumns = [];
        this._sRegionMetaColumns = [];
        this._pgSphereMetaColumns = [];
    }

    /**
     * 
     * @param {TapMetadata} tapMetadata 
     */
    addMetadata(tapMetadata){
        let length = this._metadataList.push(tapMetadata);
        let idx = length - 1;
        tapMetadata.index = idx;

        if (tapMetadata.ucd !== undefined && tapMetadata.ucd !== null && tapMetadata.ucd.includes("pos.eq.ra")){
            this._posEqRAMetaColumns.push(tapMetadata);
        } else if (tapMetadata.ucd !== undefined && tapMetadata.ucd !== null && tapMetadata.ucd.includes("pos.eq.dec")){
            this._posEqDecMetaColumns.push(tapMetadata);
        }

        if (tapMetadata.ucd !== undefined && tapMetadata.ucd !== null && tapMetadata.ucd.includes("pos.outline;meta.pgsphere")){
            this._pgSphereMetaColumns.push(tapMetadata);
        }

        if ((tapMetadata.uType !== undefined && tapMetadata.uType !== null && tapMetadata.uType.includes("Char.SpatialAxis.Coverage.Support.Area")) ||
            (tapMetadata.datatype !== undefined && tapMetadata.datatype !== null && tapMetadata.datatype.includes("adql:REGION")) ||
            (tapMetadata.ucd !== undefined && tapMetadata.ucd !== null && tapMetadata.ucd.includes("pos.outline;obs.field")) ||
            (tapMetadata.name !== undefined && tapMetadata.name !== null && tapMetadata.name == "stc_s")){ // <-- last one for ESASky not OBSCore standard
                this._sRegionMetaColumns.push(tapMetadata);
        }
    }

    get metadataList() {
        return this._metadataList;
    }

    get pgSphereMetaColumns () {
        return this._pgSphereMetaColumns;
    }

    get sRegionMetaColumns () {
        return this._sRegionMetaColumns;
    }

    get posEqRAMetaColumns () {
        return this._posEqRAMetaColumns;
    }

    get posEqDecMetaColumns () {
        return this._posEqDecMetaColumns;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TapMetadataList);

/***/ }),

/***/ "./src/js/repos/tap/TapRepo.js":
/*!*************************************!*\
  !*** ./src/js/repos/tap/TapRepo.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * @author Fabrizio Giordano (Fab77)
 */

const AVAILABILITY = "availability";
const TABLES = "tables";
class TapRepo {

    _adqlFunctionList;

    _cataloguesList;
    _observationsList;
    _notClassified;

    _activeObservations;
    _activeCatalogues;

    _tapBaseURL;
    
    constructor(tapUrl) {

        this._tapBaseURL = tapUrl;
        this._adqlFunctionList;

        this._cataloguesList = [];
        this._observationsList = [];
        this._notClassified = [];

        this._activeObservations = [];
        this._activeCatalogues = [];

        this._adqlFunctionList = []
    }

    get tapBaseUrl () {
        return this._tapBaseURL;
    }

    setCataloguesList(cataloguesList) {
        this._cataloguesList = cataloguesList;
    }

    setObservationsList(observationList) {
        this._observationsList = observationList;
    }

    setNotClassifiedList(notClassifiedList) {
        this._notClassified = notClassifiedList;
    }

    setCatalogueActive(catalogue) {
        this._activeCatalogues.push(catalogue);
    }

    setObservationActive(observation) {
        this._activeObservations.push(observation);
    }
    get cataloguesList(){
        return this._cataloguesList;
    }

    get observationsList() {
        return this._observationsList;
    }

    /**
     * @param {any[]} adqlFunctionList
     */
    set adqlFunctionList(adqlFunctionList) {
        if (adqlFunctionList !== undefined) {
            this._adqlFunctionList = adqlFunctionList;
        }
    }

    get adqlFunctionList() {
        return this._adqlFunctionList;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TapRepo);

/***/ }),

/***/ "./src/js/repos/tap/TapRepoService.js":
/*!********************************************!*\
  !*** ./src/js/repos/tap/TapRepoService.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tapRepoSingleton: () => (/* binding */ tapRepoSingleton)
/* harmony export */ });
/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js");
/* harmony import */ var _modules_controlpanel_cataloguepanel_model_Catalogue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../modules/controlpanel/cataloguepanel/model/Catalogue.js */ "./src/js/modules/controlpanel/cataloguepanel/model/Catalogue.js");
/* harmony import */ var _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/FoVUtils.js */ "./src/js/utils/FoVUtils.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Global.js */ "./src/js/Global.js");
/* harmony import */ var _modules_controlpanel_footprintpanel_model_FootprintSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../modules/controlpanel/footprintpanel/model/FootprintSet.js */ "./src/js/modules/controlpanel/footprintpanel/model/FootprintSet.js");
/* harmony import */ var _TapRepo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TapRepo.js */ "./src/js/repos/tap/TapRepo.js");
/* harmony import */ var _TapMetadata_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TapMetadata.js */ "./src/js/repos/tap/TapMetadata.js");
/* harmony import */ var _TapMetadataList_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TapMetadataList.js */ "./src/js/repos/tap/TapMetadataList.js");
/* harmony import */ var _events_AddMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../events/AddMessageToMsgBoxEvent.js */ "./src/js/events/AddMessageToMsgBoxEvent.js");
/* harmony import */ var _events_RemoveMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../events/RemoveMessageToMsgBoxEvent.js */ "./src/js/events/RemoveMessageToMsgBoxEvent.js");
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../events/EventBus.js */ "./src/js/events/EventBus.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */


// import Catalogue from "../../model/Catalogue.js";












class TapRepoSingleton {



    constructor() {

    }


    async addRepos(tapurl) {
        let tapRepo = new _TapRepo_js__WEBPACK_IMPORTED_MODULE_5__["default"](tapurl);
        let functions = this.getAvailableFunctions(tapRepo);
        // TODO https://archive.eso.org/tap_cat/capabilities to check capabilities (CIRCLE, INTERSECTS, POLYGON, ...)
        // need to create a TapRepo.js Object with properties
        let tablesurl = tapurl + "/tables";
        let u;
        if (_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].useCORSProxy) {
            // tablesurl = tablesurl.replaceAll(":", "**");
            // tablesurl = tablesurl.replaceAll("/", "@@");
            // u = global.corsProxyUrl + "/" + tablesurl

            u = _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].corsProxyUrl + "exturl?url=" + tablesurl
        } else {
            u = tapurl + "/tables";
        }
        if (u === undefined) {
            console.error("Repo URL not defined ", u);
            return;
        }

        return cross_fetch__WEBPACK_IMPORTED_MODULE_0__(u, {
            method: 'GET',
            mode: 'cors',
            // headers: {
            //   'Access-Control-Allow-Origin':'*'
            // }
        }).then(res => res.text()
        ).then(xmlStr => {
            xmlStr = xmlStr.replaceAll('\n\t', '');
            xmlStr = xmlStr.replaceAll('\t', '');
            xmlStr = xmlStr.replaceAll('\n', '');
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlStr, "application/xml");

            if (doc.childElementCount > 1) {
                console.error("Error parsing TAP XML. More than 1 node from root");
                return null;
            }

            if (!doc.childNodes[0].nodeName.includes("tableset")) {


                // if (doc.childNodes[0].nodeName.includes("tableset") != "vod:tableset" && doc.childNodes[0].nodeName != "vosi:tableset"
                // || doc.childNodes[0].nodeName != "ns2:tableset") {
                console.error("Error parsing TAP XML. " + doc.childNodes[0].nodeName + " not recognised");
            }

            let obsList = [];
            let catalogueList = [];
            let notClassifiedList = [];

            for (let i = 0; i < doc.childNodes[0].childElementCount; i++) {
                let schema = doc.childNodes[0].childNodes[i];

                if (schema.nodeName != 'schema') {
                    continue;
                }

                for (let t = 0; t < schema.childElementCount; t++) {
                    let table = schema.childNodes[t];
                    if (table.nodeName == 'table') {

                        let dataset = this.parseTable(table, tablesurl);
                        if (dataset !== null) {

                            if (dataset.catalogue != null) {
                                catalogueList.push(dataset.catalogue);
                            }
                            if (dataset.footprint != null) {
                                obsList.push(dataset.footprint);
                            }
                            if (dataset.notClassified != null) {
                                notClassifiedList.push(dataset.notClassified);
                            }
                        }

                    }
                }

            }

            tapRepo.setCataloguesList(catalogueList);
            tapRepo.setObservationsList(obsList);
            tapRepo.setNotClassifiedList(notClassifiedList);
            return tapRepo;
        });

    }

    async getAvailableFunctions(tapRepo) {
        let capabilitiesURL = tapRepo.tapBaseUrl + "/capabilities";
        let u;
        if (_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].useCORSProxy) {
            // capabilitiesURL = capabilitiesURL.replaceAll(":", "**");
            // capabilitiesURL = capabilitiesURL.replaceAll("/", "@@");
            // u = global.corsProxyUrl + "/" + capabilitiesURL

            u = _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].corsProxyUrl + "exturl?url=" + capabilitiesURL
        } else {
            u = tapRepo.tapBaseUrl + "/capabilities";
        }
        if (u === undefined) {
            console.error("Capabilities URL not defined ", u);
            return;
        }

        return cross_fetch__WEBPACK_IMPORTED_MODULE_0__(u, {
            method: 'GET',
            mode: 'cors',
        }).then(res => res.text()
        ).then(xmlStr => {
            xmlStr = xmlStr.replaceAll('\n\t', '');
            xmlStr = xmlStr.replaceAll('\t', '');
            xmlStr = xmlStr.replaceAll('\n', '');
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlStr, "application/xml");
            // console.log(doc);
            if (doc.childElementCount > 1) {
                console.error("Error parsing TAP XML. More than 1 node from root");
                return null;
            }

            let capabilities = [];
            if (!doc.childNodes[0].nodeName.includes("capabilities")) {
                console.error("Error parsing TAP XML. " + doc.childNodes[0].nodeName + " not recognised");
            }
            for (let i = 0; i < doc.childNodes[0].childElementCount; i++) {
                let capability = doc.childNodes[0].childNodes[i];

                if (capability.nodeName != 'capability') {
                    continue;
                }
                for (let t = 0; t < capability.childElementCount; t++) {
                    let child = capability.childNodes[t];
                    if (child.nodeName == 'language') {
                        capabilities = this.parseCapabilities(child);
                    }
                }

            }

            tapRepo.adqlFunctionList = capabilities;
            // return capabilities;

        });
    }

    parseCapabilities(node) {
        let functions = [];
        // node.getElementsByTagName("name");
        // node.getElementsByTagName("version");
        // node.getElementsByTagName("description");
        let featureNodeList = node.getElementsByTagName("languageFeatures")[0].getElementsByTagName("feature")
        for (let i = 0; i < featureNodeList.length; i++) {

            let fNode = featureNodeList[i];
            let f = fNode.getElementsByTagName("form");
            functions.push(f[0].innerHTML);
        }
        return functions;
    }

    parseTable(tablenode, tablesurl) {

        let tablename = tablenode.getElementsByTagName("name")[0].innerHTML;
        // console.log(tablename)
        let tabledesc = (tablenode.getElementsByTagName("description")[0] !== undefined) ? tablenode.getElementsByTagName("description")[0].innerHTML : null;
        // console.log(tabledesc)
        let metacolumns = tablenode.getElementsByTagName("column");



        let columns = [];
        let tapMetas = new _TapMetadataList_js__WEBPACK_IMPORTED_MODULE_7__["default"]();
        let raColumn = undefined;
        let decColumn = undefined;
        let mainRAColumn = undefined;
        let mainDecColumn = undefined;
        let geometryColumn = undefined;
        let nameColumn = undefined;

        for (let mc = 0; mc < metacolumns.length; mc++) {

            let metacolumn = metacolumns[mc];
            let name = metacolumn.getElementsByTagName("name")[0].innerHTML;
            let description = (metacolumn.getElementsByTagName("description")[0] !== undefined) ? metacolumn.getElementsByTagName("description")[0].innerHTML : undefined;
            let unit = (metacolumn.getElementsByTagName("unit")[0] !== undefined) ? metacolumn.getElementsByTagName("unit")[0].innerHTML : undefined;
            let datatype = (metacolumn.getElementsByTagName("dataType")[0] !== undefined) ? metacolumn.getElementsByTagName("dataType")[0].innerHTML : undefined;
            let ucd = (metacolumn.getElementsByTagName("ucd")[0] !== undefined) ? metacolumn.getElementsByTagName("ucd")[0].innerHTML : undefined;
            let utype = (metacolumn.getElementsByTagName("utype")[0] !== undefined) ? metacolumn.getElementsByTagName("utype")[0].innerHTML : undefined;

            let tapMeta = new _TapMetadata_js__WEBPACK_IMPORTED_MODULE_6__["default"](name, description, unit, datatype, ucd, utype);
            tapMetas.addMetadata(tapMeta);

        }

        let catalogue = null;
        let footprint = null;
        let notClassified = null;
        if (tapMetas.pgSphereMetaColumns.length > 0 || tapMetas.sRegionMetaColumns.length > 0) {
            footprint = new _modules_controlpanel_footprintpanel_model_FootprintSet_js__WEBPACK_IMPORTED_MODULE_4__["default"](columns, geometryColumn, nameColumn, tablename, tabledesc, tablesurl, raColumn, decColumn, tapMetas);
        } else if (tapMetas.posEqRAMetaColumns.length > 0 && tapMetas.posEqDecMetaColumns.length > 0) {
            catalogue = new _modules_controlpanel_cataloguepanel_model_Catalogue_js__WEBPACK_IMPORTED_MODULE_1__["default"](columns, mainRAColumn, mainDecColumn, nameColumn, tablename, tabledesc, tablesurl, tapMetas);
        } else {
            notClassified = "TODO: create NC entity for " + tablesurl + "#" + tablename;
        }

        return {
            "catalogue": catalogue,
            "footprint": footprint,
            "notClassified": notClassified
        }

    }


    /**
         * 
         * @param {TapRepo} tapRepo 
         * @param {Catalogue} model 
         */
    queryCatalogueByFoV(tapRepo, model) {

        // let tablesurl = tapRepo.tapBaseUrl + "/sync?request=doQuery&lang=ADQL&format=json&query=";


        let tapTable, tapRa, tapDec, tapGeom, tapName, fovPolyCartesian, fovPolyAstro, queryencoded;

        tapTable = model._name;
        tapRa = model._raColumn;
        tapDec = model._decColumn;
        tapName = (model._nameColumn !== undefined) ? model._nameColumn._name : undefined;
        fovPolyCartesian = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getFoVPolygon(_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].pMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].camera, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].gl.canvas, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].defaultHips, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].rayPicker);
        fovPolyAstro = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getAstroFoVPolygon(fovPolyCartesian);
        let adqlQuery = undefined;

        if (tapRepo.adqlFunctionList.includes("POLYGON")) {
            adqlQuery = "select * " +
                "from " + tapTable + " where " +
                "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
                "POLYGON('ICRS', " + fovPolyAstro + "))";
        } else if (tapRepo.adqlFunctionList.includes("CIRCLE")) {

            let center = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getCenterJ2000(_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].gl.canvas);
            let minFoV = _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].getSelectedHiPS().getMinFoV();
            let radius = minFoV / 2;
            adqlQuery = "select * " +
                "from " + tapTable + " where " +
                "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
                "CIRCLE('ICRS', " + center._raDeg + ", " + center._decDeg + ", " + radius + "))";
        } else {
            adqlQuery = "select * " +
                "from " + tapTable + " where " +
                "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
                "POLYGON('ICRS', " + fovPolyAstro + "))";
        }

        queryencoded = encodeURI(adqlQuery);

        let tapUrl = tapRepo.tapBaseUrl
        let adql = queryencoded
        let u = _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].corsProxyUrl + "adql?tapurl=" + tapUrl + "&query=" + adql

        const msgId = model._name + "_" + (new Date().getTime())
        _events_EventBus_js__WEBPACK_IMPORTED_MODULE_10__["default"].fireEvent(new _events_AddMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_8__["default"](msgId, "Loading data for " + model._name));

        return cross_fetch__WEBPACK_IMPORTED_MODULE_0__(u, {
            method: 'GET',
            mode: 'cors',
            // headers: {
            //       'Access-Control-Allow-Origin':'*'
            //     }
        }).then(res => res.json()
        ).then(json => {

            let metadata = json.metadata;
            let data = json.data;

            console.log(data.length);

            let tapMetadataList = new _TapMetadataList_js__WEBPACK_IMPORTED_MODULE_7__["default"]();
            for (let i = 0; i < metadata.length; i++) {

                let name = metadata[i].name;
                let description = (metadata[i].description !== undefined) ? metadata[i].description : undefined;
                let unit = (metadata[i].unit !== undefined) ? metadata[i].unit : undefined;
                let datatype = (metadata[i].datatype !== undefined) ? metadata[i].datatype : undefined;
                let ucd = (metadata[i].ucd !== undefined) ? metadata[i].ucd : undefined;
                let utype = (metadata[i].utype !== undefined) ? metadata[i].utype : undefined;

                let tapMeta = new _TapMetadata_js__WEBPACK_IMPORTED_MODULE_6__["default"](name, description, unit, datatype, ucd, utype);
                tapMetadataList.addMetadata(tapMeta);
            }

            if (data.length > 0) {
                model.addSources(data, tapMetadataList.metadataList);
            } else {
                console.log("No results found");
            }
            _events_EventBus_js__WEBPACK_IMPORTED_MODULE_10__["default"].fireEvent(new _events_RemoveMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_9__["default"](msgId));
        })

    }

    /**
         * 
         * @param {TapRepo} tapRepo  
         * @param {FootprintSet} model   
         */
    queryObservationByFoV(tapRepo, model) {

        let tablesurl = tapRepo.tapBaseUrl + "/sync?request=doQuery&lang=ADQL&format=json&query=";


        let tapTable, tapRa, tapDec, tapGeom, tapPgSphere, fovPolyCartesian, fovPolyAstro, queryencoded;

        tapTable = model._name;
        tapRa = model.raColumn;
        tapDec = model.decColumn;

        // tapGeom = model._geomColumn._name;
        tapPgSphere = undefined;
        if (model._pgSphereColumn !== undefined) {
            tapPgSphere = model._pgSphereColumn._name;
        }

        // tapName = (model._nameColumn !== undefined ) ? model._nameColumn._name : undefined;
        fovPolyCartesian = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getFoVPolygon(_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].pMatrix, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].camera, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].gl.canvas, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].defaultHips, _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].rayPicker);
        fovPolyAstro = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getAstroFoVPolygon(fovPolyCartesian);
        let adqlQuery = undefined;

        // not working anymore in esasky
        // if (tapPgSphere !== undefined && tapPgSphere !== null) {
        //     adqlQuery = "select * " +
        //         "from " + tapTable + " where " +
        //         "1=INTERSECTS(" + tapPgSphere + ", " +
        //         "POLYGON('ICRS', " + fovPolyAstro + "))";
        // } else {

        if (tapRepo.adqlFunctionList.includes("POLYGON")) {
            adqlQuery = "select * " +
                "from " + tapTable + " where " +
                "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
                "POLYGON('ICRS', " + fovPolyAstro + "))";
        } else if (tapRepo.adqlFunctionList.includes("CIRCLE")) {

            let center = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getCenterJ2000(_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].gl.canvas);
            let minFoV = _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].getSelectedHiPS().getMinFoV();
            let radius = minFoV / 2;
            adqlQuery = "select * " +
                "from " + tapTable + " where " +
                "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
                "CIRCLE('ICRS', " + center._raDeg + ", " + center._decDeg + ", " + radius + "))";
        } else { // for TAP repos with no capabilities exposed
            let center = _utils_FoVUtils_js__WEBPACK_IMPORTED_MODULE_2__["default"].getCenterJ2000(_Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].gl.canvas);
            let minFoV = _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].getSelectedHiPS().getMinFoV();
            let radius = minFoV / 2;
            adqlQuery = "select * " +
                "from " + tapTable + " where " +
                "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
                "CIRCLE('ICRS', " + center._raDeg + ", " + center._decDeg + ", " + radius + "))";
        }
        
        queryencoded = encodeURI(adqlQuery);

        let tapUrl = tapRepo.tapBaseUrl
        let adql = queryencoded
        let u = _Global_js__WEBPACK_IMPORTED_MODULE_3__["default"].corsProxyUrl + "adql?tapurl=" + tapUrl + "&query=" + adql

        const msgId = model._name + "_" + (new Date().getTime())
        _events_EventBus_js__WEBPACK_IMPORTED_MODULE_10__["default"].fireEvent(new _events_AddMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_8__["default"](msgId, "Loading data for " + model._name));

        return cross_fetch__WEBPACK_IMPORTED_MODULE_0__(u, {
            method: 'GET',
            mode: 'cors',
            // headers: {
            //       'Access-Control-Allow-Origin':'*'
            //     }
        }).then(res => res.json()
        ).then(json => {
            const metadata = json.metadata;
            const data = json.data;

            console.log(data.length);

                let tapMetadataList = new _TapMetadataList_js__WEBPACK_IMPORTED_MODULE_7__["default"]();
                for (let i = 0; i < metadata.length; i++) {

                    let name = metadata[i].name;
                    let description = (metadata[i].description !== undefined) ? metadata[i].description : undefined;
                    let unit = (metadata[i].unit !== undefined) ? metadata[i].unit : undefined;
                    let datatype = (metadata[i].datatype !== undefined) ? metadata[i].datatype : undefined;
                    let ucd = (metadata[i].ucd !== undefined) ? metadata[i].ucd : undefined;
                    let utype = (metadata[i].utype !== undefined) ? metadata[i].utype : undefined;

                    let tapMeta = new _TapMetadata_js__WEBPACK_IMPORTED_MODULE_6__["default"](name, description, unit, datatype, ucd, utype);
                    tapMetadataList.addMetadata(tapMeta);
                }

                if (data.length > 0) {
                    model.addFootprints(data, tapMetadataList.metadataList);
                } else {
                    console.log("No results found");
                }
                _events_EventBus_js__WEBPACK_IMPORTED_MODULE_10__["default"].fireEvent(new _events_RemoveMessageToMsgBoxEvent_js__WEBPACK_IMPORTED_MODULE_9__["default"](msgId));
            
        });


        // let xhr = new XMLHttpRequest();

        // console.log(queryencoded);

        // var _self = this;
        // // TODO CONVERT TO PROMISE!
        // xhr.open('GET', tablesurl + queryencoded, true);
        // xhr.responseType = 'json';
        // xhr.onload = () => {
        //     var status = xhr.status;
        //     if (status === 200) {
        //         if (xhr.response == null) {
        //             console.log("No data received:");
        //             console.log(xhr.response);
        //             return;
        //         }
        //         var metadata = xhr.response.metadata;
        //         var data = xhr.response.data;

        //         // console.log(metadata);
        //         console.log(data.length);

        //         // let columnsmeta = [];
        //         let tapMetadataList = new TapMetadataList();
        //         for (let i = 0; i < metadata.length; i++) {

        //             let name = metadata[i].name;
        //             let description = (metadata[i].description !== undefined) ? metadata[i].description : undefined;
        //             let unit = (metadata[i].unit !== undefined) ? metadata[i].unit : undefined;
        //             let datatype = (metadata[i].datatype !== undefined) ? metadata[i].datatype : undefined;
        //             let ucd = (metadata[i].ucd !== undefined) ? metadata[i].ucd : undefined;
        //             let utype = (metadata[i].utype !== undefined) ? metadata[i].utype : undefined;

        //             // let column = new Column(name, description, unit, datatype, ucd, utype, i);
        //             // columnsmeta.push(column);
        //             let tapMeta = new TapMetadata(name, description, unit, datatype, ucd, utype);
        //             tapMetadataList.addMetadata(tapMeta);
        //         }

        //         if (data.length > 0) {
        //             // model.addFootprints(data, columnsmeta);
        //             model.addFootprints(data, tapMetadataList.metadataList);
        //         } else {
        //             console.log("No results found");
        //         }
        //         eventBus.fireEvent(new RemoveMessageToMsgBoxEvent(msgId));
        //     } else {
        //         console.log('Something went wrong:');
        //         console.log(xhr.response);
        //     }
        // };


        // xhr.send();

    }

    // /**
    //  * 
    //  * @param {TapRepo} tapRepo  
    //  * @param {FootprintSet} model   
    //  */
    // queryObservationByFoV(tapRepo, model) {




    //     let tablesurl = tapRepo.tapBaseUrl + "/sync?request=doQuery&lang=ADQL&format=json&query=";


    //     let tapTable, tapRa, tapDec, tapGeom, tapPgSphere, fovPolyCartesian, fovPolyAstro, queryencoded;

    //     tapTable = model._name;
    //     tapRa = model.raColumn;
    //     tapDec = model.decColumn;

    //     const msgId = model._name + "_" + (new Date().getTime())
    //     eventBus.fireEvent(new AddMessageToMsgBoxEvent(msgId, "Loading data for " + model._name));

    //     // tapGeom = model._geomColumn._name;
    //     tapPgSphere = undefined;
    //     if (model._pgSphereColumn !== undefined) {
    //         tapPgSphere = model._pgSphereColumn._name;
    //     }

    //     // tapName = (model._nameColumn !== undefined ) ? model._nameColumn._name : undefined;
    //     fovPolyCartesian = FoVUtils.getFoVPolygon(global.pMatrix, global.camera, global.gl.canvas, global.defaultHips, global.rayPicker);
    //     fovPolyAstro = FoVUtils.getAstroFoVPolygon(fovPolyCartesian);
    //     let adqlQuery = undefined;

    //     // not working anymore in esasky
    //     // if (tapPgSphere !== undefined && tapPgSphere !== null) {
    //     //     adqlQuery = "select * " +
    //     //         "from " + tapTable + " where " +
    //     //         "1=INTERSECTS(" + tapPgSphere + ", " +
    //     //         "POLYGON('ICRS', " + fovPolyAstro + "))";
    //     // } else {

    //     if (tapRepo.adqlFunctionList.includes("POLYGON")) {
    //         adqlQuery = "select * " +
    //             "from " + tapTable + " where " +
    //             "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
    //             "POLYGON('ICRS', " + fovPolyAstro + "))";
    //     } else if (tapRepo.adqlFunctionList.includes("CIRCLE")) {

    //         let center = FoVUtils.getCenterJ2000(global.gl.canvas);
    //         let minFoV = global.getSelectedHiPS().getMinFoV();
    //         let radius = minFoV / 2;
    //         adqlQuery = "select * " +
    //             "from " + tapTable + " where " +
    //             "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
    //             "CIRCLE('ICRS', " + center._raDeg + ", " + center._decDeg + ", " + radius + "))";
    //     } else { // for TAP repos with no capabilities exposed
    //         let center = FoVUtils.getCenterJ2000(global.gl.canvas);
    //         let minFoV = global.getSelectedHiPS().getMinFoV();
    //         let radius = minFoV / 2;
    //         adqlQuery = "select * " +
    //             "from " + tapTable + " where " +
    //             "1=CONTAINS(POINT('ICRS'," + tapRa._name + "," + tapDec._name + "), " +
    //             "CIRCLE('ICRS', " + center._raDeg + ", " + center._decDeg + ", " + radius + "))";
    //     }
    //     // }




    //     // ESASky with pgsphere FoV (in case I want to handle it)
    //     // let adqlQuery = "select "
    //     // adqlQuery += " * " +
    //     //     "from "+tapTable+" where " +
    //     //     "1=INTERSECTS(fov, " +
    //     //     "POLYGON('ICRS', "+fovPolyAstro+"))";

    //     queryencoded = encodeURI(adqlQuery);

    //     let xhr = new XMLHttpRequest();

    //     console.log(queryencoded);

    //     var _self = this;
    //     // TODO CONVERT TO PROMISE!
    //     xhr.open('GET', tablesurl + queryencoded, true);
    //     xhr.responseType = 'json';
    //     xhr.onload = () => {
    //         var status = xhr.status;
    //         if (status === 200) {
    //             if (xhr.response == null) {
    //                 console.log("No data received:");
    //                 console.log(xhr.response);
    //                 return;
    //             }
    //             var metadata = xhr.response.metadata;
    //             var data = xhr.response.data;

    //             // console.log(metadata);
    //             console.log(data.length);

    //             // let columnsmeta = [];
    //             let tapMetadataList = new TapMetadataList();
    //             for (let i = 0; i < metadata.length; i++) {

    //                 let name = metadata[i].name;
    //                 let description = (metadata[i].description !== undefined) ? metadata[i].description : undefined;
    //                 let unit = (metadata[i].unit !== undefined) ? metadata[i].unit : undefined;
    //                 let datatype = (metadata[i].datatype !== undefined) ? metadata[i].datatype : undefined;
    //                 let ucd = (metadata[i].ucd !== undefined) ? metadata[i].ucd : undefined;
    //                 let utype = (metadata[i].utype !== undefined) ? metadata[i].utype : undefined;

    //                 // let column = new Column(name, description, unit, datatype, ucd, utype, i);
    //                 // columnsmeta.push(column);
    //                 let tapMeta = new TapMetadata(name, description, unit, datatype, ucd, utype);
    //                 tapMetadataList.addMetadata(tapMeta);
    //             }

    //             if (data.length > 0) {
    //                 // model.addFootprints(data, columnsmeta);
    //                 model.addFootprints(data, tapMetadataList.metadataList);
    //             } else {
    //                 console.log("No results found");
    //             }
    //             eventBus.fireEvent(new RemoveMessageToMsgBoxEvent(msgId));
    //         } else {
    //             console.log('Something went wrong:');
    //             console.log(xhr.response);
    //         }
    //     };


    //     xhr.send();

    // }

    addCatalogue(catalogue) {
        this._sourceCatalogues.push(catalogue);
    }

    removeCatalogue(in_catalogueName) {
        var i;
        for (i = 0; i < this._activeSourceCatalogues.length; i++) {
            if (this._activeSourceCatalogues[i]._name == in_catalogueName) {
                this._activeSourceCatalogues[i].clearSources();
                this._activeSourceCatalogues.splice(i, 1);
                break;
            }
        }
    }

    get catalogues() {
        return this._activeSourceCatalogues;
    }

    addFootprintSet(footprintset) {
        this._footprintsCatalogues.push(footprintset);
    }

    removeFootprintSet(footprintsetname) {
        var i;
        for (i = 0; i < this._activeFootprintsCatalogues.length; i++) {
            if (this._activeFootprintsCatalogues[i]._name == footprintsetname) {
                this._activeFootprintsCatalogues[i].clearFootprints();
                this._activeFootprintsCatalogues.splice(i, 1);
                break;
            }
        }
    }

    get footprints() {
        return this._activeFootprintsCatalogues;
    }
}



const tapRepoSingleton = new TapRepoSingleton();


/***/ }),

/***/ "./src/js/shaders/GridShaderManager.js":
/*!*********************************************!*\
  !*** ./src/js/shaders/GridShaderManager.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class GridShaderManager {

    static healpixGridVS () {
		return `#version 300 es

        in vec4 aCatPosition;
        // in float u_pointsize;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        // out lowp vec4 vColor;

        void main() {

            gl_Position = uPMatrix * uMVMatrix * aCatPosition;
            gl_PointSize = 7.0;

        }`;
	}

    static healpixGridFS () {
        return `#version 300 es

		precision mediump float;
        
        out vec4 fragColor;

        void main() {
            fragColor = vec4(1.0, 0.0, 0.0, 1);
            //gl_FragColor = u_fragcolor;
		} `;
	}

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridShaderManager);

/***/ }),

/***/ "./src/js/shaders/HiPSShaderProgram.js":
/*!*********************************************!*\
  !*** ./src/js/shaders/HiPSShaderProgram.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hipsShaderProgram: () => (/* binding */ hipsShaderProgram)
/* harmony export */ });
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");
/* harmony import */ var _ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShaderManager.js */ "./src/js/shaders/ShaderManager.js");
/* harmony import */ var _model_hipsnew_ColorMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/hipsnew/ColorMap.js */ "./src/js/model/hipsnew/ColorMap.js");





class HiPSShaderProgram {

    _shaderProgram = undefined;
    _vertexShader;
    _fragmentShader;
    _UBO_colorMapBuffer;
    _UBO_colorMapVariableInfo = {};
    gl_uniforms;    // uniform names in the shader
    gl_attributes;  // uniform attribute names in the shader
    locations;

    constructor() {

        this.gl_uniforms = {
            "sampler": "uSampler0",
            "factor": "uFactor0",
            "m_perspective": "uPMatrix",
            "m_model": "uMMatrix",
            "m_view": "uVMatrix",
            "colormapIdx": "cmapIdx",
            "colormap_red": "r",
            "colormap_green": "g",
            "colormap_blue": "b"
        }

        this.gl_attributes = {
            "vertex_pos": "aVertexPosition",
            "text_coords": "aTextureCoord"
        }

        this.locations = {
            "pMatrix": "",
            "mMatrix": "",
            "vMatrix": "",
            "sampler": "",
            "textureAlpha": "",
            "clorMapIdx": "",
            "vertexPositionAttribute": "",
            "textureCoordAttribute": ""
        }
    }
    get gl_uniforms() {
        return this.gl_uniforms;
    }

    get gl_attributes() {
        return this.gl_attributes;
    }

    get locations() {
        return this.locations;
    }

    get shaderProgram() {
        if (!this._shaderProgram) {
            this._shaderProgram = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createProgram();
            this.initShaders();
        }
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.useProgram(this._shaderProgram);
        return this._shaderProgram
    }

    initShaders() {
        let fragmentShaderStr = _ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].hipsNativeFS();
        this._fragmentShader = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FRAGMENT_SHADER);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.shaderSource(this._fragmentShader, fragmentShaderStr);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.compileShader(this._fragmentShader);
        if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderParameter(this._fragmentShader, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.COMPILE_STATUS)) {
            alert(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderInfoLog(this._fragmentShader));
            return null;
        }

        let vertexShaderStr = _ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].hipsVS();
        this._vertexShader = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.VERTEX_SHADER);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.shaderSource(this._vertexShader, vertexShaderStr);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.compileShader(this._vertexShader);
        if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderParameter(this._vertexShader, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.COMPILE_STATUS)) {
            alert(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderInfoLog(this._vertexShader));
            return null;
        }

        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.attachShader(this._shaderProgram, this._vertexShader);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.attachShader(this._shaderProgram, this._fragmentShader);

        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.linkProgram(this._shaderProgram);

        if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getProgramParameter(this._shaderProgram, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        // global.gl.useProgram(this._shaderProgram);
    }

    enableProgram() {
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.useProgram(this._shaderProgram);
    }

    setGrayscaleShader() {
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.detachShader(this._shaderProgram, this._fragmentShader);
        const fragmentShaderStr = _ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].hipsGrayscaleFS();
        this.changeFSShader(fragmentShaderStr);
    }

    setNativeShader() {
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.detachShader(this._shaderProgram, this._fragmentShader);
        const fragmentShaderStr = _ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].hipsNativeFS();
        this.changeFSShader(fragmentShaderStr);
    }

    setColorMapShader(colorMap) {


        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.detachShader(this._shaderProgram, this._fragmentShader);
        const fragmentShaderStr = _ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].hipsColorMapFS();
        this.changeFSShader(fragmentShaderStr);

        // Get the index of the Uniform Block from any program
        const blockIndex = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformBlockIndex(this._shaderProgram, "colormap");
        // Get the size of the Uniform Block in bytes
        const blockSize = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getActiveUniformBlockParameter(
            this._shaderProgram,
            blockIndex,
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BLOCK_DATA_SIZE
        );
        const uboVariableNames = ["r_palette", "g_palette", "b_palette"];
        // Get the respective index of the member variables inside our Uniform Block
        const uboVariableIndices = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformIndices(
            this._shaderProgram,
            uboVariableNames
        );
        // Get the offset of the member variables inside our Uniform Block in bytes
        const uboVariableOffsets = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getActiveUniforms(
            this._shaderProgram,
            uboVariableIndices,
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_OFFSET
        );
        // const uboVariableOffsets = [0, 1024, 2048]

        this._UBO_colorMapBuffer = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createBuffer();
        // Create Uniform Buffer to store our data
        // this.uboBuffer = global.gl.createBuffer(); // moved into the constructor
        // Bind it to tell WebGL we are working on this buffer
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER, this._UBO_colorMapBuffer);
        // Allocate memory for our buffer equal to the size of our Uniform Block
        // We use dynamic draw because we expect to respecify the contents of the buffer frequently

        // global.gl.bufferData(global.gl.UNIFORM_BUFFER, blockSize, global.gl.DYNAMIC_DRAW);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bufferData(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER, 12288, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.STATIC_DRAW);

        // Unbind buffer when we're done using it for now
        // Good practice to avoid unintentionally working on it
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER, null);
        // Bind the buffer to a binding point
        // Think of it as storing the buffer into a special UBO ArrayList
        // The second argument is the index you want to store your Uniform Buffer in
        // Let's say you have 2 unique UBO, you'll store the first one in index 0 and the second one in index 1
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBufferBase(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER, 0, this._UBO_colorMapBuffer);
        // Name of the member variables inside of our Uniform Block

        // Create an object to map each variable name to its respective index and offset
        // const uboVariableInfo = {}; // moved into the constructor

        let self = this;
        uboVariableNames.forEach((name, index) => {
            self._UBO_colorMapVariableInfo[name] = {
                index: uboVariableIndices[index],
                offset: uboVariableOffsets[index],
            };
        });

    }




    changeFSShader(fragmentShaderStr) {
        this._fragmentShader = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FRAGMENT_SHADER);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.shaderSource(this._fragmentShader, fragmentShaderStr);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.compileShader(this._fragmentShader);
        if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderParameter(this._fragmentShader, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.COMPILE_STATUS)) {
            alert(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderInfoLog(this._fragmentShader));
            return null;
        }
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.attachShader(this._shaderProgram, this._fragmentShader);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.linkProgram(this._shaderProgram);
        if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getProgramParameter(this._shaderProgram, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.useProgram(this._shaderProgram);
    }



    enableShaders(pMatrix, vMatrix, mMatrix, colorMapIdx) {

        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.useProgram(this._shaderProgram);

        this.locations.pMatrix = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, this.gl_uniforms.m_perspective);
        this.locations.mMatrix = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, this.gl_uniforms.m_model);
        this.locations.vMatrix = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, this.gl_uniforms.m_view);
        this.locations.sampler = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, this.gl_uniforms.sampler);
        this.locations.textureAlpha = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, this.gl_uniforms.factor);
        this.locations.clorMapIdx = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformLocation(this._shaderProgram, this.gl_uniforms.colormapIdx);

        this.locations.vertexPositionAttribute = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getAttribLocation(this._shaderProgram, this.gl_attributes.vertex_pos);
        this.locations.textureCoordAttribute = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getAttribLocation(this._shaderProgram, this.gl_attributes.text_coords);

        if (colorMapIdx >= 2) {

            const index = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getUniformBlockIndex(this._shaderProgram, "colormap");
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.uniformBlockBinding(this._shaderProgram, index, 0);
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER, this._UBO_colorMapBuffer);

            let curentColorMap;
            if (colorMapIdx == 2) {
                curentColorMap = _model_hipsnew_ColorMap_js__WEBPACK_IMPORTED_MODULE_2__.colorMap.PLANCK;
            } else if (colorMapIdx == 3) {
                curentColorMap = _model_hipsnew_ColorMap_js__WEBPACK_IMPORTED_MODULE_2__.colorMap.CMB;
            } else if (colorMapIdx == 4) {
                curentColorMap = _model_hipsnew_ColorMap_js__WEBPACK_IMPORTED_MODULE_2__.colorMap.RAINBOW;
            } else if (colorMapIdx == 5) {
                curentColorMap = _model_hipsnew_ColorMap_js__WEBPACK_IMPORTED_MODULE_2__.colorMap.EOSB;
            } else if (colorMapIdx == 6) {
                curentColorMap = _model_hipsnew_ColorMap_js__WEBPACK_IMPORTED_MODULE_2__.colorMap.CUBEHELIX;
            }

            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bufferSubData(
                _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER,
                0,
                curentColorMap.r,
                0
            );
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bufferSubData(
                _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER,
                4096,
                curentColorMap.g,
                0
            );
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bufferSubData(
                _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER,
                8192,
                curentColorMap.b,
                0
            );
            _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.bindBuffer(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.UNIFORM_BUFFER, null);
        }



        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.uniformMatrix4fv(this.locations.mMatrix, false, mMatrix);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.uniformMatrix4fv(this.locations.pMatrix, false, pMatrix);
        _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.uniformMatrix4fv(this.locations.vMatrix, false, vMatrix);
    }

}

const hipsShaderProgram = new HiPSShaderProgram();

/***/ }),

/***/ "./src/js/shaders/ShaderManager.js":
/*!*****************************************!*\
  !*** ./src/js/shaders/ShaderManager.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });




class ShaderManager {


	static hipsVS() {
		return `#version 300 es
		
		in vec3 aVertexPosition;
		in vec2 aTextureCoord;
		
		uniform mat4 uMMatrix;
		uniform mat4 uVMatrix;
		uniform mat4 uPMatrix;
		
		out vec2 vTextureCoord;
		
		void main() {
			gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
			vTextureCoord = aTextureCoord;
		}`;
	}

	static hipsNativeFS() {
		return `#version 300 es

		precision mediump float;
  
		in vec2 vTextureCoord;
	
		uniform sampler2D uSampler0;
		uniform sampler2D uSampler1;
		uniform sampler2D uSampler2;
		uniform sampler2D uSampler3;
		uniform sampler2D uSampler4;
		uniform sampler2D uSampler5;
		uniform sampler2D uSampler6;
		uniform sampler2D uSampler7;
	
		uniform float uFactor0;
		uniform float uFactor1;
		uniform float uFactor2;
		uniform float uFactor3;
		uniform float uFactor4;
		uniform float uFactor5;
		uniform float uFactor6;
		uniform float uFactor7;
	
		out vec4 fragColor;
	
		void main() {
			vec3 finalColor;
	
			if (uFactor0 >= 0.0){
				vec4 mycolor;
				#if __VERSION__ > 120
					vec4 color0 = texture(uSampler0, vTextureCoord);
				#else
					vec4 color0 = texture2D(uSampler0, vTextureCoord);
				#endif

				mycolor = color0;
				finalColor = vec3(mycolor.x *uFactor0, mycolor.y*uFactor0, mycolor.z*uFactor0); 
			} else if (uFactor7 >= 0.0){
				finalColor = vec3(1.0, 0.0, 0.0);
			}
			fragColor = vec4(finalColor, 1);
		} `;
	}

	static hipsGrayscaleFS() {
		return `#version 300 es

		precision mediump float;
  
		in vec2 vTextureCoord;
	
		uniform sampler2D uSampler0;
		uniform sampler2D uSampler1;
		uniform sampler2D uSampler2;
		uniform sampler2D uSampler3;
		uniform sampler2D uSampler4;
		uniform sampler2D uSampler5;
		uniform sampler2D uSampler6;
		uniform sampler2D uSampler7;
	
		uniform float uFactor0;
		uniform float uFactor1;
		uniform float uFactor2;
		uniform float uFactor3;
		uniform float uFactor4;
		uniform float uFactor5;
		uniform float uFactor6;
		uniform float uFactor7;
	
		out vec4 fragColor;
	
		void main() {
			vec3 finalColor;
			

			if (uFactor0 >= 0.0){
				
				#if __VERSION__ > 120
					vec4 color0 = texture(uSampler0, vTextureCoord);
				#else
					vec4 color0 = texture2D(uSampler0, vTextureCoord);
				#endif
				float gray = 0.21 * color0.r + 0.71 * color0.g + 0.07 * color0.b;
				finalColor = vec3(color0.rgb * (1.0 - uFactor0) + (gray * uFactor0));
			}
			
			if (uFactor1 >= 0.0){
				#if __VERSION__ > 120
					vec4 color1 = texture(uSampler1, vTextureCoord);
				#else
					vec4 color1 = texture2D(uSampler1, vTextureCoord);
				#endif
				finalColor = vec3(finalColor.x +  color1.x*uFactor1,finalColor.y +  color1.y*uFactor1,finalColor.z +  color1.z*uFactor1);
			}
			if (uFactor2 >= 0.0){
				#if __VERSION__ > 120
					vec4 color2 = texture(uSampler2, vTextureCoord);
				#else
					vec4 color2 = texture2D(uSampler2, vTextureCoord);
				#endif
				finalColor = vec3(finalColor.x +  color2.x*uFactor2,finalColor.y +  color2.y*uFactor2,finalColor.z +  color2.z*uFactor2);
			}
			if (uFactor3 >= 0.0){
				#if __VERSION__ > 120
					vec4 color3 = texture(uSampler3, vTextureCoord);
				#else
					vec4 color3 = texture2D(uSampler3, vTextureCoord);
				#endif
				finalColor = vec3(finalColor.x +  color3.x*uFactor3,finalColor.y +  color3.y*uFactor3,finalColor.z +  color3.z*uFactor3);
			}
			if (uFactor4 >= 0.0){
				#if __VERSION__ > 120
					vec4 color4 = texture(uSampler4, vTextureCoord);
				#else
					vec4 color4 = texture2D(uSampler4, vTextureCoord);
				#endif
				finalColor = vec3(finalColor.x +  color4.x*uFactor4,finalColor.y +  color4.y*uFactor4,finalColor.z +  color4.z*uFactor4);
			}
			if (uFactor5 >= 0.0){
				#if __VERSION__ > 120
					vec4 color5 = texture(uSampler5, vTextureCoord);
				#else
					vec4 color5 = texture2D(uSampler5, vTextureCoord);
				#endif
				finalColor = vec3(finalColor.x +  color5.x*uFactor5,finalColor.y +  color5.y*uFactor5,finalColor.z +  color5.z*uFactor5);
			}
			if (uFactor6 >= 0.0){
				#if __VERSION__ > 120
					vec4 color6 = texture(uSampler6, vTextureCoord);
				#else
					vec4 color6 = texture2D(uSampler6, vTextureCoord);
				#endif
				finalColor = vec3(finalColor.x +  color6.x*uFactor6,finalColor.y +  color6.y*uFactor6,finalColor.z +  color6.z*uFactor6);
			}
			if (uFactor7 >= 0.0){
				#if __VERSION__ > 120
					vec4 color7 = texture(uSampler7, vTextureCoord);
				#else
					vec4 color7 = texture2D(uSampler7, vTextureCoord);
				#endif
				finalColor = vec3(finalColor.x +  color7.x*uFactor7,finalColor.y +  color7.y*uFactor7,finalColor.z +  color7.z*uFactor7);
			}
			fragColor = vec4(finalColor, 1);
		} `;
	}


	static hipsColorMapFS() {
		return `#version 300 es
		
		precision mediump float;
		
		in vec2 vTextureCoord;
		
		// UBO
		layout (std140) uniform colormap {
			float r_palette[256];
			float g_palette[256];
			float b_palette[256];
		};
		
		
		uniform sampler2D uSampler0;
		uniform float uFactor0;	
		out vec4 fragColor;
	
		void main() {
		
			#if __VERSION__ > 120
				vec4 color0 = texture(uSampler0, vTextureCoord);
			#else
				vec4 color0 = texture2D(uSampler0, vTextureCoord);
			#endif

			int x = int(color0.r * 255.0);
			float px = r_palette[x]/256.0;
			
			int y = int(color0.g * 255.0);
			float py = g_palette[y]/256.0;
			
			int z = int(color0.b * 255.0);
			float pz = b_palette[z]/256.0;
		
			fragColor = vec4(px, py, pz, 1);
		} `;
	}

	

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShaderManager);

/***/ }),

/***/ "./src/js/utils/CoordsType.js":
/*!************************************!*\
  !*** ./src/js/utils/CoordsType.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @author Fabrizio Giordano (Fab77)
 * Enum for coordinate types.
 * @readonly
 * @enum {{name: string, hex: string}}
 */
const CoordsType = Object.freeze({
  CARTESIAN:   "cartesian",
  SPHERICAL:  "spherical",
  ASTRO: "astro"
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoordsType);

/***/ }),

/***/ "./src/js/utils/FoVUtils.js":
/*!**********************************!*\
  !*** ./src/js/utils/FoVUtils.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point.js */ "./src/js/utils/Point.js");
/* harmony import */ var _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RayPickingUtils.js */ "./src/js/utils/RayPickingUtils.js");
/* harmony import */ var _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CoordsType.js */ "./src/js/utils/CoordsType.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");

/**
 * @author Fabrizio Giordano (Fab)
 */

// !!!!!!!!!!!
//TODO USE GLOBAL to get GL and Canvas instead of passing it as param all over!!!





class FoVUtils {
	
	// constructor(in_fovX = 180, in_fovY = 180){
	// 	console.error("USED!!!");
	// 	this._fovX_deg = in_fovX;
	// 	this._fovY_deg = in_fovY;
	// }
	
	// computeAngle (canvasX, canvasY, in_pMatrix, in_camera, in_model, in_canvas,
	// 		in_raypicker){
		
	// 	var rayWorld = vec3.create();
	// 	var intersectionDistance = 0;
	// 	var intersectionPoint = vec3.create();
	// 	var center = vec3.create();
	// 	var intersectionPoint_center_vector = vec3.create();
	// 	var b = vec3.create();
	// 	var scal_prod = vec3.create();
	// 	var b_center_vector = vec3.create();
	// 	var intersectionPoint_center_vector_norm = vec3.create();
	// 	var b_center_vector_norm = vec3.create();
	// 	var cos_angle = 0;
	// 	var angle_rad = 0;
	// 	var angle_deg = 0;

	// 	rayWorld = in_raypicker.getRayFromMouse(canvasX, canvasY, in_pMatrix, 
	// 			in_camera.getCameraMatrix(), in_canvas);
		
	// 	intersectionDistance = in_raypicker.raySphere(in_camera.getCameraPosition(), 
	// 			rayWorld, in_model);
	// 	console.log("[FoVUtils::computeAngle] intersectionDistance "+intersectionDistance 
	// 			+ "against object "+in_model.name);
		
	// 	if (intersectionDistance > 0){
			
	// 		vec3.scale(intersectionPoint, rayWorld, intersectionDistance);
	// 		vec3.add(intersectionPoint, in_camera.getCameraPosition(), intersectionPoint);
			
	// 		center = in_model.center;
			
	// 		vec3.subtract(intersectionPoint_center_vector, intersectionPoint, center);
			
	// 		b = vec3.create( [in_model.center[0], in_model.center[1], in_model.center[2] + in_model.radius] );
			
	// 		vec3.subtract(b_center_vector, b, center);
			
			
	// 		scal_prod = vec3.dot(intersectionPoint_center_vector, b_center_vector);
	// 		intersectionPoint_center_vector_norm = Math.sqrt(
	// 				intersectionPoint_center_vector[0]*intersectionPoint_center_vector[0] + 
	// 				intersectionPoint_center_vector[1]*intersectionPoint_center_vector[1] + 
	// 				intersectionPoint_center_vector[2]*intersectionPoint_center_vector[2]);
			
	// 		b_center_vector_norm = Math.sqrt(
	// 				b_center_vector[0]*b_center_vector[0] + 
	// 				b_center_vector[1]*b_center_vector[1] + 
	// 				b_center_vector[2]*b_center_vector[2]);
			
	// 		cos_angle = scal_prod / (intersectionPoint_center_vector_norm * b_center_vector_norm);
	// 		angle_rad = Math.acos(cos_angle);
	// 		angle_deg = 2 * radToDeg(angle_rad);
			
	// 	}else{
	// 		angle_deg = 180;
	// 	}
	// 	return angle_deg;
	// }
	
	// getFoV (in_canvas, in_pMatrix, in_camera, in_model, in_raypicker){

	// 	// horizontal FoV 
	// 	this._fovX_deg = this.computeAngle(0, in_canvas.height / 2, in_pMatrix, in_camera, in_model, in_canvas, in_raypicker);
	// 	// vertical FoV 
	// 	this._fovY_deg = this.computeAngle(in_canvas.width / 2, 0, in_pMatrix, in_camera, in_model, in_canvas, in_raypicker);
				
	// 	return [this._fovX_deg, this._fovY_deg];

	// }
	
	/** 
	 * return the minimum fov value between _fovY_deg and _fovX_deg
	 */
	getMinFoV (){
		return (this._fovY_deg <= this._fovX_deg) ? this._fovY_deg : this._fovX_deg;
	}
	
	/** raypicking on screen [0, 0] corner to check if HiPS covers the full screen
	if raypicking returns a valid point
		do raypicking on 4 screen corners and middle points
		return the points (8 in total)
	else
		do raypicking on screen [0, height/2]
		if raypicking returns a valid point
			compute middle top and bottom points
			compute intersection between frustrum and HiPS sphere using getFoVPolygonWithPlanes
		else
			compute intersection between frustum plane normal passing through the HiPS center
				and the HiPS (1 point).
			compute the middle point in the arc between the perpendicular plane and the point above (1 point)
			
		do raypicking on screen [0, width/2]
		if raypicking returns a valid point
			compute middle top and bottom points
			compute intersection between frustrum and HiPS sphere using getFoVPolygonWithPlanes
		else
			compute intersection between frustum plane normal passing through the HiPS center
				and the HiPS (1 point).
			compute the middle point in the arc between the perpendicular plane and the point above (1 point)

	 */
	static getFoVPolygon (in_pMatrix, in_cameraObj, in_gl_canvas, in_modelObj){
//		static getFoVPolygon (in_pMatrix, in_cameraObj, in_gl_canvas, in_modelObj, in_raypicker){

		var in_vMatrix = in_cameraObj.getCameraMatrix();
		var in_mMatrix = in_modelObj.getModelMatrix();
		var canvasWidth = in_gl_canvas.clientWidth;
		var canvasHeight = in_gl_canvas.clientHeight;
		
		var points = [];
		
		// Starting FIRST type of check
		var intersectionWithModel = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(0, 0);
		
		// the screen is fully covered by the sphere. (CASE C) 
		if (intersectionWithModel.intersectionPoint.length > 0){
			let cornersPoints = FoVUtils.getScreenCornersIntersection(in_pMatrix, in_cameraObj, in_gl_canvas, in_modelObj);
			
			points = cornersPoints;
			console.warn("CASE C")
			
		}else{
			// Starting SECOND type of check
			let A = 0, 
			B = 0, 
			C = 0, 
			D = 0,
			M = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create(),
			topPlaneNormal = [], 
			bottomPlaneNormal = [],
			rightPlaneNormal = [],
			leftPlaneNormal = [];
			
			let topPoints = [],
			bottomPoints = [],
			leftPoints = [],
			rightPoints = [],
			// intermidiate points
			middleLeftTop = [],
			middleTopRight = [],
			middleRightBottom = [],
			middleBottomLeft = [];
			
			M = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply(M, in_vMatrix, in_mMatrix);
			M = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply(M, in_pMatrix, M);
			
			// top plane normal
			
			A = M[3] - M[1];	// A = m41 - m21
			B = M[7] - M[5];	// B = m42 - m22
			C = M[11] - M[9];	// C = m43 - m23
			D = M[15] - M[13];	// D = m44 - m24
			topPlaneNormal = [M[3] - M[1], M[7] - M[5], M[11] - M[9], M[15] - M[13]];
			// bottom plane normal
			A = M[3] + M[1];	// A = m41 + m21
			B = M[7] + M[5];	// B = m42 + m22
			C = M[11] + M[9];	// C = m43 + m23
			D = M[15] + M[13];	// D = m44 + m24 
			bottomPlaneNormal = [M[3] + M[1], M[7] + M[5], M[11] + M[9], M[15] + M[13]];
			// right plane normal
			A = M[3] - M[0];	// A = m41 - m11
			B = M[7] - M[4];	// B = m42 - m12
			C = M[11] - M[8];	// C = m43 - m13
			D = M[15] - M[12];	// D = m44 - m14
			rightPlaneNormal = [M[3] - M[0], M[7] - M[4], M[11] - M[8], M[15] - M[12]];
			// left plane normal
			A = M[3] + M[0];	// A = m41 + m11
			B = M[7] + M[4];	// B = m42 + m12
			C = M[11] + M[8];	// C = m43 + m13
			D = M[15] + M[12];	// D = m44 + m14
			leftPlaneNormal = [M[3] + M[0], M[7] + M[4], M[11] + M[8], M[15] + M[12]];
	
			let intersectionTopMiddle = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth/2, 0);
			let intersectionRightMiddle = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth, canvasHeight/2);
	
			
			// zoomed out. half emisphere fully visible (CASE A) 
			// TODO N.B. this is the less precise algo. To make more precise, instead of computing the middle point between 2 points, 
			// it would be better to divide such segment into 3 or 4 and compute more intersection points with the sphere.
			if (intersectionTopMiddle.intersectionPoint.length == 0 && intersectionRightMiddle.intersectionPoint.length == 0){
				console.warn("CASE A")
				topPoints = FoVUtils.getNearestSpherePoint(topPlaneNormal);
				bottomPoints = FoVUtils.getNearestSpherePoint(bottomPlaneNormal);
				leftPoints = FoVUtils.getNearestSpherePoint(leftPlaneNormal);
				rightPoints = FoVUtils.getNearestSpherePoint(rightPlaneNormal);
				// computing intermidiate points
				middleLeftTop = FoVUtils.computeMiddlePoint(leftPoints[0], topPoints[0]);
				middleTopRight = FoVUtils.computeMiddlePoint(topPoints[0], rightPoints[0]);
				middleRightBottom = FoVUtils.computeMiddlePoint(rightPoints[0], bottomPoints[0]);
				middleBottomLeft = FoVUtils.computeMiddlePoint(bottomPoints[0], leftPoints[0]);
				// 8 points in total
				points.push(topPoints[0], middleTopRight[0], rightPoints[0], middleRightBottom[0], bottomPoints[0], middleBottomLeft[0], leftPoints[0], middleLeftTop[0]);
				
			} else if(intersectionTopMiddle.intersectionPoint.length == 0){
				// No intersection between top/bottom frustum planes and the sphere (CASE E)
				console.warn("CASE E")
				topPoints = FoVUtils.getNearestSpherePoint(topPlaneNormal);
				bottomPoints = FoVUtils.getNearestSpherePoint(bottomPlaneNormal);
				leftPoints = FoVUtils.getFrustumIntersectionWithSphere(M, leftPlaneNormal, bottomPlaneNormal, topPlaneNormal);
				rightPoints = FoVUtils.getFrustumIntersectionWithSphere(M, rightPlaneNormal, topPlaneNormal, bottomPlaneNormal);
				// computing intermidiate points
				middleLeftTop = FoVUtils.computeMiddlePoint(leftPoints[1], topPoints[0]);
				middleTopRight = FoVUtils.computeMiddlePoint(topPoints[0], rightPoints[0]);
				middleRightBottom = FoVUtils.computeMiddlePoint(rightPoints[1], bottomPoints[0]);
				middleBottomLeft = FoVUtils.computeMiddlePoint(bottomPoints[0], leftPoints[0]);
				// 10 points in total
				points.push(topPoints[0], middleTopRight[0], rightPoints[0], rightPoints[1], middleRightBottom[0], bottomPoints[0], middleBottomLeft[0], leftPoints[0], leftPoints[1], middleLeftTop[0]);
			
			} else if(intersectionRightMiddle.intersectionPoint.length == 0){
				console.warn("CASE D")
				// No intersection between right/left frustum planes and the sphere (CASE D)
				topPoints = FoVUtils.getFrustumIntersectionWithSphere(M, topPlaneNormal, leftPlaneNormal, rightPlaneNormal);
				bottomPoints = FoVUtils.getFrustumIntersectionWithSphere(M, bottomPlaneNormal, rightPlaneNormal, leftPlaneNormal);
				leftPoints = FoVUtils.getNearestSpherePoint(leftPlaneNormal);
				rightPoints = FoVUtils.getNearestSpherePoint(rightPlaneNormal);
				// computing intermidiate points
				middleLeftTop = FoVUtils.computeMiddlePoint(leftPoints[0], topPoints[0]);
				middleTopRight = FoVUtils.computeMiddlePoint(topPoints[1], rightPoints[0]);
				middleRightBottom = FoVUtils.computeMiddlePoint(rightPoints[0], bottomPoints[0]);
				middleBottomLeft = FoVUtils.computeMiddlePoint(bottomPoints[1], leftPoints[0]);
				// 10 points in total
				points.push(topPoints[0], topPoints[1], middleTopRight[0], rightPoints[0], middleRightBottom[0], bottomPoints[0], bottomPoints[1], middleBottomLeft[0], leftPoints[0], middleLeftTop[0]);
				
			} else {
				console.warn("CASE B")
				// all frustum planes intersect with the sphere, but the the screen is not fully covered. (CASE B)
				topPoints = FoVUtils.getFrustumIntersectionWithSphere(M, topPlaneNormal, leftPlaneNormal, rightPlaneNormal);
				bottomPoints = FoVUtils.getFrustumIntersectionWithSphere(M, bottomPlaneNormal, rightPlaneNormal, leftPlaneNormal);
				leftPoints = FoVUtils.getFrustumIntersectionWithSphere(M, leftPlaneNormal, bottomPlaneNormal, topPlaneNormal);
				rightPoints = FoVUtils.getFrustumIntersectionWithSphere(M, rightPlaneNormal, topPlaneNormal, bottomPlaneNormal);
				// 8 points in total
				points.push(topPoints[0], topPoints[1], rightPoints[0], rightPoints[1], bottomPoints[0], bottomPoints[1], leftPoints[0], leftPoints[1]);
				
			}
	
		}
		
		// var i = 0;
		// for (i = 0; i < points.length; i++){
		// 	console.log("("+points[i].raDeg+", "+points[i].decDeg+")");
		// }
		
		return points;
		
	}
	
	
	/** 
	 * by  using raypicking, it computes the intersection points between the HiPS sphere and the corners and middle points 
	 * of the screen:
	 * top:		(0,0), (canvasWidth/2,0), (canvasWidth,0)
	 * right:	(canvasWidth, canvasHeight/2)
	 * bottom:	(canvasWidth,canvasHeight), (canvasWidth/2,canvasHeight), (0, canvasHeight)
	 * left:	(0, canvasHeight/2)
	 *  
	 * return an array of intersection points in clockwise order. Top left point is in position 0
	 */
	static getScreenCornersIntersection(in_pMatrix, in_cameraObj, in_gl_canvas, in_modelObj){
//		static getScreenCornersIntersection(in_pMatrix, in_cameraObj, in_gl_canvas, in_modelObj, in_raypicker){
		
		let topLeft = null,
		topRight = null,
		bottomRight = null,
		bottomLeft = null,
		middleTop = null,
		middleBottom = null,
		middleLeft = null,
		middleRight = null; 
		let in_vMatrix = in_cameraObj.getCameraMatrix();
		let canvasWidth = in_gl_canvas.clientWidth;
		let canvasHeight = in_gl_canvas.clientHeight;
		
		let points = [];
		// TODO The code below can be replaced by 2 nested for loops 
		
		// Screen top
		
		topLeft = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(0, 0);
		
		middleTop = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth/2, 0);
		
		topRight = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth, 0);
		
		
		// screen middle right
		middleRight = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth, canvasHeight/2);
		
		// screen bottom
		bottomRight = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth, canvasHeight);
		
		middleBottom = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth/2, canvasHeight);
		
		bottomLeft = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(0, canvasHeight);
		
		// screen middle left
		middleLeft = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(0, canvasHeight/2);
		

		
		if (topLeft.intersectionPoint.length > 0){
//			points.push(new Point(topLeft.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": topLeft.intersectionPoint[0],
				"y": topLeft.intersectionPoint[1],
				"z": topLeft.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		if (middleTop.intersectionPoint.length > 0){
//			points.push(new Point(middleTop.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": middleTop.intersectionPoint[0],
				"y": middleTop.intersectionPoint[1],
				"z": middleTop.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		if (topRight.intersectionPoint.length > 0){
//			points.push(new Point(topRight.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": topRight.intersectionPoint[0],
				"y": topRight.intersectionPoint[1],
				"z": topRight.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		if (middleRight.intersectionPoint.length > 0){
//			points.push(new Point(middleRight.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": middleRight.intersectionPoint[0],
				"y": middleRight.intersectionPoint[1],
				"z": middleRight.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		if (bottomRight.intersectionPoint.length > 0){
//			points.push(new Point(bottomRight.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": bottomRight.intersectionPoint[0],
				"y": bottomRight.intersectionPoint[1],
				"z": bottomRight.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		if (middleBottom.intersectionPoint.length > 0){
//			points.push(new Point(middleBottom.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": middleBottom.intersectionPoint[0],
				"y": middleBottom.intersectionPoint[1],
				"z": middleBottom.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		if (bottomLeft.intersectionPoint.length > 0){
//			points.push(new Point(bottomLeft.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": bottomLeft.intersectionPoint[0],
				"y": bottomLeft.intersectionPoint[1],
				"z": bottomLeft.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		if (middleLeft.intersectionPoint.length > 0){
//			points.push(new Point(middleLeft.intersectionPoint));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": middleLeft.intersectionPoint[0],
				"y": middleLeft.intersectionPoint[1],
				"z": middleLeft.intersectionPoint[2]
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}

		return points;
	}

	
	/**
	 * @returns center of type Point.js
 	 */
	static getCenterJ2000(canvas) {
		
		let canvasWidth = canvas.clientWidth;
		let canvasHeight = canvas.clientHeight;

		let center_xyz = _RayPickingUtils_js__WEBPACK_IMPORTED_MODULE_1__["default"].getIntersectionPointWithSingleModel(canvasWidth/2, canvasHeight/2);
		let center = new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
			"x": center_xyz.intersectionPoint[0],
			"y": center_xyz.intersectionPoint[1],
			"z": center_xyz.intersectionPoint[2]
		}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN);

		return center;
	}


	static computeMiddlePoint (point1, point2){
		var points = [];
		var x_s = 0,
		y_s = 0,
		z_s = 0;	// sphere center
		var R = 1;	// sphere radius
		var l, m, n;
		var x_m, y_m, z_m;	// coordinates of the middle point of the segment point1-point2 
		x_m = (point1.x + point2.x) / 2;
		y_m = (point1.y + point2.y) / 2;
		z_m = (point1.z + point2.z) / 2;
		
		l = x_m - x_s;
		m = y_m - y_s;
		n = z_m - z_s;
		
		var den = Math.sqrt(l*l + m*m + n*n);
		var x_1 = x_s + (R * l) / den;
		var y_1 = y_s + (R * m) / den;
		var z_1 = z_s + (R * n) / den;
		var dist_1_M = Math.sqrt( (x_1-x_m)*(x_1-x_m) + (y_1-y_m)*(y_1-y_m) + (z_1-z_m)*(z_1-z_m) );
		
		var x_2 = x_s - (R * l) / den;
		var y_2 = y_s - (R * m) / den;
		var z_2 = z_s - (R * n) / den;
		var dist_2_M = Math.sqrt( (x_2-x_m)*(x_2-x_m) + (y_2-y_m)*(y_2-y_m) + (z_2-z_m)*(z_2-z_m) );
		
		
		
		if (dist_1_M < dist_2_M){
//			points.push(new Point([x_1, y_1, z_1]));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": x_1,
				"y": y_1,
				"z": z_1
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}else{
//			points.push(new Point([x_2, y_2, z_2]));
			points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
				"x": x_2,
				"y": y_2,
				"z": z_2
			}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		}
		return points;
		
	}


	/** 
	 * This function returns the nearest intersection point between one frustum plane
	 * and the sphere using the normal to the plane.
	 */ 
	static getNearestSpherePoint(plane){
		
		var points = [];
		var P_intersection = null;
		
		var A = plane[0],
		B = plane[1],
		C = plane[2],
		D = plane[3];
		
		var x_s = 0,
		y_s = 0,
		z_s = 0,	// center of the sphere
		R = 1;	// radius of the sphere
		
		var t1 = R * Math.sqrt( 1 / (A*A + B*B + C*C));
		var t2 = - 1 * R * Math.sqrt( 1 / (A*A + B*B + C*C));
		
		var P_1 = [x_s + A * t1, y_s + B * t1, z_s + C * t1];
		var P_2 = [x_s + A * t2, y_s + B * t2, z_s + C * t2];

		// P_1 distance from plane plane4Circle_1 
		var den = Math.sqrt(A*A + B*B + C*C);
		var dist_1 = Math.abs( A * P_1[0] + B * P_1[1] + C * P_1[2] + D ) / den;
		var dist_2 = Math.abs( A * P_2[0] + B * P_2[1] + C * P_2[2] + D ) / den;

		P_intersection = P_2;
		if (dist_1 <= dist_2 ){
			P_intersection = P_1;
		}
		
		
//		points.push(new Point(P_intersection));
		points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
			"x": P_intersection[0],
			"y": P_intersection[1],
			"z": P_intersection[2]
		}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		
		return points;
		
	}


	/**
	 * it computes the intersection points between the sphere and a plane of the frustum (plane4Sphere).
	 * To do that, the algo uses 2 perpendicular frustum planes to compute the nearest point to them.
	 * input:
	 * 	M: P * V * M matrice
	 * 	plane4Sphere: the plane the result points belong to	(e.g. top plane)
	 * 	plane4Circle_1: perpendicular plane to plane4Sphere to compute the nearest point to plane4Circle_1 (e.g. left plane)
	 * 	plane4Circle_2: perpendicular plane to plane4Sphere to compute the nearest point to plane4Circle_2 (e.g. right plane)
	 * 
	 * returns an array of 2 intersection points, first point computed with plane4Circle_1 and the second with plane4Circle_2
	 */
	static getFrustumIntersectionWithSphere (M, plane4Sphere, plane4Circle_1, plane4Circle_2){
		
		var P_intersection_1 = null,
		P_intersection_2 = null;
		var points = [];
		
		var A = plane4Sphere[0];
		var B = plane4Sphere[1];
		var C = plane4Sphere[2];
		var D = plane4Sphere[3]; 
		
		var x_s = 0,
		y_s = 0,
		z_s = 0;
		
		var R_s = 1;
		var x_c = x_s - (A * (A * x_s + B * y_s + C * z_s + D) / ( A * A + B * B + C * C));
		var y_c = y_s - (B * (A * x_s + B * y_s + C * z_s + D) / ( A * A + B * B + C * C));
		var z_c = z_s - (C * (A * x_s + B * y_s + C * z_s + D) / ( A * A + B * B + C * C));
		var d = Math.abs(A * x_s + B * y_s + C * z_s + D) / Math.sqrt( A * A + B * B + C * C);
		
		
		if (R_s > d){	// center of circle inside the sphere
			let r = Math.sqrt( R_s * R_s - ( d * d ) );
		
			A = plane4Circle_1[0];
			B = plane4Circle_1[1];
			C = plane4Circle_1[2];
			D = plane4Circle_1[3]; 
			
			let t1 = r * Math.sqrt( 1 / (A*A + B*B + C*C));
			let t2 = - 1 * r * Math.sqrt( 1 / (A*A + B*B + C*C));
			
			let P_1 = [x_c + A * t1, y_c + B * t1, z_c + C * t1];
			let P_2 = [x_c + A * t2, y_c + B * t2, z_c + C * t2];

			// P_1 distance from plane plane4Circle_1 
			let den = Math.sqrt(A*A + B*B + C*C);
			let dist_1 = Math.abs( A * P_1[0] + B * P_1[1] + C * P_1[2] + D ) / den;
			let dist_2 = Math.abs( A * P_2[0] + B * P_2[1] + C * P_2[2] + D ) / den;

			P_intersection_1 = P_2;
			if (dist_1 <= dist_2 ){
				P_intersection_1 = P_1;
			}
			
			
			console.log("from plane 1 -> P_intersection_1: "+P_intersection_1);
			
			A = plane4Circle_2[0];
			B = plane4Circle_2[1];
			C = plane4Circle_2[2];
			D = plane4Circle_2[3]; 
			
			t1 = r * Math.sqrt( 1 / (A*A + B*B + C*C));
			t2 = - 1 * r * Math.sqrt( 1 / (A*A + B*B + C*C));
			
			P_1 = [x_c + A * t1, y_c + B * t1, z_c + C * t1];
			P_2 = [x_c + A * t2, y_c + B * t2, z_c + C * t2];
			
			// P_1 distance from plane plane4Circle_1 
			den = Math.sqrt(A*A + B*B + C*C);
			dist_1 = Math.abs( A * P_1[0] + B * P_1[1] + C * P_1[2] + D ) / den;
			dist_2 = Math.abs( A * P_2[0] + B * P_2[1] + C * P_2[2] + D ) / den;

			P_intersection_2 = P_2;
			if (dist_1 <= dist_2 ){
				P_intersection_2 = P_1;
			}
			console.log("from plane 2 -> P_intersection_2: "+P_intersection_2);
			
		}else if ( R_s == d){	// center of circle tangent to the sphere
			let r = 0;
			
			A = plane4Circle_1[0];
			B = plane4Circle_1[1];
			C = plane4Circle_1[2];
			D = plane4Circle_1[3]; 
			
			let P_1 = P_2 = [x_c, y_c, z_c];
			P_intersection_1 = P_intersection_2 = P_1; 
			
		}else{	// center of circle outside the sphere 
			console.log("Top frustum plane not intersecting the sphere");
			P_intersection_1 = P_intersection_2 = null;
		}
//		points.push(new Point(P_intersection_1));
		points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
			"x": P_intersection_1[0],
			"y": P_intersection_1[1],
			"z": P_intersection_1[2]	
		}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		
//		points.push(new Point(P_intersection_2));
		points.push(new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
			"x": P_intersection_2[0],
			"y": P_intersection_2[1],
			"z": P_intersection_2[2]	
		}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CARTESIAN));
		
		return points;
	}
	
	
	static getAstroFoVPolygon(points){
		var poly = "";
		var i = 0;
		var point;
		for (i = 0; i < points.length; i++){
			point = points[i];
			poly += point.toADQL();
			if (i < points.length - 1){
				poly += ",";
			}
		}
		return poly;
	}
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FoVUtils);







/***/ }),

/***/ "./src/js/utils/GeomUtils.js":
/*!***********************************!*\
  !*** ./src/js/utils/GeomUtils.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point.js */ "./src/js/utils/Point.js");
/* harmony import */ var _Point2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point2D.js */ "./src/js/utils/Point2D.js");
/* harmony import */ var _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/CoordsType.js */ "./src/js/utils/CoordsType.js");





/**
 * @author Fabrizio Giordano (Fab77)
 */
class GeomUtils{
	

	// orthodromic distance - great circle distance
	static orthodromicDistance(p1, p2) {

		// Math.sqrt( ((p1._raRad - p2._raRad)*Math.cos(p1._decRad) )**2 + (p1._decRad - p2._decRad)**2 );
		return Math.acos(Math.sin(p1._decRad) * Math.sin(p2._decRad) + Math.cos(p1._decRad) * Math.cos(p2._decRad) * Math.cos(p2._raRad - p1._raRad));

	}

	

	/**
	 * 
	 * @param {*} polygons 
	 * @returns {points: [[]], flag: int} where flag is
	 * 0 -> if all points are in the same emisphere and abs(Dec) > 10 -> uses spherical projection with z=0, x = sin(dec) cos (ra); y = sin(dec) sin(ra)
	 * 1 -> if all points are in the equatorial belt (abs(dec)< 10) => normal BBox using x=RA, y=Dec directly
	 * 2 -> if all points are in the equatorial belt (abs(dec)< 10) and poly is crossing RA 0 => subtract 360 to every RA > 180
	 */
	 static computeSelectionObject(polygons) {
		let poly4selection = [];
		let flag = 0;
		let maxx = undefined;
		let maxy = undefined;
		let minx = undefined;
		let miny = undefined;


		const DEC_THRESHOLD = 10;
		let emisphere = 0;  // 1 means northen emisphere with Dec > 10 deg, -1 southern emisphere with Dec < -10 deg
		// let emishpere = (polygons[0][0].decDeg() >= DEC_THRESHOLD) ? 1 : -1; // 1 means northen emisphere, -1 southern emisphere
		if (polygons[0][0].decDeg >= DEC_THRESHOLD) {
			emisphere = 1;
		} else if (polygons[0][0].decDeg <= -1 * DEC_THRESHOLD) {
			emisphere = -1;
		} else {
			flag = 1;
		}
		if (flag == 0) {
			// let first = new Point2D(polygons[0][0].x, polygons[0][0].y);
			let first = GeomUtils.projectIn2D(polygons[0][0]);
			maxx = first.x;
			maxy = first.y;
			minx = first.x;
			miny = first.y;
			for (let currpoly of polygons) {
				let selpoly = [];
				for (let point of currpoly) {
					if ( (point.decDeg > emisphere * DEC_THRESHOLD && emisphere == -1) ||
						 (point.decDeg < emisphere * DEC_THRESHOLD && emisphere == 1) ) {
						flag = 1;
						poly4selection = [];
						break;
					}
					// let p = new Point2D(point.x, point.y);
					let p = GeomUtils.projectIn2D(point);
					selpoly.push(p);
					if (p.x > maxx) {
						maxx = p.x;
					}
					if (p.y > maxy) {
						maxy = p.y;
					}
					if (p.x < minx) {
						minx = p.x;
					}
					if (p.y < miny) {
						miny = p.y;
					}
					
				}
				poly4selection.push(selpoly);
			}
		}
		
		if (flag == 0) {
			return {
				'poly4selection': poly4selection,
				'flag': flag,
				'maxx': maxx,
				'maxy': maxy,
				'minx': minx,
				'miny': miny
			};
		}


		const RA_THRESHOLD = 180;
		let belowThreshold = (polygons[0][0].raDeg < RA_THRESHOLD); // 1 means northen emisphere, -1 southern emisphere;
		maxx = polygons[0][0].raDeg;
		maxy = polygons[0][0].decDeg;
		minx = polygons[0][0].raDeg;
		miny = polygons[0][0].decDeg;
		for (let currpoly of polygons) {
			let selpoly = [];
			for (let point of  currpoly) {
				let p = new _Point2D_js__WEBPACK_IMPORTED_MODULE_1__["default"](point.raDeg, point.decDeg);
				selpoly.push(p);
				if (point.raDeg > maxx) {
					maxx = point.raDeg;
				}
				if (point.decDeg > maxy) {
					maxy = point.decDeg;
				}
				if (point.raDeg < minx) {
					minx = point.raDeg;
				}
				if (point.decDeg < miny) {
					miny = point.decDeg;
				}

				if ( (point.raDeg >= RA_THRESHOLD && belowThreshold) ||
					(point.raDeg <= RA_THRESHOLD && !belowThreshold) ) {
					flag = 2;
					poly4selection = [];
					break;
				}
			}
			poly4selection.push(selpoly);
		}

		if (flag == 1) {
			return {
				'poly4selection': poly4selection,
				'flag': flag,
				'maxx': maxx,
				'maxy': maxy,
				'minx': minx,
				'miny': miny
			};
		}

		maxx = polygons[0][0].raDeg;
		if (polygons[0][0].raDeg >= RA_THRESHOLD) {
			maxx = polygons[0][0].raDeg - 360;
		}
		maxy = polygons[0][0].decDeg;
		minx = maxx;
		miny = maxy;
		for (let currpoly of polygons) {
			let selpoly = [];
			for (let point of currpoly) {
				let curra = (point.raDeg >= RA_THRESHOLD ? (point.raDeg - 360) : point.raDeg);
				if (curra > maxx) {
					maxx = curra;
				}
				if (point.decDeg > maxy) {
					maxy = point.decDeg;
				}

				if (curra < minx) {
					minx = curra;
				}
				if (point.decDeg < miny) {
					miny = point.decDeg;
				}

				// if (point.raDeg >= RA_THRESHOLD){
				let p = new _Point2D_js__WEBPACK_IMPORTED_MODULE_1__["default"](curra, point.decDeg);
				selpoly.push(p);
				// }
			}
			poly4selection.push(selpoly);
		}

		return {
			'poly4selection': poly4selection,
			'flag': flag,
			'maxx': maxx,
			'maxy': maxy,
			'minx': minx,
			'miny': miny
		};
	}



	static stereographic (point) {
		return { 
			'x': 2* parseFloat(point.x)/(1-parseFloat(point.z)), 
			'y': 2* parseFloat(point.y)/(1-parseFloat(point.z))
		};
	}

	static projectIn2D(point) {
		return GeomUtils.stereographic(point);
		//return GeomUtils.mercator(point);
		// return point;
	}

	static checkPointInsidePolygon5(selectionObj, point) {

		let intersections = 0;
		let flag = selectionObj.flag;
		let p0 = undefined;
		let p1 = undefined;

		if (flag == 0) {
			// p0 = new Point2D(point.x, point.y);
			p0 = GeomUtils.projectIn2D(point);
		} else if (flag == 1) {
			p0 = new _Point2D_js__WEBPACK_IMPORTED_MODULE_1__["default"](point.raDeg, point.decDeg);
		} else if (flag == 2) {
			const RA_THRESHOLD = 180; // TODO move it as a statci constant since it's been used in other methods
			if (point.raDeg >= RA_THRESHOLD) {
				p0 = new _Point2D_js__WEBPACK_IMPORTED_MODULE_1__["default"](point.raDeg - 360, point.decDeg);
			} else {
				p0 = new _Point2D_js__WEBPACK_IMPORTED_MODULE_1__["default"](point.raDeg, point.decDeg);
			}
			
		}
		p1 = new _Point2D_js__WEBPACK_IMPORTED_MODULE_1__["default"](p0.x, p0.y + 2* Math.abs(selectionObj.maxy - selectionObj.miny));

		if (p0.x > selectionObj.maxx || p0.x < selectionObj.minx ||
			p0.y > selectionObj.maxy || p0.y < selectionObj.miny) {
				return false;
			}

		let polygons = selectionObj.poly4selection;
		// iterating over all subpolygons
		for (let i = 0; i < polygons.length; i++){
			let currpoly = polygons[i];
			
			
			intersections = 0;
			let p2, p3;

			// computing intersection between each segment of the current subpolygon (p) and the rect m01, q01
			for (let p = 0; p < currpoly.length-1; p++) {
			
				p2 = currpoly[p];
				p3 = currpoly[p+1];

				let denominator = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y) ;
				let numerator01 = (p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x);
				let numerator23 = (p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x);

				if ( denominator != 0) {

					let lamda01 = numerator01 / denominator;
					let lambda23 = numerator23 / denominator;
					if (lamda01 >= 0 && lamda01 <= 1 &&
						lambda23 >= 0 && lambda23 <= 1) {
							intersections++;
					}	
				}	
			}
			// computing intersection against last point and first point of the currpoly
			p2 = currpoly[currpoly.length-1];
			p3 = currpoly[0]
			let denominator = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y) ;
			let numerator01 = (p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x);
			let numerator23 = (p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x);

			if ( denominator != 0) {

				let lamda01 = numerator01 / denominator;
				let lambda23 = numerator23 / denominator;
				if (lamda01 >= 0 && lamda01 <= 1 &&
					lambda23 >= 0 && lambda23 <= 1) {

						intersections++;
					}

				
			} 
			// odd intersections means point inside, even => point outside
			if ( (intersections % 2) == 1 ) {
				return true;
			}
		}
		return false;
	}

	static checkPointInsidePolygon4(polygons, point) {

		let intersections;
		// mouse position projected into 2D XY plane
		let p0 = GeomUtils.projectIn2D(point);
		let lambda_p, lambda_s;

		// // second arbitrary point used to construct the rect
		// let p1 = { 
		// 	'x': p0.x + Math.PI/2,
		// 	'y': p0.y
		// };

		// TODO 
		/**
		 * [flag to indicate the projection strategy to be use fo footprint selection. 
		 * Each polygon has is own flag computed at init time (in the constructor)]
		 * 1. compute correct flag to be used in each Footprint (constructor)  <- move this into the Footprint constructor 
		 * 		
		 * 		a. flag 0:if all points are in the same emisphere and abs(Dec) > 10 -> x = sin(dec) cos (ra); y = sin(dec) sin(ra)
		 * 		b. flag 1: normal BBox using x=RA, y=Dec directly
		 * 		c. flag 2: subtract 360 to every RA > 180 (case when poly is crossing RA 0)
		 * 		
		 * 2. when cursor moves, update mouse(x, y) for each 0,1,2 projections
		 * 3. foreach poly: 
		 * 	3.1 select correct mouse x,y
		 * 	3.2 check if mouse is inside BBox(poly)
		 * 	3.3 compute p1 = p0 + (max x and y of polygon)
		 * 	3.4 count intersections 
		 * 
		 */

		let maxdist = point._raDeg + 15;
		if (maxdist > 360) {
			maxdist = point._raDeg - 15;;
		}

		let p1point = new _Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
			"raDeg": maxdist,
			"decDeg": point._decDeg
		}, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ASTRO);
		let p1 = GeomUtils.projectIn2D(p1point);

		
		// iterating over all subpolygons
		for (let i = 0; i < polygons.length; i++){
			let currpoly = polygons[i];
			
			
			intersections = 0;
			let p2, p3;
			// compute BBox
			// computing intersection between each segment of the current subpolygon (p) and the rect m01, q01
			for (let p = 0; p < currpoly.length-1; p++) {
			
				p2 = GeomUtils.projectIn2D(currpoly[p]);
				p3 = GeomUtils.projectIn2D(currpoly[p+1]);

				let denominator = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y) ;
				let numerator01 = (p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x);
				let numerator23 = (p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x);

				if ( denominator != 0) {

					let lamda01 = numerator01 / denominator;
					let lambda23 = numerator23 / denominator;
					if (lamda01 >= 0 && lamda01 <= 1 &&
						lambda23 >= 0 && lambda23 <= 1) {
							intersections++;
						}

					
				} 
				// else if (denominator == 0 && numerator01 == 0 && numerator23 == 0) { // coincident
				// 	intersections++;
				// }
					
			}
			p2 = GeomUtils.projectIn2D(currpoly[currpoly.length-1])
			p3 = GeomUtils.projectIn2D(currpoly[0])
			let denominator = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y) ;
			let numerator01 = (p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x);
			let numerator23 = (p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x);

			if ( denominator != 0) {

				let lamda01 = numerator01 / denominator;
				let lambda23 = numerator23 / denominator;
				if (lamda01 >= 0 && lamda01 <= 1 &&
					lambda23 >= 0 && lambda23 <= 1) {

						intersections++;
					}

				
			} 
			// else if (denominator == 0 && numerator01 == 0 && numerator23 == 0) { // coincident
			// 	// not sure ... need to check if p0 lies between p2-p3
			// 	intersections++;
			// }

			// odd intersections means point inside, even => point outside
			if ( (intersections % 2) == 1 ) {
				return true;
			}
			
			
		
		}

		return false;

	}
	

	
	
  }

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeomUtils);

/***/ }),

/***/ "./src/js/utils/MouseHelper.js":
/*!*************************************!*\
  !*** ./src/js/utils/MouseHelper.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var healpixjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! healpixjs */ "./node_modules/healpixjs/lib-esm/index.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils.js */ "./src/js/utils/Utils.js");

/**
 * @author Fabrizio Giordano (Fab)
 */






class MouseHelper {
	
	xyz;
	raDec;
	phiTheta;
	
	/**
	 * @param xyz array [x, y, z] 
	 * @param raDecDeg [ra, dec] in degrees in equatorial J2000 
	 * @param phiThetaDeg [phi, theta] in degrees spherical coords
	 */
	constructor(in_xyz, in_raDecDeg, in_phiThetaDeg) {
		if (in_xyz != null && in_xyz !== undefined){
			this.xyz = in_xyz;
		}
		
		if (in_raDecDeg != null && in_raDecDeg !== undefined){
			this.raDec = in_raDecDeg;
		}
		
		if (in_phiThetaDeg != null && in_phiThetaDeg !== undefined){
			this.phiTheta = in_phiThetaDeg;
		}
	};
	
	
	// TODO wrong method name. No more fixed nside=256. nside is now defined into Global.js 
	computeNpix256() {
		
		if (this.xyz != null){
			// let healpix256 = new Healpix(global.nsideForSelection);
			let healpix256 = _Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].getHealpix(_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].nsideForSelection);
			let vec3 = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Vec3(this.x, this.y, this.z);
			let pointing = new healpixjs__WEBPACK_IMPORTED_MODULE_0__.Pointing(vec3);
			let res = healpix256.ang2pix(pointing);
//			console.log(res);
			return res;
		}
		return null;
		
	};

	update (mousePoint) {

		this.phiThetaDeg = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.cartesianToSpherical)(mousePoint);
		this.raDecDeg = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.sphericalToAstroDeg)(this.phiThetaDeg.phi, this.phiThetaDeg.theta);
		this.xyz = mousePoint;
		this.raHMS = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.raDegToHMS)(this.raDecDeg.ra);
		this.decDMS = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.decDegToDMS)(this.raDecDeg.dec);
		
	}
	
	clear(){
		
		this.xyz = null;
		this.raDec = null;
		this.phiTheta = null;
	};
	
	// /**
	//  * @param {any} in_xyz
	//  */
	// set xyz(in_xyz){
	// 	if (in_xyz != null && in_xyz !== undefined){
	// 		this.xyz = in_xyz;
	// 	}
	// };
	
	// /**
	//  * @param {any} in_raDecDeg
	//  */
	// set raDecDeg(in_raDecDeg){
	// 	if (in_raDecDeg != null && in_raDecDeg !== undefined){
	// 		this.raDec = in_raDecDeg;
	// 	}
		
	// };
	
	// /**
	//  * @param {any} in_phiThetaDeg
	//  */
	// set phiThetaDeg(in_phiThetaDeg){
	// 	if (in_phiThetaDeg != null && in_phiThetaDeg !== undefined){
	// 		this.phiTheta = in_phiThetaDeg;
	// 	}
		
	// };
	
	
	
	get xyz() {
		return this.xyz;
	};
	
	get x(){
		return this.xyz[0];
	};
	
	get y(){
		return this.xyz[1];
	};
	
	get z(){
		return this.xyz[2];
	};
	
	get ra(){
		return this.raDec[0];
	};
	
	get dec(){
		return this.raDec[1];
	};
	
	get phi(){
		return this.phiTheta[0];
	};
	
	get theta(){
		return this.phiTheta[1];
	};
	
	
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MouseHelper);

/***/ }),

/***/ "./src/js/utils/Point.js":
/*!*******************************!*\
  !*** ./src/js/utils/Point.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CoordsType.js */ "./src/js/utils/CoordsType.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */





class Point{
	
	_x;
	_y;
	_z;
	_xyz;
	_raDeg;
	_decDeg;
	_raRad;
	_decRad;
	_raDecDeg;
	
	/**
	 * @param in_options: 
	 * 		{x: <x>, y: <y>, z: <z>} in case of CoordsType.CARTESIAN
	 * 		{raDeg: <raDeg>, decDeg: <decDeg>} in case of CoordsType.ASTRO
	 * 		{phiDeg: <phiDeg>, thetaDeg: <thetaDeg>} in case of CoordsType.SPHERICAL
	 * @param in_type: CoordsType
	 */
	constructor(in_options, in_type){
		
		
		this._xyz = [];
		this._raDecDeg = [];
		// const MAX_DECIMALS = 12;
		
		if (in_type == _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CARTESIAN){
			
			this._x = parseFloat(in_options.x.toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS));
			this._y = parseFloat(in_options.y.toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS));
			this._z = parseFloat(in_options.z.toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS));
			this._xyz = [this._x, this._y, this._z];
			this._raDecDeg = this.computeAstroCoords();
			this._raDeg = parseFloat(this._raDecDeg[0]);
			this._decDeg = parseFloat(this._raDecDeg[1]);
			this._raRad = this._raDeg * Math.PI / 180;
			this._decRad = this._decDeg * Math.PI / 180;
			
		}else if (in_type == _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ASTRO){
			
			this._raDeg = parseFloat(in_options.raDeg);
			this._decDeg = parseFloat(in_options.decDeg);
			this._raDecDeg = [this._raDeg, this._decDeg];
			this._raRad = this._raDeg * Math.PI / 180;
			this._decRad = this._decDeg * Math.PI / 180;
			this._xyz = this.computeCartesianCoords();
			this._x = parseFloat(this._xyz[0].toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS));
			this._y = parseFloat(this._xyz[1].toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS));
			this._z = parseFloat(this._xyz[2].toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS));
			
		}else if (in_type == _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SPHERICAL){
			// TODO still not implemented
			console.log(_CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SPHERICAL+" not implemented yet");
		}else{
			console.err("CoordsType "+in_type+" not recognised.");
		}
	}

	computeAstroCoords(){

    	var phiThetaDeg = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.cartesianToSpherical)([this._xyz[0], this._xyz[1], this._xyz[2]]);
		var raDecDeg = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.sphericalToAstroDeg)(phiThetaDeg.phi, phiThetaDeg.theta);
		var raDecDeg = [raDecDeg.ra, raDecDeg.dec];
		return raDecDeg;
    }
	
	computeCartesianCoords(){
		var phiThetaDeg = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.astroDegToSpherical)(this._raDeg, this._decDeg);
		var xyz = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.sphericalToCartesian)(phiThetaDeg.phi, phiThetaDeg.theta, 1);
		return xyz;
	}
	
	/**
	 * @return {phi: phideg, theta: thetadeg} 
	 */
	computeHealpixPhiTheta(){
		return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.astroDegToSpherical)(this._raDeg, this._decDeg);
	}
	

	// taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified 
	/** Scale the vector by a given factor
    @param n the scale factor */
	scale(n){
		return new Point({x: this.x*n, y: this.y*n, z: this.z*n}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CARTESIAN)
	};
	// taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified 
	dot(v){ 
		return this.x*v.x + this.y*v.y + this.z*v.z; 
	};
	// taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified
	cross(v){ 
		return new Point({x: this.y*v.z - v.y*this.z, y: this.z*v.x - v.z*this.x, z: this.x*v.y - v.x*this.y}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CARTESIAN);
	};
	// taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified
	norm() {
		let d = 1./this.length();
		return new Point({x: this.x*d, y: this.y*d, z: this.z*d}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CARTESIAN);
	};
	// taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified
	length(){ 
		return Math.sqrt(this.lengthSquared()); 
	};
	// taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified
	lengthSquared(){ 
		return this.x*this.x + this.y*this.y + this.z*this.z; 
  	};

	subtract(v) {
		return new Point({x: this.x - v.x, y: this.y - v.y, z: this.z - v.z}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CARTESIAN);
	}

	add(v) {
		return new Point({x: this.x + v.x, y: this.y + v.y, z: this.z + v.z}, _CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CARTESIAN);
	}
	

	get x(){
		return this._x;
	}
	
	get y(){
		return this._y;
	}
	
	get z(){
		return this._z;
	}
	
	get xyz(){
        return this._xyz;
    }
	
    get raDeg(){
        return this._raDeg;
    }
    
    get decDeg(){
        return this._decDeg;
    }
    
    get raDecDeg(){
        return this._raDecDeg;
    }
    
    toADQL(){
    	return this._raDecDeg[0]+","+this._raDecDeg[1];
    }
    
    toString(){
    	return "(raDeg, decDeg) => ("+this._raDecDeg[0]+","+this._raDecDeg[1]+") (x, y,z) => ("+this._xyz[0]+","+this._xyz[1]+","+this._xyz[2]+")";
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Point);

/***/ }),

/***/ "./src/js/utils/Point2D.js":
/*!*********************************!*\
  !*** ./src/js/utils/Point2D.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


class Point2D{

    _x;
    _y;

    constructor (x, y) {
        this._x = x;
        this._y = y;
    }

    get x () {
        return this._x;
    }

    get y () {
        return this._y;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Point2D);

/***/ }),

/***/ "./src/js/utils/RayPickingUtils.js":
/*!*****************************************!*\
  !*** ./src/js/utils/RayPickingUtils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");

/**
 * @author Fabrizio Giordano (Fab)
 */




class RayPickingUtils{
	
	static lastNearestVisibleObjectIdx = -1;
	
	
	constructor(){}
	
	
	static getRayFromMouse (in_mouseX, in_mouseY, pMatrix) {
		
		let vMatrix = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].camera.getCameraMatrix();
		var gl = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl;
		var pMatrix = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].pMatrix; // TODO try to remove global.pMatrix
		
		var rect = gl.canvas.getBoundingClientRect();
		
		var canvasMX = in_mouseX - rect.left;
		var canvasMY = in_mouseY - rect.top;
		
		// viewport space -> normalized device space
		var x = 2.0 * canvasMX  / gl.canvas.clientWidth - 1.0;
		var y = 1.0 - 2.0 * canvasMY / gl.canvas.clientHeight;
		var z = -1.0;

		// normalized device space
		var rayNds = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.clone([x, y, z]);
		
		// normalized device space -> homogeneous clip space
		var rayClip = [rayNds[0], rayNds[1], rayNds[2], 1.0];
		
		// homogeneous clip space -> eye space
		var pMatrixInverse = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_2__.invert(pMatrixInverse, pMatrix);

		var rayEye = [];
		RayPickingUtils.mat4MultiplyVec4(pMatrixInverse, rayClip, rayEye);
		// direction
		rayEye = [rayEye[0], rayEye[1], -1.0, 0.0];
		
		// eye space -> world space
		var rayWorld = [];
		var vMatrixInverse = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_2__.invert(vMatrixInverse, vMatrix);
		RayPickingUtils.mat4MultiplyVec4(vMatrixInverse, rayEye, rayWorld);
				
		gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(rayWorld, rayWorld);
		
		return rayWorld;
		
	}
	
	static mat4MultiplyVec4 = function(a, b, c) {
		c || (c = b);
		var d = b[0],
			e = b[1],
			g = b[2];
		b = b[3];
		c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;
		c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;
		c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;
		c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;
		return c
	};
	
	/*
	 * antongerdelan.net/opengl/raycasting.html
	 */
	static raySphere (rayOrigWorld, rayDirectionWorld, in_model){
//		static raySphere (rayOrigWorld, rayDirectionWorld, model){
		
//		console.log(rayOrigWorld);
		
		var intersectionDistance = -1;
		var distToMoldel = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
		gl_matrix__WEBPACK_IMPORTED_MODULE_1__.subtract(distToMoldel, rayOrigWorld, in_model.center);
		
		var b = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.dot(rayDirectionWorld, distToMoldel);
		
		var c = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.dot(distToMoldel, distToMoldel) - in_model.radius * in_model.radius;
		
		var bSquaredMinus_c = b * b - c;
		
		if (bSquaredMinus_c > 0.0){

			var t_a = -b + Math.sqrt(bSquaredMinus_c);
			var t_b = -b - Math.sqrt(bSquaredMinus_c);

			if (t_a < 0.0){
				if (t_b < 0.0){
					console.log("[RayPickingUtils::raySphere] intersection behind your shoulder");
				}
			}else if (t_b < 0.0){
				intersectionDistance = t_a;
			}else{
				intersectionDistance = ( t_a < t_b ? t_a : t_b);
			}
		}else if (bSquaredMinus_c == 0.0){
			console.log("TAKEN (tangent)!!!");
			var t = -b + Math.sqrt(bSquaredMinus_c);
			if (t < 0.0){
				console.log("[RayPickingUtils::raySphere] intersection behind your shoulder");
			}else{
				intersectionDistance = t;
			}
		}
		return intersectionDistance;
	}
	
	static getNearestVisibleObjectIdx(){
		
		return 	this.lastNearestVisibleObjectIdx;
		
	}
	
	
	
	
	
	// TODO pass only matrices
	/**
	 * 
	 * if intersection:
	 * 	returns vec3 as intersectionPoint,
	 * else
	 * 	 returns undefned as intersectionPoint,
	 */
	static getIntersectionPointWithSingleModel(in_mouseX, in_mouseY, in_modelObj = null){
		
		var camera = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].camera;
		
		if (in_modelObj == null){
			in_modelObj = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].defaultHips;
		}
		
		// TODO it has been already computed in getIntersectionPointWithModel
		var rayWorld = RayPickingUtils.getRayFromMouse(in_mouseX, in_mouseY);
		
		var intersectionDistance = RayPickingUtils.raySphere(camera.getCameraPosition(), rayWorld, in_modelObj);
		
		var intersectionPoint = [],
		intersectionModelPoint = [];
		var intersectionPoint4d;
		
		if (intersectionDistance >= 0){
			
			intersectionPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();
			gl_matrix__WEBPACK_IMPORTED_MODULE_1__.scale(intersectionPoint, rayWorld, intersectionDistance);
			gl_matrix__WEBPACK_IMPORTED_MODULE_1__.add(intersectionPoint, camera.getCameraPosition(), intersectionPoint);

			intersectionPoint4d = [intersectionPoint[0], intersectionPoint[1], intersectionPoint[2], 1.0];
			RayPickingUtils.mat4MultiplyVec4(in_modelObj.getModelMatrixInverse(), intersectionPoint4d, intersectionModelPoint);
			
			
		}
		
		return {
			"intersectionPoint": intersectionModelPoint,
			"pickedObject": in_modelObj
		};
		
	}


	
	
	static getIntersectionPointWithModel(in_mouseX, in_mouseY, models){

		
		var nearestObj = RayPickingUtils.getNearestObjectOnRay(in_mouseX, in_mouseY, models);
		
		var intersectionModelPoint = [];
		var pickedObject;

		if (nearestObj.distance >= 0){
			
			var pickedObject = models[nearestObj.idx];
			
			
			intersectionModelPoint = RayPickingUtils.getIntersectionPointWithSingleModel(in_mouseX, in_mouseY, pickedObject);
			
		}
		
		return {
			"intersectionPoint": intersectionModelPoint,
			"pickedObject": pickedObject
		};
		
	}
	
	
	static getNearestObjectOnRay (in_mouseX, in_mouseY, models){
		
		var camera = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].camera;
		
		document.getElementsByTagName("body")[0].style.cursor = "auto";
		
		var intersectionDistance = -1;
		var nearestVisibleObjectIdx = -1;
		var currModel;
		var nearestVisibleIntersectionDistance = undefined;
		
		var rayWorld = RayPickingUtils.getRayFromMouse(in_mouseX, in_mouseY);

		for (var i = 0; i < models.length; i++){

			currModel = models[i];
				
			intersectionDistance = RayPickingUtils.raySphere(camera.getCameraPosition(), rayWorld, currModel);

			if (intersectionDistance >= 0){
				if (nearestVisibleIntersectionDistance === undefined || intersectionDistance < nearestVisibleIntersectionDistance){
					nearestVisibleIntersectionDistance = intersectionDistance;
					nearestVisibleObjectIdx = i;
				}
			}
		}
		if (nearestVisibleIntersectionDistance >= 0){
			if (_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].debug){
				console.log("[RayPickingUtils]::getNearestObjectOnRay nearest object name "+currModel.name);
				
			}
		}
		this.lastNearestVisibleObjectIdx = nearestVisibleObjectIdx;
		
		return {
			"idx": nearestVisibleObjectIdx,
			"distance": nearestVisibleIntersectionDistance
		};
	}
	
	
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RayPickingUtils);




/***/ }),

/***/ "./src/js/utils/STCSParser.js":
/*!************************************!*\
  !*** ./src/js/utils/STCSParser.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Point.js */ "./src/js/utils/Point.js");
/* harmony import */ var _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/CoordsType.js */ "./src/js/utils/CoordsType.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");

/**
 * @author Fabrizio Giordano (Fab77)
 */
 
 
 

class STCSParser {

    static parseSTCS(stcs) {

        let stcsParsed = STCSParser.cleanStcs(stcs);
        let totPoints = 0;
        let polygons = [];

        if (stcsParsed.includes("POLYGON")){
        
            return STCSParser.parsePolygon(stcsParsed);
  

        } else if (stcsParsed.includes("CIRCLE")){
            return STCSParser.parseCircle(stcsParsed);
        } else {
            console.warn("STCS not recognised");
        }
        return {
            "totpoints": totPoints,
            "polygons": polygons    
        }
    }

    static cleanStcs(stcs) {
        let stcs2upper = stcs.toUpperCase();
        let stcsParsed = stcs2upper.replaceAll("'ICRS'", "")
			.replaceAll("ICRS", "")
			.replaceAll("J2000", "")
			.replaceAll("UNION", "")
			.replaceAll("UNION", "")
			.replaceAll("TOPOCENTER", "")
			.replaceAll("\(", "")
			.replaceAll("\)", "")
			.trim().replace(/  +/g, ' ').toUpperCase();
        return stcsParsed;
    }

    static parsePolygon (stcs) {
        let totPoints = 0;
        let polygons = [];

        // const MAX_DECIMALS=8;
        let polys = stcs.split("POLYGON ");
            
            
        for (let i = 1; i < polys.length; i++){
            let currPoly = [];
            let points = polys[i].trim().split(" ");
            
            
            // case when in the stc_s the first point is repeated at the end. Removes the repeated point at the end 
            if (parseFloat(points[0]).toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS) == parseFloat(points[points.length - 2]).toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS) && 
            parseFloat(points[1]).toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS) == parseFloat(points[points.length - 1]).toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS)){
                points.splice(points.length - 2 ,2);
            }
            
            
            if (points.length > 2){
                for (let p = 0; p < points.length - 1; p = p+2){
                    let point = new _utils_Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
                        "raDeg": parseFloat(points[p]).toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS),
                        "decDeg": parseFloat(points[p+1]).toFixed(_Global_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_DECIMALS)
                    }, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ASTRO);
                    currPoly.push(point);
                    totPoints+=1;
                }
                polygons.push(currPoly);
            }
            
        }

        return {
            "totpoints": totPoints,
            "polygons": polygons    
        }
    }

    // CIRCLE ICRS 8.739685 4.38147 0.027833
    static parseCircle(stcs) {

        let totPoints = 0;
        let polygons = [];

        let polys = stcs.split("CIRCLE ");

        for (let i = 1; i < polys.length; i++){
            let currPoly = [];
            let tokens = polys[i].trim().split(" ");
            let ra = tokens[0] * 1.0;
            let dec = tokens[1] * 1.0;
            let radius = tokens[2] * 1.0;
            const POINTSxQUADRANT = 6;
            let delta = radius / POINTSxQUADRANT;
            let npoints = POINTSxQUADRANT *  4;
            let minra = ra - radius;
            let maxra = ra + radius;
            let mindec = dec - radius;
            let maxdec = dec + radius;

            let curra = minra;
            let curdec = dec;
            let alpha = 2*Math.PI / npoints;
            for (let p = npoints; p > 0; p--) {
            // for (let p = 0; p < npoints; p++) {

                curra = radius * Math.cos(p * alpha) + ra;
                curdec = radius * Math.sin(p * alpha) + dec;

                let point = new _utils_Point_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
                    "raDeg": curra,
                    "decDeg": curdec
                }, _utils_CoordsType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ASTRO);
                currPoly.push(point);
                totPoints+=1;
                
            }
            polygons.push(currPoly);
        }

        return {
            "totpoints": totPoints,
            "polygons": polygons    
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (STCSParser);

/***/ }),

/***/ "./src/js/utils/Session.js":
/*!*********************************!*\
  !*** ./src/js/utils/Session.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   session: () => (/* binding */ session)
/* harmony export */ });
/* harmony import */ var _events_EventBus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventBus.js */ "./src/js/events/EventBus.js");
/* harmony import */ var _events_HiPSSelectedEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/HiPSSelectedEvent.js */ "./src/js/events/HiPSSelectedEvent.js");
/* harmony import */ var _modules_controlpanel_cataloguepanel_model_Catalogue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/controlpanel/cataloguepanel/model/Catalogue.js */ "./src/js/modules/controlpanel/cataloguepanel/model/Catalogue.js");
/* harmony import */ var _modules_controlpanel_cataloguepanel_model_Source_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/controlpanel/cataloguepanel/model/Source.js */ "./src/js/modules/controlpanel/cataloguepanel/model/Source.js");







class Session {

    _tapRepoList;
    _activeFootprintsCatalogues;
    _activeSourceCatalogues;
    _activeHiPS;
    _hoveredFootprints;
    _hoveredSources;

    constructor() {

        this._tapRepoList = [];
        this._activeSourceCatalogues = [];
        this._activeFootprintsCatalogues = [];
        this._activeHiPS = [];
        this._hoveredFootprints = new Map();
        this._hoveredSources = new Map();

    }

    get tapRepoList() {
        return this._tapRepoList;
    }

    /**
     * 
     * @param {Catalogue} catalogue 
     * @param {Source} sources 
     */
    updateHoveredSources(catalogue, sources) {
        this._hoveredSources.set(catalogue, sources)
    }

    get hoveredSources() {
        return this._hoveredSources
    }

    clearHoveredSources() {
        this._hoveredSources = new Map();
    }

    /**
     * @param {Footprint[]} footprints
     * @param {FootprintSet} footprintSetName
     */
    updateHoveredFootprints(footprintSet, footprints) {

        this._hoveredFootprints.set(footprintSet, footprints);
    }

    get hoveredFootprints() {
        return this._hoveredFootprints
    }

    clearHoveredFootprints() {
        this._hoveredFootprints = new Map();
    }

    addTapRepo(tapRepo) {
        this._tapRepoList.push(tapRepo);
    }

    clearTapRepoList() {
        this._tapRepoList = [];
    }

    activateCatalogue(catalogue) {
        this._activeSourceCatalogues.push(catalogue);
    }

    deactivateCatalogue(catalogue) {
        for (let i = 0; i < this._activeSourceCatalogues.length; i++) {
            if (this._activeSourceCatalogues[i] == catalogue) {
                this._activeSourceCatalogues[i].clearSources();
                this._activeSourceCatalogues.splice(i, 1);
                break;
            }
        }
    }

    activateFootprintSet(fset) {
        this._activeFootprintsCatalogues.push(fset);
    }

    deactivateFootprintSet(fset) {
        for (let i = 0; i < this._activeFootprintsCatalogues.length; i++) {
            if (this._activeFootprintsCatalogues[i] == fset) {
                this._activeFootprintsCatalogues[i].clearFootprints();
                this._activeFootprintsCatalogues.splice(i, 1);
                break;
            }
        }
    }


    activateHiPS(hips) {
        this._activeHiPS.push(hips);
        _events_EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].fireEvent(new _events_HiPSSelectedEvent_js__WEBPACK_IMPORTED_MODULE_1__["default"](hips));
    }

    deactivateHiPS(hips) {
        for (let i = 0; i < this._activeHiPS.length; i++) {
            if (this._activeHiPS[i] == hips) {
                this._activeHiPS.splice(i, 1);
                break;
            }
        }
    }

    get activeFSets() {
        return this._activeFootprintsCatalogues;
    }

    get activeCatSets() {
        return this._activeSourceCatalogues;
    }

    get activeHiPS() {
        return this._activeHiPS;
    }
}

const session = new Session();

/***/ }),

/***/ "./src/js/utils/ShaderUtility.js":
/*!***************************************!*\
  !*** ./src/js/utils/ShaderUtility.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shaderUtility: () => (/* binding */ shaderUtility)
/* harmony export */ });
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");
/* harmony import */ var _shaders_ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shaders/ShaderManager.js */ "./src/js/shaders/ShaderManager.js");




class ShaderUtility {

  useProgram(program) {
    if (this.lastUsedProgram != program) {
      _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.useProgram(program);
      this.lastUsedProgram = program;
    }
  }

  createHiPSFSShaderProgram() {
    const fragmentShaderStr = _shaders_ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].hipsNativeFS();
    let fragmentShader = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.FRAGMENT_SHADER);
    _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.shaderSource(fragmentShader, fragmentShaderStr);
    _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.compileShader(fragmentShader);
    if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderParameter(fragmentShader, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.COMPILE_STATUS)) {
      alert(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderInfoLog(fragmentShader));
      return null;
    }
    return fragmentShader;
  }

  createHiPSVSShaderProgram() {
    const vertexShaderStr = _shaders_ShaderManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].hipsVS();
    let vertexShader = _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.createShader(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.VERTEX_SHADER);
    _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.shaderSource(vertexShader, vertexShaderStr);
    _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.compileShader(vertexShader);
    if (!_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderParameter(vertexShader, _Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.COMPILE_STATUS)) {
      alert(_Global_js__WEBPACK_IMPORTED_MODULE_0__["default"].gl.getShaderInfoLog(vertexShader));
      return null;
    }
    return vertexShader;
  }


  enableHiPSShader() {

  }

  enableFootprintShader() {

  }

  enableCatalgueShader() {

  }

  enebaleHEALPixShader() {

  }

  enableRADecShader() {

  }

}

const shaderUtility = new ShaderUtility();




/***/ }),

/***/ "./src/js/utils/Utils.js":
/*!*******************************!*\
  !*** ./src/js/utils/Utils.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   astroDegToSpherical: () => (/* binding */ astroDegToSpherical),
/* harmony export */   cartesianToSpherical: () => (/* binding */ cartesianToSpherical),
/* harmony export */   colorHex2RGB: () => (/* binding */ colorHex2RGB),
/* harmony export */   decDegToDMS: () => (/* binding */ decDegToDMS),
/* harmony export */   degToRad: () => (/* binding */ degToRad),
/* harmony export */   raDegToHMS: () => (/* binding */ raDegToHMS),
/* harmony export */   radToDeg: () => (/* binding */ radToDeg),
/* harmony export */   sphericalToAstroDeg: () => (/* binding */ sphericalToAstroDeg),
/* harmony export */   sphericalToCartesian: () => (/* binding */ sphericalToCartesian)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/vec3.js");
/**
 * @author Fabrizio Giordano (Fab)
 */


function Utils(){
	
}

function cartesianToSpherical(xyz){
	var dotXYZ = gl_matrix__WEBPACK_IMPORTED_MODULE_0__.dot(xyz, xyz);
	var r = Math.sqrt(dotXYZ);	
	var theta = Math.acos(xyz[2]/r);
	theta = radToDeg(theta);
	// NB: in atan(y/x) is written with params switched atan2(x, y)
	var phi = Math.atan2(xyz[1],xyz[0]);
	phi = radToDeg(phi);

	if (phi < 0){
		phi += 360;
	}
	return {
		phi: phi, 
		theta: theta
	};
};

function colorHex2RGB(hexColor){

//	console.log(hexColor);
	var hex1 = hexColor.substring(1,3);
	var hex2 = hexColor.substring(3,5);
	var hex3 = hexColor.substring(5,7);
	
	var dec1 = parseInt(hex1, 16);
	var dec2 = parseInt(hex2, 16);
	var dec3 = parseInt(hex3, 16);
	
	var rgb1 = (dec1 / 255).toFixed(2);
	var rgb2 = (dec2 / 255).toFixed(2);
	var rgb3 = (dec3 / 255).toFixed(2);
	
	return [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];

}

function degToRad(degrees) {
	return (degrees / 180 ) * Math.PI ;
}

function radToDeg(radians) {
	return radians * 180 / Math.PI;
}

function sphericalToAstroDeg(phiDeg, thetaDeg){
	var raDeg, decDeg;

	raDeg = phiDeg;
	if (raDeg < 0){
		raDeg += 360;
	}
	
//	decDeg = 90 - thetaDeg;
	decDeg = 90 - thetaDeg;
	
	return {
		ra: raDeg,
		dec: decDeg
	};
}

function sphericalToCartesian(phiDeg, thetaDeg, r){
	r = (r == undefined) ? 1 : r;
	var x = r * Math.sin(degToRad(thetaDeg)) * Math.cos(degToRad(phiDeg));
	var y = r * Math.sin(degToRad(thetaDeg)) * Math.sin(degToRad(phiDeg));
	var z = r * Math.cos(degToRad(thetaDeg));

	
//	var z = r * Math.cos(degToRad(thetaDeg)).toFixed(4);
	return [x, y, z];
};


function astroDegToSpherical(raDeg, decDeg){
	
	let phiDeg, thetaDeg;
//	phiDeg = 90 - raDeg;
	phiDeg = raDeg;
	if (phiDeg < 0){
		phiDeg += 360;
	}
	
	thetaDeg = 90 - decDeg;
	
	return {
		phi: phiDeg,
		theta: thetaDeg
	};
}

function raDegToHMS(raDeg){
	
	var h = Math.floor(raDeg/15);
	var m = Math.floor((raDeg/15 - h) * 60);
	var s = (raDeg/15 - h - m/60) * 3600;
	
	return {
		h: h, 
		m: m, 
		s: s
	};
}

function decDegToDMS(decDeg){
	var sign = 1;
	if (decDeg < 0){
		sign = -1;
	}
	
	var decDeg_abs = Math.abs(decDeg);
	var d = Math.trunc(decDeg_abs);
	
	var m = Math.trunc( (decDeg_abs - d) * 60);
	
	var s = (decDeg_abs - d - m/60) * 3600;
	d = d * sign;
	
	return {
		d: d, 
		m: m, 
		s: s
	};
}

function dms2DecDeg(decDMS){
	var sign = Math.sign(decDMS.d);
	var deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);
	return deg;
}

function hms2RaDeg(raHMS){
//	console.log(JSON.stringify(raHMS));
	var sign = Math.sign(raHMS.h);
	var deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;
//	console.log(deg);
	return deg;
}

function worldToModel(xy, radius){
	var x = xy[0];
	var y = xy[1];
	var z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);
	
	return [x, y, z];
}



/***/ }),

/***/ "./src/js/view/CoordinatesPanelView.js":
/*!*********************************************!*\
  !*** ./src/js/view/CoordinatesPanelView.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");



class CoordinatesPanelView{
 
	_html;
	_model;
	_showSphericalCoords;
	
    constructor(){
    	
        this.init();
        
        let _public = {
    
            getHtml: ()=>{
                return this._html;
            },
            setModel: (in_raDecDeg, in_raHMS, in_decDMS, phi, theta)=>{

            	jquery__WEBPACK_IMPORTED_MODULE_0__('#raDecDeg').html(in_raDecDeg.ra.toFixed(4)+' '+in_raDecDeg.dec.toFixed(4));
            	
            	let sign = '+';
        		if (in_decDMS.d < 0){
        			sign = '';
        		}
            	jquery__WEBPACK_IMPORTED_MODULE_0__('#raDecHms').html(in_raHMS.h +" "+in_raHMS.m +" "+in_raHMS.s.toFixed(2)+ " "+sign+in_decDMS.d+" "+in_decDMS.m+" "+in_decDMS.s.toFixed(2));
            	
            	if(this._showSphericalCoords){
            		jquery__WEBPACK_IMPORTED_MODULE_0__('#phiThetaDeg').html(phi.toFixed(4) +" "+theta.toFixed(4));
            	}
            },
            showSphericalCoords: (show) => {
            	this._showSphericalCoords = show;
            	if (!this._showSphericalCoords){
            		jquery__WEBPACK_IMPORTED_MODULE_0__('#phiTheta').css("display", "none");
            	}else{
            		jquery__WEBPACK_IMPORTED_MODULE_0__('#phiTheta').css("display", "block");
            	}
            } 
        }
        return _public;
    }
 
    
    
    init(){
    	this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div id='coordsContainer'>" +
    			"<div>RA/Dec (degrees) <span id='raDecDeg'></span></div>" +
    			"<div>RA/Dec (hms/dms) <span id='raDecHms'></span></div>" +
    			"<div id='phiTheta'>Phi/Theta (degs) <span id='phiThetaDeg'></span></div>" +
    			"</div>");
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoordinatesPanelView);

/***/ }),

/***/ "./src/js/view/FoVView.js":
/*!********************************!*\
  !*** ./src/js/view/FoVView.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");



class FoVView{
 
	_html;
	_model;
	
    constructor(){
    	
        this.init();
        
        let _public = {
    
            getHtml: ()=>{
                return this._html;
            },
            setModel: (in_fovObj)=>{
            	
//            	this.fovvalue_dom.innerHTML = in_fovObj.fovXDeg.toFixed(4) + '&deg;x'+ in_fovObj.fovYDeg.toFixed(4) + '&deg;';
                jquery__WEBPACK_IMPORTED_MODULE_0__('#fovValue').html(in_fovObj.fovXDeg.toFixed(4) + '&deg;x'+ in_fovObj.fovYDeg.toFixed(4) + '&deg;');
            }
        }
        return _public;
    }
 
    init(){
    	this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div id='fovContainer'><label>FoV</label><span id='fovValue'></span></div>");
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FoVView);

/***/ }),

/***/ "./src/js/view/SettingsPanelView.js":
/*!******************************************!*\
  !*** ./src/js/view/SettingsPanelView.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Global.js */ "./src/js/Global.js");



class SettingsPanelView{

    _html;
    _visible;
    
    constructor(insideSphere){
        
        this.init(insideSphere);
    
        let _public = {
            getHtml: ()=>{
                return this._html;
            },

            getProxyUrl: () => {
                return jquery__WEBPACK_IMPORTED_MODULE_0__("#corsURL").val();
            },
            setModel : (model)=> {
                this._html.find("#fpsvalue").html(model.getFps());
                this._html.find("#avgfpsvalue").html(model.getAvgFps());
            },
            addFovPolyHandler : (handler) => {
                this._html.find("#getFovPoly").on("click", handler);
            },

            addUpdateCorsProxyHandler : (handler) => {
                this._html.find("#updateCorsProxy").on("click", handler);
            },

            addHealpixGridCheckboxHandler:(handler)=>{
                this._html.find("#healpix-grid-checkbox").on("click", handler);
            },
            addCoordsGridCheckboxHandler:(handler)=>{
                this._html.find("#coords-grid-checkbox").on("click", handler);
            },
            
            addInsideSphereCheckboxHandler: (handler)=>{
                this._html.find("#inside-sphere-checkbox").on("click", handler);
            },
            addCORSProxyCheckboxHandler: (handler)=>{
                this._html.find("#cors-proxy-checkbox").on("click", handler);
            },

            setSphericalCoordinates: (phiThetaDeg)=>{
                this._html.find("#phi").html(phiThetaDeg.phi.toFixed(4));
                this._html.find("#theta").html(phiThetaDeg.theta.toFixed(4));
            },
            toggle: ()=>{
                if (this._visible){
                    this._html.css("display","none");
                    this._visible = false;
                }else{
                    this._html.css("display","block");
                    this._visible = true;
                }
            },
            close: ()=>{
            	if (this._visible){
            		this._html.css("display","none");
            		this._visible = false;
            	}
            }
        }
        return _public;
    }		

    init(insideSphere){
        this._visible = false;
        let checked = "";
        if(insideSphere){
            checked = "checked";
        }
        let corsProxyChecked = "";
        if (_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].useCORSProxy){
            corsProxyChecked = "checked";
        }
        this._html = jquery__WEBPACK_IMPORTED_MODULE_0__("<div id='settingsPanel' class='controlPanel'>"
        + "<div id='fps'>"
        + "<div style='display: grid; grid-template-columns: 50%; text-align: center; margin-bottom: 15px'>" 
        + "	<div>FPS</div>"
        + "	<div style='grid-column:2'>Avg FPS</div>" 
        + "	<div style='grid-row:2 grid-column:1' id='fpsvalue'></div>"
        + "	<div style='grid-row:2; grid-column:2' id='avgfpsvalue'></div>" 
        + "</div>" 


        + "<div id='sphericalCoordName'><i>Spherical coords</i></div>"
        + "<div id='coords'>"
        + "<span id='phiName'>phi</span>"
        +"<span id='thetaName'>theta</span>"
        + "<span id='phi'></span><span id='theta'></span>"
        + "</div>"

        + "<div class='settingsRow dataRow'> <input type='checkbox' " + checked + "' id='inside-sphere-checkbox' style='vertical-align: middle;'></input>"
        + "<label for='inside-sphere-checkbox'>Inside Sphere</label>"
        + "</div>"
        + "<div class='settingsRow dataRow'> <input type='checkbox' id='healpix-grid-checkbox' style='vertical-align: middle;'></input>"
        + "<label for='healpix-grid-checkbox'>Healpix Grid</label>"
        + "</div>"
        + "<div class='settingsRow dataRow'> <input type='checkbox' id='coords-grid-checkbox' style='vertical-align: middle;'></input>"
        + "<label for='coords-grid-checkbox'>Coords Grid</label>"
        + "</div>"

        + "<div class=''> <input type='checkbox' id='cors-proxy-checkbox' style='vertical-align: middle;' "+corsProxyChecked+"></input>"
        + "<label for='cors-proxy-checkbox'>Enable CORS proxy</label>"
        + "<br>"
        + "<input type='text' id='corsURL' value='"+_Global_js__WEBPACK_IMPORTED_MODULE_1__["default"].corsProxyUrl+"'/>"
        + "<div id='updateCorsProxy' class='button' >change</div>"
        // + "<label for='cors-proxy-checkbox'>Enable CORS proxy</label>"

        + "</div>"

        // + "<div id='getFovPoly' class='button' >Log FoV Polygon</div>"


        + "</div>");
        this._html.css("display","none");
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SettingsPanelView);

/***/ }),

/***/ "?5648":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?f615":
/*!*************************!*\
  !*** process (ignored) ***!
  \*************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "fabviewer:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"fabviewer": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkfabviewer"] = self["webpackChunkfabviewer"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FVApi: () => (/* reexport safe */ _js_FVApi_js__WEBPACK_IMPORTED_MODULE_1__.FVApi),
/* harmony export */   FVApp: () => (/* reexport safe */ _js_FVApp_js__WEBPACK_IMPORTED_MODULE_0__.FVApp)
/* harmony export */ });
/* harmony import */ var _js_FVApp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/FVApp.js */ "./src/js/FVApp.js");
/* harmony import */ var _js_FVApi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/FVApi.js */ "./src/js/FVApi.js");



})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=fabviewer.js.map